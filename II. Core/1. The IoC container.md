##1. IoC 容器
###1.1. Spring IoC 容器和 beans 介绍

本章涵盖了所有控制反转（IoC）<sup >[[1]]("#_footnote_1)</sup>原则的 Spring 框架实现。
IoC 也被称为*依赖注入*（DI）。这是对象定义它们依赖关系的一个过程，即，与它们一起运作的其他对象，
只有通过构造器参数、传递参数给工厂方法，或者在对象实例构造完成或工厂方法返回对象实例之后才能
设置对象属性。然后当创建bean时，容器再将那些依赖对象  *注入*进去。 这个过程从根本上颠倒了bean本身
通过使用类的直接构建或者通过一种机制例如*服务定位*模式来控制依赖对象的实例化或定位，
因此叫做*控制反转*（IoC）。

<code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 
包是 Spring 框架 IoC 容器的基础。<code>[BeanFactory](https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html)</code> 接口提供了一种能管理任何类型对象的高级配置机制。
<code>[ApplicationContext](https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html)</code>
是 <code>BeanFactory</code> 的一个子接口。它更容易与以下功能集成：Spring 的AOP功能；
消息资源处理（用于国际化）；事件发布；应用层特定上下文如 <code>WebApplicationContext</code> 在Web应用中的使用。

总之， BeanFactory 提供了配置框架和基本功能， ApplicationContext 添加了更多企业级专用功能。 ApplicationContext 是 BeanFactory 的一个全面超集, 在本章专门用来描述 Spring 的 IoC 容器。想要了解更多有关用 BeanFactory 代替 ApplicationContext 的信息，请参考The BeanFactory。

在 Spring 中，构成应用程序主干并由 Spring IoC 容器 管理的对象称为 beans。Bean 是由 Spring IoC 容器实例化、组装或者管理的对象。否则，bean 仅仅只是应用程序中许多对象中的一个。Beans 和它们之间的依赖 关系都反映在容器使用的配置元数据 中了。

###1.2. 容器概述

 <code>org.springframework.context.ApplicationContext</code> 接口代表了 Spring IoC 容器并且负责初始化，
 配置，装配上述的 beans。容器通过读取配置元数据获取关于实例化、配置和装配的操作指南。配置元数据以XML, Java注解，
 或者Java代码的形式表示。它展示了组成你的应用程序的对象和这些对象之间丰富的相互依赖关系。

 Spring 提供了几个开箱即用的 <code>ApplicationContext</code> 接口的实现。在独立的应用程序中，常见的做法是创建
 <code>[ClassPathXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html)</code>
或者 <code>[FileSystemXmlApplicationContext](https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html)</code>接口的实例。
考虑到XML已经成为定义配置元数据的传统文件格式，你可以引导容器使用Java注解或者以元数据格式呈现的代码，
这是通过提供少量用于声明对这些额外元数据格式支持的XML配置来实现的。

在大多数应用场景中，不需要显式用户代码来实例化一个或多个 Spring IoC 容器。举个例子，在一个web应用场景中，
一个含有八行（左右）的<code>web.xml</code>模板web描述XML文件就足够了（点击查看 [web应用的简单 ApplicationContext 实例化](#context-create">)）。
如果你在 Eclipse 驱动的开发环境中使用[Spring 工具套装](https://spring.io/tools/sts)，那么点几下鼠标或敲几下键盘就能
很容易创建这个模板配置文件。

下图是表示 Spring 的工作原理的高级视图。 应用程序中的类会跟配置元数据结合起来以便在 <code>ApplicationContext</code> 
创建和初始化以后，你可以得到一个完全配置好而且可执行的系统或者应用。

![container magic](container-magic.png)

*Figure 1. Spring IoC 容器*

####1.2.1. 配置元数据

正如前图所示，Spring IoC 容器使用这样一种*配置元数据*形式：此配置元数据展示了作为应用开发者，
你是如何告诉 Spring 容器来实例化，配置和组装应用中的对象的。

配置元数据传统上使用既简单又直观的XML格式，本章大多数时候使用它来传递 pring IoC 容器核心概念和功能特点。

<table>
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>基于XML的元数据并<em>不是</em> 唯一允许的配置元数据格式。Spring IoC 容器本身与配置元数据实际的编写格式是<em>完全</em> 解耦的。目前，许多开发者选择<a href="#beans-java">基于 Java 代码的配置</a> 为他们的 Spring 应用配置元数据。</p>
</div>
</td>
</tr>
</table>

有关对 Spring 容器使用其他格式的元数据，请参见：

* [基于注解的配置](#beans-annotation-config): Spring 2.5 引入了对基于注解配置元数据的支持。

* [基于Java的配置](#beans-java)：从 Spring 3.0 开始，JavaConfig 项目提供的很多功能成为了 Spring 框架核心的一部分。因此你可以使用Java而不使用XML文件在你的应用程序类之外定义 beans。要使用这些新功能，请参见<code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code>
和 <code>@DependsOn</code> 注解。

<p>Spring configuration consists of at least one and typically more than one bean
definition that the container must manage. XML-based configuration metadata shows these
beans configured as <code>&lt;bean/&gt;</code> elements inside a top-level <code>&lt;beans/&gt;</code> element. Java
configuration typically uses <code>@Bean</code> annotated methods within a <code>@Configuration</code> class.</p>
</div>
<div class="paragraph">
<p>These bean definitions correspond to the actual objects that make up your application.
Typically you define service layer objects, data access objects (DAOs), presentation
objects such as Struts <code>Action</code> instances, infrastructure objects such as Hibernate
<code>SessionFactories</code>, JMS <code>Queues</code>, and so forth. Typically one does not configure
fine-grained domain objects in the container, because it is usually the responsibility
of DAOs and business logic to create and load domain objects. However, you can use
Spring&#8217;s integration with AspectJ to configure objects that have been created outside
the control of an IoC container. See <a href="#aop-atconfigurable">Using AspectJ to
dependency-inject domain objects with Spring</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows the basic structure of XML-based configuration metadata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>id</code> attribute is a string that you use to identify the individual bean definition.
The <code>class</code> attribute defines the type of the bean and uses the fully qualified
classname. The value of the id attribute refers to collaborating objects. The XML for
referring to collaborating objects is not shown in this example; see
<a href="#beans-dependencies">Dependencies</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-instantiation"><a class="anchor" href="#beans-factory-instantiation"></a>1.2.2. Instantiating a container</h4>
<div class="paragraph">
<p>Instantiating a Spring IoC container is straightforward. The location path or paths
supplied to an <code>ApplicationContext</code> constructor are actually resource strings that allow
the container to load configuration metadata from a variety of external resources such
as the local file system, from the Java <code>CLASSPATH</code>, and so on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>After you learn about Spring&#8217;s IoC container, you may want to know more about Spring&#8217;s
<code>Resource</code> abstraction, as described in <a href="#resources">Resources</a>, which provides a convenient
mechanism for reading an InputStream from locations defined in a URI syntax. In
particular, <code>Resource</code> paths are used to construct applications contexts as described in
<a href="#resources-app-ctx">Application contexts and Resource paths</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the service layer objects <code>(services.xml)</code> configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- services --&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">petStore</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.services.PetStoreServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the data access objects <code>daos.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.dao.jpa.JpaItemDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the service layer consists of the class <code>PetStoreServiceImpl</code>,
and two data access objects of the type <code>JpaAccountDao</code> and <code>JpaItemDao</code> (based
on the JPA Object/Relational mapping standard). The <code>property name</code> element refers to the
name of the JavaBean property, and the <code>ref</code> element refers to the name of another bean
definition. This linkage between <code>id</code> and <code>ref</code> elements expresses the dependency between
collaborating objects. For details of configuring an object&#8217;s dependencies, see
<a href="#beans-dependencies">Dependencies</a>.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-xml-import"><a class="anchor" href="#beans-factory-xml-import"></a>Composing XML-based configuration metadata</h5>
<div class="paragraph">
<p>It can be useful to have bean definitions span multiple XML files. Often each individual
XML configuration file represents a logical layer or module in your architecture.</p>
</div>
<div class="paragraph">
<p>You can use the application context constructor to load bean definitions from all these
XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the
previous section. Alternatively, use one or more occurrences of the <code>&lt;import/&gt;</code> element
to load bean definitions from another file or files. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">resources/messageSource.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/resources/themeSource.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, external bean definitions are loaded from three files:
<code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. All location paths are
relative to the definition file doing the importing, so <code>services.xml</code> must be in the
same directory or classpath location as the file doing the importing, while
<code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the
location of the importing file. As you can see, a leading slash is ignored, but given
that these paths are relative, it is better form not to use the slash at all. The
contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must
be valid XML bean definitions according to the Spring Schema.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is possible, but not recommended, to reference files in parent directories using a
relative "../" path. Doing so creates a dependency on a file that is outside the current
application. In particular, this reference is not recommended for "classpath:" URLs (for
example, "classpath:../services.xml"), where the runtime resolution process chooses the
"nearest" classpath root and then looks into its parent directory. Classpath
configuration changes may lead to the choice of a different, incorrect directory.</p>
</div>
<div class="paragraph">
<p>You can always use fully qualified resource locations instead of relative paths: for
example, "file:C:/config/services.xml" or "classpath:/config/services.xml". However, be
aware that you are coupling your application&#8217;s configuration to specific absolute
locations. It is generally preferable to keep an indirection for such absolute
locations, for example, through "${&#8230;&#8203;}" placeholders that are resolved against JVM
system properties at runtime.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The import directive is a feature provided by the beans namespace itself. Further
configuration features beyond plain bean definitions are available in a selection
of XML namespaces provided by Spring, e.g. the "context" and the "util" namespace.</p>
</div>
</div>
<div class="sect4">
<h5 id="groovy-bean-definition-dsl"><a class="anchor" href="#groovy-bean-definition-dsl"></a>The Groovy Bean Definition DSL</h5>
<div class="paragraph">
<p>As a further example for externalized configuration metadata, bean definitions can also
be expressed in Spring&#8217;s Groovy Bean Definition DSL, as known from the Grails framework.
Typically, such configuration will live in a ".groovy" file with a structure as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">beans {
    dataSource(BasicDataSource) {
        driverClassName = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.hsqldb.jdbcDriver</span><span class="delimiter">&quot;</span></span>
        url = <span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:hsqldb:mem:grailsDB</span><span class="delimiter">&quot;</span></span>
        username = <span class="string"><span class="delimiter">&quot;</span><span class="content">sa</span><span class="delimiter">&quot;</span></span>
        password = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>
        settings = [mynew:<span class="string"><span class="delimiter">&quot;</span><span class="content">setting</span><span class="delimiter">&quot;</span></span>]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean -&gt;
            dataSource = dataSource
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration style is largely equivalent to XML bean definitions and even
supports Spring&#8217;s XML configuration namespaces. It also allows for importing XML
bean definition files through an "importBeans" directive.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-client"><a class="anchor" href="#beans-factory-client"></a>1.2.3. Using the container</h4>
<div class="paragraph">
<p>The <code>ApplicationContext</code> is the interface for an advanced factory capable of maintaining
a registry of different beans and their dependencies. Using the method <code>T getBean(String
name, Class&lt;T&gt; requiredType)</code> you can retrieve instances of your beans.</p>
</div>
<div class="paragraph">
<p>The <code>ApplicationContext</code> enables you to read bean definitions and access them as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// create and configure beans</span>
ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// retrieve configured instance</span>
PetStoreService service = context.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">petStore</span><span class="delimiter">&quot;</span></span>, PetStoreService.class);

<span class="comment">// use configured instance</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; userList = service.getUsernameList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Groovy configuration, bootstrapping looks very similar, just a different context
implementation class which is Groovy-aware (but also understands XML bean definitions):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.groovy</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.groovy</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most flexible variant is <code>GenericApplicationContext</code> in combination with reader
delegates, e.g. with <code>XmlBeanDefinitionReader</code> for XML files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();
<span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);
   context.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or with <code>GroovyBeanDefinitionReader</code> for Groovy files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();
<span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.groovy</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.groovy</span><span class="delimiter">&quot;</span></span>);
   context.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such reader delegates can be mixed and matched on the same <code>ApplicationContext</code>,
reading bean definitions from diverse configuration sources, if desired.</p>
</div>
<div class="paragraph">
<p>You can then use <code>getBean</code> to retrieve instances of your beans. The <code>ApplicationContext</code>
interface has a few other methods for retrieving beans, but ideally your application
code should never use them. Indeed, your application code should have no calls to the
<code>getBean()</code> method at all, and thus no dependency on Spring APIs at all. For example,
Spring&#8217;s integration with web frameworks provides dependency injection for various web
framework components such as controllers and JSF-managed beans, allowing you to declare
a dependency on a specific bean through metadata (e.g. an autowiring annotation).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-definition"><a class="anchor" href="#beans-definition"></a>1.3. Bean overview</h3>
<div class="paragraph">
<p>A Spring IoC container manages one or more <em>beans</em>. These beans are created with the
configuration metadata that you supply to the container, for example, in the form of XML
<code>&lt;bean/&gt;</code> definitions.</p>
</div>
<div class="paragraph">
<p>Within the container itself, these bean definitions are represented as <code>BeanDefinition</code>
objects, which contain (among other information) the following metadata:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>A package-qualified class name:</em> typically the actual implementation class of the
bean being defined.</p>
</li>
<li>
<p>Bean behavioral configuration elements, which state how the bean should behave in the
container (scope, lifecycle callbacks, and so forth).</p>
</li>
<li>
<p>References to other beans that are needed for the bean to do its work; these
references are also called <em>collaborators</em> or <em>dependencies</em>.</p>
</li>
<li>
<p>Other configuration settings to set in the newly created object, for example, the
number of connections to use in a bean that manages a connection pool, or the size
limit of the pool.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This metadata translates to a set of properties that make up each bean definition.</p>
</div>
<table id="beans-factory-bean-definition-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. The bean definition</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Explained in&#8230;&#8203;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">Instantiating beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-beanname">Naming beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">scope</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes">Bean scopes</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor arguments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">Dependency Injection</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">Dependency Injection</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">autowiring mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-autowire">Autowiring collaborators</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lazy-initialization mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lazy-init">Lazy-initialized beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">initialization method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-initializingbean">Initialization callbacks</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">destruction method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-disposablebean">Destruction callbacks</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In addition to bean definitions that contain information on how to create a specific
bean, the <code>ApplicationContext</code> implementations also permit the registration of existing
objects that are created outside the container, by users. This is done by accessing the
ApplicationContext&#8217;s BeanFactory via the method <code>getBeanFactory()</code> which returns the
BeanFactory implementation <code>DefaultListableBeanFactory</code>. <code>DefaultListableBeanFactory</code>
supports this registration through the methods <code>registerSingleton(..)</code> and
<code>registerBeanDefinition(..)</code>. However, typical applications work solely with beans
defined through metadata bean definitions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bean metadata and manually supplied singleton instances need to be registered as early
as possible, in order for the container to properly reason about them during autowiring
and other introspection steps. While overriding of existing metadata and existing
singleton instances is supported to some degree, the registration of new beans at
runtime (concurrently with live access to factory) is not officially supported and may
lead to concurrent access exceptions and/or inconsistent state in the bean container.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-beanname"><a class="anchor" href="#beans-beanname"></a>1.3.1. Naming beans</h4>
<div class="paragraph">
<p>Every bean has one or more identifiers. These identifiers must be unique within the
container that hosts the bean. A bean usually has only one identifier, but if it
requires more than one, the extra ones can be considered aliases.</p>
</div>
<div class="paragraph">
<p>In XML-based configuration metadata, you use the <code>id</code> and/or <code>name</code> attributes
to specify the bean identifier(s). The <code>id</code> attribute allows you to specify
exactly one id. Conventionally these names are alphanumeric ('myBean',
'fooService', etc.), but may contain special characters as well. If you want to
introduce other aliases to the bean, you can also specify them in the <code>name</code>
attribute, separated by a comma (<code>,</code>), semicolon (<code>;</code>), or white space. As a
historical note, in versions prior to Spring 3.1, the <code>id</code> attribute was
defined as an <code>xsd:ID</code> type, which constrained possible characters. As of 3.1,
it is defined as an <code>xsd:string</code> type. Note that bean <code>id</code> uniqueness is still
enforced by the container, though no longer by XML parsers.</p>
</div>
<div class="paragraph">
<p>You are not required to supply a name or id for a bean. If no name or id is supplied
explicitly, the container generates a unique name for that bean. However, if you want to
refer to that bean by name, through the use of the <code>ref</code> element or
<a href="#beans-servicelocator">Service Locator</a> style lookup, you must provide a name.
Motivations for not supplying a name are related to using <a href="#beans-inner-beans">inner
beans</a> and <a href="#beans-factory-autowire">autowiring collaborators</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bean Naming Conventions</div>
<div class="paragraph">
<p>The convention is to use the standard Java convention for instance field names when
naming beans. That is, bean names start with a lowercase letter, and are camel-cased
from then on. Examples of such names would be (without quotes) <code>'accountManager'</code>,
<code>'accountService'</code>, <code>'userDao'</code>, <code>'loginController'</code>, and so forth.</p>
</div>
<div class="paragraph">
<p>Naming beans consistently makes your configuration easier to read and understand, and if
you are using Spring AOP it helps a lot when applying advice to a set of beans related
by name.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>With component scanning in the classpath, Spring generates bean names for unnamed
components, following the rules above: essentially, taking the simple class name
and turning its initial character to lower-case. However, in the (unusual) special
case when there is more than one character and both the first and second characters
are upper case, the original casing gets preserved. These are the same rules as
defined by <code>java.beans.Introspector.decapitalize</code> (which Spring is using here).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-beanname-alias"><a class="anchor" href="#beans-beanname-alias"></a>Aliasing a bean outside the bean definition</h5>
<div class="paragraph">
<p>In a bean definition itself, you can supply more than one name for the bean, by using a
combination of up to one name specified by the <code>id</code> attribute, and any number of other
names in the <code>name</code> attribute. These names can be equivalent aliases to the same bean,
and are useful for some situations, such as allowing each component in an application to
refer to a common dependency by using a bean name that is specific to that component
itself.</p>
</div>
<div class="paragraph">
<p>Specifying all aliases where the bean is actually defined is not always adequate,
however. It is sometimes desirable to introduce an alias for a bean that is defined
elsewhere. This is commonly the case in large systems where configuration is split
amongst each subsystem, each subsystem having its own set of object definitions. In
XML-based configuration metadata, you can use the <code>&lt;alias/&gt;</code> element to accomplish this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fromName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">toName</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, a bean in the same container which is named <code>fromName</code>, may also,
after the use of this alias definition, be referred to as <code>toName</code>.</p>
</div>
<div class="paragraph">
<p>For example, the configuration metadata for subsystem A may refer to a DataSource via
the name <code>subsystemA-dataSource</code>. The configuration metadata for subsystem B may refer to
a DataSource via the name <code>subsystemB-dataSource</code>. When composing the main application
that uses both these subsystems the main application refers to the DataSource via the
name <code>myApp-dataSource</code>. To have all three names refer to the same object you add to the
MyApp configuration metadata the following aliases definitions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemB-dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myApp-dataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now each component and the main application can refer to the dataSource through a name
that is unique and guaranteed not to clash with any other definition (effectively
creating a namespace), yet they refer to the same bean.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Java-configuration</div>
<div class="paragraph">
<p>If you are using Java-configuration, the <code>@Bean</code> annotation can be used to provide aliases
see <a href="#beans-java-bean-annotation">Using the @Bean annotation</a> for details.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-class"><a class="anchor" href="#beans-factory-class"></a>1.3.2. Instantiating beans</h4>
<div class="paragraph">
<p>A bean definition essentially is a recipe for creating one or more objects. The
container looks at the recipe for a named bean when asked, and uses the configuration
metadata encapsulated by that bean definition to create (or acquire) an actual object.</p>
</div>
<div class="paragraph">
<p>If you use XML-based configuration metadata, you specify the type (or class) of object
that is to be instantiated in the <code>class</code> attribute of the <code>&lt;bean/&gt;</code> element. This
<code>class</code> attribute, which internally is a <code>Class</code> property on a <code>BeanDefinition</code>
instance, is usually mandatory. (For exceptions, see
<a href="#beans-factory-class-instance-factory-method">Instantiation using an instance factory method</a> and <a href="#beans-child-bean-definitions">Bean definition inheritance</a>.)
You use the <code>Class</code> property in one of two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Typically, to specify the bean class to be constructed in the case where the container
itself directly creates the bean by calling its constructor reflectively, somewhat
equivalent to Java code using the <code>new</code> operator.</p>
</li>
<li>
<p>To specify the actual class containing the <code>static</code> factory method that will be
invoked to create the object, in the less common case where the container invokes a
<code>static</code> <em>factory</em> method on a class to create the bean. The object type returned
from the invocation of the <code>static</code> factory method may be the same class or another
class entirely.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<div class="title">Inner class names</div>
<p>If you want to configure a bean definition for a <code>static</code> nested class, you have to use
the <em>binary</em> name of the nested class.</p>
</div>
<div class="paragraph">
<p>For example, if you have a class called <code>Foo</code> in the <code>com.example</code> package, and this
<code>Foo</code> class has a <code>static</code> nested class called <code>Bar</code>, the value of the <code>'class'</code>
attribute on a bean definition would be&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><code>com.example.Foo$Bar</code></p>
</div>
<div class="paragraph">
<p>Notice the use of the <code>$</code> character in the name to separate the nested class name from
the outer class name.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-ctor"><a class="anchor" href="#beans-factory-class-ctor"></a>Instantiation with a constructor</h5>
<div class="paragraph">
<p>When you create a bean by the constructor approach, all normal classes are usable by and
compatible with Spring. That is, the class being developed does not need to implement
any specific interfaces or to be coded in a specific fashion. Simply specifying the bean
class should suffice. However, depending on what type of IoC you use for that specific
bean, you may need a default (empty) constructor.</p>
</div>
<div class="paragraph">
<p>The Spring IoC container can manage virtually <em>any</em> class you want it to manage; it is
not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with
only a default (no-argument) constructor and appropriate setters and getters modeled
after the properties in the container. You can also have more exotic non-bean-style
classes in your container. If, for example, you need to use a legacy connection pool
that absolutely does not adhere to the JavaBean specification, Spring can manage it as
well.</p>
</div>
<div class="paragraph">
<p>With XML-based configuration metadata you can specify your bean class as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBeanTwo</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For details about the mechanism for supplying arguments to the constructor (if required)
and setting object instance properties after the object is constructed, see
<a href="#beans-factory-collaborators">Injecting Dependencies</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-static-factory-method"><a class="anchor" href="#beans-factory-class-static-factory-method"></a>Instantiation with a static factory method</h5>
<div class="paragraph">
<p>When defining a bean that you create with a static factory method, you use the <code>class</code>
attribute to specify the class containing the <code>static</code> factory method and an attribute
named <code>factory-method</code> to specify the name of the factory method itself. You should be
able to call this method (with optional arguments as described later) and return a live
object, which subsequently is treated as if it had been created through a constructor.
One use for such a bean definition is to call <code>static</code> factories in legacy code.</p>
</div>
<div class="paragraph">
<p>The following bean definition specifies that the bean will be created by calling a
factory-method. The definition does not specify the type (class) of the returned object,
only the class containing the factory method. In this example, the <code>createInstance()</code>
method must be a <em>static</em> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ClientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ClientService</span> {
        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();
        <span class="directive">private</span> ClientService() {}

        <span class="directive">public</span> <span class="directive">static</span> ClientService createInstance() {
                <span class="keyword">return</span> clientService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For details about the mechanism for supplying (optional) arguments to the factory method
and setting object instance properties after the object is returned from the factory,
see <a href="#beans-factory-properties-detailed">Dependencies and configuration in detail</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-instance-factory-method"><a class="anchor" href="#beans-factory-class-instance-factory-method"></a>Instantiation using an instance factory method</h5>
<div class="paragraph">
<p>Similar to instantiation through a <a href="#beans-factory-class-static-factory-method">static
factory method</a>, instantiation with an instance factory method invokes a non-static
method of an existing bean from the container to create a new bean. To use this
mechanism, leave the <code>class</code> attribute empty, and in the <code>factory-bean</code> attribute,
specify the name of a bean in the current (or parent/ancestor) container that contains
the instance method that is to be invoked to create the object. Set the name of the
factory method itself with the <code>factory-method</code> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.DefaultServiceLocator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createClientServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> {

        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();

        <span class="directive">public</span> ClientService createClientServiceInstance() {
                <span class="keyword">return</span> clientService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One factory class can also hold more than one factory method as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.DefaultServiceLocator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createClientServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createAccountServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> {

        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();

        <span class="directive">private</span> <span class="directive">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();

        <span class="directive">public</span> ClientService createClientServiceInstance() {
                <span class="keyword">return</span> clientService;
        }

        <span class="directive">public</span> AccountService createAccountServiceInstance() {
                <span class="keyword">return</span> accountService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach shows that the factory bean itself can be managed and configured through
dependency injection (DI). See <a href="#beans-factory-properties-detailed">Dependencies and
configuration in detail</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In Spring documentation,<em> factory bean</em> refers to a bean that is configured in the
Spring container that will create objects through an
<a href="#beans-factory-class-instance-factory-method">instance</a> or
<a href="#beans-factory-class-static-factory-method">static</a> factory method. By contrast,
<code>FactoryBean</code> (notice the capitalization) refers to a Spring-specific
<a href="#beans-factory-extension-factorybean"><code>FactoryBean</code> </a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-dependencies"><a class="anchor" href="#beans-dependencies"></a>1.4. Dependencies</h3>
<div class="paragraph">
<p>A typical enterprise application does not consist of a single object (or bean in the
Spring parlance). Even the simplest application has a few objects that work together to
present what the end-user sees as a coherent application. This next section explains how
you go from defining a number of bean definitions that stand alone to a fully realized
application where objects collaborate to achieve a goal.</p>
</div>
<div class="sect3">
<h4 id="beans-factory-collaborators"><a class="anchor" href="#beans-factory-collaborators"></a>1.4.1. Dependency Injection</h4>
<div class="paragraph">
<p><em>Dependency injection</em> (DI) is a process whereby objects define their dependencies,
that is, the other objects they work with, only through constructor arguments, arguments
to a factory method, or properties that are set on the object instance after it is
constructed or returned from a factory method. The container then <em>injects</em> those
dependencies when it creates the bean. This process is fundamentally the inverse, hence
the name <em>Inversion of Control</em> (IoC), of the bean itself controlling the instantiation
or location of its dependencies on its own by using direct construction of classes, or
the <em>Service Locator</em> pattern.</p>
</div>
<div class="paragraph">
<p>Code is cleaner with the DI principle and decoupling is more effective when objects are
provided with their dependencies. The object does not look up its dependencies, and does
not know the location or class of the dependencies. As such, your classes become easier
to test, in particular when the dependencies are on interfaces or abstract base classes,
which allow for stub or mock implementations to be used in unit tests.</p>
</div>
<div class="paragraph">
<p>DI exists in two major variants, <a href="#beans-constructor-injection">Constructor-based
dependency injection</a> and <a href="#beans-setter-injection">Setter-based dependency injection</a>.</p>
</div>
<div class="sect4">
<h5 id="beans-constructor-injection"><a class="anchor" href="#beans-constructor-injection"></a>Constructor-based dependency injection</h5>
<div class="paragraph">
<p><em>Constructor-based</em> DI is accomplished by the container invoking a constructor with a
number of arguments, each representing a dependency. Calling a <code>static</code> factory method
with specific arguments to construct the bean is nearly equivalent, and this discussion
treats arguments to a constructor and to a <code>static</code> factory method similarly. The
following example shows a class that can only be dependency-injected with constructor
injection. Notice that there is nothing <em>special</em> about this class, it is a POJO that
has no dependencies on container specific interfaces, base classes or annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span>
        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span>
        <span class="directive">public</span> SimpleMovieLister(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-ctor-arguments-resolution"><a class="anchor" href="#beans-factory-ctor-arguments-resolution"></a>Constructor argument resolution</h6>
<div class="paragraph">
<p>Constructor argument resolution matching occurs using the argument&#8217;s type. If no
potential ambiguity exists in the constructor arguments of a bean definition, then the
order in which the constructor arguments are defined in a bean definition is the order
in which those arguments are supplied to the appropriate constructor when the bean is
being instantiated. Consider the following class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">x.y</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">public</span> Foo(Bar bar, Baz baz) {
                <span class="comment">// ...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>No potential ambiguity exists, assuming that <code>Bar</code> and <code>Baz</code> classes are not related by
inheritance. Thus the following configuration works fine, and you do not need to specify
the constructor argument indexes and/or types explicitly in the <code>&lt;constructor-arg/&gt;</code>
element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When another bean is referenced, the type is known, and matching can occur (as was the
case with the preceding example). When a simple type is used, such as
<code>&lt;value&gt;true&lt;/value&gt;</code>, Spring cannot determine the type of the value, and so cannot match
by type without help. Consider the following class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">examples</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// Number of years to calculate the Ultimate Answer</span>
        <span class="directive">private</span> <span class="type">int</span> years;

        <span class="comment">// The Answer to Life, the Universe, and Everything</span>
        <span class="directive">private</span> <span class="predefined-type">String</span> ultimateAnswer;

        <span class="directive">public</span> ExampleBean(<span class="type">int</span> years, <span class="predefined-type">String</span> ultimateAnswer) {
                <span class="local-variable">this</span>.years = years;
                <span class="local-variable">this</span>.ultimateAnswer = ultimateAnswer;
        }
}</code></pre>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-type"></a>Constructor argument type matching</div>
<div class="content">
<div class="paragraph">
<p>In the preceding scenario, the container <em>can</em> use type matching with simple types if
you explicitly specify the type of the constructor argument using the <code>type</code> attribute.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">int</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java.lang.String</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-index"></a>Constructor argument index</div>
<div class="content">
<div class="paragraph">
<p>Use the <code>index</code> attribute to specify explicitly the index of constructor arguments. For
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to resolving the ambiguity of multiple simple values, specifying an index
resolves ambiguity where a constructor has two arguments of the same type. Note that the
<em>index is 0 based</em>.</p>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-name"></a>Constructor argument name</div>
<div class="content">
<div class="paragraph">
<p>You can also use the constructor parameter name for value disambiguation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">years</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ultimateAnswer</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that to make this work out of the box your code must be compiled with the
debug flag enabled so that Spring can look up the parameter name from the constructor.
If you can&#8217;t compile your code with debug flag (or don&#8217;t want to) you can use
<a href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a>
JDK annotation to explicitly name your constructor arguments. The sample class would
then have to look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">examples</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// Fields omitted</span>

        <span class="annotation">@ConstructorProperties</span>({<span class="string"><span class="delimiter">&quot;</span><span class="content">years</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">ultimateAnswer</span><span class="delimiter">&quot;</span></span>})
        <span class="directive">public</span> ExampleBean(<span class="type">int</span> years, <span class="predefined-type">String</span> ultimateAnswer) {
                <span class="local-variable">this</span>.years = years;
                <span class="local-variable">this</span>.ultimateAnswer = ultimateAnswer;
        }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-setter-injection"><a class="anchor" href="#beans-setter-injection"></a>Setter-based dependency injection</h5>
<div class="paragraph">
<p><em>Setter-based</em> DI is accomplished by the container calling setter methods on your
beans after invoking a no-argument constructor or no-argument <code>static</code> factory method to
instantiate your bean.</p>
</div>
<div class="paragraph">
<p>The following example shows a class that can only be dependency-injected using pure
setter injection. This class is conventional Java. It is a POJO that has no dependencies
on container specific interfaces, base classes or annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span>
        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ApplicationContext</code> supports constructor-based and setter-based DI for the beans it
manages. It also supports setter-based DI after some dependencies have already been
injected through the constructor approach. You configure the dependencies in the form of
a <code>BeanDefinition</code>, which you use in conjunction with <code>PropertyEditor</code> instances to
convert properties from one format to another. However, most Spring users do not work
with these classes directly (i.e., programmatically) but rather with XML <code>bean</code>
definitions, annotated components (i.e., classes annotated with <code>@Component</code>,
<code>@Controller</code>, etc.), or <code>@Bean</code> methods in Java-based <code>@Configuration</code> classes. These
sources are then converted internally into instances of <code>BeanDefinition</code> and used to
load an entire Spring IoC container instance.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Constructor-based or setter-based DI?</div>
<div class="paragraph">
<p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to
use constructors for <em>mandatory dependencies</em> and setter methods or configuration methods
for <em>optional dependencies</em>. Note that use of the <a href="#beans-required-annotation">@Required</a>
annotation on a setter method can be used to make the property a required dependency.</p>
</div>
<div class="paragraph">
<p>The Spring team generally advocates constructor injection as it enables one to implement
application components as <em>immutable objects</em> and to ensure that required dependencies
are not <code>null</code>. Furthermore constructor-injected components are always returned to client
(calling) code in a fully initialized state. As a side note, a large number of constructor
arguments is a <em>bad code smell</em>, implying that the class likely has too many
responsibilities and should be refactored to better address proper separation of concerns.</p>
</div>
<div class="paragraph">
<p>Setter injection should primarily only be used for optional dependencies that can be
assigned reasonable default values within the class. Otherwise, not-null checks must be
performed everywhere the code uses the dependency. One benefit of setter injection is that
setter methods make objects of that class amenable to reconfiguration or re-injection
later. Management through <a href="integration.html#jmx">JMX MBeans</a> is therefore a compelling
use case for setter injection.</p>
</div>
<div class="paragraph">
<p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing
with third-party classes for which you do not have the source, the choice is made for you.
For example, if a third-party class does not expose any setter methods, then constructor
injection may be the only available form of DI.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-dependency-resolution"><a class="anchor" href="#beans-dependency-resolution"></a>Dependency resolution process</h5>
<div class="paragraph">
<p>The container performs bean dependency resolution as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>ApplicationContext</code> is created and initialized with configuration metadata that
describes all the beans. Configuration metadata can be specified via XML, Java code, or
annotations.</p>
</li>
<li>
<p>For each bean, its dependencies are expressed in the form of properties, constructor
arguments, or arguments to the static-factory method if you are using that instead of
a normal constructor. These dependencies are provided to the bean, <em>when the bean is
actually created</em>.</p>
</li>
<li>
<p>Each property or constructor argument is an actual definition of the value to set, or
a reference to another bean in the container.</p>
</li>
<li>
<p>Each property or constructor argument which is a value is converted from its specified
format to the actual type of that property or constructor argument. By default Spring
can convert a value supplied in string format to all built-in types, such as <code>int</code>,
<code>long</code>, <code>String</code>, <code>boolean</code>, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring container validates the configuration of each bean as the container is created.
However, the bean properties themselves are not set until the bean <em>is actually created</em>.
Beans that are singleton-scoped and set to be pre-instantiated (the default) are created
when the container is created. Scopes are defined in <a href="#beans-factory-scopes">Bean scopes</a>. Otherwise,
the bean is created only when it is requested. Creation of a bean potentially causes a
graph of beans to be created, as the bean&#8217;s dependencies and its dependencies'
dependencies (and so on) are created and assigned. Note that resolution mismatches among
those dependencies may show up late, i.e. on first creation of the affected bean.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Circular dependencies</div>
<div class="paragraph">
<p>If you use predominantly constructor injection, it is possible to create an unresolvable
circular dependency scenario.</p>
</div>
<div class="paragraph">
<p>For example: Class A requires an instance of class B through constructor injection, and
class B requires an instance of class A through constructor injection. If you configure
beans for classes A and B to be injected into each other, the Spring IoC container
detects this circular reference at runtime, and throws a
<code>BeanCurrentlyInCreationException</code>.</p>
</div>
<div class="paragraph">
<p>One possible solution is to edit the source code of some classes to be configured by
setters rather than constructors. Alternatively, avoid constructor injection and use
setter injection only. In other words, although it is not recommended, you can configure
circular dependencies with setter injection.</p>
</div>
<div class="paragraph">
<p>Unlike the <em>typical</em> case (with no circular dependencies), a circular dependency
between bean A and bean B forces one of the beans to be injected into the other prior to
being fully initialized itself (a classic chicken/egg scenario).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>You can generally trust Spring to do the right thing. It detects configuration problems,
such as references to non-existent beans and circular dependencies, at container
load-time. Spring sets properties and resolves dependencies as late as possible, when
the bean is actually created. This means that a Spring container which has loaded
correctly can later generate an exception when you request an object if there is a
problem creating that object or one of its dependencies. For example, the bean throws an
exception as a result of a missing or invalid property. This potentially delayed
visibility of some configuration issues is why <code>ApplicationContext</code> implementations by
default pre-instantiate singleton beans. At the cost of some upfront time and memory to
create these beans before they are actually needed, you discover configuration issues
when the <code>ApplicationContext</code> is created, not later. You can still override this default
behavior so that singleton beans will lazy-initialize, rather than be pre-instantiated.</p>
</div>
<div class="paragraph">
<p>If no circular dependencies exist, when one or more collaborating beans are being
injected into a dependent bean, each collaborating bean is <em>totally</em> configured prior
to being injected into the dependent bean. This means that if bean A has a dependency on
bean B, the Spring IoC container completely configures bean B prior to invoking the
setter method on bean A. In other words, the bean is instantiated (if not a
pre-instantiated singleton), its dependencies are set, and the relevant lifecycle
methods (such as a <a href="#beans-factory-lifecycle-initializingbean">configured init method</a>
or the <a href="#beans-factory-lifecycle-initializingbean">InitializingBean callback method</a>)
are invoked.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-some-examples"><a class="anchor" href="#beans-some-examples"></a>Examples of dependency injection</h5>
<div class="paragraph">
<p>The following example uses XML-based configuration metadata for setter-based DI. A small
part of a Spring XML configuration file specifies some bean definitions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>

        <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanTwo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">integerProperty</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">private</span> AnotherBean beanOne;

        <span class="directive">private</span> YetAnotherBean beanTwo;

        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">public</span> <span class="type">void</span> setBeanOne(AnotherBean beanOne) {
                <span class="local-variable">this</span>.beanOne = beanOne;
        }

        <span class="directive">public</span> <span class="type">void</span> setBeanTwo(YetAnotherBean beanTwo) {
                <span class="local-variable">this</span>.beanTwo = beanTwo;
        }

        <span class="directive">public</span> <span class="type">void</span> setIntegerProperty(<span class="type">int</span> i) {
                <span class="local-variable">this</span>.i = i;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, setters are declared to match against the properties specified
in the XML file. The following example uses constructor-based DI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span>
        <span class="tag">&lt;constructor-arg&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/constructor-arg&gt;</span>

        <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">int</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">private</span> AnotherBean beanOne;

        <span class="directive">private</span> YetAnotherBean beanTwo;

        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">public</span> ExampleBean(
                AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i) {
                <span class="local-variable">this</span>.beanOne = anotherBean;
                <span class="local-variable">this</span>.beanTwo = yetAnotherBean;
                <span class="local-variable">this</span>.i = i;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor arguments specified in the bean definition will be used as arguments to
the constructor of the <code>ExampleBean</code>.</p>
</div>
<div class="paragraph">
<p>Now consider a variant of this example, where instead of using a constructor, Spring is
told to call a <code>static</code> factory method to return an instance of the object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createInstance</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// a private constructor</span>
        <span class="directive">private</span> ExampleBean(...) {
                ...
        }

        <span class="comment">// a static factory method; the arguments to this method can be</span>
        <span class="comment">// considered the dependencies of the bean that is returned,</span>
        <span class="comment">// regardless of how those arguments are actually used.</span>
        <span class="directive">public</span> <span class="directive">static</span> ExampleBean createInstance (
                AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i) {

                ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);
                <span class="comment">// some other operations...</span>
                <span class="keyword">return</span> eb;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Arguments to the <code>static</code> factory method are supplied via <code>&lt;constructor-arg/&gt;</code> elements,
exactly the same as if a constructor had actually been used. The type of the class being
returned by the factory method does not have to be of the same type as the class that
contains the <code>static</code> factory method, although in this example it is. An instance
(non-static) factory method would be used in an essentially identical fashion (aside
from the use of the <code>factory-bean</code> attribute instead of the <code>class</code> attribute), so
details will not be discussed here.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-properties-detailed"><a class="anchor" href="#beans-factory-properties-detailed"></a>1.4.2. Dependencies and configuration in detail</h4>
<div class="paragraph">
<p>As mentioned in the previous section, you can define bean properties and constructor
arguments as references to other managed beans (collaborators), or as values defined
inline. Spring&#8217;s XML-based configuration metadata supports sub-element types within its
<code>&lt;property/&gt;</code> and <code>&lt;constructor-arg/&gt;</code> elements for this purpose.</p>
</div>
<div class="sect4">
<h5 id="beans-value-element"><a class="anchor" href="#beans-value-element"></a>Straight values (primitives, Strings, and so on)</h5>
<div class="paragraph">
<p>The <code>value</code> attribute of the <code>&lt;property/&gt;</code> element specifies a property or constructor
argument as a human-readable string representation. Spring&#8217;s
<a href="#core-convert-ConversionService-API">conversion service</a> is used to convert these
values from a <code>String</code> to the actual type of the property or argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">driverClassName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mysql.jdbc.Driver</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:mysql://localhost:3306/mydb</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">root</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterkaoli</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example uses the <a href="#beans-p-namespace">p-namespace</a> for even more succinct
XML configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
        <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:driverClassName</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mysql.jdbc.Driver</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:url</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:mysql://localhost:3306/mydb</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:username</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">root</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:password</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterkaoli</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding XML is more succinct; however, typos are discovered at runtime rather than
design time, unless you use an IDE such as <a href="http://www.jetbrains.com/idea/">IntelliJ
IDEA</a> or the <a href="https://spring.io/tools/sts">Spring Tool Suite</a> (STS)
that support automatic property completion when you create bean definitions. Such IDE
assistance is highly recommended.</p>
</div>
<div class="paragraph">
<p>You can also configure a <code>java.util.Properties</code> instance as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>
                        jdbc.driver.className=com.mysql.jdbc.Driver
                        jdbc.url=jdbc:mysql://localhost:3306/mydb
                <span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container converts the text inside the <code>&lt;value/&gt;</code> element into a
<code>java.util.Properties</code> instance by using the JavaBeans <code>PropertyEditor</code> mechanism. This
is a nice shortcut, and is one of a few places where the Spring team do favor the use of
the nested <code>&lt;value/&gt;</code> element over the <code>value</code> attribute style.</p>
</div>
<div class="sect5">
<h6 id="beans-idref-element"><a class="anchor" href="#beans-idref-element"></a>The idref element</h6>
<div class="paragraph">
<p>The <code>idref</code> element is simply an error-proof way to pass the <em>id</em> (string value - not
a reference) of another bean in the container to a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code>
element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theClientBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetName</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;idref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above bean definition snippet is <em>exactly</em> equivalent (at runtime) to the
following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">client</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first form is preferable to the second, because using the <code>idref</code> tag allows the
container to validate <em>at deployment time</em> that the referenced, named bean actually
exists. In the second variation, no validation is performed on the value that is passed
to the <code>targetName</code> property of the <code>client</code> bean. Typos are only discovered (with most
likely fatal results) when the <code>client</code> bean is actually instantiated. If the <code>client</code>
bean is a <a href="#beans-factory-scopes">prototype</a> bean, this typo and the resulting exception
may only be discovered long after the container is deployed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>local</code> attribute on the <code>idref</code> element is no longer supported in the 4.0 beans xsd
since it does not provide value over a regular <code>bean</code> reference anymore. Simply change
your existing <code>idref local</code> references to <code>idref bean</code> when upgrading to the 4.0 schema.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A common place (at least in versions earlier than Spring 2.0) where the <code>&lt;idref/&gt;</code> element
brings value is in the configuration of <a href="#aop-pfb-1">AOP interceptors</a> in a
<code>ProxyFactoryBean</code> bean definition. Using <code>&lt;idref/&gt;</code> elements when you specify the
interceptor names prevents you from misspelling an interceptor id.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-ref-element"><a class="anchor" href="#beans-ref-element"></a>References to other beans (collaborators)</h5>
<div class="paragraph">
<p>The <code>ref</code> element is the final element inside a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code>
definition element. Here you set the value of the specified property of a bean to be a
reference to another bean (a collaborator) managed by the container. The referenced bean
is a dependency of the bean whose property will be set, and it is initialized on demand
as needed before the property is set. (If the collaborator is a singleton bean, it may
be initialized already by the container.) All references are ultimately a reference to
another object. Scoping and validation depend on whether you specify the id/name of the
other object through the <code>bean</code>, <code>local,</code> or <code>parent</code> attributes.</p>
</div>
<div class="paragraph">
<p>Specifying the target bean through the <code>bean</code> attribute of the <code>&lt;ref/&gt;</code> tag is the most
general form, and allows creation of a reference to any bean in the same container or
parent container, regardless of whether it is in the same XML file. The value of the
<code>bean</code> attribute may be the same as the <code>id</code> attribute of the target bean, or as one of
the values in the <code>name</code> attribute of the target bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifying the target bean through the <code>parent</code> attribute creates a reference to a bean
that is in a parent container of the current container. The value of the <code>parent</code>
attribute may be the same as either the <code>id</code> attribute of the target bean, or one of the
values in the <code>name</code> attribute of the target bean, and the target bean must be in a
parent container of the current one. You use this bean reference variant mainly when you
have a hierarchy of containers and you want to wrap an existing bean in a parent
container with a proxy that will have the same name as the parent bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- in the parent context --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.SimpleAccountService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- in the child (descendant) context --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="error">&lt;</span><span class="error">!</span><span class="attribute-name">--</span> <span class="attribute-name">bean</span> <span class="attribute-name">name</span> <span class="attribute-name">is</span> <span class="attribute-name">the</span> <span class="attribute-name">same</span> <span class="attribute-name">as</span> <span class="attribute-name">the</span> <span class="attribute-name">parent</span> <span class="attribute-name">bean</span> <span class="attribute-name">--</span><span class="tag">&gt;</span>
        class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;<span class="error">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span> <span class="comment">&lt;!-- notice how we refer to the parent bean --&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>local</code> attribute on the <code>ref</code> element is no longer supported in the 4.0 beans xsd
since it does not provide value over a regular <code>bean</code> reference anymore. Simply change
your existing <code>ref local</code> references to <code>ref bean</code> when upgrading to the 4.0 schema.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-inner-beans"><a class="anchor" href="#beans-inner-beans"></a>Inner beans</h5>
<div class="paragraph">
<p>A <code>&lt;bean/&gt;</code> element inside the <code>&lt;property/&gt;</code> or <code>&lt;constructor-arg/&gt;</code> elements defines a
so-called <em>inner bean</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">outer</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Fiona Apple</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">25</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An inner bean definition does not require a defined id or name; if specified, the container
does not use such a value as an identifier. The container also ignores the <code>scope</code> flag on
creation: Inner beans are <em>always</em> anonymous and they are <em>always</em> created with the outer
bean. It is <em>not</em> possible to inject inner beans into collaborating beans other than into
the enclosing bean or to access them independently.</p>
</div>
<div class="paragraph">
<p>As a corner case, it is possible to receive destruction callbacks from a custom scope, e.g.
for a request-scoped inner bean contained within a singleton bean: The creation of the inner
bean instance will be tied to its containing bean, but destruction callbacks allow it to
participate in the request scope&#8217;s lifecycle. This is not a common scenario; inner beans
typically simply share their containing bean&#8217;s scope.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-collection-elements"><a class="anchor" href="#beans-collection-elements"></a>Collections</h5>
<div class="paragraph">
<p>In the <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;props/&gt;</code> elements, you set the properties
and arguments of the Java <code>Collection</code> types <code>List</code>, <code>Set</code>, <code>Map</code>, and <code>Properties</code>,
respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">moreComplexObject</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ComplexObject</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;props&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">administrator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2b3b6bfbbbcbba1a6a0b3a6bda092b7aab3bfa2beb7fcbda0b5">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a7d4d2d7d7c8d5d3e7c2dfc6cad7cbc289c8d5c0">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d6b2b3a0b3bab9a6bbb3b8a296b3aeb7bba6bab3f8b9a4b1">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                <span class="tag">&lt;/props&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someList</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>a list element followed by a reference<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someMap</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;map&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">an entry</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">just some string</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> =<span class="string"><span class="delimiter">&quot;</span><span class="content">a ref</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/map&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someSet</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;value&gt;</span>just some string<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>The value of a map key or value, or a set value, can also again be any of the
following elements:</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">bean | ref | idref | list | set | map | props | value | null</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-merging"><a class="anchor" href="#beans-collection-elements-merging"></a>Collection merging</h6>
<div class="paragraph">
<p>The Spring container also supports the <em>merging</em> of collections. An application
developer can define a parent-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> element,
and have child-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> elements inherit and
override values from the parent collection. That is, the child collection&#8217;s values are
the result of merging the elements of the parent and child collections, with the child&#8217;s
collection elements overriding values specified in the parent collection.</p>
</div>
<div class="paragraph">
<p><em>This section on merging discusses the parent-child bean mechanism. Readers unfamiliar
with parent and child bean definitions may wish to read the
<a href="#beans-child-bean-definitions">relevant section</a> before continuing.</em></p>
</div>
<div class="paragraph">
<p>The following example demonstrates collection merging:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ComplexObject</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;props&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">administrator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c2d28212522253f383e2d38233e0c29342d213c2029622f2321">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5f2c2a2f2f302d2b1f3a273e322f333a713c3032">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;/props&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">child</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span>
                        <span class="tag">&lt;props</span> <span class="attribute-name">merge</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sales</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2251434e475162475a434f524e470c414d4f">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="295a5c5959465b5d694c51484459454c074a46075c42">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;/props&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the use of the <code>merge=true</code> attribute on the <code>&lt;props/&gt;</code> element of the
<code>adminEmails</code> property of the <code>child</code> bean definition. When the <code>child</code> bean is resolved
and instantiated by the container, the resulting instance has an <code>adminEmails</code>
<code>Properties</code> collection that contains the result of the merging of the child&#8217;s
<code>adminEmails</code> collection with the parent&#8217;s <code>adminEmails</code> collection.</p>
</div>
<div class="literalblock">
<div class="content">
<pre><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4120252c282f2832353320352e337c20252c282f2832353320352e33012439202c312d246f222e2c">[email&#160;protected]</a>
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c2b1a3aea7b1ffb1a3aea7b182a7baa3afb2aea7eca1adaf">[email&#160;protected]</a>
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="60131510100f12145d131510100f1214200518010d100c054e030f4e150b">[email&#160;protected]</a></pre>
</div>
</div>
<div class="paragraph">
<p>The child <code>Properties</code> collection&#8217;s value set inherits all property elements from the
parent <code>&lt;props/&gt;</code>, and the child&#8217;s value for the <code>support</code> value overrides the value in
the parent collection.</p>
</div>
<div class="paragraph">
<p>This merging behavior applies similarly to the <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;set/&gt;</code>
collection types. In the specific case of the <code>&lt;list/&gt;</code> element, the semantics
associated with the <code>List</code> collection type, that is, the notion of an <code>ordered</code>
collection of values, is maintained; the parent&#8217;s values precede all of the child list&#8217;s
values. In the case of the <code>Map</code>, <code>Set</code>, and <code>Properties</code> collection types, no ordering
exists. Hence no ordering semantics are in effect for the collection types that underlie
the associated <code>Map</code>, <code>Set</code>, and <code>Properties</code> implementation types that the container
uses internally.</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-merge-limitations"><a class="anchor" href="#beans-collection-merge-limitations"></a>Limitations of collection merging</h6>
<div class="paragraph">
<p>You cannot merge different collection types (such as a <code>Map</code> and a <code>List</code>), and if you
do attempt to do so an appropriate <code>Exception</code> is thrown. The <code>merge</code> attribute must be
specified on the lower, inherited, child definition; specifying the <code>merge</code> attribute on
a parent collection definition is redundant and will not result in the desired merging.</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-strongly-typed"><a class="anchor" href="#beans-collection-elements-strongly-typed"></a>Strongly-typed collection</h6>
<div class="paragraph">
<p>With the introduction of generic types in Java 5, you can use strongly typed collections.
That is, it is possible to declare a <code>Collection</code> type such that it can only contain
<code>String</code> elements (for example). If you are using Spring to dependency-inject a
strongly-typed <code>Collection</code> into a bean, you can take advantage of Spring&#8217;s
type-conversion support such that the elements of your strongly-typed <code>Collection</code>
instances are converted to the appropriate type prior to being added to the <code>Collection</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Float</span>&gt; accounts;

        <span class="directive">public</span> <span class="type">void</span> setAccounts(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Float</span>&gt; accounts) {
                <span class="local-variable">this</span>.accounts = accounts;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accounts</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;map&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">9.99</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2.75</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">six</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.99</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;/map&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>accounts</code> property of the <code>foo</code> bean is prepared for injection, the generics
information about the element type of the strongly-typed <code>Map&lt;String, Float&gt;</code> is
available by reflection. Thus Spring&#8217;s type conversion infrastructure recognizes the
various value elements as being of type <code>Float</code>, and the string values <code>9.99, 2.75</code>, and
<code>3.99</code> are converted into an actual <code>Float</code> type.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-null-element"><a class="anchor" href="#beans-null-element"></a>Null and empty string values</h5>
<div class="paragraph">
<p>Spring treats empty arguments for properties and the like as empty <code>Strings</code>. The
following XML-based configuration metadata snippet sets the email property to the empty
<code>String</code> value ("").</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example is equivalent to the following Java code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;null/&gt;</code> element handles <code>null</code> values. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;null</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above configuration is equivalent to the following Java code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail(<span class="predefined-constant">null</span>)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-p-namespace"><a class="anchor" href="#beans-p-namespace"></a>XML shortcut with the p-namespace</h5>
<div class="paragraph">
<p>The p-namespace enables you to use the <code>bean</code> element&#8217;s attributes, instead of nested
<code>&lt;property/&gt;</code> elements, to describe your property values and/or collaborating beans.</p>
</div>
<div class="paragraph">
<p>Spring supports extensible configuration formats <a href="appendix.html#xsd-configuration">with namespaces</a>,
which are based on an XML Schema definition. The <code>beans</code> configuration format discussed in this
chapter is defined in an XML Schema document. However, the p-namespace is not defined in
an XSD file and exists only in the core of Spring.</p>
</div>
<div class="paragraph">
<p>The following example shows two XML snippets that resolve to the same result: The first
uses standard XML format and the second uses the p-namespace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classic</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="72141d1d321013005c111d1f">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">p-namespace</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.ExampleBean</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:email</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b5d3dadaf5d7d4c79bd6dad8">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The example shows an attribute in the p-namespace called email in the bean definition.
This tells Spring to include a property declaration. As previously mentioned, the
p-namespace does not have a schema definition, so you can set the name of the attribute
to the property name.</p>
</div>
<div class="paragraph">
<p>This next example includes two more bean definitions that both have a reference to
another bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">john-classic</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">John Doe</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">spouse</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">john-modern</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">John Doe</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:spouse-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Jane Doe</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, this example includes not only a property value using the p-namespace,
but also uses a special format to declare property references. Whereas the first bean
definition uses <code>&lt;property name="spouse" ref="jane"/&gt;</code> to create a reference from bean
<code>john</code> to bean <code>jane</code>, the second bean definition uses <code>p:spouse-ref="jane"</code> as an
attribute to do the exact same thing. In this case <code>spouse</code> is the property name,
whereas the <code>-ref</code> part indicates that this is not a straight value but rather a
reference to another bean.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The p-namespace is not as flexible as the standard XML format. For example, the format
for declaring property references clashes with properties that end in <code>Ref</code>, whereas the
standard XML format does not. We recommend that you choose your approach carefully and
communicate this to your team members, to avoid producing XML documents that use all
three approaches at the same time.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-c-namespace"><a class="anchor" href="#beans-c-namespace"></a>XML shortcut with the c-namespace</h5>
<div class="paragraph">
<p>Similar to the <a href="#beans-p-namespace">XML shortcut with the p-namespace</a>, the <em>c-namespace</em>, newly introduced in Spring
3.1, allows usage of inlined attributes for configuring the constructor arguments rather
then nested <code>constructor-arg</code> elements.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s review the examples from <a href="#beans-constructor-injection">Constructor-based dependency injection</a> with the <code>c:</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:c</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/c</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- traditional declaration --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="62040d0d220003104c010d0f">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- c-namespace declaration --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:bar-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:baz-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:email</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82e4ededc2e0e3f0ace1edef">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>c:</code> namespace uses the same conventions as the <code>p:</code> one (trailing <code>-ref</code> for bean
references) for setting the constructor arguments by their names. And just as well, it
needs to be declared even though it is not defined in an XSD schema (but it exists
inside the Spring core).</p>
</div>
<div class="paragraph">
<p>For the rare cases where the constructor argument names are not available (usually if
the bytecode was compiled without debugging information), one can use fallback to the
argument indexes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:_0-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:_1-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Due to the XML grammar, the index notation requires the presence of the leading <code>_</code> as
XML attribute names cannot start with a number (even though some IDE allow it).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In practice, the constructor resolution
<a href="#beans-factory-ctor-arguments-resolution">mechanism</a> is quite efficient in matching
arguments so unless one really needs to, we recommend using the name notation
through-out your configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-compound-property-names"><a class="anchor" href="#beans-compound-property-names"></a>Compound property names</h5>
<div class="paragraph">
<p>You can use compound or nested property names when you set bean properties, as long as
all components of the path except the final property name are not <code>null</code>. Consider the
following bean definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fred.bob.sammy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>foo</code> bean has a <code>fred</code> property, which has a <code>bob</code> property, which has a <code>sammy</code>
property, and that final <code>sammy</code> property is being set to the value <code>123</code>. In order for
this to work, the <code>fred</code> property of <code>foo</code>, and the <code>bob</code> property of <code>fred</code> must not be
<code>null</code> after the bean is constructed, or a <code>NullPointerException</code> is thrown.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-dependson"><a class="anchor" href="#beans-factory-dependson"></a>1.4.3. Using depends-on</h4>
<div class="paragraph">
<p>If a bean is a dependency of another that usually means that one bean is set as a
property of another. Typically you accomplish this with the <a href="#beans-ref-element"><code>&lt;ref/&gt;</code>
element</a> in XML-based configuration metadata. However, sometimes dependencies between
beans are less direct; for example, a static initializer in a class needs to be
triggered, such as database driver registration. The <code>depends-on</code> attribute can
explicitly force one or more beans to be initialized before the bean using this element
is initialized. The following example uses the <code>depends-on</code> attribute to express a
dependency on a single bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ManagerBean</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To express a dependency on multiple beans, supply a list of bean names as the value of
the <code>depends-on</code> attribute, with commas, whitespace and semicolons, used as valid
delimiters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager,accountDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ManagerBean</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.jdbc.JdbcAccountDao</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>depends-on</code> attribute in the bean definition can specify both an initialization
time dependency and, in the case of <a href="#beans-factory-scopes-singleton">singleton</a> beans
only, a corresponding destroy time dependency. Dependent beans that define a
<code>depends-on</code> relationship with a given bean are destroyed first, prior to the given bean
itself being destroyed. Thus <code>depends-on</code> can also control shutdown order.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-lazy-init"><a class="anchor" href="#beans-factory-lazy-init"></a>1.4.4. Lazy-initialized beans</h4>
<div class="paragraph">
<p>By default, <code>ApplicationContext</code> implementations eagerly create and configure all
<a href="#beans-factory-scopes-singleton">singleton</a> beans as part of the initialization
process. Generally, this pre-instantiation is desirable, because errors in the
configuration or surrounding environment are discovered immediately, as opposed to hours
or even days later. When this behavior is <em>not</em> desirable, you can prevent
pre-instantiation of a singleton bean by marking the bean definition as
lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean
instance when it is first requested, rather than at startup.</p>
</div>
<div class="paragraph">
<p>In XML, this behavior is controlled by the <code>lazy-init</code> attribute on the <code>&lt;bean/&gt;</code>
element; for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lazy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.ExpensiveToCreateBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">lazy-init</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">not.lazy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When the preceding configuration is consumed by an <code>ApplicationContext</code>, the bean named
<code>lazy</code> is not eagerly pre-instantiated when the <code>ApplicationContext</code> is starting up,
whereas the <code>not.lazy</code> bean is eagerly pre-instantiated.</p>
</div>
<div class="paragraph">
<p>However, when a lazy-initialized bean is a dependency of a singleton bean that is
<em>not</em> lazy-initialized, the <code>ApplicationContext</code> creates the lazy-initialized bean at
startup, because it must satisfy the singleton&#8217;s dependencies. The lazy-initialized bean
is injected into a singleton bean elsewhere that is not lazy-initialized.</p>
</div>
<div class="paragraph">
<p>You can also control lazy-initialization at the container level by using the
<code>default-lazy-init</code> attribute on the <code>&lt;beans/&gt;</code> element; for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-lazy-init</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-autowire"><a class="anchor" href="#beans-factory-autowire"></a>1.4.5. Autowiring collaborators</h4>
<div class="paragraph">
<p>The Spring container can <em>autowire</em> relationships between collaborating beans. You can
allow Spring to resolve collaborators (other beans) automatically for your bean by
inspecting the contents of the <code>ApplicationContext</code>. Autowiring has the following
advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Autowiring can significantly reduce the need to specify properties or constructor
arguments. (Other mechanisms such as a bean template
<a href="#beans-child-bean-definitions">discussed elsewhere in this chapter</a> are also valuable
in this regard.)</p>
</li>
<li>
<p>Autowiring can update a configuration as your objects evolve. For example, if you need
to add a dependency to a class, that dependency can be satisfied automatically without
you needing to modify the configuration. Thus autowiring can be especially useful
during development, without negating the option of switching to explicit wiring when
the code base becomes more stable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using XML-based configuration metadata <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup>, you specify autowire
mode for a bean definition with the <code>autowire</code> attribute of the <code>&lt;bean/&gt;</code> element. The
autowiring functionality has four modes. You specify autowiring <em>per</em> bean and thus
can choose which ones to autowire.</p>
</div>
<table id="beans-factory-autowiring-modes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. Autowiring modes</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mode</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Default) No autowiring. Bean references must be defined via a <code>ref</code> element. Changing
the default setting is not recommended for larger deployments, because specifying
collaborators explicitly gives greater control and clarity. To some extent, it
documents the structure of a system.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Autowiring by property name. Spring looks for a bean with the same name as the
property that needs to be autowired. For example, if a bean definition is set to
autowire by name, and it contains a <em>master</em> property (that is, it has a
<em>setMaster(..)</em> method), Spring looks for a bean definition named <code>master</code>, and uses
it to set the property.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows a property to be autowired if exactly one bean of the property type exists in
the container. If more than one exists, a fatal exception is thrown, which indicates
that you may not use <em>byType</em> autowiring for that bean. If there are no matching
beans, nothing happens; the property is not set.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Analogous to <em>byType</em>, but applies to constructor arguments. If there is not exactly
one bean of the constructor argument type in the container, a fatal error is raised.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>With <em>byType</em> or <em>constructor</em> autowiring mode, you can wire arrays and
typed-collections. In such cases <em>all</em> autowire candidates within the container that
match the expected type are provided to satisfy the dependency. You can autowire
strongly-typed Maps if the expected key type is <code>String</code>. An autowired Maps values will
consist of all bean instances that match the expected type, and the Maps keys will
contain the corresponding bean names.</p>
</div>
<div class="paragraph">
<p>You can combine autowire behavior with dependency checking, which is performed after
autowiring completes.</p>
</div>
<div class="sect4">
<h5 id="beans-autowired-exceptions"><a class="anchor" href="#beans-autowired-exceptions"></a>Limitations and disadvantages of autowiring</h5>
<div class="paragraph">
<p>Autowiring works best when it is used consistently across a project. If autowiring is
not used in general, it might be confusing to developers to use it to wire only one or
two bean definitions.</p>
</div>
<div class="paragraph">
<p>Consider the limitations and disadvantages of autowiring:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Explicit dependencies in <code>property</code> and <code>constructor-arg</code> settings always override
autowiring. You cannot autowire so-called <em>simple</em> properties such as primitives,
<code>Strings</code>, and <code>Classes</code> (and arrays of such simple properties). This limitation is
by-design.</p>
</li>
<li>
<p>Autowiring is less exact than explicit wiring. Although, as noted in the above table,
Spring is careful to avoid guessing in case of ambiguity that might have unexpected
results, the relationships between your Spring-managed objects are no longer
documented explicitly.</p>
</li>
<li>
<p>Wiring information may not be available to tools that may generate documentation from
a Spring container.</p>
</li>
<li>
<p>Multiple bean definitions within the container may match the type specified by the
setter method or constructor argument to be autowired. For arrays, collections, or
Maps, this is not necessarily a problem. However for dependencies that expect a single
value, this ambiguity is not arbitrarily resolved. If no unique bean definition is
available, an exception is thrown.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the latter scenario, you have several options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abandon autowiring in favor of explicit wiring.</p>
</li>
<li>
<p>Avoid autowiring for a bean definition by setting its <code>autowire-candidate</code> attributes
to <code>false</code> as described in the next section.</p>
</li>
<li>
<p>Designate a single bean definition as the <em>primary</em> candidate by setting the
<code>primary</code> attribute of its <code>&lt;bean/&gt;</code> element to <code>true</code>.</p>
</li>
<li>
<p>Implement the more fine-grained control available
with annotation-based configuration, as described in <a href="#beans-annotation-config">Annotation-based container configuration</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-autowire-candidate"><a class="anchor" href="#beans-factory-autowire-candidate"></a>Excluding a bean from autowiring</h5>
<div class="paragraph">
<p>On a per-bean basis, you can exclude a bean from autowiring. In Spring&#8217;s XML format, set
the <code>autowire-candidate</code> attribute of the <code>&lt;bean/&gt;</code> element to <code>false</code>; the container
makes that specific bean definition unavailable to the autowiring infrastructure
(including annotation style configurations such as <a href="#beans-autowired-annotation"><code>@Autowired</code></a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>autowire-candidate</code> attribute is designed to only affect type-based autowiring.
It does not affect explicit references by name, which will get resolved even if the
specified bean is not marked as an autowire candidate. As a consequence, autowiring
by name will nevertheless inject a bean if the name matches.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also limit autowire candidates based on pattern-matching against bean names. The
top-level <code>&lt;beans/&gt;</code> element accepts one or more patterns within its
<code>default-autowire-candidates</code> attribute. For example, to limit autowire candidate status
to any bean whose name ends with <em>Repository,</em> provide a value of *Repository. To
provide multiple patterns, define them in a comma-separated list. An explicit value of
<code>true</code> or <code>false</code> for a bean definitions <code>autowire-candidate</code> attribute always takes
precedence, and for such beans, the pattern matching rules do not apply.</p>
</div>
<div class="paragraph">
<p>These techniques are useful for beans that you never want to be injected into other
beans by autowiring. It does not mean that an excluded bean cannot itself be configured
using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-method-injection"><a class="anchor" href="#beans-factory-method-injection"></a>1.4.6. Method injection</h4>
<div class="paragraph">
<p>In most application scenarios, most beans in the container are
<a href="#beans-factory-scopes-singleton">singletons</a>. When a singleton bean needs to
collaborate with another singleton bean, or a non-singleton bean needs to collaborate
with another non-singleton bean, you typically handle the dependency by defining one
bean as a property of the other. A problem arises when the bean lifecycles are
different. Suppose singleton bean A needs to use non-singleton (prototype) bean B,
perhaps on each method invocation on A. The container only creates the singleton bean A
once, and thus only gets one opportunity to set the properties. The container cannot
provide bean A with a new instance of bean B every time one is needed.</p>
</div>
<div class="paragraph">
<p>A solution is to forego some inversion of control. You can <a href="#beans-factory-aware">make
bean A aware of the container</a> by implementing the <code>ApplicationContextAware</code> interface,
and by <a href="#beans-factory-client">making a getBean("B") call to the container</a> ask for (a
typically new) bean B instance every time bean A needs it. The following is an example
of this approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span>
<span class="keyword">package</span> <span class="namespace">fiona.apple</span>;

<span class="comment">// Spring-API imports</span>
<span class="keyword">import</span> <span class="include">org.springframework.beans.BeansException</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContextAware</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">CommandManager</span> <span class="directive">implements</span> ApplicationContextAware {

        <span class="directive">private</span> ApplicationContext applicationContext;

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Map</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="directive">protected</span> Command createCommand() {
                <span class="comment">// notice the Spring API dependency!</span>
                <span class="keyword">return</span> <span class="local-variable">this</span>.applicationContext.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">command</span><span class="delimiter">&quot;</span></span>, Command.class);
        }

        <span class="directive">public</span> <span class="type">void</span> setApplicationContext(
                        ApplicationContext applicationContext) <span class="directive">throws</span> BeansException {
                <span class="local-variable">this</span>.applicationContext = applicationContext;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding is not desirable, because the business code is aware of and coupled to the
Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC
container, allows this use case to be handled in a clean fashion.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>You can read more about the motivation for Method Injection in
<a href="https://spring.io/blog/2004/08/06/method-injection/">this blog entry</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lookup-method-injection"><a class="anchor" href="#beans-factory-lookup-method-injection"></a>Lookup method injection</h5>
<div class="paragraph">
<p>Lookup method injection is the ability of the container to override methods on
<em>container managed beans</em>, to return the lookup result for another named bean in the
container. The lookup typically involves a prototype bean as in the scenario described
in the preceding section. The Spring Framework implements this method injection by using
bytecode generation from the CGLIB library to generate dynamically a subclass that
overrides the method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>For this dynamic subclassing to work, the class that the Spring bean container will
subclass cannot be <code>final</code>, and the method to be overridden cannot be <code>final</code> either.</p>
</li>
<li>
<p>Unit-testing a class that has an <code>abstract</code> method requires you to subclass the class
yourself and to supply a stub implementation of the <code>abstract</code> method.</p>
</li>
<li>
<p>Concrete methods are also necessary for component scanning which requires concrete
classes to pick up.</p>
</li>
<li>
<p>A further key limitation is that lookup methods won&#8217;t work with factory methods and
in particular not with <code>@Bean</code> methods in configuration classes, since the container
is not in charge of creating the instance in that case and therefore cannot create
a runtime-generated subclass on the fly.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Looking at the <code>CommandManager</code> class in the previous code snippet, you see that the
Spring container will dynamically override the implementation of the <code>createCommand()</code>
method. Your <code>CommandManager</code> class will not have any Spring dependencies, as can be
seen in the reworked example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">fiona.apple</span>;

<span class="comment">// no more Spring imports!</span>

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command interface</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="comment">// okay... but where is the implementation of this method?</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the client class containing the method to be injected (the <code>CommandManager</code> in this
case), the method to be injected requires a signature of the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;public</span><span class="error">|</span><span class="attribute-name">protected</span><span class="tag">&gt;</span> [abstract] <span class="tag">&lt;return-type&gt;</span> theMethodName(no-arguments);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the method is <code>abstract</code>, the dynamically-generated subclass implements the method.
Otherwise, the dynamically-generated subclass overrides the concrete method defined in
the original class. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fiona.apple.AsyncCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">commandManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fiona.apple.CommandManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;lookup-method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean identified as <em>commandManager</em> calls its own method <code>createCommand()</code>
whenever it needs a new instance of the <em>myCommand</em> bean. You must be careful to deploy
the <code>myCommand</code> bean as a prototype, if that is actually what is needed. If it is
as a <a href="#beans-factory-scopes-singleton">singleton</a>, the same instance of the <code>myCommand</code>
bean is returned each time.</p>
</div>
<div class="paragraph">
<p>Alternatively, within the annotation-based component model, you may declare a lookup
method through the <code>@Lookup</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                Command command = createCommand();
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="annotation">@Lookup</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, more idiomatically, you may rely on the target bean getting resolved against the
declared return type of the lookup method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                MyCommand command = createCommand();
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="annotation">@Lookup</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> MyCommand createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you will typically declare such annotated lookup methods with a concrete
stub implementation, in order for them to be compatible with Spring&#8217;s component
scanning rules where abstract classes get ignored by default. This limitation does not
apply in case of explicitly registered or explicitly imported bean classes.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Another way of accessing differently scoped target beans is an <code>ObjectFactory</code>/
<code>Provider</code> injection point. Check out <a href="#beans-factory-scopes-other-injection">Scoped beans as dependencies</a>.</p>
</div>
<div class="paragraph">
<p>The interested reader may also find the <code>ServiceLocatorFactoryBean</code> (in the
<code>org.springframework.beans.factory.config</code> package) to be of use.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-arbitrary-method-replacement"><a class="anchor" href="#beans-factory-arbitrary-method-replacement"></a>Arbitrary method replacement</h5>
<div class="paragraph">
<p>A less useful form of method injection than lookup method injection is the ability to
replace arbitrary methods in a managed bean with another method implementation. Users
may safely skip the rest of this section until the functionality is actually needed.</p>
</div>
<div class="paragraph">
<p>With XML-based configuration metadata, you can use the <code>replaced-method</code> element to
replace an existing method implementation with another, for a deployed bean. Consider
the following class, with a method computeValue, which we want to override:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyValueCalculator</span> {

        <span class="directive">public</span> <span class="predefined-type">String</span> computeValue(<span class="predefined-type">String</span> input) {
                <span class="comment">// some real code...</span>
        }

        <span class="comment">// some other methods...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A class implementing the <code>org.springframework.beans.factory.support.MethodReplacer</code>
interface provides the new method definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ReplacementComputeValue</span> <span class="directive">implements</span> MethodReplacer {

        <span class="directive">public</span> <span class="predefined-type">Object</span> reimplement(<span class="predefined-type">Object</span> o, <span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// get the input value, work with it, and return a computed result</span>
                <span class="predefined-type">String</span> input = (<span class="predefined-type">String</span>) args[<span class="integer">0</span>];
                ...
                return ...;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean definition to deploy the original class and specify the method override would
look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myValueCalculator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.z.MyValueCalculator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span>
        <span class="tag">&lt;replaced-method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">computeValue</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">replacer</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replacementComputeValue</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;arg-type&gt;</span>String<span class="tag">&lt;/arg-type&gt;</span>
        <span class="tag">&lt;/replaced-method&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replacementComputeValue</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">a.b.c.ReplacementComputeValue</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use one or more contained <code>&lt;arg-type/&gt;</code> elements within the <code>&lt;replaced-method/&gt;</code>
element to indicate the method signature of the method being overridden. The signature
for the arguments is necessary only if the method is overloaded and multiple variants
exist within the class. For convenience, the type string for an argument may be a
substring of the fully qualified type name. For example, the following all match
<code>java.lang.String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">java.lang.String
<span class="predefined-type">String</span>
Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the number of arguments is often enough to distinguish between each possible
choice, this shortcut can save a lot of typing, by allowing you to type only the
shortest string that will match an argument type.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-scopes"><a class="anchor" href="#beans-factory-scopes"></a>1.5. Bean scopes</h3>
<div class="paragraph">
<p>When you create a bean definition, you create a <em>recipe</em> for creating actual instances
of the class defined by that bean definition. The idea that a bean definition is a
recipe is important, because it means that, as with a class, you can create many object
instances from a single recipe.</p>
</div>
<div class="paragraph">
<p>You can control not only the various dependencies and configuration values that are to
be plugged into an object that is created from a particular bean definition, but also
the <em>scope</em> of the objects created from a particular bean definition. This approach is
powerful and flexible in that you can <em>choose</em> the scope of the objects you create
through configuration instead of having to bake in the scope of an object at the Java
class level. Beans can be defined to be deployed in one of a number of scopes: out of
the box, the Spring Framework supports six scopes, five of which are available only if
you use a web-aware <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>The following scopes are supported out of the box. You can also create
<a href="#beans-factory-scopes-custom">a custom scope.</a></p>
</div>
<table id="beans-factory-scopes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Bean scopes</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Scope</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-singleton">singleton</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Default) Scopes a single bean definition to a single object instance per Spring IoC
container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-prototype">prototype</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to any number of object instances.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-request">request</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of a single HTTP request; that is,
each HTTP request has its own instance of a bean created off the back of a single bean
definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-session">session</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in
the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-application">application</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in
the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#websocket-stomp-websocket-scope">websocket</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in
the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring 3.0, a <em>thread scope</em> is available, but is not registered by default. For
more information, see the documentation for
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code>SimpleThreadScope</code></a>.
For instructions on how to register this or any other custom scope, see
<a href="#beans-factory-scopes-custom-using">Using a custom scope</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-singleton"><a class="anchor" href="#beans-factory-scopes-singleton"></a>1.5.1. The singleton scope</h4>
<div class="paragraph">
<p>Only one <em>shared</em> instance of a singleton bean is managed, and all requests for beans
with an id or ids matching that bean definition result in that one specific bean
instance being returned by the Spring container.</p>
</div>
<div class="paragraph">
<p>To put it another way, when you define a bean definition and it is scoped as a
singleton, the Spring IoC container creates <em>exactly one</em> instance of the object
defined by that bean definition. This single instance is stored in a cache of such
singleton beans, and <em>all subsequent requests and references</em> for that named bean
return the cached object.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/singleton.png" alt="singleton">
</div>
</div>
<div class="paragraph">
<p>Spring&#8217;s concept of a singleton bean differs from the Singleton pattern as defined in
the Gang of Four (GoF) patterns book. The GoF Singleton hard-codes the scope of an
object such that one <em>and only one</em> instance of a particular class is created <em>per
ClassLoader</em>. The scope of the Spring singleton is best described as <em>per container
and per bean</em>. This means that if you define one bean for a particular class in a
single Spring container, then the Spring container creates one <em>and only one</em> instance
of the class defined by that bean definition. <em>The singleton scope is the default scope
in Spring</em>. To define a bean as a singleton in XML, you would write, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-prototype"><a class="anchor" href="#beans-factory-scopes-prototype"></a>1.5.2. The prototype scope</h4>
<div class="paragraph">
<p>The non-singleton, prototype scope of bean deployment results in the <em>creation of a new
bean instance</em> every time a request for that specific bean is made. That is, the bean
is injected into another bean or you request it through a <code>getBean()</code> method call on the
container. As a rule, use the prototype scope for all stateful beans and the singleton
scope for stateless beans.</p>
</div>
<div class="paragraph">
<p>The following diagram illustrates the Spring prototype scope. <em>A data access object
(DAO) is not typically configured as a prototype, because a typical DAO does not hold
any conversational state; it was just easier for this author to reuse the core of the
singleton diagram.</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/prototype.png" alt="prototype">
</div>
</div>
<div class="paragraph">
<p>The following example defines a bean as a prototype in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast to the other scopes, Spring does not manage the complete lifecycle of a
prototype bean: the container instantiates, configures, and otherwise assembles a
prototype object, and hands it to the client, with no further record of that prototype
instance. Thus, although<em> initialization</em> lifecycle callback methods are called on all
objects regardless of scope, in the case of prototypes, configured <em>destruction</em>
lifecycle callbacks are <em>not</em> called. The client code must clean up prototype-scoped
objects and release expensive resources that the prototype bean(s) are holding. To get
the Spring container to release resources held by prototype-scoped beans, try using a
custom <a href="#beans-factory-extension-bpp">bean post-processor</a>, which holds a reference to
beans that need to be cleaned up.</p>
</div>
<div class="paragraph">
<p>In some respects, the Spring container&#8217;s role in regard to a prototype-scoped bean is a
replacement for the Java <code>new</code> operator. All lifecycle management past that point must
be handled by the client. (For details on the lifecycle of a bean in the Spring
container, see <a href="#beans-factory-lifecycle">Lifecycle callbacks</a>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-sing-prot-interaction"><a class="anchor" href="#beans-factory-scopes-sing-prot-interaction"></a>1.5.3. Singleton beans with prototype-bean dependencies</h4>
<div class="paragraph">
<p>When you use singleton-scoped beans with dependencies on prototype beans, be aware that
<em>dependencies are resolved at instantiation time</em>. Thus if you dependency-inject a
prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated
and then dependency-injected into the singleton bean. The prototype instance is the sole
instance that is ever supplied to the singleton-scoped bean.</p>
</div>
<div class="paragraph">
<p>However, suppose you want the singleton-scoped bean to acquire a new instance of the
prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a
prototype-scoped bean into your singleton bean, because that injection occurs only
<em>once</em>, when the Spring container is instantiating the singleton bean and resolving
and injecting its dependencies. If you need a new instance of a prototype bean at
runtime more than once, see <a href="#beans-factory-method-injection">Method injection</a></p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-other"><a class="anchor" href="#beans-factory-scopes-other"></a>1.5.4. Request, session, application, and WebSocket scopes</h4>
<div class="paragraph">
<p>The <code>request</code>, <code>session</code>, <code>application</code>, and <code>websocket</code> scopes are <em>only</em> available
if you use a web-aware Spring <code>ApplicationContext</code> implementation (such as
<code>XmlWebApplicationContext</code>). If you use these scopes with regular Spring IoC containers
such as the <code>ClassPathXmlApplicationContext</code>, an <code>IllegalStateException</code> will be thrown
complaining about an unknown bean scope.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-web-configuration"><a class="anchor" href="#beans-factory-scopes-other-web-configuration"></a>Initial web configuration</h5>
<div class="paragraph">
<p>To support the scoping of beans at the <code>request</code>, <code>session</code>, <code>application</code>, and
<code>websocket</code> levels (web-scoped beans), some minor initial configuration is
required before you define your beans. (This initial setup is <em>not</em> required
for the standard scopes, <code>singleton</code> and <code>prototype</code>.)</p>
</div>
<div class="paragraph">
<p>How you accomplish this initial setup depends on your particular Servlet environment.</p>
</div>
<div class="paragraph">
<p>If you access scoped beans within Spring Web MVC, in effect, within a request that is
processed by the Spring <code>DispatcherServlet</code>, then no special setup is necessary:
<code>DispatcherServlet</code> already exposes all relevant state.</p>
</div>
<div class="paragraph">
<p>If you use a Servlet 2.5 web container, with requests processed outside of Spring&#8217;s
<code>DispatcherServlet</code> (for example, when using JSF or Struts), you need to register the
<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>.
For Servlet 3.0+, this can be done programmatically via the <code>WebApplicationInitializer</code>
interface. Alternatively, or for older containers, add the following declaration to
your web application&#8217;s <code>web.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        ...
        <span class="tag">&lt;listener&gt;</span>
                <span class="tag">&lt;listener-class&gt;</span>
                        org.springframework.web.context.request.RequestContextListener
                <span class="tag">&lt;/listener-class&gt;</span>
        <span class="tag">&lt;/listener&gt;</span>
        ...
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if there are issues with your listener setup, consider using Spring&#8217;s
<code>RequestContextFilter</code>. The filter mapping depends on the surrounding web
application configuration, so you have to change it as appropriate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        ...
        <span class="tag">&lt;filter&gt;</span>
                <span class="tag">&lt;filter-name&gt;</span>requestContextFilter<span class="tag">&lt;/filter-name&gt;</span>
                <span class="tag">&lt;filter-class&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/filter-class&gt;</span>
        <span class="tag">&lt;/filter&gt;</span>
        <span class="tag">&lt;filter-mapping&gt;</span>
                <span class="tag">&lt;filter-name&gt;</span>requestContextFilter<span class="tag">&lt;/filter-name&gt;</span>
                <span class="tag">&lt;url-pattern&gt;</span>/*<span class="tag">&lt;/url-pattern&gt;</span>
        <span class="tag">&lt;/filter-mapping&gt;</span>
        ...
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code>, <code>RequestContextListener</code>, and <code>RequestContextFilter</code> all do exactly
the same thing, namely bind the HTTP request object to the <code>Thread</code> that is servicing
that request. This makes beans that are request- and session-scoped available further
down the call chain.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-request"><a class="anchor" href="#beans-factory-scopes-request"></a>Request scope</h5>
<div class="paragraph">
<p>Consider the following XML configuration for a bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">loginAction</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.LoginAction</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">request</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container creates a new instance of the <code>LoginAction</code> bean by using the
<code>loginAction</code> bean definition for each and every HTTP request. That is, the
<code>loginAction</code> bean is scoped at the HTTP request level. You can change the internal
state of the instance that is created as much as you want, because other instances
created from the same <code>loginAction</code> bean definition will not see these changes in state;
they are particular to an individual request. When the request completes processing, the
bean that is scoped to the request is discarded.</p>
</div>
<div class="paragraph">
<p>When using annotation-driven components or Java Config, the <code>@RequestScope</code> annotation
can be used to assign a component to the <code>request</code> scope.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@RequestScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginAction</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-session"><a class="anchor" href="#beans-factory-scopes-session"></a>Session scope</h5>
<div class="paragraph">
<p>Consider the following XML configuration for a bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container creates a new instance of the <code>UserPreferences</code> bean by using the
<code>userPreferences</code> bean definition for the lifetime of a single HTTP <code>Session</code>. In other
words, the <code>userPreferences</code> bean is effectively scoped at the HTTP <code>Session</code> level. As
with <code>request-scoped</code> beans, you can change the internal state of the instance that is
created as much as you want, knowing that other HTTP <code>Session</code> instances that are also
using instances created from the same <code>userPreferences</code> bean definition do not see these
changes in state, because they are particular to an individual HTTP <code>Session</code>. When the
HTTP <code>Session</code> is eventually discarded, the bean that is scoped to that particular HTTP
<code>Session</code> is also discarded.</p>
</div>
<div class="paragraph">
<p>When using annotation-driven components or Java Config, the <code>@SessionScope</code> annotation
can be used to assign a component to the <code>session</code> scope.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@SessionScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">UserPreferences</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-application"><a class="anchor" href="#beans-factory-scopes-application"></a>Application scope</h5>
<div class="paragraph">
<p>Consider the following XML configuration for a bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">appPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.AppPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">application</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container creates a new instance of the <code>AppPreferences</code> bean by using the
<code>appPreferences</code> bean definition once for the entire web application. That is, the
<code>appPreferences</code> bean is scoped at the <code>ServletContext</code> level, stored as a regular
<code>ServletContext</code> attribute. This is somewhat similar to a Spring singleton bean but
differs in two important ways: It is a singleton per <code>ServletContext</code>, not per Spring
'ApplicationContext' (for which there may be several in any given web application),
and it is actually exposed and therefore visible as a <code>ServletContext</code> attribute.</p>
</div>
<div class="paragraph">
<p>When using annotation-driven components or Java Config, the <code>@ApplicationScope</code>
annotation can be used to assign a component to the <code>application</code> scope.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@ApplicationScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppPreferences</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-injection"><a class="anchor" href="#beans-factory-scopes-other-injection"></a>Scoped beans as dependencies</h5>
<div class="paragraph">
<p>The Spring IoC container manages not only the instantiation of your objects (beans),
but also the wiring up of collaborators (or dependencies). If you want to inject (for
example) an HTTP request scoped bean into another bean of a longer-lived scope, you may
choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject
a proxy object that exposes the same public interface as the scoped object but that can
also retrieve the real target object from the relevant scope (such as an HTTP request)
and delegate method calls onto the real object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may also use <code>&lt;aop:scoped-proxy/&gt;</code> between beans that are scoped as <code>singleton</code>,
with the reference then going through an intermediate proxy that is serializable
and therefore able to re-obtain the target singleton bean on deserialization.</p>
</div>
<div class="paragraph">
<p>When declaring <code>&lt;aop:scoped-proxy/&gt;</code> against a bean of scope <code>prototype</code>, every method
call on the shared proxy will lead to the creation of a new target instance which the
call is then being forwarded to.</p>
</div>
<div class="paragraph">
<p>Also, scoped proxies are not the only way to access beans from shorter scopes in a
lifecycle-safe fashion. You may also simply declare your injection point (i.e. the
constructor/setter argument or autowired field) as <code>ObjectFactory&lt;MyTargetBean&gt;</code>,
allowing for a <code>getObject()</code> call to retrieve the current instance on demand every
time it is needed - without holding on to the instance or storing it separately.</p>
</div>
<div class="paragraph">
<p>As an extended variant, you may declare <code>ObjectProvider&lt;MyTargetBean&gt;</code> which delivers
several additional access variants, including <code>getIfAvailable</code> and <code>getIfUnique</code>.</p>
</div>
<div class="paragraph">
<p>The JSR-330 variant of this is called <code>Provider</code>, used with a <code>Provider&lt;MyTargetBean&gt;</code>
declaration and a corresponding <code>get()</code> call for every retrieval attempt.
See <a href="#beans-standard-annotations">here</a> for more details on JSR-330 overall.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The configuration in the following example is only one line, but it is important to
understand the "why" as well as the "how" behind it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop</span>
                <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- instructs the container to proxy the surrounding bean --&gt;</span>
                <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.SimpleUserService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- a reference to the proxied userPreferences bean --&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To create such a proxy, you insert a child <code>&lt;aop:scoped-proxy/&gt;</code> element into a scoped
bean definition (see <a href="#beans-factory-scopes-other-injection-proxies">Choosing the type of proxy to create</a> and
<a href="appendix.html#xsd-configuration">XML Schema-based configuration</a>).
Why do definitions of beans scoped at the <code>request</code>, <code>session</code> and custom-scope
levels require the <code>&lt;aop:scoped-proxy/&gt;</code> element?
Let&#8217;s examine the following singleton bean definition and contrast it with
what you need to define for the aforementioned scopes (note that the following
<code>userPreferences</code> bean definition as it stands is <em>incomplete</em>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the singleton bean <code>userManager</code> is injected with a reference
to the HTTP <code>Session</code>-scoped bean <code>userPreferences</code>. The salient point here is that the
<code>userManager</code> bean is a singleton: it will be instantiated <em>exactly once</em> per
container, and its dependencies (in this case only one, the <code>userPreferences</code> bean) are
also injected only once. This means that the <code>userManager</code> bean will only operate on the
exact same <code>userPreferences</code> object, that is, the one that it was originally injected
with.</p>
</div>
<div class="paragraph">
<p>This is <em>not</em> the behavior you want when injecting a shorter-lived scoped bean into a
longer-lived scoped bean, for example injecting an HTTP <code>Session</code>-scoped collaborating
bean as a dependency into singleton bean. Rather, you need a single <code>userManager</code>
object, and for the lifetime of an HTTP <code>Session</code>, you need a <code>userPreferences</code> object
that is specific to said HTTP <code>Session</code>. Thus the container creates an object that
exposes the exact same public interface as the <code>UserPreferences</code> class (ideally an
object that <em>is a</em> <code>UserPreferences</code> instance) which can fetch the real
<code>UserPreferences</code> object from the scoping mechanism (HTTP request, <code>Session</code>, etc.). The
container injects this proxy object into the <code>userManager</code> bean, which is unaware that
this <code>UserPreferences</code> reference is a proxy. In this example, when a <code>UserManager</code>
instance invokes a method on the dependency-injected <code>UserPreferences</code> object, it
actually is invoking a method on the proxy. The proxy then fetches the real
<code>UserPreferences</code> object from (in this case) the HTTP <code>Session</code>, and delegates the
method invocation onto the retrieved real <code>UserPreferences</code> object.</p>
</div>
<div class="paragraph">
<p>Thus you need the following, correct and complete, configuration when injecting
<code>request-</code> and <code>session-scoped</code> beans into collaborating objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-scopes-other-injection-proxies"><a class="anchor" href="#beans-factory-scopes-other-injection-proxies"></a>Choosing the type of proxy to create</h6>
<div class="paragraph">
<p>By default, when the Spring container creates a proxy for a bean that is marked up with
the <code>&lt;aop:scoped-proxy/&gt;</code> element, <em>a CGLIB-based class proxy is created</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>CGLIB proxies only intercept public method calls! Do not call non-public methods
on such a proxy; they will not be delegated to the actual scoped target object.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you can configure the Spring container to create standard JDK
interface-based proxies for such scoped beans, by specifying <code>false</code> for the value of
the <code>proxy-target-class</code> attribute of the <code>&lt;aop:scoped-proxy/&gt;</code> element. Using JDK
interface-based proxies means that you do not need additional libraries in your
application classpath to effect such proxying. However, it also means that the class of
the scoped bean must implement at least one interface, and <em>that all</em> collaborators
into which the scoped bean is injected must reference the bean through one of its
interfaces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultUserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;aop:scoped-proxy</span> <span class="attribute-name">proxy-target-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For more detailed information about choosing class-based or interface-based proxying,
see <a href="#aop-proxying">Proxying mechanisms</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-custom"><a class="anchor" href="#beans-factory-scopes-custom"></a>1.5.5. Custom scopes</h4>
<div class="paragraph">
<p>The bean scoping mechanism is extensible; You can define your own
scopes, or even redefine existing scopes, although the latter is considered bad practice
and you <em>cannot</em> override the built-in <code>singleton</code> and <code>prototype</code> scopes.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-creating"><a class="anchor" href="#beans-factory-scopes-custom-creating"></a>Creating a custom scope</h5>
<div class="paragraph">
<p>To integrate your custom scope(s) into the Spring container, you need to implement the
<code>org.springframework.beans.factory.config.Scope</code> interface, which is described in this
section. For an idea of how to implement your own scopes, see the <code>Scope</code>
implementations that are supplied with the Spring Framework itself and the
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html"><code>Scope</code> javadocs</a>,
which explains the methods you need to implement in more detail.</p>
</div>
<div class="paragraph">
<p>The <code>Scope</code> interface has four methods to get objects from the scope, remove them from
the scope, and allow them to be destroyed.</p>
</div>
<div class="paragraph">
<p>The following method returns the object from the underlying scope. The session scope
implementation, for example, returns the session-scoped bean (and if it does not exist,
the method returns a new instance of the bean, after having bound it to the session for
future reference).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Object</span> get(<span class="predefined-type">String</span> name, <span class="predefined-type">ObjectFactory</span> objectFactory)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following method removes the object from the underlying scope. The session scope
implementation for example, removes the session-scoped bean from the underlying session.
The object should be returned, but you can return null if the object with the specified
name is not found.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Object</span> remove(<span class="predefined-type">String</span> name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following method registers the callbacks the scope should execute when it is
destroyed or when the specified object in the scope is destroyed. Refer to the javadocs
or a Spring scope implementation for more information on destruction callbacks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerDestructionCallback(<span class="predefined-type">String</span> name, <span class="predefined-type">Runnable</span> destructionCallback)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following method obtains the conversation identifier for the underlying scope. This
identifier is different for each scope. For a session scoped implementation, this
identifier can be the session identifier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> getConversationId()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-using"><a class="anchor" href="#beans-factory-scopes-custom-using"></a>Using a custom scope</h5>
<div class="paragraph">
<p>After you write and test one or more custom <code>Scope</code> implementations, you need to make
the Spring container aware of your new scope(s). The following method is the central
method to register a new <code>Scope</code> with the Spring container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerScope(<span class="predefined-type">String</span> scopeName, Scope scope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method is declared on the <code>ConfigurableBeanFactory</code> interface, which is available
on most of the concrete <code>ApplicationContext</code> implementations that ship with Spring via
the BeanFactory property.</p>
</div>
<div class="paragraph">
<p>The first argument to the <code>registerScope(..)</code> method is the unique name associated with
a scope; examples of such names in the Spring container itself are <code>singleton</code> and
<code>prototype</code>. The second argument to the <code>registerScope(..)</code> method is an actual instance
of the custom <code>Scope</code> implementation that you wish to register and use.</p>
</div>
<div class="paragraph">
<p>Suppose that you write your custom <code>Scope</code> implementation, and then register it as below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The example below uses <code>SimpleThreadScope</code> which is included with Spring, but not
registered by default. The instructions would be the same for your own custom <code>Scope</code>
implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Scope threadScope = <span class="keyword">new</span> SimpleThreadScope();
beanFactory.registerScope(<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span>, threadScope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You then create bean definitions that adhere to the scoping rules of your custom <code>Scope</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With a custom <code>Scope</code> implementation, you are not limited to programmatic registration
of the scope. You can also do the <code>Scope</code> registration declaratively, using the
<code>CustomScopeConfigurer</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop</span>
                <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.CustomScopeConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scopes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;map&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.SimpleThreadScope</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;/entry&gt;</span>
                        <span class="tag">&lt;/map&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you place <code>&lt;aop:scoped-proxy/&gt;</code> in a <code>FactoryBean</code> implementation, it is the factory
bean itself that is scoped, not the object returned from <code>getObject()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-nature"><a class="anchor" href="#beans-factory-nature"></a>1.6. Customizing the nature of a bean</h3>
<div class="sect3">
<h4 id="beans-factory-lifecycle"><a class="anchor" href="#beans-factory-lifecycle"></a>1.6.1. Lifecycle callbacks</h4>
<div class="paragraph">
<p>To interact with the container&#8217;s management of the bean lifecycle, you can implement the
Spring <code>InitializingBean</code> and <code>DisposableBean</code> interfaces. The container calls
<code>afterPropertiesSet()</code> for the former and <code>destroy()</code> for the latter to allow the bean
to perform certain actions upon initialization and destruction of your beans.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The JSR-250 <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are generally considered best
practice for receiving lifecycle callbacks in a modern Spring application. Using these
annotations means that your beans are not coupled to Spring specific interfaces. For
details see <a href="#beans-postconstruct-and-predestroy-annotations">@PostConstruct and @PreDestroy</a>.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to use the JSR-250 annotations but you are still looking to remove
coupling consider the use of init-method and destroy-method object definition metadata.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally, the Spring Framework uses <code>BeanPostProcessor</code> implementations to process any
callback interfaces it can find and call the appropriate methods. If you need custom
features or other lifecycle behavior Spring does not offer out-of-the-box, you can
implement a <code>BeanPostProcessor</code> yourself. For more information, see
<a href="#beans-factory-extension">Container Extension Points</a>.</p>
</div>
<div class="paragraph">
<p>In addition to the initialization and destruction callbacks, Spring-managed objects may
also implement the <code>Lifecycle</code> interface so that those objects can participate in the
startup and shutdown process as driven by the container&#8217;s own lifecycle.</p>
</div>
<div class="paragraph">
<p>The lifecycle callback interfaces are described in this section.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-initializingbean"><a class="anchor" href="#beans-factory-lifecycle-initializingbean"></a>Initialization callbacks</h5>
<div class="paragraph">
<p>The <code>org.springframework.beans.factory.InitializingBean</code> interface allows a bean to
perform initialization work after all necessary properties on the bean have been set by
the container. The <code>InitializingBean</code> interface specifies a single method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterPropertiesSet() <span class="directive">throws</span> <span class="exception">Exception</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is recommended that you do not use the <code>InitializingBean</code> interface because it
unnecessarily couples the code to Spring. Alternatively, use
the <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a> annotation or
specify a POJO initialization method. In the case of XML-based configuration metadata,
you use the <code>init-method</code> attribute to specify the name of the method that has a void
no-argument signature. With Java config, you use the <code>initMethod</code> attribute of <code>@Bean</code>,
see <a href="#beans-java-lifecycle-callbacks">Receiving lifecycle callbacks</a>. For example, the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="comment">// do some initialization work</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;is exactly the same as&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">AnotherExampleBean</span> <span class="directive">implements</span> InitializingBean {

        <span class="directive">public</span> <span class="type">void</span> afterPropertiesSet() {
                <span class="comment">// do some initialization work</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but does not couple the code to Spring.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-disposablebean"><a class="anchor" href="#beans-factory-lifecycle-disposablebean"></a>Destruction callbacks</h5>
<div class="paragraph">
<p>Implementing the <code>org.springframework.beans.factory.DisposableBean</code> interface allows a
bean to get a callback when the container containing it is destroyed. The
<code>DisposableBean</code> interface specifies a single method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> destroy() <span class="directive">throws</span> <span class="exception">Exception</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is recommended that you do not use the <code>DisposableBean</code> callback interface because it
unnecessarily couples the code to Spring. Alternatively, use
the <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a> annotation or
specify a generic method that is supported by bean definitions. With XML-based
configuration metadata, you use the <code>destroy-method</code> attribute on the <code>&lt;bean/&gt;</code>.
With Java config, you use the <code>destroyMethod</code> attribute of <code>@Bean</code>, see
<a href="#beans-java-lifecycle-callbacks">Receiving lifecycle callbacks</a>. For example, the following definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">cleanup</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">public</span> <span class="type">void</span> cleanup() {
                <span class="comment">// do some destruction work (like releasing pooled connections)</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is exactly the same as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">AnotherExampleBean</span> <span class="directive">implements</span> DisposableBean {

        <span class="directive">public</span> <span class="type">void</span> destroy() {
                <span class="comment">// do some destruction work (like releasing pooled connections)</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but does not couple the code to Spring.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>destroy-method</code> attribute of a <code>&lt;bean&gt;</code> element can be assigned a special
<code>(inferred)</code> value which instructs Spring to automatically detect a public <code>close</code> or
<code>shutdown</code> method on the specific bean class (any class that implements
<code>java.lang.AutoCloseable</code> or <code>java.io.Closeable</code> would therefore match). This special
<code>(inferred)</code> value can also be set on the <code>default-destroy-method</code> attribute of a
<code>&lt;beans&gt;</code> element to apply this behavior to an entire set of beans (see
<a href="#beans-factory-lifecycle-default-init-destroy-methods">Default initialization and destroy methods</a>). Note that this is the
default behavior with Java config.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-default-init-destroy-methods"><a class="anchor" href="#beans-factory-lifecycle-default-init-destroy-methods"></a>Default initialization and destroy methods</h5>
<div class="paragraph">
<p>When you write initialization and destroy method callbacks that do not use the
Spring-specific <code>InitializingBean</code> and <code>DisposableBean</code> callback interfaces, you
typically write methods with names such as <code>init()</code>, <code>initialize()</code>, <code>dispose()</code>, and so
on. Ideally, the names of such lifecycle callback methods are standardized across a
project so that all developers use the same method names and ensure consistency.</p>
</div>
<div class="paragraph">
<p>You can configure the Spring container to <code>look</code> for named initialization and destroy
callback method names on <em>every</em> bean. This means that you, as an application
developer, can write your application classes and use an initialization callback called
<code>init()</code>, without having to configure an <code>init-method="init"</code> attribute with each bean
definition. The Spring IoC container calls that method when the bean is created (and in
accordance with the standard lifecycle callback contract described previously). This
feature also enforces a consistent naming convention for initialization and destroy
method callbacks.</p>
</div>
<div class="paragraph">
<p>Suppose that your initialization callback methods are named <code>init()</code> and destroy
callback methods are named <code>destroy()</code>. Your class will resemble the class in the
following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultBlogService</span> <span class="directive">implements</span> BlogService {

        <span class="directive">private</span> BlogDao blogDao;

        <span class="directive">public</span> <span class="type">void</span> setBlogDao(BlogDao blogDao) {
                <span class="local-variable">this</span>.blogDao = blogDao;
        }

        <span class="comment">// this is (unsurprisingly) the initialization callback method</span>
        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="keyword">if</span> (<span class="local-variable">this</span>.blogDao == <span class="predefined-constant">null</span>) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">The [blogDao] property must be set.</span><span class="delimiter">&quot;</span></span>);
                }
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultBlogService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogDao</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The presence of the <code>default-init-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element
attribute causes the Spring IoC container to recognize a method called <code>init</code> on beans
as the initialization method callback. When a bean is created and assembled, if the bean
class has such a method, it is invoked at the appropriate time.</p>
</div>
<div class="paragraph">
<p>You configure destroy method callbacks similarly (in XML, that is) by using the
<code>default-destroy-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>Where existing bean classes already have callback methods that are named at variance
with the convention, you can override the default by specifying (in XML, that is) the
method name using the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean/&gt;</code>
itself.</p>
</div>
<div class="paragraph">
<p>The Spring container guarantees that a configured initialization callback is called
immediately after a bean is supplied with all dependencies. Thus the initialization
callback is called on the raw bean reference, which means that AOP interceptors and so
forth are not yet applied to the bean. A target bean is fully created <em>first</em>,
<em>then</em> an AOP proxy (for example) with its interceptor chain is applied. If the target
bean and the proxy are defined separately, your code can even interact with the raw
target bean, bypassing the proxy. Hence, it would be inconsistent to apply the
interceptors to the init method, because doing so would couple the lifecycle of the
target bean with its proxy/interceptors and leave strange semantics when your code
interacts directly to the raw target bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-combined-effects"><a class="anchor" href="#beans-factory-lifecycle-combined-effects"></a>Combining lifecycle mechanisms</h5>
<div class="paragraph">
<p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior: the
<a href="#beans-factory-lifecycle-initializingbean"><code>InitializingBean</code></a> and
<a href="#beans-factory-lifecycle-disposablebean"><code>DisposableBean</code></a> callback interfaces; custom
<code>init()</code> and <code>destroy()</code> methods; and the
<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code> and <code>@PreDestroy</code>
annotations</a>. You can combine these mechanisms to control a given bean.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If multiple lifecycle mechanisms are configured for a bean, and each mechanism is
configured with a different method name, then each configured method is executed in the
order listed below. However, if the same method name is configured - for example,
<code>init()</code> for an initialization method - for more than one of these lifecycle mechanisms,
that method is executed once, as explained in the preceding section.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Multiple lifecycle mechanisms configured for the same bean, with different
initialization methods, are called as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Methods annotated with <code>@PostConstruct</code></p>
</li>
<li>
<p><code>afterPropertiesSet()</code> as defined by the <code>InitializingBean</code> callback interface</p>
</li>
<li>
<p>A custom configured <code>init()</code> method</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Destroy methods are called in the same order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Methods annotated with <code>@PreDestroy</code></p>
</li>
<li>
<p><code>destroy()</code> as defined by the <code>DisposableBean</code> callback interface</p>
</li>
<li>
<p>A custom configured <code>destroy()</code> method</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-processor"><a class="anchor" href="#beans-factory-lifecycle-processor"></a>Startup and shutdown callbacks</h5>
<div class="paragraph">
<p>The <code>Lifecycle</code> interface defines the essential methods for any object that has its own
lifecycle requirements (e.g. starts and stops some background process):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lifecycle</span> {

        <span class="type">void</span> start();

        <span class="type">void</span> stop();

        <span class="type">boolean</span> isRunning();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any Spring-managed object may implement that interface. Then, when the
<code>ApplicationContext</code> itself receives start and stop signals, e.g. for a stop/restart
scenario at runtime, it will cascade those calls to all <code>Lifecycle</code> implementations
defined within that context. It does this by delegating to a <code>LifecycleProcessor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">LifecycleProcessor</span> <span class="directive">extends</span> Lifecycle {

        <span class="type">void</span> onRefresh();

        <span class="type">void</span> onClose();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the <code>LifecycleProcessor</code> is itself an extension of the <code>Lifecycle</code>
interface. It also adds two other methods for reacting to the context being refreshed
and closed.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that the regular <code>org.springframework.context.Lifecycle</code> interface is just a plain
contract for explicit start/stop notifications and does NOT imply auto-startup at context
refresh time. Consider implementing <code>org.springframework.context.SmartLifecycle</code> instead
for fine-grained control over auto-startup of a specific bean (including startup phases).
Also, please note that stop notifications are not guaranteed to come before destruction:
On regular shutdown, all <code>Lifecycle</code> beans will first receive a stop notification before
the general destruction callbacks are being propagated; however, on hot refresh during a
context&#8217;s lifetime or on aborted refresh attempts, only destroy methods will be called.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The order of startup and shutdown invocations can be important. If a "depends-on"
relationship exists between any two objects, the dependent side will start <em>after</em> its
dependency, and it will stop <em>before</em> its dependency. However, at times the direct
dependencies are unknown. You may only know that objects of a certain type should start
prior to objects of another type. In those cases, the <code>SmartLifecycle</code> interface defines
another option, namely the <code>getPhase()</code> method as defined on its super-interface,
<code>Phased</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Phased</span> {

        <span class="type">int</span> getPhase();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">SmartLifecycle</span> <span class="directive">extends</span> Lifecycle, Phased {

        <span class="type">boolean</span> isAutoStartup();

        <span class="type">void</span> stop(<span class="predefined-type">Runnable</span> callback);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When starting, the objects with the lowest phase start first, and when stopping, the
reverse order is followed. Therefore, an object that implements <code>SmartLifecycle</code> and
whose <code>getPhase()</code> method returns <code>Integer.MIN_VALUE</code> would be among the first to start
and the last to stop. At the other end of the spectrum, a phase value of
<code>Integer.MAX_VALUE</code> would indicate that the object should be started last and stopped
first (likely because it depends on other processes to be running). When considering the
phase value, it&#8217;s also important to know that the default phase for any "normal"
<code>Lifecycle</code> object that does not implement <code>SmartLifecycle</code> would be 0. Therefore, any
negative phase value would indicate that an object should start before those standard
components (and stop after them), and vice versa for any positive phase value.</p>
</div>
<div class="paragraph">
<p>As you can see the stop method defined by <code>SmartLifecycle</code> accepts a callback. Any
implementation <em>must</em> invoke that callback&#8217;s <code>run()</code> method after that implementation&#8217;s
shutdown process is complete. That enables asynchronous shutdown where necessary since
the default implementation of the <code>LifecycleProcessor</code> interface,
<code>DefaultLifecycleProcessor</code>, will wait up to its timeout value for the group of objects
within each phase to invoke that callback. The default per-phase timeout is 30 seconds.
You can override the default lifecycle processor instance by defining a bean named
"lifecycleProcessor" within the context. If you only want to modify the timeout, then
defining the following would be sufficient:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lifecycleProcessor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.DefaultLifecycleProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">timeoutPerShutdownPhase</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As mentioned, the <code>LifecycleProcessor</code> interface defines callback methods for the
refreshing and closing of the context as well. The latter will simply drive the shutdown
process as if <code>stop()</code> had been called explicitly, but it will happen when the context is
closing. The 'refresh' callback on the other hand enables another feature of
<code>SmartLifecycle</code> beans. When the context is refreshed (after all objects have been
instantiated and initialized), that callback will be invoked, and at that point the
default lifecycle processor will check the boolean value returned by each
<code>SmartLifecycle</code> object&#8217;s <code>isAutoStartup()</code> method. If "true", then that object will be
started at that point rather than waiting for an explicit invocation of the context&#8217;s or
its own <code>start()</code> method (unlike the context refresh, the context start does not happen
automatically for a standard context implementation). The "phase" value as well as any
"depends-on" relationships will determine the startup order in the same way as described
above.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-shutdown"><a class="anchor" href="#beans-factory-shutdown"></a>Shutting down the Spring IoC container gracefully in non-web applications</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This section applies only to non-web applications. Spring&#8217;s web-based
<code>ApplicationContext</code> implementations already have code in place to shut down the Spring
IoC container gracefully when the relevant web application is shut down.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are using Spring&#8217;s IoC container in a non-web application environment; for
example, in a rich client desktop environment; you register a shutdown hook with the
JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your
singleton beans so that all resources are released. Of course, you must still configure
and implement these destroy callbacks correctly.</p>
</div>
<div class="paragraph">
<p>To register a shutdown hook, you call the <code>registerShutdownHook()</code> method that is
declared on the <code>ConfigurableApplicationContext</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context.ConfigurableApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);

                <span class="comment">// add a shutdown hook for the above context...</span>
                ctx.registerShutdownHook();

                <span class="comment">// app runs here...</span>

                <span class="comment">// main method exits, hook is called prior to the app shutting down...</span>
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-aware"><a class="anchor" href="#beans-factory-aware"></a>1.6.2. ApplicationContextAware and BeanNameAware</h4>
<div class="paragraph">
<p>When an <code>ApplicationContext</code> creates an object instance that implements the
<code>org.springframework.context.ApplicationContextAware</code> interface, the instance is provided
with a reference to that <code>ApplicationContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ApplicationContextAware</span> {

        <span class="type">void</span> setApplicationContext(ApplicationContext applicationContext) <span class="directive">throws</span> BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus beans can manipulate programmatically the <code>ApplicationContext</code> that created them,
through the <code>ApplicationContext</code> interface, or by casting the reference to a known
subclass of this interface, such as <code>ConfigurableApplicationContext</code>, which exposes
additional functionality. One use would be the programmatic retrieval of other beans.
Sometimes this capability is useful; however, in general you should avoid it, because it
couples the code to Spring and does not follow the Inversion of Control style, where
collaborators are provided to beans as properties. Other methods of the
<code>ApplicationContext</code> provide access to file resources, publishing application events, and
accessing a <code>MessageSource</code>. These additional features are described in
<a href="#context-introduction">Additional Capabilities of the ApplicationContext</a></p>
</div>
<div class="paragraph">
<p>As of Spring 2.5, autowiring is another alternative to obtain reference to the
<code>ApplicationContext</code>. The "traditional" <code>constructor</code> and <code>byType</code> autowiring modes (as
described in <a href="#beans-factory-autowire">Autowiring collaborators</a>) can provide a dependency of type
<code>ApplicationContext</code> for a constructor argument or setter method parameter,
respectively. For more flexibility, including the ability to autowire fields and
multiple parameter methods, use the new annotation-based autowiring features. If you do,
the <code>ApplicationContext</code> is autowired into a field, constructor argument, or method
parameter that is expecting the <code>ApplicationContext</code> type if the field, constructor, or
method in question carries the <code>@Autowired</code> annotation. For more information, see
<a href="#beans-autowired-annotation">@Autowired</a>.</p>
</div>
<div class="paragraph">
<p>When an <code>ApplicationContext</code> creates a class that implements the
<code>org.springframework.beans.factory.BeanNameAware</code> interface, the class is provided with
a reference to the name defined in its associated object definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeanNameAware</span> {

        <span class="type">void</span> setBeanName(<span class="predefined-type">String</span> name) <span class="directive">throws</span> BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The callback is invoked after population of normal bean properties but before an
initialization callback such as <code>InitializingBean</code> <em>afterPropertiesSet</em> or a custom
init-method.</p>
</div>
</div>
<div class="sect3">
<h4 id="aware-list"><a class="anchor" href="#aware-list"></a>1.6.3. Other Aware interfaces</h4>
<div class="paragraph">
<p>Besides <code>ApplicationContextAware</code> and <code>BeanNameAware</code> discussed above, Spring offers a
range of <code>Aware</code> interfaces that allow beans to indicate to the container that they
require a certain <em>infrastructure</em> dependency. The most important <code>Aware</code> interfaces
are summarized below - as a general rule, the name is a good indication of the
dependency type:</p>
</div>
<table id="beans-factory-nature-aware-list" class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. Aware interfaces</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Injected Dependency</th>
<th class="tableblock halign-left valign-top">Explained in&#8230;&#8203;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEventPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event publisher of the enclosing <code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the ApplicationContext</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanClassLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class loader used to load the bean classes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">Instantiating beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanFactoryAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>BeanFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanNameAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the declaring bean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BootstrapContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in
JCA aware <code>ApplicationContext</code>s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#cci">JCA CCI</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LoadTimeWeaverAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defined <em>weaver</em> for processing class definition at load time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#aop-aj-ltw">Load-time weaving with AspectJ in the Spring Framework</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageSourceAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured strategy for resolving messages (with support for parametrization and
internationalization)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the ApplicationContext</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotificationPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring JMX notification publisher</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#jmx-notifications">Notifications</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured loader for low-level access to resources</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#resources">Resources</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletConfigAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note again that usage of these interfaces ties your code to the Spring API and does not
follow the Inversion of Control style. As such, they are recommended for infrastructure
beans that require programmatic access to the container.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-child-bean-definitions"><a class="anchor" href="#beans-child-bean-definitions"></a>1.7. Bean definition inheritance</h3>
<div class="paragraph">
<p>A bean definition can contain a lot of configuration information, including constructor
arguments, property values, and container-specific information such as initialization
method, static factory method name, and so on. A child bean definition inherits
configuration data from a parent definition. The child definition can override some
values, or add others, as needed. Using parent and child bean definitions can save a lot
of typing. Effectively, this is a form of templating.</p>
</div>
<div class="paragraph">
<p>If you work with an <code>ApplicationContext</code> interface programmatically, child bean
definitions are represented by the <code>ChildBeanDefinition</code> class. Most users do not work
with them on this level, instead configuring bean definitions declaratively in something
like the <code>ClassPathXmlApplicationContext</code>. When you use XML-based configuration
metadata, you indicate a child bean definition by using the <code>parent</code> attribute,
specifying the parent bean as the value of this attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.TestBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritsWithDifferentClass</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.DerivedTestBean</span><span class="delimiter">&quot;</span></span>
                <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBean</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialize</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">override</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A child bean definition uses the bean class from the parent definition if none is
specified, but can also override it. In the latter case, the child bean class must be
compatible with the parent, that is, it must accept the parent&#8217;s property values.</p>
</div>
<div class="paragraph">
<p>A child bean definition inherits scope, constructor argument values, property values, and
method overrides from the parent, with the option to add new values. Any scope, initialization
method, destroy method, and/or <code>static</code> factory method settings that you specify will
override the corresponding parent settings.</p>
</div>
<div class="paragraph">
<p>The remaining settings are <em>always</em> taken from the child definition: <em>depends on</em>,
<em>autowire mode</em>, <em>dependency check</em>, <em>singleton</em>, <em>lazy init</em>.</p>
</div>
<div class="paragraph">
<p>The preceding example explicitly marks the parent bean definition as abstract by using
the <code>abstract</code> attribute. If the parent definition does not specify a class, explicitly
marking the parent bean definition as <code>abstract</code> is required, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBeanWithoutClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritsWithClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.DerivedTestBean</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBeanWithoutClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialize</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">override</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parent bean cannot be instantiated on its own because it is incomplete, and it is
also explicitly marked as <code>abstract</code>. When a definition is <code>abstract</code> like this, it is
usable only as a pure template bean definition that serves as a parent definition for
child definitions. Trying to use such an <code>abstract</code> parent bean on its own, by referring
to it as a ref property of another bean or doing an explicit <code>getBean()</code> call with the
parent bean id, returns an error. Similarly, the container&#8217;s internal
<code>preInstantiateSingletons()</code> method ignores bean definitions that are defined as
abstract.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ApplicationContext</code> pre-instantiates all singletons by default. Therefore, it is
important (at least for singleton beans) that if you have a (parent) bean definition
which you intend to use only as a template, and this definition specifies a class, you
must make sure to set the <em>abstract</em> attribute to <em>true</em>, otherwise the application
context will actually (attempt to) pre-instantiate the <code>abstract</code> bean.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-extension"><a class="anchor" href="#beans-factory-extension"></a>1.8. Container Extension Points</h3>
<div class="paragraph">
<p>Typically, an application developer does not need to subclass <code>ApplicationContext</code>
implementation classes. Instead, the Spring IoC container can be extended by plugging in
implementations of special integration interfaces. The next few sections describe these
integration interfaces.</p>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-bpp"><a class="anchor" href="#beans-factory-extension-bpp"></a>1.8.1. Customizing beans using a BeanPostProcessor</h4>
<div class="paragraph">
<p>The <code>BeanPostProcessor</code> interface defines <em>callback methods</em> that you can implement to
provide your own (or override the container&#8217;s default) instantiation logic,
dependency-resolution logic, and so forth. If you want to implement some custom logic
after the Spring container finishes instantiating, configuring, and initializing a bean,
you can plug in one or more <code>BeanPostProcessor</code> implementations.</p>
</div>
<div class="paragraph">
<p>You can configure multiple <code>BeanPostProcessor</code> instances, and you can control the order
in which these <code>BeanPostProcessor</code>s execute by setting the <code>order</code> property. You can
set this property only if the <code>BeanPostProcessor</code> implements the <code>Ordered</code> interface; if
you write your own <code>BeanPostProcessor</code> you should consider implementing the <code>Ordered</code>
interface too. For further details, consult the javadocs of the <code>BeanPostProcessor</code> and
<code>Ordered</code> interfaces. See also the note below on
<a href="#beans-factory-programmatically-registering-beanpostprocessors">programmatic
registration of <code>BeanPostProcessor</code>s</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>BeanPostProcessor</code>s operate on bean (or object) <em>instances</em>; that is to say, the
Spring IoC container instantiates a bean instance and <em>then</em> <code>BeanPostProcessor</code>s do
their work.</p>
</div>
<div class="paragraph">
<p><code>BeanPostProcessor</code>s are scoped <em>per-container</em>. This is only relevant if you are
using container hierarchies. If you define a <code>BeanPostProcessor</code> in one container, it
will <em>only</em> post-process the beans in that container. In other words, beans that are
defined in one container are not post-processed by a <code>BeanPostProcessor</code> defined in
another container, even if both containers are part of the same hierarchy.</p>
</div>
<div class="paragraph">
<p>To change the actual bean definition (i.e., the <em>blueprint</em> that defines the bean),
you instead need to use a <code>BeanFactoryPostProcessor</code> as described in
<a href="#beans-factory-extension-factory-postprocessors">Customizing configuration metadata with a BeanFactoryPostProcessor</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface consists of
exactly two callback methods. When such a class is registered as a post-processor with
the container, for each bean instance that is created by the container, the
post-processor gets a callback from the container both <em>before</em> container
initialization methods (such as InitializingBean&#8217;s <em>afterPropertiesSet()</em> and any
declared init method) are called as well as <em>after</em> any bean initialization callbacks.
The post-processor can take any action with the bean instance, including ignoring the
callback completely. A bean post-processor typically checks for callback interfaces or
may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as
bean post-processors in order to provide proxy-wrapping logic.</p>
</div>
<div class="paragraph">
<p>An <code>ApplicationContext</code> <em>automatically detects</em> any beans that are defined in the
configuration metadata which implement the <code>BeanPostProcessor</code> interface. The
<code>ApplicationContext</code> registers these beans as post-processors so that they can be called
later upon bean creation. Bean post-processors can be deployed in the container just
like any other beans.</p>
</div>
<div class="paragraph">
<p>Note that when declaring a <code>BeanPostProcessor</code> using an <code>@Bean</code> factory method on a
configuration class, the return type of the factory method should be the implementation
class itself or at least the <code>org.springframework.beans.factory.config.BeanPostProcessor</code>
interface, clearly indicating the post-processor nature of that bean. Otherwise, the
<code>ApplicationContext</code> won&#8217;t be able to autodetect it by type before fully creating it.
Since a <code>BeanPostProcessor</code> needs to be instantiated early in order to apply to the
initialization of other beans in the context, this early type detection is critical.</p>
</div>
<div id="beans-factory-programmatically-registering-beanpostprocessors" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Programmatically registering BeanPostProcessors</div>
<div class="paragraph">
<p>While the recommended approach for <code>BeanPostProcessor</code> registration is through
<code>ApplicationContext</code> auto-detection (as described above), it is also possible to
register them <em>programmatically</em> against a <code>ConfigurableBeanFactory</code> using the
<code>addBeanPostProcessor</code> method. This can be useful when needing to evaluate conditional
logic before registration, or even for copying bean post processors across contexts in a
hierarchy. Note however that <code>BeanPostProcessor</code>s added programmatically <em>do not
respect the <code>Ordered</code> interface</em>. Here it is the <em>order of registration</em> that
dictates the order of execution. Note also that <code>BeanPostProcessor</code>s registered
programmatically are always processed before those registered through auto-detection,
regardless of any explicit ordering.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">BeanPostProcessors and AOP auto-proxying</div>
<div class="paragraph">
<p>Classes that implement the <code>BeanPostProcessor</code> interface are <em>special</em> and are treated
differently by the container. All <code>BeanPostProcessor</code>s <em>and beans that they reference
directly</em> are instantiated on startup, as part of the special startup phase of the
<code>ApplicationContext</code>. Next, all <code>BeanPostProcessor</code>s are registered in a sorted fashion
and applied to all further beans in the container. Because AOP auto-proxying is
implemented as a <code>BeanPostProcessor</code> itself, neither <code>BeanPostProcessor</code>s nor the beans
they reference directly are eligible for auto-proxying, and thus do not have aspects
woven into them.</p>
</div>
<div class="paragraph">
<p>For any such bean, you should see an informational log message: "<em>Bean foo is not
eligible for getting processed by all BeanPostProcessor interfaces (for example: not
eligible for auto-proxying)</em>".</p>
</div>
<div class="paragraph">
<p>Note that if you have beans wired into your <code>BeanPostProcessor</code> using autowiring or
<code>@Resource</code> (which may fall back to autowiring), Spring might access unexpected beans
when searching for type-matching dependency candidates, and therefore make them
ineligible for auto-proxying or other kinds of bean post-processing. For example, if you
have a dependency annotated with <code>@Resource</code> where the field/setter name does not
directly correspond to the declared name of a bean and no name attribute is used, then
Spring will access other beans for matching them by type.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following examples show how to write, register, and use <code>BeanPostProcessor</code>s in an
<code>ApplicationContext</code>.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-hw"><a class="anchor" href="#beans-factory-extension-bpp-examples-hw"></a>Example: Hello World, BeanPostProcessor-style</h5>
<div class="paragraph">
<p>This first example illustrates basic usage. The example shows a custom
<code>BeanPostProcessor</code> implementation that invokes the <code>toString()</code> method of each bean as
it is created by the container and prints the resulting string to the system console.</p>
</div>
<div class="paragraph">
<p>Find below the custom <code>BeanPostProcessor</code> implementation class definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">scripting</span>;

<span class="keyword">import</span> <span class="include">org.springframework.beans.factory.config.BeanPostProcessor</span>;
<span class="keyword">import</span> <span class="include">org.springframework.beans.BeansException</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">InstantiationTracingBeanPostProcessor</span> <span class="directive">implements</span> BeanPostProcessor {

        <span class="comment">// simply return the instantiated bean as-is</span>
        <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessBeforeInitialization(<span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) {
                <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span>
        }

        <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessAfterInitialization(<span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Bean '</span><span class="delimiter">&quot;</span></span> + beanName + <span class="string"><span class="delimiter">&quot;</span><span class="content">' created : </span><span class="delimiter">&quot;</span></span> + bean.toString());
                <span class="keyword">return</span> bean;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:lang</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/lang</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/lang</span>
                <span class="content">http://www.springframework.org/schema/lang/spring-lang.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;lang:groovy</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messenger</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">script-source</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:org/springframework/scripting/groovy/Messenger.groovy</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;lang:property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Fiona Apple Is Just So Dreamy.</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/lang:groovy&gt;</span>

        <span class="comment">&lt;!--
        when the above bean (messenger) is instantiated, this custom
        BeanPostProcessor implementation will output the fact to the system console
        --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scripting.InstantiationTracingBeanPostProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the <code>InstantiationTracingBeanPostProcessor</code> is simply defined. It does not
even have a name, and because it is a bean it can be dependency-injected just like any
other bean. (The preceding configuration also defines a bean that is backed by a Groovy
script. The Spring dynamic language support is detailed in the chapter entitled
<a href="integration.html#dynamic-language">Dynamic language support</a>.)</p>
</div>
<div class="paragraph">
<p>The following simple Java application executes the preceding code and configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.scripting.Messenger</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">scripting/beans.xml</span><span class="delimiter">&quot;</span></span>);
                Messenger messenger = (Messenger) ctx.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">messenger</span><span class="delimiter">&quot;</span></span>);
                <span class="predefined-type">System</span>.out.println(messenger);
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the preceding application resembles the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Bean 'messenger' created : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="89e6fbeea7faf9fbe0e7eeeffbe8e4ecfee6fbe2a7faeafbe0f9fde0e7eea7eefbe6e6fff0a7cefbe6e6fff0c4ecfafaece7eeecfbc9bbbebbb0bfb8">[email&#160;protected]</a>
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7a15081d54090a0813141d1c081b171f0d15081154091908130a0e13141d541d0815150c03543d0815150c03371f09091f141d1f083a484d48434c4b">[email&#160;protected]</a></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-rabpp"><a class="anchor" href="#beans-factory-extension-bpp-examples-rabpp"></a>Example: The RequiredAnnotationBeanPostProcessor</h5>
<div class="paragraph">
<p>Using callback interfaces or annotations in conjunction with a custom
<code>BeanPostProcessor</code> implementation is a common means of extending the Spring IoC
container. An example is Spring&#8217;s <code>RequiredAnnotationBeanPostProcessor</code> - a
<code>BeanPostProcessor</code> implementation that ships with the Spring distribution which ensures
that JavaBean properties on beans that are marked with an (arbitrary) annotation are
actually (configured to be) dependency-injected with a value.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factory-postprocessors"><a class="anchor" href="#beans-factory-extension-factory-postprocessors"></a>1.8.2. Customizing configuration metadata with a BeanFactoryPostProcessor</h4>
<div class="paragraph">
<p>The next extension point that we will look at is the
<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>. The semantics of
this interface are similar to those of the <code>BeanPostProcessor</code>, with one major
difference: <code>BeanFactoryPostProcessor</code> operates on the <em>bean configuration metadata</em>;
that is, the Spring IoC container allows a <code>BeanFactoryPostProcessor</code> to read the
configuration metadata and potentially change it <em>before</em> the container instantiates
any beans other than <code>BeanFactoryPostProcessor</code>s.</p>
</div>
<div class="paragraph">
<p>You can configure multiple <code>BeanFactoryPostProcessor</code>s, and you can control the order in
which these <code>BeanFactoryPostProcessor</code>s execute by setting the <code>order</code> property.
However, you can only set this property if the <code>BeanFactoryPostProcessor</code> implements the
<code>Ordered</code> interface. If you write your own <code>BeanFactoryPostProcessor</code>, you should
consider implementing the <code>Ordered</code> interface too. Consult the javadocs of the
<code>BeanFactoryPostProcessor</code> and <code>Ordered</code> interfaces for more details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you want to change the actual bean <em>instances</em> (i.e., the objects that are created
from the configuration metadata), then you instead need to use a <code>BeanPostProcessor</code>
(described above in <a href="#beans-factory-extension-bpp">Customizing beans using a BeanPostProcessor</a>). While it is technically possible
to work with bean instances within a <code>BeanFactoryPostProcessor</code> (e.g., using
<code>BeanFactory.getBean()</code>), doing so causes premature bean instantiation, violating the
standard container lifecycle. This may cause negative side effects such as bypassing
bean post processing.</p>
</div>
<div class="paragraph">
<p>Also, <code>BeanFactoryPostProcessor</code>s are scoped <em>per-container</em>. This is only relevant if
you are using container hierarchies. If you define a <code>BeanFactoryPostProcessor</code> in one
container, it will <em>only</em> be applied to the bean definitions in that container. Bean
definitions in one container will not be post-processed by <code>BeanFactoryPostProcessor</code>s
in another container, even if both containers are part of the same hierarchy.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A bean factory post-processor is executed automatically when it is declared inside an
<code>ApplicationContext</code>, in order to apply changes to the configuration metadata that
define the container. Spring includes a number of predefined bean factory
post-processors, such as <code>PropertyOverrideConfigurer</code> and
<code>PropertyPlaceholderConfigurer</code>. A custom <code>BeanFactoryPostProcessor</code> can also be used,
for example, to register custom property editors.</p>
</div>
<div id="null" class="paragraph">
<p>An <code>ApplicationContext</code> automatically detects any beans that are deployed into it that
implement the <code>BeanFactoryPostProcessor</code> interface. It uses these beans as bean factory
post-processors, at the appropriate time. You can deploy these post-processor beans as
you would any other bean.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As with <code>BeanPostProcessor</code>s , you typically do not want to configure
<code>BeanFactoryPostProcessor</code>s for lazy initialization. If no other bean references a
<code>Bean(Factory)PostProcessor</code>, that post-processor will not get instantiated at all.
Thus, marking it for lazy initialization will be ignored, and the
<code>Bean(Factory)PostProcessor</code> will be instantiated eagerly even if you set the
<code>default-lazy-init</code> attribute to <code>true</code> on the declaration of your <code>&lt;beans /&gt;</code> element.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-factory-placeholderconfigurer"><a class="anchor" href="#beans-factory-placeholderconfigurer"></a>Example: the Class name substitution PropertyPlaceholderConfigurer</h5>
<div class="paragraph">
<p>You use the <code>PropertyPlaceholderConfigurer</code> to externalize property values from a bean
definition in a separate file using the standard Java <code>Properties</code> format. Doing so
enables the person deploying an application to customize environment-specific properties
such as database URLs and passwords, without the complexity or risk of modifying the
main XML definition file or files for the container.</p>
</div>
<div class="paragraph">
<p>Consider the following XML-based configuration metadata fragment, where a <code>DataSource</code>
with placeholder values is defined. The example shows properties configured from an
external <code>Properties</code> file. At runtime, a <code>PropertyPlaceholderConfigurer</code> is applied to
the metadata that will replace some properties of the DataSource. The values to replace
are specified as <em>placeholders</em> of the form <code>${property-name}</code> which follows the Ant /
log4j / JSP EL style.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">locations</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/foo/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">driverClassName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.driverClassName}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The actual values come from another file in the standard Java <code>Properties</code> format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre>
</div>
</div>
<div class="paragraph">
<p>Therefore, the string <code>${jdbc.username}</code> is replaced at runtime with the value 'sa', and
the same applies for other placeholder values that match keys in the properties file.
The <code>PropertyPlaceholderConfigurer</code> checks for placeholders in most properties and
attributes of a bean definition. Furthermore, the placeholder prefix and suffix can be
customized.</p>
</div>
<div class="paragraph">
<p>With the <code>context</code> namespace introduced in Spring 2.5, it is possible to configure
property placeholders with a dedicated configuration element. One or more locations can
be provided as a comma-separated list in the <code>location</code> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/foo/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PropertyPlaceholderConfigurer</code> not only looks for properties in the <code>Properties</code>
file you specify. By default it also checks against the Java <code>System</code> properties if it
cannot find a property in the specified properties files. You can customize this
behavior by setting the <code>systemPropertiesMode</code> property of the configurer with one of
the following three supported integer values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>never</em> (0): Never check system properties</p>
</li>
<li>
<p><em>fallback</em> (1): Check system properties if not resolvable in the specified
properties files. This is the default.</p>
</li>
<li>
<p><em>override</em> (2): Check system properties first, before trying the specified
properties files. This allows system properties to override any other property source.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consult the <code>PropertyPlaceholderConfigurer</code> javadocs for more information.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use the <code>PropertyPlaceholderConfigurer</code> to substitute class names, which is
sometimes useful when you have to pick a particular implementation class at runtime. For
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">locations</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>classpath:com/foo/strategy.properties<span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>custom.strategy.class=com.foo.DefaultStrategy<span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceStrategy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${custom.strategy.class}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the class cannot be resolved at runtime to a valid class, resolution of the bean
fails when it is about to be created, which is during the <code>preInstantiateSingletons()</code>
phase of an <code>ApplicationContext</code> for a non-lazy-init bean.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-overrideconfigurer"><a class="anchor" href="#beans-factory-overrideconfigurer"></a>Example: the PropertyOverrideConfigurer</h5>
<div class="paragraph">
<p>The <code>PropertyOverrideConfigurer</code>, another bean factory post-processor, resembles the
<code>PropertyPlaceholderConfigurer</code>, but unlike the latter, the original definitions can
have default values or no values at all for bean properties. If an overriding
<code>Properties</code> file does not have an entry for a certain bean property, the default
context definition is used.</p>
</div>
<div class="paragraph">
<p>Note that the bean definition is <em>not</em> aware of being overridden, so it is not
immediately obvious from the XML definition file that the override configurer is being
used. In case of multiple <code>PropertyOverrideConfigurer</code> instances that define different
values for the same bean property, the last one wins, due to the overriding mechanism.</p>
</div>
<div class="paragraph">
<p>Properties file configuration lines take this format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>beanName.property=value</pre>
</div>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre>
</div>
</div>
<div class="paragraph">
<p>This example file can be used with a container definition that contains a bean called
<em>dataSource</em>, which has <em>driver</em> and <em>url</em> properties.</p>
</div>
<div class="paragraph">
<p>Compound property names are also supported, as long as every component of the path
except the final property being overridden is already non-null (presumably initialized
by the constructors). In this example&#8230;&#8203;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>foo.fred.bob.sammy=123</pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>the <code>sammy</code> property of the <code>bob</code> property of the <code>fred</code> property of the <code>foo</code> bean
is set to the scalar value <code>123</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Specified override values are always <em>literal</em> values; they are not translated into
bean references. This convention also applies when the original value in the XML bean
definition specifies a bean reference.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With the <code>context</code> namespace introduced in Spring 2.5, it is possible to configure
property overriding with a dedicated configuration element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:property-override</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:override.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factorybean"><a class="anchor" href="#beans-factory-extension-factorybean"></a>1.8.3. Customizing instantiation logic with a FactoryBean</h4>
<div class="paragraph">
<p>Implement the <code>org.springframework.beans.factory.FactoryBean</code> interface for objects that
<em>are themselves factories</em>.</p>
</div>
<div class="paragraph">
<p>The <code>FactoryBean</code> interface is a point of pluggability into the Spring IoC container&#8217;s
instantiation logic. If you have complex initialization code that is better expressed in
Java as opposed to a (potentially) verbose amount of XML, you can create your own
<code>FactoryBean</code>, write the complex initialization inside that class, and then plug your
custom <code>FactoryBean</code> into the container.</p>
</div>
<div class="paragraph">
<p>The <code>FactoryBean</code> interface provides three methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object getObject()</code>: returns an instance of the object this factory creates. The
instance can possibly be shared, depending on whether this factory returns singletons
or prototypes.</p>
</li>
<li>
<p><code>boolean isSingleton()</code>: returns <code>true</code> if this <code>FactoryBean</code> returns singletons,
<code>false</code> otherwise.</p>
</li>
<li>
<p><code>Class getObjectType()</code>: returns the object type returned by the <code>getObject()</code> method
or <code>null</code> if the type is not known in advance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>FactoryBean</code> concept and interface is used in a number of places within the Spring
Framework; more than 50 implementations of the <code>FactoryBean</code> interface ship with Spring
itself.</p>
</div>
<div class="paragraph">
<p>When you need to ask a container for an actual <code>FactoryBean</code> instance itself instead of
the bean it produces, preface the bean&#8217;s id with the ampersand symbol ( <code>&amp;</code>) when
calling the <code>getBean()</code> method of the <code>ApplicationContext</code>. So for a given <code>FactoryBean</code>
with an id of <code>myBean</code>, invoking <code>getBean("myBean")</code> on the container returns the
product of the <code>FactoryBean</code>; whereas, invoking <code>getBean("&amp;myBean")</code> returns the
<code>FactoryBean</code> instance itself.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-annotation-config"><a class="anchor" href="#beans-annotation-config"></a>1.9. Annotation-based container configuration</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">Are annotations better than XML for configuring Spring?</div>
<div class="paragraph">
<p>The introduction of annotation-based configurations raised the question of whether this
approach is 'better' than XML. The short answer is <em>it depends</em>. The long answer is
that each approach has its pros and cons, and usually it is up to the developer to
decide which strategy suits them better. Due to the way they are defined, annotations
provide a lot of context in their declaration, leading to shorter and more concise
configuration. However, XML excels at wiring up components without touching their source
code or recompiling them. Some developers prefer having the wiring close to the source
while others argue that annotated classes are no longer POJOs and, furthermore, that the
configuration becomes decentralized and harder to control.</p>
</div>
<div class="paragraph">
<p>No matter the choice, Spring can accommodate both styles and even mix them together.
It&#8217;s worth pointing out that through its <a href="#beans-java">JavaConfig</a> option, Spring allows
annotations to be used in a non-invasive way, without touching the target components
source code and that in terms of tooling, all configuration styles are supported by the
<a href="https://spring.io/tools/sts">Spring Tool Suite</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>An alternative to XML setups is provided by annotation-based configuration which rely on
the bytecode metadata for wiring up components instead of angle-bracket declarations.
Instead of using XML to describe a bean wiring, the developer moves the configuration
into the component class itself by using annotations on the relevant class, method, or
field declaration. As mentioned in <a href="#beans-factory-extension-bpp-examples-rabpp">Example: The RequiredAnnotationBeanPostProcessor</a>, using
a <code>BeanPostProcessor</code> in conjunction with annotations is a common means of extending the
Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing
required properties with the <a href="#beans-required-annotation">@Required</a> annotation. Spring
2.5 made it possible to follow that same general approach to drive Spring&#8217;s dependency
injection. Essentially, the <code>@Autowired</code> annotation provides the same capabilities as
described in <a href="#beans-factory-autowire">Autowiring collaborators</a> but with more fine-grained control and wider
applicability. Spring 2.5 also added support for JSR-250 annotations such as
<code>@PostConstruct</code>, and <code>@PreDestroy</code>. Spring 3.0 added support for JSR-330 (Dependency
Injection for Java) annotations contained in the javax.inject package such as <code>@Inject</code>
and <code>@Named</code>. Details about those annotations can be found in the
<a href="#beans-standard-annotations">relevant section</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Annotation injection is performed <em>before</em> XML injection, thus the latter
configuration will override the former for properties wired through both approaches.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As always, you can register them as individual bean definitions, but they can also be
implicitly registered by including the following tag in an XML-based Spring
configuration (notice the inclusion of the <code>context</code> namespace):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(The implicitly registered post-processors include
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a>,
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a>,
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a>,
as well as the aforementioned
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a>.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;context:annotation-config/&gt;</code> only looks for annotations on beans in the same
application context in which it is defined. This means that, if you put
<code>&lt;context:annotation-config/&gt;</code> in a <code>WebApplicationContext</code> for a <code>DispatcherServlet</code>,
it only checks for <code>@Autowired</code> beans in your controllers, and not your services. See
<a href="web.html#mvc-servlet">The DispatcherServlet</a> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-required-annotation"><a class="anchor" href="#beans-required-annotation"></a>1.9.1. @Required</h4>
<div class="paragraph">
<p>The <code>@Required</code> annotation applies to bean property setter methods, as in the following
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Required</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This annotation simply indicates that the affected bean property must be populated at
configuration time, through an explicit property value in a bean definition or through
autowiring. The container throws an exception if the affected bean property has not been
populated; this allows for eager and explicit failure, avoiding <code>NullPointerException</code>s
or the like later on. It is still recommended that you put assertions into the bean
class itself, for example, into an init method. Doing so enforces those required
references and values even when you use the class outside of a container.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation"><a class="anchor" href="#beans-autowired-annotation"></a>1.9.2. @Autowired</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR 330&#8217;s <code>@Inject</code> annotation can be used in place of Spring&#8217;s <code>@Autowired</code> annotation
in the examples below. See <a href="#beans-standard-annotations">here</a> for more details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can apply the <code>@Autowired</code> annotation to constructors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="directive">final</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Framework 4.3, an <code>@Autowired</code> annotation on such a constructor is
no longer necessary if the target bean only defines one constructor to begin with.
However, if several constructors are available, at least one must be annotated to
teach the container which one to use.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As expected, you can also apply the <code>@Autowired</code> annotation to "traditional" setter
methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also apply the annotation to methods with arbitrary names and/or multiple
arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> prepare(MovieCatalog movieCatalog,
                        CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.movieCatalog = movieCatalog;
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can apply <code>@Autowired</code> to fields as well and even mix it with constructors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="directive">final</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Make sure that your target components (e.g. <code>MovieCatalog</code>, <code>CustomerPreferenceDao</code>)
are consistently declared by the type that you are using for your <code>@Autowired</code>-annotated
injection points. Otherwise injection may fail due to no type match found at runtime.</p>
</div>
<div class="paragraph">
<p>For XML-defined beans or component classes found through a classpath scan, the container
usually knows the concrete type upfront. However, for <code>@Bean</code> factory methods, you need
to make sure that the declared return type is sufficiently expressive. For components
implementing several interfaces or for components potentially referred to by their
implementation type, consider declaring the most specific return type on your factory
method (at least as specific as required by the injection points referring to your bean).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is also possible to provide <em>all</em> beans of a particular type from the
<code>ApplicationContext</code> by adding the annotation to a field or method that expects an array
of that type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog<span class="type">[]</span> movieCatalogs;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same applies for typed collections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">Set</span>&lt;MovieCatalog&gt; movieCatalogs;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs(<span class="predefined-type">Set</span>&lt;MovieCatalog&gt; movieCatalogs) {
                <span class="local-variable">this</span>.movieCatalogs = movieCatalogs;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Your beans can implement the <code>org.springframework.core.Ordered</code> interface or either use
the <code>@Order</code> or standard <code>@Priority</code> annotation if you want items in the array or list
to be sorted into a specific order.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even typed Maps can be autowired as long as the expected key type is <code>String</code>. The Map
values will contain all beans of the expected type, and the keys will contain the
corresponding bean names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, MovieCatalog&gt; movieCatalogs;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, MovieCatalog&gt; movieCatalogs) {
                <span class="local-variable">this</span>.movieCatalogs = movieCatalogs;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the autowiring fails whenever <em>zero</em> candidate beans are available; the
default behavior is to treat annotated methods, constructors, and fields as
indicating <em>required</em> dependencies. This behavior can be changed as demonstrated below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>(required = <span class="predefined-constant">false</span>)
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Only <em>one annotated constructor per-class</em> can be marked as <em>required</em>, but multiple
non-required constructors can be annotated. In that case, each is considered among the
candidates and Spring uses the <em>greediest</em> constructor whose dependencies can be
satisfied, that is the constructor that has the largest number of arguments.</p>
</div>
<div class="paragraph">
<p><code>@Autowired&#8217;s <em>required</em> attribute is recommended over the `@Required</code> annotation.
The <em>required</em> attribute indicates that the property is not required for autowiring
purposes, the property is ignored if it cannot be autowired. <code>@Required</code>, on the other
hand, is stronger in that it enforces the property that was set by any means supported
by the container. If no value is injected, a corresponding exception is raised.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use <code>@Autowired</code> for interfaces that are well-known resolvable
dependencies: <code>BeanFactory</code>, <code>ApplicationContext</code>, <code>Environment</code>, <code>ResourceLoader</code>,
<code>ApplicationEventPublisher</code>, and <code>MessageSource</code>. These interfaces and their extended
interfaces, such as <code>ConfigurableApplicationContext</code> or <code>ResourcePatternResolver</code>, are
automatically resolved, with no special setup necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> ApplicationContext context;

        <span class="directive">public</span> MovieRecommender() {
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Autowired</code>, <code>@Inject</code>, <code>@Resource</code>, and <code>@Value</code> annotations are handled by Spring
<code>BeanPostProcessor</code> implementations which in turn means that you <em>cannot</em> apply these
annotations within your own <code>BeanPostProcessor</code> or <code>BeanFactoryPostProcessor</code> types (if
any). These types must be 'wired up' explicitly via XML or using a Spring <code>@Bean</code> method.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-primary"><a class="anchor" href="#beans-autowired-annotation-primary"></a>1.9.3. Fine-tuning annotation-based autowiring with @Primary</h4>
<div class="paragraph">
<p>Because autowiring by type may lead to multiple candidates, it is often necessary to have
more control over the selection process. One way to accomplish this is with Spring&#8217;s
<code>@Primary</code> annotation. <code>@Primary</code> indicates that a particular bean should be given
preference when multiple beans are candidates to be autowired to a single-valued
dependency. If exactly one 'primary' bean exists among the candidates, it will be the
autowired value.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we have the following configuration that defines <code>firstMovieCatalog</code> as the
<em>primary</em> <code>MovieCatalog</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieConfiguration</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Primary</span></strong>
        <span class="directive">public</span> MovieCatalog firstMovieCatalog() { ... }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> MovieCatalog secondMovieCatalog() { ... }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With such configuration, the following <code>MovieRecommender</code> will be autowired with the
<code>firstMovieCatalog</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding bean definitions appear as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span> <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">primary</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-qualifiers"><a class="anchor" href="#beans-autowired-annotation-qualifiers"></a>1.9.4. Fine-tuning annotation-based autowiring with qualifiers</h4>
<div class="paragraph">
<p><code>@Primary</code> is an effective way to use autowiring by type with several instances when one
primary candidate can be determined. When more control over the selection process is
required, Spring&#8217;s <code>@Qualifier</code> annotation can be used. You can associate qualifier values
with specific arguments, narrowing the set of type matches so that a specific bean is
chosen for each argument. In the simplest case, this can be a plain descriptive value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Qualifier</code> annotation can also be specified on individual constructor arguments or
method parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> prepare(<strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>)</strong>MovieCatalog movieCatalog,
                        CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.movieCatalog = movieCatalog;
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding bean definitions appear as follows. The bean with qualifier value
"main" is wired with the constructor argument that is qualified with the same value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>

                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>

                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For a fallback match, the bean name is considered a default qualifier value. Thus you
can define the bean with an id "main" instead of the nested qualifier element, leading
to the same matching result. However, although you can use this convention to refer to
specific beans by name, <code>@Autowired</code> is fundamentally about type-driven injection with
optional semantic qualifiers. This means that qualifier values, even with the bean name
fallback, always have narrowing semantics within the set of type matches; they do not
semantically express a reference to a unique bean id. Good qualifier values are "main"
or "EMEA" or "persistent", expressing characteristics of a specific component that are
independent from the bean <code>id</code>, which may be auto-generated in case of an anonymous bean
definition like the one in the preceding example.</p>
</div>
<div class="paragraph">
<p>Qualifiers also apply to typed collections, as discussed above, for example, to
<code>Set&lt;MovieCatalog&gt;</code>. In this case, all matching beans according to the declared
qualifiers are injected as a collection. This implies that qualifiers do not have to be
unique; they rather simply constitute filtering criteria. For example, you can define
multiple <code>MovieCatalog</code> beans with the same qualifier value "action", all of which would
be injected into a <code>Set&lt;MovieCatalog&gt;</code> annotated with <code>@Qualifier("action")</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you intend to express annotation-driven injection by name, do not primarily use
<code>@Autowired</code>, even if is technically capable of referring to a bean name through
<code>@Qualifier</code> values. Instead, use the JSR-250 <code>@Resource</code> annotation, which is
semantically defined to identify a specific target component by its unique name, with
the declared type being irrelevant for the matching process. <code>@Autowired</code> has rather
different semantics: After selecting candidate beans by type, the specified String
qualifier value will be considered within those type-selected candidates only, e.g.
matching an "account" qualifier against beans marked with the same qualifier label.</p>
</div>
<div class="paragraph">
<p>For beans that are themselves defined as a collection/map or array type, <code>@Resource</code>
is a fine solution, referring to the specific collection or array bean by unique name.
That said, as of 4.3, collection/map and array types can be matched through Spring&#8217;s
<code>@Autowired</code> type matching algorithm as well, as long as the element type information
is preserved in <code>@Bean</code> return type signatures or collection inheritance hierarchies.
In this case, qualifier values can be used to select among same-typed collections,
as outlined in the previous paragraph.</p>
</div>
<div class="paragraph">
<p>As of 4.3, <code>@Autowired</code> also considers self references for injection, i.e. references
back to the bean that is currently injected. Note that self injection is a fallback;
regular dependencies on other components always have precedence. In that sense, self
references do not participate in regular candidate selection and are therefore in
particular never primary; on the contrary, they always end up as lowest precedence.
In practice, use self references as a last resort only, e.g. for calling other methods
on the same instance through the bean&#8217;s transactional proxy: Consider factoring out
the affected methods to a separate delegate bean in such a scenario. Alternatively,
use <code>@Resource</code> which may obtain a proxy back to the current bean by its unique name.</p>
</div>
<div class="paragraph">
<p><code>@Autowired</code> applies to fields, constructors, and multi-argument methods, allowing for
narrowing through qualifier annotations at the parameter level. By contrast, <code>@Resource</code>
is supported only for fields and bean property setter methods with a single argument.
As a consequence, stick with qualifiers if your injection target is a constructor or a
multi-argument method.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can create your own custom qualifier annotations. Simply define an annotation and
provide the <code>@Qualifier</code> annotation within your definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<strong><span class="annotation">@Qualifier</span></strong>
<span class="directive">public</span> <span class="annotation">@interface</span> Genre {

        <span class="predefined-type">String</span> value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can provide the custom qualifier on autowired fields and parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">private</span> MovieCatalog actionCatalog;

        <span class="directive">private</span> MovieCatalog comedyCatalog;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setComedyCatalog(<strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)</strong> MovieCatalog comedyCatalog) {
                <span class="local-variable">this</span>.comedyCatalog = comedyCatalog;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, provide the information for the candidate bean definitions. You can add
<code>&lt;qualifier/&gt;</code> tags as sub-elements of the <code>&lt;bean/&gt;</code> tag and then specify the <code>type</code> and
<code>value</code> to match your custom qualifier annotations. The type is matched against the
fully-qualified class name of the annotation. Or, as a convenience if no risk of
conflicting names exists, you can use the short class name. Both approaches are
demonstrated in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.Genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#beans-classpath-scanning">Classpath scanning and managed components</a>, you will see an annotation-based alternative to
providing the qualifier metadata in XML. Specifically, see <a href="#beans-scanning-qualifiers">Providing qualifier metadata with annotations</a>.</p>
</div>
<div class="paragraph">
<p>In some cases, it may be sufficient to use an annotation without a value. This may be
useful when the annotation serves a more generic purpose and can be applied across
several different types of dependencies. For example, you may provide an <em>offline</em>
catalog that would be searched when no Internet connection is available. First define
the simple annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Qualifier</span>
<span class="directive">public</span> <span class="annotation">@interface</span> Offline {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the annotation to the field or property to be autowired:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Offline</span></strong>
        <span class="directive">private</span> MovieCatalog offlineCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the bean definition only needs a qualifier <code>type</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Offline</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also define custom qualifier annotations that accept named attributes in
addition to or instead of the simple <code>value</code> attribute. If multiple attribute values are
then specified on a field or parameter to be autowired, a bean definition must match
<em>all</em> such attribute values to be considered an autowire candidate. As an example,
consider the following annotation definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Qualifier</span>
<span class="directive">public</span> <span class="annotation">@interface</span> MovieQualifier {

        <span class="predefined-type">String</span> genre();

        <span class="predefined-type">Format</span> format();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case <code>Format</code> is an enum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> <span class="predefined-type">Format</span> {
        VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fields to be autowired are annotated with the custom qualifier and include values
for both attributes: <code>genre</code> and <code>format</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.VHS, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog actionVhsCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.VHS, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog comedyVhsCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.DVD, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog actionDvdCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.BLURAY, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog comedyBluRayCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the bean definitions should contain matching qualifier values. This example
also demonstrates that bean <em>meta</em> attributes may be used instead of the
<code>&lt;qualifier/&gt;</code> sub-elements. If available, the <code>&lt;qualifier/&gt;</code> and its attributes take
precedence, but the autowiring mechanism falls back on the values provided within the
<code>&lt;meta/&gt;</code> tags if no such qualifier is present, as in the last two bean definitions in
the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MovieQualifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">VHS</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/qualifier&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MovieQualifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">VHS</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/qualifier&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">DVD</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">BLURAY</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-generics-as-qualifiers"><a class="anchor" href="#beans-generics-as-qualifiers"></a>1.9.5. Using generics as autowiring qualifiers</h4>
<div class="paragraph">
<p>In addition to the <code>@Qualifier</code> annotation, it is also possible to use Java generic types
as an implicit form of qualification. For example, suppose you have the following
configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> StringStore stringStore() {
                <span class="keyword">return</span> <span class="keyword">new</span> StringStore();
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> IntegerStore integerStore() {
                <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming that beans above implement a generic interface, i.e. <code>Store&lt;String&gt;</code> and
<code>Store&lt;Integer&gt;</code>, you can <code>@Autowire</code> the <code>Store</code> interface and the <em>generic</em> will
be used as a qualifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span>
<span class="directive">private</span> Store&lt;<span class="predefined-type">String</span>&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span>

<span class="annotation">@Autowired</span>
<span class="directive">private</span> Store&lt;<span class="predefined-type">Integer</span>&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Generic qualifiers also apply when autowiring Lists, Maps and Arrays:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span>
<span class="comment">// Store&lt;String&gt; beans will not appear in this list</span>
<span class="annotation">@Autowired</span>
<span class="directive">private</span> <span class="predefined-type">List</span>&lt;Store&lt;<span class="predefined-type">Integer</span>&gt;&gt; s;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-custom-autowire-configurer"><a class="anchor" href="#beans-custom-autowire-configurer"></a>1.9.6. CustomAutowireConfigurer</h4>
<div class="paragraph">
<p>The
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a>
is a <code>BeanFactoryPostProcessor</code> that enables you to register your own custom qualifier
annotation types even if they are not annotated with Spring&#8217;s <code>@Qualifier</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customAutowireConfigurer</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.annotation.CustomAutowireConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customQualifierTypes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;value&gt;</span>example.CustomQualifier<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AutowireCandidateResolver</code> determines autowire candidates by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>autowire-candidate</code> value of each bean definition</p>
</li>
<li>
<p>any <code>default-autowire-candidates</code> pattern(s) available on the <code>&lt;beans/&gt;</code> element</p>
</li>
<li>
<p>the presence of <code>@Qualifier</code> annotations and any custom annotations registered
with the <code>CustomAutowireConfigurer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When multiple beans qualify as autowire candidates, the determination of a "primary" is
the following: if exactly one bean definition among the candidates has a <code>primary</code>
attribute set to <code>true</code>, it will be selected.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-resource-annotation"><a class="anchor" href="#beans-resource-annotation"></a>1.9.7. @Resource</h4>
<div class="paragraph">
<p>Spring also supports injection using the JSR-250 <code>@Resource</code> annotation on fields or
bean property setter methods. This is a common pattern in Java EE 5 and 6, for example
in JSF 1.2 managed beans or JAX-WS 2.0 endpoints. Spring supports this pattern for
Spring-managed objects as well.</p>
</div>
<div class="paragraph">
<p><code>@Resource</code> takes a name attribute, and by default Spring interprets that value as the
bean name to be injected. In other words, it follows <em>by-name</em> semantics, as
demonstrated in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <strong><span class="annotation">@Resource</span>(name=<span class="string"><span class="delimiter">&quot;</span><span class="content">myMovieFinder</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no name is specified explicitly, the default name is derived from the field name or
setter method. In case of a field, it takes the field name; in case of a setter method,
it takes the bean property name. So the following example is going to have the bean with
name "movieFinder" injected into its setter method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <strong><span class="annotation">@Resource</span></strong>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The name provided with the annotation is resolved as a bean name by the
<code>ApplicationContext</code> of which the <code>CommonAnnotationBeanPostProcessor</code> is aware. The
names can be resolved through JNDI if you configure Spring&#8217;s
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>
explicitly. However, it is recommended that you rely on the default behavior and simply
use Spring&#8217;s JNDI lookup capabilities to preserve the level of indirection.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the exclusive case of <code>@Resource</code> usage with no explicit name specified, and similar
to <code>@Autowired</code>, <code>@Resource</code> finds a primary type match instead of a specific named bean
and resolves well-known resolvable dependencies: the <code>BeanFactory</code>,
<code>ApplicationContext</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code>
interfaces.</p>
</div>
<div class="paragraph">
<p>Thus in the following example, the <code>customerPreferenceDao</code> field first looks for a bean
named customerPreferenceDao, then falls back to a primary type match for the type
<code>CustomerPreferenceDao</code>. The "context" field is injected based on the known resolvable
dependency type <code>ApplicationContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Resource</span>
        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Resource</span>
        <span class="directive">private</span> ApplicationContext context;

        <span class="directive">public</span> MovieRecommender() {
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-postconstruct-and-predestroy-annotations"><a class="anchor" href="#beans-postconstruct-and-predestroy-annotations"></a>1.9.8. @PostConstruct and @PreDestroy</h4>
<div class="paragraph">
<p>The <code>CommonAnnotationBeanPostProcessor</code> not only recognizes the <code>@Resource</code> annotation
but also the JSR-250 <em>lifecycle</em> annotations. Introduced in Spring 2.5, the support
for these annotations offers yet another alternative to those described in
<a href="#beans-factory-lifecycle-initializingbean">initialization callbacks</a> and
<a href="#beans-factory-lifecycle-disposablebean">destruction callbacks</a>. Provided that the
<code>CommonAnnotationBeanPostProcessor</code> is registered within the Spring
<code>ApplicationContext</code>, a method carrying one of these annotations is invoked at the same
point in the lifecycle as the corresponding Spring lifecycle interface method or
explicitly declared callback method. In the example below, the cache will be
pre-populated upon initialization and cleared upon destruction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CachingMovieLister</span> {

        <span class="annotation">@PostConstruct</span>
        <span class="directive">public</span> <span class="type">void</span> populateMovieCache() {
                <span class="comment">// populates the movie cache upon initialization...</span>
        }

        <span class="annotation">@PreDestroy</span>
        <span class="directive">public</span> <span class="type">void</span> clearMovieCache() {
                <span class="comment">// clears the movie cache upon destruction...</span>
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For details about the effects of combining various lifecycle mechanisms, see
<a href="#beans-factory-lifecycle-combined-effects">Combining lifecycle mechanisms</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-classpath-scanning"><a class="anchor" href="#beans-classpath-scanning"></a>1.10. Classpath scanning and managed components</h3>
<div class="paragraph">
<p>Most examples in this chapter use XML to specify the configuration metadata that produces
each <code>BeanDefinition</code> within the Spring container. The previous section
(<a href="#beans-annotation-config">Annotation-based container configuration</a>) demonstrates how to provide a lot of the configuration
metadata through source-level annotations. Even in those examples, however, the "base"
bean definitions are explicitly defined in the XML file, while the annotations only drive
the dependency injection. This section describes an option for implicitly detecting the
<em>candidate components</em> by scanning the classpath. Candidate components are classes that
match against a filter criteria and have a corresponding bean definition registered with
the container. This removes the need to use XML to perform bean registration; instead you
can use annotations (for example <code>@Component</code>), AspectJ type expressions, or your own
custom filter criteria to select which classes will have bean definitions registered with
the container.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with Spring 3.0, many features provided by the Spring JavaConfig project are
part of the core Spring Framework. This allows you to define beans using Java rather
than using the traditional XML files. Take a look at the <code>@Configuration</code>, <code>@Bean</code>,
<code>@Import</code>, and <code>@DependsOn</code> annotations for examples of how to use these new features.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-stereotype-annotations"><a class="anchor" href="#beans-stereotype-annotations"></a>1.10.1. @Component and further stereotype annotations</h4>
<div class="paragraph">
<p>The <code>@Repository</code> annotation is a marker for any class that fulfills the role or
<em>stereotype</em> of a repository (also known as Data Access Object or DAO). Among the uses
of this marker is the automatic translation of exceptions as described in
<a href="data-access.html#orm-exception-translation">Exception translation</a>.</p>
</div>
<div class="paragraph">
<p>Spring provides further stereotype annotations: <code>@Component</code>, <code>@Service</code>, and
<code>@Controller</code>. <code>@Component</code> is a generic stereotype for any Spring-managed component.
<code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are specializations of <code>@Component</code> for
more specific use cases, for example, in the persistence, service, and presentation
layers, respectively. Therefore, you can annotate your component classes with
<code>@Component</code>, but by annotating them with <code>@Repository</code>, <code>@Service</code>, or <code>@Controller</code>
instead, your classes are more properly suited for processing by tools or associating
with aspects. For example, these stereotype annotations make ideal targets for
pointcuts. It is also possible that <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> may
carry additional semantics in future releases of the Spring Framework. Thus, if you are
choosing between using <code>@Component</code> or <code>@Service</code> for your service layer, <code>@Service</code> is
clearly the better choice. Similarly, as stated above, <code>@Repository</code> is already
supported as a marker for automatic exception translation in your persistence layer.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-meta-annotations"><a class="anchor" href="#beans-meta-annotations"></a>1.10.2. Meta-annotations</h4>
<div class="paragraph">
<p>Many of the annotations provided by Spring can be used as <em>meta-annotations</em> in your
own code. A meta-annotation is simply an annotation that can be applied to another
annotation. For example, the <code>@Service</code> annotation mentioned above is meta-annotated with
<code>@Component</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.TYPE)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Documented</span>
<strong><span class="annotation">@Component</span></strong> <span class="comment">// Spring will see this and treat @Service in the same way as @Component</span>
<span class="directive">public</span> <span class="annotation">@interface</span> Service {

        <span class="comment">// ....</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Meta-annotations can also be combined to create <em>composed annotations</em>. For example,
the <code>@RestController</code> annotation from Spring MVC is <em>composed</em> of <code>@Controller</code> and
<code>@ResponseBody</code>.</p>
</div>
<div class="paragraph">
<p>In addition, composed annotations may optionally redeclare attributes from
meta-annotations to allow user customization. This can be particularly useful when you
want to only expose a subset of the meta-annotation&#8217;s attributes. For example, Spring&#8217;s
<code>@SessionScope</code> annotation hardcodes the scope name to <code>session</code> but still allows
customization of the <code>proxyMode</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.TYPE, <span class="predefined-type">ElementType</span>.METHOD})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Documented</span>
<span class="annotation">@Scope</span>(WebApplicationContext.SCOPE_SESSION)
<span class="directive">public</span> <span class="annotation">@interface</span> SessionScope {

        <span class="comment">/**
         * Alias for {@link Scope#proxyMode}.
         * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
         */</span>
        <span class="annotation">@AliasFor</span>(annotation = Scope.class)
        ScopedProxyMode proxyMode() <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@SessionScope</code> can then be used without declaring the <code>proxyMode</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<strong><span class="annotation">@SessionScope</span></strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SessionScopedService</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or with an overridden value for the <code>proxyMode</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<strong><span class="annotation">@SessionScope</span>(proxyMode = ScopedProxyMode.INTERFACES)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SessionScopedUserService</span> <span class="directive">implements</span> UserService {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For further details, consult the <a href="appendix.html#annotation-programming-model">Spring Annotation Programming Model</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-autodetection"><a class="anchor" href="#beans-scanning-autodetection"></a>1.10.3. Automatically detecting classes and registering bean definitions</h4>
<div class="paragraph">
<p>Spring can automatically detect stereotyped classes and register corresponding
<code>BeanDefinition</code>s with the <code>ApplicationContext</code>. For example, the following two classes
are eligible for such autodetection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> SimpleMovieLister(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">JpaMovieFinder</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// implementation elided for clarity</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To autodetect these classes and register the corresponding beans, you need to add
<code>@ComponentScan</code> to your <code>@Configuration</code> class, where the <code>basePackages</code> attribute
is a common parent package for the two classes. (Alternatively, you can specify a
comma/semicolon/space-separated list that includes the parent package of each class.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>for concision, the above may have used the <code>value</code> attribute of the
annotation, i.e. <code>@ComponentScan("org.example")</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is an alternative using XML</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The use of <code>&lt;context:component-scan&gt;</code> implicitly enables the functionality of
<code>&lt;context:annotation-config&gt;</code>. There is usually no need to include the
<code>&lt;context:annotation-config&gt;</code> element when using <code>&lt;context:component-scan&gt;</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The scanning of classpath packages requires the presence of corresponding directory
entries in the classpath. When you build JARs with Ant, make sure that you do <em>not</em>
activate the files-only switch of the JAR task. Also, classpath directories may not
get exposed based on security policies in some environments, e.g. standalone apps on
JDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests; see
<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, the <code>AutowiredAnnotationBeanPostProcessor</code> and
<code>CommonAnnotationBeanPostProcessor</code> are both included implicitly when you use the
component-scan element. That means that the two components are autodetected <em>and</em>
wired together - all without any bean configuration metadata provided in XML.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can disable the registration of <code>AutowiredAnnotationBeanPostProcessor</code> and
<code>CommonAnnotationBeanPostProcessor</code> by including the <em>annotation-config</em> attribute
with a value of false.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-filters"><a class="anchor" href="#beans-scanning-filters"></a>1.10.4. Using filters to customize scanning</h4>
<div class="paragraph">
<p>By default, classes annotated with <code>@Component</code>, <code>@Repository</code>, <code>@Service</code>,
<code>@Controller</code>, or a custom annotation that itself is annotated with <code>@Component</code> are the
only detected candidate components. However, you can modify and extend this behavior
simply by applying custom filters. Add them as <em>includeFilters</em> or <em>excludeFilters</em>
parameters of the <code>@ComponentScan</code> annotation (or as <em>include-filter</em> or <em>exclude-filter</em>
sub-elements of the <code>component-scan</code> element). Each filter element requires the <code>type</code>
and <code>expression</code> attributes. The following table describes the filtering options.</p>
</div>
<table id="beans-scanning-filters-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. Filter Types</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Filter Type</th>
<th class="tableblock halign-left valign-top">Example Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">annotation (default)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeAnnotation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An annotation to be present at the type level in target components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A class (or interface) that the target components are assignable to (extend/implement).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectj</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example..*Service+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An AspectJ type expression to be matched by the target components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org\.example\.Default.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A regex expression to be matched by the target components class names.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.MyTypeFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A custom implementation of the <code>org.springframework.core.type .TypeFilter</code> interface.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following example shows the configuration ignoring all <code>@Repository</code> annotations
and using "stub" repositories instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
   <span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>,
                   includeFilters = <span class="annotation">@Filter</span>(type = FilterType.REGEX, pattern = <span class="string"><span class="delimiter">&quot;</span><span class="content">.*Stub.*Repository</span><span class="delimiter">&quot;</span></span>),
                   excludeFilters = <span class="annotation">@Filter</span>(Repository.class))
   <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the equivalent using XML</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;context:include-filter</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">regex</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">.*Stub.*Repository</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;context:exclude-filter</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">annotation</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.stereotype.Repository</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/context:component-scan&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can also disable the default filters by setting <code>useDefaultFilters=false</code> on the annotation or
providing <code>use-default-filters="false"</code> as an attribute of the <code>&lt;component-scan/&gt;</code> element. This
will in effect disable automatic detection of classes annotated with <code>@Component</code>, <code>@Repository</code>,
<code>@Service</code>, <code>@Controller</code>, or <code>@Configuration</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factorybeans-annotations"><a class="anchor" href="#beans-factorybeans-annotations"></a>1.10.5. Defining bean metadata within components</h4>
<div class="paragraph">
<p>Spring components can also contribute bean definition metadata to the container. You do
this with the same <code>@Bean</code> annotation used to define bean metadata within <code>@Configuration</code>
annotated classes. Here is a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="annotation">@Bean</span>
        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean publicInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">publicInstance</span><span class="delimiter">&quot;</span></span>);
        }

        <span class="directive">public</span> <span class="type">void</span> doWork() {
                <span class="comment">// Component method implementation omitted</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This class is a Spring component that has application-specific code contained in its
<code>doWork()</code> method. However, it also contributes a bean definition that has a factory
method referring to the method <code>publicInstance()</code>. The <code>@Bean</code> annotation identifies the
factory method and other bean definition properties, such as a qualifier value through
the <code>@Qualifier</code> annotation. Other method level annotations that can be specified are
<code>@Scope</code>, <code>@Lazy</code>, and custom qualifier annotations.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In addition to its role for component initialization, the <code>@Lazy</code> annotation may also be
placed on injection points marked with <code>@Autowired</code> or <code>@Inject</code>. In this context, it
leads to the injection of a lazy-resolution proxy.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Autowired fields and methods are supported as previously discussed, with additional
support for autowiring of <code>@Bean</code> methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="directive">private</span> <span class="directive">static</span> <span class="type">int</span> i;

        <span class="annotation">@Bean</span>
        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean publicInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">publicInstance</span><span class="delimiter">&quot;</span></span>);
        }

        <span class="comment">// use of a custom qualifier and autowiring of method parameters</span>
        <span class="annotation">@Bean</span>
        <span class="directive">protected</span> TestBean protectedInstance(
                        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>) TestBean spouse,
                        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{privateInstance.age}</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> country) {
                TestBean tb = <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">protectedInstance</span><span class="delimiter">&quot;</span></span>, <span class="integer">1</span>);
                tb.setSpouse(spouse);
                tb.setCountry(country);
                <span class="keyword">return</span> tb;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">private</span> TestBean privateInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">privateInstance</span><span class="delimiter">&quot;</span></span>, i++);
        }

        <span class="annotation">@Bean</span>
        <span class="annotation">@RequestScope</span>
        <span class="directive">public</span> TestBean requestScopedInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">requestScopedInstance</span><span class="delimiter">&quot;</span></span>, <span class="integer">3</span>);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example autowires the <code>String</code> method parameter <code>country</code> to the value of the <code>Age</code>
property on another bean named <code>privateInstance</code>. A Spring Expression Language element
defines the value of the property through the notation <code>#{ &lt;expression&gt; }</code>. For <code>@Value</code>
annotations, an expression resolver is preconfigured to look for bean names when
resolving expression text.</p>
</div>
<div class="paragraph">
<p>As of Spring Framework 4.3, you may also declare a factory method parameter of type
<code>InjectionPoint</code> (or its more specific subclass <code>DependencyDescriptor</code>) in order to
access the requesting injection point that triggers the creation of the current bean.
Note that this will only apply to the actual creation of bean instances, not to the
injection of existing instances. As a consequence, this feature makes most sense for
beans of prototype scope. For other scopes, the factory method will only ever see the
injection point which triggered the creation of a new bean instance in the given scope:
for example, the dependency that triggered the creation of a lazy singleton bean.
Use the provided injection point metadata with semantic care in such scenarios.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="annotation">@Bean</span> <span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean prototypeInstance(InjectionPoint injectionPoint) {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototypeInstance for </span><span class="delimiter">&quot;</span></span> + injectionPoint.getMember());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> methods in a regular Spring component are processed differently than their
counterparts inside a Spring <code>@Configuration</code> class. The difference is that <code>@Component</code>
classes are not enhanced with CGLIB to intercept the invocation of methods and fields.
CGLIB proxying is the means by which invoking methods or fields within <code>@Bean</code> methods
in <code>@Configuration</code> classes creates bean metadata references to collaborating objects;
such methods are <em>not</em> invoked with normal Java semantics but rather go through the
container in order to provide the usual lifecycle management and proxying of Spring
beans even when referring to other beans via programmatic calls to <code>@Bean</code> methods.
In contrast, invoking a method or field in an <code>@Bean</code> method within a plain <code>@Component</code>
class <em>has</em> standard Java semantics, with no special CGLIB processing or other
constraints applying.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may declare <code>@Bean</code> methods as <code>static</code>, allowing for them to be called without
creating their containing configuration class as an instance. This makes particular
sense when defining post-processor beans, e.g. of type <code>BeanFactoryPostProcessor</code> or
<code>BeanPostProcessor</code>, since such beans will get initialized early in the container
lifecycle and should avoid triggering other parts of the configuration at that point.</p>
</div>
<div class="paragraph">
<p>Note that calls to static <code>@Bean</code> methods will never get intercepted by the container,
not even within <code>@Configuration</code> classes (see above). This is due to technical
limitations: CGLIB subclassing can only override non-static methods. As a consequence,
a direct call to another <code>@Bean</code> method will have standard Java semantics, resulting
in an independent instance being returned straight from the factory method itself.</p>
</div>
<div class="paragraph">
<p>The Java language visibility of <code>@Bean</code> methods does not have an immediate impact on
the resulting bean definition in Spring&#8217;s container. You may freely declare your
factory methods as you see fit in non-<code>@Configuration</code> classes and also for static
methods anywhere. However, regular <code>@Bean</code> methods in <code>@Configuration</code> classes need
to be overridable, i.e. they must not be declared as <code>private</code> or <code>final</code>.</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> methods will also be discovered on base classes of a given component or
configuration class, as well as on Java 8 default methods declared in interfaces
implemented by the component or configuration class. This allows for a lot of
flexibility in composing complex configuration arrangements, with even multiple
inheritance being possible through Java 8 default methods as of Spring 4.2.</p>
</div>
<div class="paragraph">
<p>Finally, note that a single class may hold multiple <code>@Bean</code> methods for the same
bean, as an arrangement of multiple factory methods to use depending on available
dependencies at runtime. This is the same algorithm as for choosing the "greediest"
constructor or factory method in other configuration scenarios: The variant with
the largest number of satisfiable dependencies will be picked at construction time,
analogous to how the container selects between multiple <code>@Autowired</code> constructors.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-name-generator"><a class="anchor" href="#beans-scanning-name-generator"></a>1.10.6. Naming autodetected components</h4>
<div class="paragraph">
<p>When a component is autodetected as part of the scanning process, its bean name is
generated by the <code>BeanNameGenerator</code> strategy known to that scanner. By default, any
Spring stereotype annotation (<code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, and
<code>@Controller</code>) that contains a <em>name</em> <code>value</code> will thereby provide that name to the
corresponding bean definition.</p>
</div>
<div class="paragraph">
<p>If such an annotation contains no <em>name</em> <code>value</code> or for any other detected component (such
as those discovered by custom filters), the default bean name generator returns the
uncapitalized non-qualified class name. For example, if the following two components
were detected, the names would be <code>myMovieLister</code> and <code>movieFinderImpl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">myMovieLister</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieFinderImpl</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you do not want to rely on the default bean-naming strategy, you can provide a custom
bean-naming strategy. First, implement the
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a>
interface, and be sure to include a default no-arg constructor. Then, provide the
fully-qualified class name when configuring the scanner:</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
   <span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, nameGenerator = MyNameGenerator.class)
   <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">name-generator</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.MyNameGenerator</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As a general rule, consider specifying the name with the annotation whenever other
components may be making explicit references to it. On the other hand, the
auto-generated names are adequate whenever the container is responsible for wiring.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-scope-resolver"><a class="anchor" href="#beans-scanning-scope-resolver"></a>1.10.7. Providing a scope for autodetected components</h4>
<div class="paragraph">
<p>As with Spring-managed components in general, the default and most common scope for
autodetected components is <code>singleton</code>. However, sometimes you need a different scope
which can be specified via the <code>@Scope</code> annotation. Simply provide the name of the scope
within the annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieFinderImpl</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For details on web-specific scopes, see <a href="#beans-factory-scopes-other">Request, session, application, and WebSocket scopes</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To provide a custom strategy for scope resolution rather than relying on the
annotation-based approach, implement the
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a>
interface, and be sure to include a default no-arg constructor. Then, provide the
fully-qualified class name when configuring the scanner:</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, scopeResolver = MyScopeResolver.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">scope-resolver</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.MyScopeResolver</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When using certain non-singleton scopes, it may be necessary to generate proxies for the
scoped objects. The reasoning is described in <a href="#beans-factory-scopes-other-injection">Scoped beans as dependencies</a>.
For this purpose, a <em>scoped-proxy</em> attribute is available on the component-scan
element. The three possible values are: no, interfaces, and targetClass. For example,
the following configuration will result in standard JDK dynamic proxies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, scopedProxy = ScopedProxyMode.INTERFACES)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">scoped-proxy</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interfaces</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-qualifiers"><a class="anchor" href="#beans-scanning-qualifiers"></a>1.10.8. Providing qualifier metadata with annotations</h4>
<div class="paragraph">
<p>The <code>@Qualifier</code> annotation is discussed in <a href="#beans-autowired-annotation-qualifiers">Fine-tuning annotation-based autowiring with qualifiers</a>.
The examples in that section demonstrate the use of the <code>@Qualifier</code> annotation and
custom qualifier annotations to provide fine-grained control when you resolve autowire
candidates. Because those examples were based on XML bean definitions, the qualifier
metadata was provided on the candidate bean definitions using the <code>qualifier</code> or <code>meta</code>
sub-elements of the <code>bean</code> element in the XML. When relying upon classpath scanning for
autodetection of components, you provide the qualifier metadata with type-level
annotations on the candidate class. The following three examples demonstrate this
technique:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ActionMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ActionMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Offline</span></strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CachingMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As with most annotation-based alternatives, keep in mind that the annotation metadata is
bound to the class definition itself, while the use of XML allows for multiple beans
<em>of the same type</em> to provide variations in their qualifier metadata, because that
metadata is provided per-instance rather than per-class.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-index"><a class="anchor" href="#beans-scanning-index"></a>1.10.9. Generating an index of candidate components</h4>
<div class="paragraph">
<p>While classpath scanning is very fast, it is possible to improve the startup performance
of large applications by creating a static list of candidates at compilation time. In this
mode, <em>all modules</em> of the application must use this mechanism as, when the
<code>ApplicationContext</code> detects such index, it will automatically use it rather than scanning
the classpath.</p>
</div>
<div class="paragraph">
<p>To generate the index, simply add an additional dependency to each module that contains
components that are target for component scan directives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
                <span class="tag">&lt;groupId&gt;</span>org.springframework<span class="tag">&lt;/groupId&gt;</span>
                <span class="tag">&lt;artifactId&gt;</span>spring-context-indexer<span class="tag">&lt;/artifactId&gt;</span>
                <span class="tag">&lt;version&gt;</span>5.0.0.RELEASE<span class="tag">&lt;/version&gt;</span>
                <span class="tag">&lt;optional&gt;</span>true<span class="tag">&lt;/optional&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;/dependencies&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, using Gradle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
        compileOnly(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework:spring-context-indexer:5.0.0.RELEASE</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That process will generate a <code>META-INF/spring.components</code> file that is going to be
included in the jar.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When working with this mode in your IDE, the <code>spring-context-indexer</code> must be registered
as an annotation processor to make sure the index is up to date when candidate components
are updated.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The index is enabled automatically when a <code>META-INF/spring.components</code> is found on the
classpath. If an index is partially available for some libraries (or use cases) but
couldn&#8217;t be built for the whole application, you can fallback to a regular classpath
arrangement (i.e. as no index was present at all) by setting <code>spring.index.ignore</code> to
<code>true</code>, either as a system property or in a <code>spring.properties</code> file at the root of the
classpath.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-standard-annotations"><a class="anchor" href="#beans-standard-annotations"></a>1.11. Using JSR 330 Standard Annotations</h3>
<div class="paragraph">
<p>Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations
(Dependency Injection). Those annotations are scanned in the same way as the Spring
annotations. You just need to have the relevant jars in your classpath.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are using Maven, the <code>javax.inject</code> artifact is available in the standard Maven
repository (
<a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/">http://repo1.maven.org/maven2/javax/inject/javax.inject/1/</a>).
You can add the following dependency to your file pom.xml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>javax.inject<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>javax.inject<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>1<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-inject-named"><a class="anchor" href="#beans-inject-named"></a>1.11.1. Dependency Injection with @Inject and @Named</h4>
<div class="paragraph">
<p>Instead of <code>@Autowired</code>, <code>@javax.inject.Inject</code> may be used as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="directive">public</span> <span class="type">void</span> listMovies() {
                <span class="local-variable">this</span>.movieFinder.findMovies(...);
                ...
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>@Autowired</code>, it is possible to use <code>@Inject</code> at the field level, method level
and constructor-argument level. Furthermore, you may declare your injection point as a
<code>Provider</code>, allowing for on-demand access to beans of shorter scopes or lazy access to
other beans through a <code>Provider.get()</code> call. As a variant of the example above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Provider</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> <span class="predefined-type">Provider</span>&lt;MovieFinder&gt; movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(<span class="predefined-type">Provider</span>&lt;MovieFinder&gt; movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="directive">public</span> <span class="type">void</span> listMovies() {
                <span class="local-variable">this</span>.movieFinder.get().findMovies(...);
                ...
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you would like to use a qualified name for the dependency that should be injected,
you should use the <code>@Named</code> annotation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>) MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-named"><a class="anchor" href="#beans-named"></a>1.11.2. @Named and @ManagedBean: standard equivalents to the @Component annotation</h4>
<div class="paragraph">
<p>Instead of <code>@Component</code>, <code>@javax.inject.Named</code> or <code>javax.annotation.ManagedBean</code> may be
used as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">movieListener</span><span class="delimiter">&quot;</span></span>)  <span class="comment">// @ManagedBean(&quot;movieListener&quot;) could be used as well</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is very common to use <code>@Component</code> without specifying a name for the component.
<code>@Named</code> can be used in a similar fashion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="annotation">@Named</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using <code>@Named</code> or <code>@ManagedBean</code>, it is possible to use component scanning in the
exact same way as when using Spring annotations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In contrast to <code>@Component</code>, the JSR-330 <code>@Named</code> and the JSR-250 <code>ManagedBean</code>
annotations are not composable. Please use Spring&#8217;s stereotype model for building custom
component annotations.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-standard-annotations-limitations"><a class="anchor" href="#beans-standard-annotations-limitations"></a>1.11.3. Limitations of JSR-330 standard annotations</h4>
<div class="paragraph">
<p>When working with standard annotations, it is important to know that some significant
features are not available as shown in the table below:</p>
</div>
<table id="annotations-comparison" class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. Spring component model elements vs. JSR-330 variants</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring</th>
<th class="tableblock halign-left valign-top">javax.inject.*</th>
<th class="tableblock halign-left valign-top">javax.inject restrictions / comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Autowired</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Inject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Inject</code> has no 'required' attribute; can be used with Java 8&#8217;s <code>Optional</code> instead.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Component</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Named / @ManagedBean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330 does not provide a composable model, just a way to identify named components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Scope("singleton")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Singleton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JSR-330 default scope is like Spring&#8217;s <code>prototype</code>. However, in order to keep it
consistent with Spring&#8217;s general defaults, a JSR-330 bean declared in the Spring
container is a <code>singleton</code> by default. In order to use a scope other than <code>singleton</code>,
you should use Spring&#8217;s <code>@Scope</code> annotation. <code>javax.inject</code> also provides a
<a href="http://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a> annotation.
Nevertheless, this one is only intended to be used for creating your own annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier / @Named</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Qualifier</code> is just a meta-annotation for building custom qualifiers.
Concrete String qualifiers (like Spring&#8217;s <code>@Qualifier</code> with a value) can be associated
through <code>javax.inject.Named</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no equivalent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no equivalent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Lazy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no equivalent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provider</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Provider</code> is a direct alternative to Spring&#8217;s <code>ObjectFactory</code>,
just with a shorter <code>get()</code> method name. It can also be used in combination with
Spring&#8217;s <code>@Autowired</code> or with non-annotated constructors and setter methods.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-java"><a class="anchor" href="#beans-java"></a>1.12. Java-based container configuration</h3>
<div class="sect3">
<h4 id="beans-java-basic-concepts"><a class="anchor" href="#beans-java-basic-concepts"></a>1.12.1. Basic concepts: @Bean and @Configuration</h4>
<div class="paragraph">
<p>The central artifacts in Spring&#8217;s new Java-configuration support are
<code>@Configuration</code>-annotated classes and <code>@Bean</code>-annotated methods.</p>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> annotation is used to indicate that a method instantiates, configures and
initializes a new object to be managed by the Spring IoC container. For those familiar
with Spring&#8217;s <code>&lt;beans/&gt;</code> XML configuration the <code>@Bean</code> annotation plays the same role as
the <code>&lt;bean/&gt;</code> element. You can use <code>@Bean</code> annotated methods with any Spring
<code>@Component</code>, however, they are most often used with <code>@Configuration</code> beans.</p>
</div>
<div class="paragraph">
<p>Annotating a class with <code>@Configuration</code> indicates that its primary purpose is as a
source of bean definitions. Furthermore, <code>@Configuration</code> classes allow inter-bean
dependencies to be defined by simply calling other <code>@Bean</code> methods in the same class.
The simplest possible <code>@Configuration</code> class would read as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> MyService myService() {
                <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AppConfig</code> class above would be equivalent to the following Spring <code>&lt;beans/&gt;</code> XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.services.MyServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Full @Configuration vs 'lite' @Beans mode?</div>
<div class="paragraph">
<p>When <code>@Bean</code> methods are declared within classes that are <em>not</em> annotated with
<code>@Configuration</code> they are referred to as being processed in a 'lite' mode. For example,
bean methods declared in a <code>@Component</code> or even in a <em>plain old class</em> will be
considered 'lite'.</p>
</div>
<div class="paragraph">
<p>Unlike full <code>@Configuration</code>, lite <code>@Bean</code> methods cannot easily declare inter-bean
dependencies. Usually one <code>@Bean</code> method should not invoke another <code>@Bean</code> method when
operating in 'lite' mode.</p>
</div>
<div class="paragraph">
<p>Only using <code>@Bean</code> methods within <code>@Configuration</code> classes is a recommended approach of
ensuring that 'full' mode is always used. This will prevent the same <code>@Bean</code> method from
accidentally being invoked multiple times and helps to reduce subtle bugs that can be
hard to track down when operating in 'lite' mode.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> and <code>@Configuration</code> annotations will be discussed in depth in the sections
below. First, however, we&#8217;ll cover the various ways of creating a spring container using
Java-based configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-instantiating-container"><a class="anchor" href="#beans-java-instantiating-container"></a>1.12.2. Instantiating the Spring container using AnnotationConfigApplicationContext</h4>
<div class="paragraph">
<p>The sections below document Spring&#8217;s <code>AnnotationConfigApplicationContext</code>, new in Spring
3.0. This versatile <code>ApplicationContext</code> implementation is capable of accepting not only
<code>@Configuration</code> classes as input, but also plain <code>@Component</code> classes and classes
annotated with JSR-330 metadata.</p>
</div>
<div class="paragraph">
<p>When <code>@Configuration</code> classes are provided as input, the <code>@Configuration</code> class itself
is registered as a bean definition, and all declared <code>@Bean</code> methods within the class
are also registered as bean definitions.</p>
</div>
<div class="paragraph">
<p>When <code>@Component</code> and JSR-330 classes are provided, they are registered as bean
definitions, and it is assumed that DI metadata such as <code>@Autowired</code> or <code>@Inject</code> are
used within those classes where necessary.</p>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-contstructor"><a class="anchor" href="#beans-java-instantiating-container-contstructor"></a>Simple construction</h5>
<div class="paragraph">
<p>In much the same way that Spring XML files are used as input when instantiating a
<code>ClassPathXmlApplicationContext</code>, <code>@Configuration</code> classes may be used as input when
instantiating an <code>AnnotationConfigApplicationContext</code>. This allows for completely
XML-free usage of the Spring container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As mentioned above, <code>AnnotationConfigApplicationContext</code> is not limited to working only
with <code>@Configuration</code> classes. Any <code>@Component</code> or JSR-330 annotated class may be supplied
as input to the constructor. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above assumes that <code>MyServiceImpl</code>, <code>Dependency1</code> and <code>Dependency2</code> use Spring
dependency injection annotations such as <code>@Autowired</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-register"><a class="anchor" href="#beans-java-instantiating-container-register"></a>Building the container programmatically using register(Class&lt;?&gt;&#8230;&#8203;)</h5>
<div class="paragraph">
<p>An <code>AnnotationConfigApplicationContext</code> may be instantiated using a no-arg constructor
and then configured using the <code>register()</code> method. This approach is particularly useful
when programmatically building an <code>AnnotationConfigApplicationContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
        ctx.register(AppConfig.class, OtherConfig.class);
        ctx.register(AdditionalConfig.class);
        ctx.refresh();
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-scan"><a class="anchor" href="#beans-java-instantiating-container-scan"></a>Enabling component scanning with scan(String&#8230;&#8203;)</h5>
<div class="paragraph">
<p>To enable component scanning, just annotate your <code>@Configuration</code> class as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Experienced Spring users will be familiar with the XML declaration equivalent from
Spring&#8217;s <code>context:</code> namespace</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the example above, the <code>com.acme</code> package will be scanned, looking for any
<code>@Component</code>-annotated classes, and those classes will be registered as Spring bean
definitions within the container. <code>AnnotationConfigApplicationContext</code> exposes the
<code>scan(String&#8230;&#8203;)</code> method to allow for the same component-scanning functionality:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
        ctx.scan(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span>);
        ctx.refresh();
        MyService myService = ctx.getBean(MyService.class);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Remember that <code>@Configuration</code> classes are <a href="#beans-meta-annotations">meta-annotated</a>
with <code>@Component</code>, so they are candidates for component-scanning! In the example above,
assuming that <code>AppConfig</code> is declared within the <code>com.acme</code> package (or any package
underneath), it will be picked up during the call to <code>scan()</code>, and upon <code>refresh()</code> all
its <code>@Bean</code> methods will be processed and registered as bean definitions within the
container.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-web"><a class="anchor" href="#beans-java-instantiating-container-web"></a>Support for web applications with AnnotationConfigWebApplicationContext</h5>
<div class="paragraph">
<p>A <code>WebApplicationContext</code> variant of <code>AnnotationConfigApplicationContext</code> is available
with <code>AnnotationConfigWebApplicationContext</code>. This implementation may be used when
configuring the Spring <code>ContextLoaderListener</code> servlet listener, Spring MVC
<code>DispatcherServlet</code>, etc. What follows is a <code>web.xml</code> snippet that configures a typical
Spring MVC web application. Note the use of the <code>contextClass</code> context-param and
init-param:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
                instead of the default XmlWebApplicationContext --&gt;</span>
        <span class="tag">&lt;context-param&gt;</span>
                <span class="tag">&lt;param-name&gt;</span>contextClass<span class="tag">&lt;/param-name&gt;</span>
                <span class="tag">&lt;param-value&gt;</span>
                        org.springframework.web.context.support.AnnotationConfigWebApplicationContext
                <span class="tag">&lt;/param-value&gt;</span>
        <span class="tag">&lt;/context-param&gt;</span>

        <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited
                fully-qualified @Configuration classes. Fully-qualified packages may also be
                specified for component-scanning --&gt;</span>
        <span class="tag">&lt;context-param&gt;</span>
                <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
                <span class="tag">&lt;param-value&gt;</span>com.acme.AppConfig<span class="tag">&lt;/param-value&gt;</span>
        <span class="tag">&lt;/context-param&gt;</span>

        <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span>
        <span class="tag">&lt;listener&gt;</span>
                <span class="tag">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/listener-class&gt;</span>
        <span class="tag">&lt;/listener&gt;</span>

        <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span>
        <span class="tag">&lt;servlet&gt;</span>
                <span class="tag">&lt;servlet-name&gt;</span>dispatcher<span class="tag">&lt;/servlet-name&gt;</span>
                <span class="tag">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/servlet-class&gt;</span>
                <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
                        instead of the default XmlWebApplicationContext --&gt;</span>
                <span class="tag">&lt;init-param&gt;</span>
                        <span class="tag">&lt;param-name&gt;</span>contextClass<span class="tag">&lt;/param-name&gt;</span>
                        <span class="tag">&lt;param-value&gt;</span>
                                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
                        <span class="tag">&lt;/param-value&gt;</span>
                <span class="tag">&lt;/init-param&gt;</span>
                <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited
                        and fully-qualified @Configuration classes --&gt;</span>
                <span class="tag">&lt;init-param&gt;</span>
                        <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
                        <span class="tag">&lt;param-value&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/param-value&gt;</span>
                <span class="tag">&lt;/init-param&gt;</span>
        <span class="tag">&lt;/servlet&gt;</span>

        <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span>
        <span class="tag">&lt;servlet-mapping&gt;</span>
                <span class="tag">&lt;servlet-name&gt;</span>dispatcher<span class="tag">&lt;/servlet-name&gt;</span>
                <span class="tag">&lt;url-pattern&gt;</span>/app/*<span class="tag">&lt;/url-pattern&gt;</span>
        <span class="tag">&lt;/servlet-mapping&gt;</span>
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-bean-annotation"><a class="anchor" href="#beans-java-bean-annotation"></a>1.12.3. Using the @Bean annotation</h4>
<div class="paragraph">
<p><code>@Bean</code> is a method-level annotation and a direct analog of the XML <code>&lt;bean/&gt;</code> element.
The annotation supports some of the attributes offered by <code>&lt;bean/&gt;</code>, such as:
<a href="#beans-factory-lifecycle-initializingbean">init-method</a>,
<a href="#beans-factory-lifecycle-disposablebean">destroy-method</a>,
<a href="#beans-factory-autowire">autowiring</a> and <code>name</code>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>@Bean</code> annotation in a <code>@Configuration</code>-annotated or in a
<code>@Component</code>-annotated class.</p>
</div>
<div class="sect4">
<h5 id="beans-java-declaring-a-bean"><a class="anchor" href="#beans-java-declaring-a-bean"></a>Declaring a bean</h5>
<div class="paragraph">
<p>To declare a bean, simply annotate a method with the <code>@Bean</code> annotation. You use this
method to register a bean definition within an <code>ApplicationContext</code> of the type
specified as the method&#8217;s return value. By default, the bean name will be the same as
the method name. The following is a simple example of a <code>@Bean</code> method declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferServiceImpl transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration is exactly equivalent to the following Spring XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transferService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.TransferServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Both declarations make a bean named <code>transferService</code> available in the
<code>ApplicationContext</code>, bound to an object instance of type <code>TransferServiceImpl</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>transferService -&gt; com.acme.TransferServiceImpl</pre>
</div>
</div>
<div class="paragraph">
<p>You may also declare your <code>@Bean</code> method with an interface (or base class)
return type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this limits the visibility for advance type prediction to the specified
interface type (<code>TransferService</code>) then, with the full type (<code>TransferServiceImpl</code>)
only known to the container once the affected singleton bean has been instantiated.
Non-lazy singleton beans get instantiated according to their declaration order,
so you may see different type matching results depending on when another component
tries to match by a non-declared type (such as <code>@Autowired TransferServiceImpl</code>
which will only resolve once the "transferService" bean has been instantiated).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you consistently refer to your types by a declared service interface, your
<code>@Bean</code> return types may safely join that design decision. However, for components
implementing several interfaces or for components potentially referred to by their
implementation type, it is safer to declare the most specific return type possible
(at least as specific as required by the injection points referring to your bean).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-dependencies"><a class="anchor" href="#beans-java-dependencies"></a>Bean dependencies</h5>
<div class="paragraph">
<p>A <code>@Bean</code> annotated method can have an arbitrary number of parameters describing the
dependencies required to build that bean. For instance if our <code>TransferService</code>
requires an <code>AccountRepository</code> we can materialize that dependency via a method
parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService(AccountRepository accountRepository) {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resolution mechanism is pretty much identical to constructor-based dependency
injection, see <a href="#beans-constructor-injection">the relevant section</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-lifecycle-callbacks"><a class="anchor" href="#beans-java-lifecycle-callbacks"></a>Receiving lifecycle callbacks</h5>
<div class="paragraph">
<p>Any classes defined with the <code>@Bean</code> annotation support the regular lifecycle callbacks
and can use the <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations from JSR-250, see
<a href="#beans-postconstruct-and-predestroy-annotations">JSR-250 annotations</a> for further
details.</p>
</div>
<div class="paragraph">
<p>The regular Spring <a href="#beans-factory-nature">lifecycle</a> callbacks are fully supported as
well. If a bean implements <code>InitializingBean</code>, <code>DisposableBean</code>, or <code>Lifecycle</code>, their
respective methods are called by the container.</p>
</div>
<div class="paragraph">
<p>The standard set of <code>*Aware</code> interfaces such as <a href="#beans-beanfactory">BeanFactoryAware</a>,
<a href="#beans-factory-aware">BeanNameAware</a>,
<a href="#context-functionality-messagesource">MessageSourceAware</a>,
<a href="#beans-factory-aware">ApplicationContextAware</a>, and so on are also fully supported.</p>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> annotation supports specifying arbitrary initialization and destruction
callback methods, much like Spring XML&#8217;s <code>init-method</code> and <code>destroy-method</code> attributes
on the <code>bean</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="comment">// initialization logic</span>
        }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Bar</span> {

        <span class="directive">public</span> <span class="type">void</span> cleanup() {
                <span class="comment">// destruction logic</span>
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(initMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }

        <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">cleanup</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Bar bar() {
                <span class="keyword">return</span> <span class="keyword">new</span> Bar();
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, beans defined using Java config that have a public <code>close</code> or <code>shutdown</code>
method are automatically enlisted with a destruction callback. If you have a public
<code>close</code> or <code>shutdown</code> method and you do not wish for it to be called when the container
shuts down, simply add <code>@Bean(destroyMethod="")</code> to your bean definition to disable the
default <code>(inferred)</code> mode.</p>
</div>
<div class="paragraph">
<p>You may want to do that by default for a resource that you acquire via JNDI as its
lifecycle is managed outside the application. In particular, make sure to always do it
for a <code>DataSource</code> as it is known to be problematic on Java EE application servers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">NamingException</span> {
        <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) jndiTemplate.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">MyDS</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, with <code>@Bean</code> methods, you will typically choose to use programmatic JNDI lookups:
either using Spring&#8217;s <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> helpers or straight JNDI
<code>InitialContext</code> usage, but not the <code>JndiObjectFactoryBean</code> variant which would force
you to declare the return type as the <code>FactoryBean</code> type instead of the actual target
type, making it harder to use for cross-reference calls in other <code>@Bean</code> methods that
intend to refer to the provided resource here.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, in the case of <code>Foo</code> above, it would be equally as valid to call the <code>init()</code>
method directly during construction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Foo foo() {
                Foo foo = <span class="keyword">new</span> Foo();
                foo.init();
            <span class="keyword">return</span> foo;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you work directly in Java, you can do anything you like with your objects and do
not always need to rely on the container lifecycle!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-specifying-bean-scope"><a class="anchor" href="#beans-java-specifying-bean-scope"></a>Specifying bean scope</h5>
<div class="sect5">
<h6 id="beans-java-available-scopes"><a class="anchor" href="#beans-java-available-scopes"></a>Using the @Scope annotation</h6>
<div class="paragraph">
<p>You can specify that your beans defined with the <code>@Bean</code> annotation should have a
specific scope. You can use any of the standard scopes specified in the
<a href="#beans-factory-scopes">Bean Scopes</a> section.</p>
</div>
<div class="paragraph">
<p>The default scope is <code>singleton</code>, but you can override this with the <code>@Scope</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> Encryptor encryptor() {
                <span class="comment">// ...</span>
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-scoped-proxy"><a class="anchor" href="#beans-java-scoped-proxy"></a>@Scope and scoped-proxy</h6>
<div class="paragraph">
<p>Spring offers a convenient way of working with scoped dependencies through
<a href="#beans-factory-scopes-other-injection">scoped proxies</a>. The easiest way to create such
a proxy when using the XML configuration is the <code>&lt;aop:scoped-proxy/&gt;</code> element.
Configuring your beans in Java with a @Scope annotation offers equivalent support with
the proxyMode attribute. The default is no proxy ( <code>ScopedProxyMode.NO</code>), but you can
specify <code>ScopedProxyMode.TARGET_CLASS</code> or <code>ScopedProxyMode.INTERFACES</code>.</p>
</div>
<div class="paragraph">
<p>If you port the scoped proxy example from the XML reference documentation (see preceding
link) to our <code>@Bean</code> using Java, it would look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span>
<span class="annotation">@Bean</span>
<strong><span class="annotation">@SessionScope</span></strong>
<span class="directive">public</span> UserPreferences userPreferences() {
        <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();
}

<span class="annotation">@Bean</span>
<span class="directive">public</span> Service userService() {
        UserService service = <span class="keyword">new</span> SimpleUserService();
        <span class="comment">// a reference to the proxied userPreferences bean</span>
        service.setUserPreferences(userPreferences());
        <span class="keyword">return</span> service;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-customizing-bean-naming"><a class="anchor" href="#beans-java-customizing-bean-naming"></a>Customizing bean naming</h5>
<div class="paragraph">
<p>By default, configuration classes use a <code>@Bean</code> method&#8217;s name as the name of the
resulting bean. This functionality can be overridden, however, with the <code>name</code> attribute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">myFoo</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-aliasing"><a class="anchor" href="#beans-java-bean-aliasing"></a>Bean aliasing</h5>
<div class="paragraph">
<p>As discussed in <a href="#beans-beanname">Naming beans</a>, it is sometimes desirable to give a single bean
multiple names, otherwise known as <em>bean aliasing</em>. The <code>name</code> attribute of the <code>@Bean</code>
annotation accepts a String array for this purpose.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(name = { <span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemB-dataSource</span><span class="delimiter">&quot;</span></span> })
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// instantiate, configure and return DataSource bean...</span>
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-description"><a class="anchor" href="#beans-java-bean-description"></a>Bean description</h5>
<div class="paragraph">
<p>Sometimes it is helpful to provide a more detailed textual description of a bean. This can
be particularly useful when beans are exposed (perhaps via JMX) for monitoring purposes.</p>
</div>
<div class="paragraph">
<p>To add a description to a <code>@Bean</code> the
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a>
annotation can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Description</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Provides a basic example of a bean</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-configuration-annotation"><a class="anchor" href="#beans-java-configuration-annotation"></a>1.12.4. Using the @Configuration annotation</h4>
<div class="paragraph">
<p><code>@Configuration</code> is a class-level annotation indicating that an object is a source of
bean definitions. <code>@Configuration</code> classes declare beans via public <code>@Bean</code> annotated
methods. Calls to <code>@Bean</code> methods on <code>@Configuration</code> classes can also be used to define
inter-bean dependencies. See <a href="#beans-java-basic-concepts">Basic concepts: @Bean and @Configuration</a> for a general introduction.</p>
</div>
<div class="sect4">
<h5 id="beans-java-injecting-dependencies"><a class="anchor" href="#beans-java-injecting-dependencies"></a>Injecting inter-bean dependencies</h5>
<div class="paragraph">
<p>When <code>@Bean</code>s have dependencies on one another, expressing that dependency is as simple
as having one bean method call another:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Bar bar() {
                <span class="keyword">return</span> <span class="keyword">new</span> Bar();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, the <code>foo</code> bean receives a reference to <code>bar</code> via constructor
injection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This method of declaring inter-bean dependencies only works when the <code>@Bean</code> method is
declared within a <code>@Configuration</code> class. You cannot declare inter-bean dependencies
using plain <code>@Component</code> classes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-method-injection"><a class="anchor" href="#beans-java-method-injection"></a>Lookup method injection</h5>
<div class="paragraph">
<p>As noted earlier, <a href="#beans-factory-method-injection">lookup method injection</a> is an
advanced feature that you should use rarely. It is useful in cases where a
singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this
type of configuration provides a natural means for implementing this pattern.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {
        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command interface</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="comment">// okay... but where is the implementation of this method?</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using Java-configuration support , you can create a subclass of <code>CommandManager</code> where
the abstract <code>createCommand()</code> method is overridden in such a way that it looks up a new
(prototype) command object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
<span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> AsyncCommand asyncCommand() {
        AsyncCommand command = <span class="keyword">new</span> AsyncCommand();
        <span class="comment">// inject dependencies here as required</span>
        <span class="keyword">return</span> command;
}

<span class="annotation">@Bean</span>
<span class="directive">public</span> CommandManager commandManager() {
        <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span>
        <span class="comment">// to return a new prototype Command object</span>
        <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() {
                <span class="directive">protected</span> Command createCommand() {
                        <span class="keyword">return</span> asyncCommand();
                }
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-further-information-java-config"><a class="anchor" href="#beans-java-further-information-java-config"></a>Further information about how Java-based configuration works internally</h5>
<div class="paragraph">
<p>The following example shows a <code>@Bean</code> annotated method being called twice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientService clientService1() {
                ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();
                clientService.setClientDao(clientDao());
                <span class="keyword">return</span> clientService;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientService clientService2() {
                ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();
                clientService.setClientDao(clientDao());
                <span class="keyword">return</span> clientService;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientDao clientDao() {
                <span class="keyword">return</span> <span class="keyword">new</span> ClientDaoImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientDao()</code> has been called once in <code>clientService1()</code> and once in <code>clientService2()</code>.
Since this method creates a new instance of <code>ClientDaoImpl</code> and returns it, you would
normally expect having 2 instances (one for each service). That definitely would be
problematic: in Spring, instantiated beans have a <code>singleton</code> scope by default. This is
where the magic comes in: All <code>@Configuration</code> classes are subclassed at startup-time
with <code>CGLIB</code>. In the subclass, the child method checks the container first for any
cached (scoped) beans before it calls the parent method and creates a new instance. Note
that as of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because
CGLIB classes have been repackaged under <code>org.springframework.cglib</code> and included directly
within the spring-core JAR.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The behavior could be different according to the scope of your bean. We are talking
about singletons here.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There are a few restrictions due to the fact that CGLIB dynamically adds features at
startup-time, in particular that configuration classes must not be final. However, as
of 4.3, any constructors are allowed on configuration classes, including the use of
<code>@Autowired</code> or a single non-default constructor declaration for default injection.</p>
</div>
<div class="paragraph">
<p>If you prefer to avoid any CGLIB-imposed limitations, consider declaring your <code>@Bean</code>
methods on non-<code>@Configuration</code> classes, e.g. on plain <code>@Component</code> classes instead.
Cross-method calls between <code>@Bean</code> methods won&#8217;t get intercepted then, so you&#8217;ll have
to exclusively rely on dependency injection at the constructor or method level there.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-composing-configuration-classes"><a class="anchor" href="#beans-java-composing-configuration-classes"></a>1.12.5. Composing Java-based configurations</h4>
<div class="sect4">
<h5 id="beans-java-using-import"><a class="anchor" href="#beans-java-using-import"></a>Using the @Import annotation</h5>
<div class="paragraph">
<p>Much as the <code>&lt;import/&gt;</code> element is used within Spring XML files to aid in modularizing
configurations, the <code>@Import</code> annotation allows for loading <code>@Bean</code> definitions from
another configuration class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigA</span> {

         <span class="annotation">@Bean</span>
        <span class="directive">public</span> A a() {
                <span class="keyword">return</span> <span class="keyword">new</span> A();
        }

}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>(ConfigA.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigB</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> B b() {
                <span class="keyword">return</span> <span class="keyword">new</span> B();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, rather than needing to specify both <code>ConfigA.class</code> and <code>ConfigB.class</code> when
instantiating the context, only <code>ConfigB</code> needs to be supplied explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);

        <span class="comment">// now both beans A and B will be available...</span>
        A a = ctx.getBean(A.class);
        B b = ctx.getBean(B.class);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach simplifies container instantiation, as only one class needs to be dealt
with, rather than requiring the developer to remember a potentially large number of
<code>@Configuration</code> classes during construction.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Framework 4.2, <code>@Import</code> also supports references to regular component
classes, analogous to the <code>AnnotationConfigApplicationContext.register</code> method.
This is particularly useful if you&#8217;d like to avoid component scanning, using a few
configuration classes as entry points for explicitly defining all your components.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="beans-java-injecting-imported-beans"><a class="anchor" href="#beans-java-injecting-imported-beans"></a>Injecting dependencies on imported @Bean definitions</h6>
<div class="paragraph">
<p>The example above works, but is simplistic. In most practical scenarios, beans will have
dependencies on one another across configuration classes. When using XML, this is not an
issue, per se, because there is no compiler involved, and one can simply declare
<code>ref="someBean"</code> and trust that Spring will work it out during container initialization.
Of course, when using <code>@Configuration</code> classes, the Java compiler places constraints on
the configuration model, in that references to other beans must be valid Java syntax.</p>
</div>
<div class="paragraph">
<p>Fortunately, solving this problem is simple. As <a href="#beans-java-dependencies">we already discussed</a>,
<code>@Bean</code> method can have an arbitrary number of parameters describing the bean
dependencies. Let&#8217;s consider a more real-world scenario with several <code>@Configuration</code>
classes, each depending on beans declared in the others:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService(AccountRepository accountRepository) {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">RepositoryConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository(<span class="predefined-type">DataSource</span> dataSource) {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, RepositoryConfig.class})
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return new DataSource</span>
        }
}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        <span class="comment">// everything wires up across configuration classes...</span>
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is another way to achieve the same result. Remember that <code>@Configuration</code> classes are
ultimately just another bean in the container: This means that they can take advantage of
<code>@Autowired</code> and <code>@Value</code> injection etc just like any other bean!</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Make sure that the dependencies you inject that way are of the simplest kind only. <code>@Configuration</code>
classes are processed quite early during the initialization of the context and forcing a dependency
to be injected this way may lead to unexpected early initialization. Whenever possible, resort to
parameter-based injection as in the example above.</p>
</div>
<div class="paragraph">
<p>Also, be particularly careful with <code>BeanPostProcessor</code> and <code>BeanFactoryPostProcessor</code> definitions
via <code>@Bean</code>. Those should usually be declared as <code>static @Bean</code> methods, not triggering the
instantiation of their containing configuration class. Otherwise, <code>@Autowired</code> and <code>@Value</code> won&#8217;t
work on the configuration class itself since it is being created as a bean instance too early.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> AccountRepository accountRepository;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">RepositoryConfig</span> {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">DataSource</span> dataSource;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> RepositoryConfig(<span class="predefined-type">DataSource</span> dataSource) {
                <span class="local-variable">this</span>.dataSource = dataSource;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, RepositoryConfig.class})
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return new DataSource</span>
        }
}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        <span class="comment">// everything wires up across configuration classes...</span>
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Constructor injection in <code>@Configuration</code> classes is only supported as of Spring
Framework 4.3. Note also that there is no need to specify <code>@Autowired</code> if the target
bean defines only one constructor; in the example above, <code>@Autowired</code> is not necessary
on the <code>RepositoryConfig</code> constructor.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-injecting-imported-beans-fq"></a>Fully-qualifying imported beans for ease of navigation</div>
<div class="content">
<div class="paragraph">
<p>In the scenario above, using <code>@Autowired</code> works well and provides the desired
modularity, but determining exactly where the autowired bean definitions are declared is
still somewhat ambiguous. For example, as a developer looking at <code>ServiceConfig</code>, how do
you know exactly where the <code>@Autowired AccountRepository</code> bean is declared? It&#8217;s not
explicit in the code, and this may be just fine. Remember that the
<a href="https://spring.io/tools/sts">Spring Tool Suite</a> provides tooling that
can render graphs showing how everything is wired up - that may be all you need. Also,
your Java IDE can easily find all declarations and uses of the <code>AccountRepository</code> type,
and will quickly show you the location of <code>@Bean</code> methods that return that type.</p>
</div>
<div class="paragraph">
<p>In cases where this ambiguity is not acceptable and you wish to have direct navigation
from within your IDE from one <code>@Configuration</code> class to another, consider autowiring the
configuration classes themselves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> RepositoryConfig repositoryConfig;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="comment">// navigate 'through' the config class to the @Bean method!</span>
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the situation above, it is completely explicit where <code>AccountRepository</code> is defined.
However, <code>ServiceConfig</code> is now tightly coupled to <code>RepositoryConfig</code>; that&#8217;s the
tradeoff. This tight coupling can be somewhat mitigated by using interface-based or
abstract class-based <code>@Configuration</code> classes. Consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> RepositoryConfig repositoryConfig;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">RepositoryConfig</span> {

        <span class="annotation">@Bean</span>
        AccountRepository accountRepository();
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultRepositoryConfig</span> <span class="directive">implements</span> RepositoryConfig {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(...);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, DefaultRepositoryConfig.class})  <span class="comment">// import the concrete config!</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return DataSource</span>
        }

}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now <code>ServiceConfig</code> is loosely coupled with respect to the concrete
<code>DefaultRepositoryConfig</code>, and built-in IDE tooling is still useful: it will be easy for
the developer to get a type hierarchy of <code>RepositoryConfig</code> implementations. In this
way, navigating <code>@Configuration</code> classes and their dependencies becomes no different
than the usual process of navigating interface-based code.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-conditional"><a class="anchor" href="#beans-java-conditional"></a>Conditionally include @Configuration classes or @Bean methods</h5>
<div class="paragraph">
<p>It is often useful to conditionally enable or disable a complete <code>@Configuration</code> class,
or even individual <code>@Bean</code> methods, based on some arbitrary system state. One common
example of this is to use the <code>@Profile</code> annotation to activate beans only when a specific
profile has been enabled in the Spring <code>Environment</code> (see <a href="#beans-definition-profiles">Bean definition profiles</a>
for details).</p>
</div>
<div class="paragraph">
<p>The <code>@Profile</code> annotation is actually implemented using a much more flexible annotation
called <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>.
The <code>@Conditional</code> annotation indicates specific
<code>org.springframework.context.annotation.Condition</code> implementations that should be
consulted before a <code>@Bean</code> is registered.</p>
</div>
<div class="paragraph">
<p>Implementations of the <code>Condition</code> interface simply provide a <code>matches(&#8230;&#8203;)</code>
method that returns <code>true</code> or <code>false</code>. For example, here is the actual
<code>Condition</code> implementation used for <code>@Profile</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        <span class="keyword">if</span> (context.getEnvironment() != <span class="predefined-constant">null</span>) {
                <span class="comment">// Read the @Profile annotation attributes</span>
                MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
                <span class="keyword">if</span> (attrs != <span class="predefined-constant">null</span>) {
                        <span class="keyword">for</span> (<span class="predefined-type">Object</span> value : attrs.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>)) {
                                <span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(((<span class="predefined-type">String</span><span class="type">[]</span>) value))) {
                                        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
                                }
                        }
                        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
                }
        }
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html">
<code>@Conditional</code> javadocs</a> for more detail.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-combining"><a class="anchor" href="#beans-java-combining"></a>Combining Java and XML configuration</h5>
<div class="paragraph">
<p>Spring&#8217;s <code>@Configuration</code> class support does not aim to be a 100% complete replacement
for Spring XML. Some facilities such as Spring XML namespaces remain an ideal way to
configure the container. In cases where XML is convenient or necessary, you have a
choice: either instantiate the container in an "XML-centric" way using, for example,
<code>ClassPathXmlApplicationContext</code>, or in a "Java-centric" fashion using
<code>AnnotationConfigApplicationContext</code> and the <code>@ImportResource</code> annotation to import XML
as needed.</p>
</div>
<div class="sect5">
<h6 id="beans-java-combining-xml-centric"><a class="anchor" href="#beans-java-combining-xml-centric"></a>XML-centric use of @Configuration classes</h6>
<div class="paragraph">
<p>It may be preferable to bootstrap the Spring container from XML and include
<code>@Configuration</code> classes in an ad-hoc fashion. For example, in a large existing codebase
that uses Spring XML, it will be easier to create <code>@Configuration</code> classes on an
as-needed basis and include them from the existing XML files. Below you&#8217;ll find the
options for using <code>@Configuration</code> classes in this kind of "XML-centric" situation.</p>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-declare-as-bean"></a>Declaring @Configuration classes as plain Spring <code>&lt;bean/&gt;</code> elements</div>
<div class="content">
<div class="paragraph">
<p>Remember that <code>@Configuration</code> classes are ultimately just bean definitions in the
container. In this example, we create a <code>@Configuration</code> class named <code>AppConfig</code> and
include it within <code>system-test-config.xml</code> as a <code>&lt;bean/&gt;</code> definition. Because
<code>&lt;context:annotation-config/&gt;</code> is switched on, the container will recognize the
<code>@Configuration</code> annotation and process the <code>@Bean</code> methods declared in <code>AppConfig</code>
properly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> <span class="predefined-type">DataSource</span> dataSource;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>system-test-config.xml</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span>
        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.AppConfig</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.jdbc.datasource.DriverManagerDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>jdbc.properties</strong>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/system-test-config.xml</span><span class="delimiter">&quot;</span></span>);
        TransferService transferService = ctx.getBean(TransferService.class);
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In <code>system-test-config.xml</code> above, the <code>AppConfig</code> <code>&lt;bean/&gt;</code> does not declare an <code>id</code>
element. While it would be acceptable to do so, it is unnecessary given that no other
bean will ever refer to it, and it is unlikely that it will be explicitly fetched from
the container by name. Likewise with the <code>DataSource</code> bean - it is only ever autowired
by type, so an explicit bean <code>id</code> is not strictly required.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-component-scan"></a> Using &lt;context:component-scan/&gt; to pick up <code>@Configuration</code> classes</div>
<div class="content">
<div class="paragraph">
<p>Because <code>@Configuration</code> is meta-annotated with <code>@Component</code>, <code>@Configuration</code>-annotated
classes are automatically candidates for component scanning. Using the same scenario as
above, we can redefine <code>system-test-config.xml</code> to take advantage of component-scanning.
Note that in this case, we don&#8217;t need to explicitly declare
<code>&lt;context:annotation-config/&gt;</code>, because <code>&lt;context:component-scan/&gt;</code> enables the same
functionality.</p>
</div>
<div class="paragraph">
<p><strong>system-test-config.xml</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.jdbc.datasource.DriverManagerDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-combining-java-centric"><a class="anchor" href="#beans-java-combining-java-centric"></a>@Configuration class-centric use of XML with @ImportResource</h6>
<div class="paragraph">
<p>In applications where <code>@Configuration</code> classes are the primary mechanism for configuring
the container, it will still likely be necessary to use at least some XML. In these
scenarios, simply use <code>@ImportResource</code> and define only as much XML as is needed. Doing
so achieves a "Java-centric" approach to configuring the container and keeps XML to a
bare minimum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ImportResource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/properties-config.xml</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> url;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> username;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> password;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">properties-config.xml
<span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);
        TransferService transferService = ctx.getBean(TransferService.class);
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-environment"><a class="anchor" href="#beans-environment"></a>1.13. Environment abstraction</h3>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/Environment.html"><code>Environment</code></a>
is an abstraction integrated in the container that models two key
aspects of the application environment: <a href="#beans-definition-profiles"><em>profiles</em></a>
and <a href="#beans-property-source-abstraction"><em>properties</em></a>.</p>
</div>
<div class="paragraph">
<p>A <em>profile</em> is a named, logical group of bean definitions to be registered with the
container only if the given profile is active. Beans may be assigned to a profile
whether defined in XML or via annotations. The role of the <code>Environment</code> object with
relation to profiles is in determining which profiles (if any) are currently active,
and which profiles (if any) should be active by default.</p>
</div>
<div class="paragraph">
<p>Properties play an important role in almost all applications, and may originate from
a variety of sources: properties files, JVM system properties, system environment
variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so
on. The role of the <code>Environment</code> object with relation to properties is to provide the
user with a convenient service interface for configuring property sources and resolving
properties from them.</p>
</div>
<div class="sect3">
<h4 id="beans-definition-profiles"><a class="anchor" href="#beans-definition-profiles"></a>1.13.1. Bean definition profiles</h4>
<div class="paragraph">
<p>Bean definition profiles is a mechanism in the core container that allows for
registration of different beans in different environments. The word <em>environment</em>
can mean different things to different users and this feature can help with many
use cases, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>working against an in-memory datasource in development vs looking up that same
datasource from JNDI when in QA or production</p>
</li>
<li>
<p>registering monitoring infrastructure only when deploying an application into a
performance environment</p>
</li>
<li>
<p>registering customized implementations of beans for customer A vs. customer
B deployments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the first use case in a practical application that requires a
<code>DataSource</code>. In a test environment, the configuration may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-schema.sql</span><span class="delimiter">&quot;</span></span>)
                .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-test-data.sql</span><span class="delimiter">&quot;</span></span>)
                .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s now consider how this application will be deployed into a QA or production
environment, assuming that the datasource for the application will be registered
with the production application server&#8217;s JNDI directory. Our <code>dataSource</code> bean
now looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
        <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is how to switch between using these two variations based on the
current environment. Over time, Spring users have devised a number of ways to
get this done, usually relying on a combination of system environment variables
and XML <code>&lt;import/&gt;</code> statements containing <code>${placeholder}</code> tokens that resolve
to the correct configuration file path depending on the value of an environment
variable. Bean definition profiles is a core container feature that provides a
solution to this problem.</p>
</div>
<div class="paragraph">
<p>If we generalize the example use case above of environment-specific bean
definitions, we end up with the need to register certain bean definitions in
certain contexts, while not in others. You could say that you want to register a
certain profile of bean definitions in situation A, and a different profile in
situation B. Let&#8217;s first see how we can update our configuration to reflect
this need.</p>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-java"><a class="anchor" href="#beans-definition-profiles-java"></a>@Profile</h5>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a>
annotation allows you to indicate that a component is eligible for registration
when one or more specified profiles are active. Using our example above, we
can rewrite the <code>dataSource</code> configuration as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">StandaloneDataConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">JndiDataConfig</span> {

        <span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
                <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
                <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As mentioned before, with <code>@Bean</code> methods, you will typically choose to use programmatic
JNDI lookups: either using Spring&#8217;s <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> helpers or the
straight JNDI <code>InitialContext</code> usage shown above, but not the <code>JndiObjectFactoryBean</code>
variant which would force you to declare the return type as the <code>FactoryBean</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Profile</code> can be used as a <a href="#beans-meta-annotations">meta-annotation</a> for the purpose
of creating a custom <em>composed annotation</em>. The following example defines a custom
<code>@Production</code> annotation that can be used as a drop-in replacement for
<code>@Profile("production")</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.TYPE)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="annotation">@interface</span> Production {
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a <code>@Configuration</code> class is marked with <code>@Profile</code>, all of the <code>@Bean</code> methods and
<code>@Import</code> annotations associated with that class will be bypassed unless one or more of
the specified profiles are active. If a <code>@Component</code> or <code>@Configuration</code> class is marked
with <code>@Profile({"p1", "p2"})</code>, that class will not be registered/processed unless
profiles 'p1' and/or 'p2' have been activated. If a given profile is prefixed with the
NOT operator (<code>!</code>), the annotated element will be registered if the profile is <strong>not</strong>
active. For example, given <code>@Profile({"p1", "!p2"})</code>, registration will occur if profile
'p1' is active or if profile 'p2' is not active.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Profile</code> can also be declared at the method level to include only one particular bean
of a configuration class, e.g. for alternative variants of a particular bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>)
        <strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> standaloneDataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }

        <span class="annotation">@Bean</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>)
        <strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> jndiDataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
                <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
                <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>With <code>@Profile</code> on <code>@Bean</code> methods, a special scenario may apply: In the case of
overloaded <code>@Bean</code> methods of the same Java method name (analogous to constructor
overloading), an <code>@Profile</code> condition needs to be consistently declared on all
overloaded methods. If the conditions are inconsistent, only the condition on the
first declaration among the overloaded methods will matter. <code>@Profile</code> can therefore
not be used to select an overloaded method with a particular argument signature over
another; resolution between all factory methods for the same bean follows Spring&#8217;s
constructor resolution algorithm at creation time.</p>
</div>
<div class="paragraph">
<p>If you would like to define alternative beans with different profile conditions,
use distinct Java method names pointing to the same bean name via the <code>@Bean</code> name
attribute, as indicated in the example above. If the argument signatures are all
the same (e.g. all of the variants have no-arg factory methods), this is the only
way to represent such an arrangement in a valid Java class in the first place
(since there can only be one method of a particular name and argument signature).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-xml"><a class="anchor" href="#beans-definition-profiles-xml"></a>XML bean definition profiles</h5>
<div class="paragraph">
<p>The XML counterpart is the <code>profile</code> attribute of the <code>&lt;beans&gt;</code> element. Our sample
configuration above can be rewritten in two XML files as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jdbc</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jdbc</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;jdbc:embedded-database</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/jdbc:embedded-database&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jee</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;jee:jndi-lookup</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">jndi-name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to avoid that split and nest <code>&lt;beans/&gt;</code> elements within the same file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jdbc</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jdbc</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jee</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- other bean definitions --&gt;</span>

        <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jdbc:embedded-database</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/jdbc:embedded-database&gt;</span>
        <span class="tag">&lt;/beans&gt;</span>

        <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jee:jndi-lookup</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">jndi-name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/beans&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spring-bean.xsd</code> has been constrained to allow such elements only as the
last ones in the file. This should help provide flexibility without incurring
clutter in the XML files.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-enable"><a class="anchor" href="#beans-definition-profiles-enable"></a>Activating a profile</h5>
<div class="paragraph">
<p>Now that we have updated our configuration, we still need to instruct Spring which
profile is active. If we started our sample application right now, we would see
a <code>NoSuchBeanDefinitionException</code> thrown, because the container could not find
the Spring bean named <code>dataSource</code>.</p>
</div>
<div class="paragraph">
<p>Activating a profile can be done in several ways, but the most straightforward is to do
it programmatically against the <code>Environment</code> API which is available via an
<code>ApplicationContext</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, profiles may also be activated declaratively through the
<code>spring.profiles.active</code> property which may be specified through system environment
variables, JVM system properties, servlet context parameters in <code>web.xml</code>, or even as an
entry in JNDI (see <a href="#beans-property-source-abstraction">PropertySource abstraction</a>). In integration tests, active
profiles can be declared via the <code>@ActiveProfiles</code> annotation in the <code>spring-test</code> module
(see <a href="testing.html#testcontext-ctx-management-env-profiles">Context configuration with environment profiles</a>).</p>
</div>
<div class="paragraph">
<p>Note that profiles are not an "either-or" proposition; it is possible to activate multiple
profiles at once. Programmatically, simply provide multiple profile names to the
<code>setActiveProfiles()</code> method, which accepts <code>String&#8230;&#8203;</code> varargs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ctx.getEnvironment().setActiveProfiles(<span class="string"><span class="delimiter">&quot;</span><span class="content">profile1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">profile2</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Declaratively, <code>spring.profiles.active</code> may accept a comma-separated list of profile names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">-Dspring.profiles.active=<span class="string"><span class="delimiter">&quot;</span><span class="content">profile1,profile2</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-default"><a class="anchor" href="#beans-definition-profiles-default"></a>Default profile</h5>
<div class="paragraph">
<p>The <em>default</em> profile represents the profile that is enabled by default. Consider the
following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">default</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultDataConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no profile is active, the <code>dataSource</code> above will be created; this can be
seen as a way to provide a <em>default</em> definition for one or more beans. If any
profile is enabled, the <em>default</em> profile will not apply.</p>
</div>
<div class="paragraph">
<p>The name of the default profile can be changed using <code>setDefaultProfiles()</code> on
the <code>Environment</code> or declaratively using the <code>spring.profiles.default</code> property.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-property-source-abstraction"><a class="anchor" href="#beans-property-source-abstraction"></a>1.13.2. PropertySource abstraction</h4>
<div class="paragraph">
<p>Spring&#8217;s <code>Environment</code> abstraction provides search operations over a configurable
hierarchy of property sources. To explain fully, consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();
Environment env = ctx.getEnvironment();
<span class="type">boolean</span> containsFoo = env.containsProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Does my environment contain the 'foo' property? </span><span class="delimiter">&quot;</span></span> + containsFoo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the snippet above, we see a high-level way of asking Spring whether the <code>foo</code> property is
defined for the current environment. To answer this question, the <code>Environment</code> object performs
a search over a set of <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a>
objects. A <code>PropertySource</code> is a simple abstraction over any source of key-value pairs, and
Spring&#8217;s <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a>
is configured with two PropertySource objects&#8201;&#8212;&#8201;one representing the set of JVM system properties
(<em>a la</em> <code>System.getProperties()</code>) and one representing the set of system environment variables
(<em>a la</em> <code>System.getenv()</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>These default property sources are present for <code>StandardEnvironment</code>, for use in standalone
applications. <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a>
is populated with additional default property sources including servlet config and servlet
context parameters. It can optionally enable a <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a>.
See the javadocs for details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Concretely, when using the <code>StandardEnvironment</code>, the call to <code>env.containsProperty("foo")</code>
will return true if a <code>foo</code> system property or <code>foo</code> environment variable is present at
runtime.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The search performed is hierarchical. By default, system properties have precedence over
environment variables, so if the <code>foo</code> property happens to be set in both places during
a call to <code>env.getProperty("foo")</code>, the system property value will 'win' and be returned
preferentially over the environment variable. Note that property values will not get merged
but rather completely overridden by a preceding entry.</p>
</div>
<div class="paragraph">
<p>For a common <code>StandardServletEnvironment</code>, the full hierarchy looks as follows, with the
highest-precedence entries at the top:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ServletConfig parameters (if applicable, e.g. in case of a <code>DispatcherServlet</code> context)</p>
</li>
<li>
<p>ServletContext parameters (web.xml context-param entries)</p>
</li>
<li>
<p>JNDI environment variables ("java:comp/env/" entries)</p>
</li>
<li>
<p>JVM system properties ("-D" command-line arguments)</p>
</li>
<li>
<p>JVM system environment (operating system environment variables)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most importantly, the entire mechanism is configurable. Perhaps you have a custom source
of properties that you&#8217;d like to integrate into this search. No problem&#8201;&#8212;&#8201;simply implement
and instantiate your own <code>PropertySource</code> and add it to the set of <code>PropertySources</code> for the
current <code>Environment</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConfigurableApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(<span class="keyword">new</span> MyPropertySource());</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code above, <code>MyPropertySource</code> has been added with highest precedence in the
search. If it contains a <code>foo</code> property, it will be detected and returned ahead of
any <code>foo</code> property in any other <code>PropertySource</code>. The
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a>
API exposes a number of methods that allow for precise manipulation of the set of
property sources.</p>
</div>
</div>
<div class="sect3">
<h4 id="propertysource"><a class="anchor" href="#propertysource"></a>1.13.3. @PropertySource</h4>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>
annotation provides a convenient and declarative mechanism for adding a <code>PropertySource</code>
to Spring&#8217;s <code>Environment</code>.</p>
</div>
<div class="paragraph">
<p>Given a file "app.properties" containing the key/value pair <code>testbean.name=myTestBean</code>,
the following <code>@Configuration</code> class uses <code>@PropertySource</code> in such a way that
a call to <code>testBean.getName()</code> will return "myTestBean".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@PropertySource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/myco/app.properties</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

 <span class="annotation">@Autowired</span>
 Environment env;

 <span class="annotation">@Bean</span>
 <span class="directive">public</span> TestBean testBean() {
  TestBean testBean = <span class="keyword">new</span> TestBean();
  testBean.setName(env.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">testbean.name</span><span class="delimiter">&quot;</span></span>));
  <span class="keyword">return</span> testBean;
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any <code>${&#8230;&#8203;}</code> placeholders present in a <code>@PropertySource</code> resource location will
be resolved against the set of property sources already registered against the
environment. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@PropertySource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/${my.placeholder:default/path}/app.properties</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

 <span class="annotation">@Autowired</span>
 Environment env;

 <span class="annotation">@Bean</span>
 <span class="directive">public</span> TestBean testBean() {
  TestBean testBean = <span class="keyword">new</span> TestBean();
  testBean.setName(env.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">testbean.name</span><span class="delimiter">&quot;</span></span>));
  <span class="keyword">return</span> testBean;
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming that "my.placeholder" is present in one of the property sources already
registered, e.g. system properties or environment variables, the placeholder will
be resolved to the corresponding value. If not, then "default/path" will be used
as a default. If no default is specified and a property cannot be resolved, an
<code>IllegalArgumentException</code> will be thrown.</p>
</div>
</div>
<div class="sect3">
<h4 id="placeholder-resolution-in-statements"><a class="anchor" href="#placeholder-resolution-in-statements"></a>1.13.4. Placeholder resolution in statements</h4>
<div class="paragraph">
<p>Historically, the value of placeholders in elements could be resolved only against
JVM system properties or environment variables. No longer is this the case. Because
the Environment abstraction is integrated throughout the container, it&#8217;s easy to
route resolution of placeholders through it. This means that you may configure the
resolution process in any way you like: change the precedence of searching through
system properties and environment variables, or remove them entirely; add your
own property sources to the mix as appropriate.</p>
</div>
<div class="paragraph">
<p>Concretely, the following statement works regardless of where the <code>customer</code>
property is defined, as long as it is available in the <code>Environment</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com/bank/service/${customer}-config.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context-load-time-weaver"><a class="anchor" href="#context-load-time-weaver"></a>1.14. Registering a LoadTimeWeaver</h3>
<div class="paragraph">
<p>The <code>LoadTimeWeaver</code> is used by Spring to dynamically transform classes as they are
loaded into the Java virtual machine (JVM).</p>
</div>
<div class="paragraph">
<p>To enable load-time weaving add the <code>@EnableLoadTimeWeaving</code> to one of your
<code>@Configuration</code> classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableLoadTimeWeaving</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively for XML configuration use the <code>context:load-time-weaver</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:load-time-weaver</span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once configured for the <code>ApplicationContext</code>. Any bean within that <code>ApplicationContext</code>
may implement <code>LoadTimeWeaverAware</code>, thereby receiving a reference to the load-time
weaver instance. This is particularly useful in combination with
<a href="data-access.html#orm-jpa">Spring&#8217;s JPA support</a> where load-time weaving may be necessary
for JPA class transformation.
Consult the <code>LocalContainerEntityManagerFactoryBean</code> javadocs for more detail. For more on
AspectJ load-time weaving, see <a href="#aop-aj-ltw">Load-time weaving with AspectJ in the Spring Framework</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="context-introduction"><a class="anchor" href="#context-introduction"></a>1.15. Additional Capabilities of the ApplicationContext</h3>
<div class="paragraph">
<p>As was discussed in the chapter introduction, the <code>org.springframework.beans.factory</code>
package provides basic functionality for managing and manipulating beans, including in a
programmatic way. The <code>org.springframework.context</code> package adds the
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>
interface, which extends the <code>BeanFactory</code> interface, in addition to extending other
interfaces to provide additional functionality in a more <em>application
framework-oriented style</em>. Many people use the <code>ApplicationContext</code> in a completely
declarative fashion, not even creating it programmatically, but instead relying on
support classes such as <code>ContextLoader</code> to automatically instantiate an
<code>ApplicationContext</code> as part of the normal startup process of a Java EE web application.</p>
</div>
<div class="paragraph">
<p>To enhance <code>BeanFactory</code> functionality in a more framework-oriented style the context
package also provides the following functionality:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Access to messages in i18n-style</em>, through the <code>MessageSource</code> interface.</p>
</li>
<li>
<p><em>Access to resources</em>, such as URLs and files, through the <code>ResourceLoader</code> interface.</p>
</li>
<li>
<p><em>Event publication</em> to namely beans implementing the <code>ApplicationListener</code> interface,
through the use of the <code>ApplicationEventPublisher</code> interface.</p>
</li>
<li>
<p><em>Loading of multiple (hierarchical) contexts</em>, allowing each to be focused on one
particular layer, such as the web layer of an application, through the
<code>HierarchicalBeanFactory</code> interface.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="context-functionality-messagesource"><a class="anchor" href="#context-functionality-messagesource"></a>1.15.1. Internationalization using MessageSource</h4>
<div class="paragraph">
<p>The <code>ApplicationContext</code> interface extends an interface called <code>MessageSource</code>, and
therefore provides internationalization (i18n) functionality. Spring also provides the
interface <code>HierarchicalMessageSource</code>, which can resolve messages hierarchically.
Together these interfaces provide the foundation upon which Spring effects message
resolution. The methods defined on these interfaces include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>: The basic
method used to retrieve a message from the <code>MessageSource</code>. When no message is found
for the specified locale, the default message is used. Any arguments passed in become
replacement values, using the <code>MessageFormat</code> functionality provided by the standard
library.</p>
</li>
<li>
<p><code>String getMessage(String code, Object[] args, Locale loc)</code>: Essentially the same as
the previous method, but with one difference: no default message can be specified; if
the message cannot be found, a <code>NoSuchMessageException</code> is thrown.</p>
</li>
<li>
<p><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>: All properties
used in the preceding methods are also wrapped in a class named
<code>MessageSourceResolvable</code>, which you can use with this method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an <code>ApplicationContext</code> is loaded, it automatically searches for a <code>MessageSource</code>
bean defined in the context. The bean must have the name <code>messageSource</code>. If such a bean
is found, all calls to the preceding methods are delegated to the message source. If no
message source is found, the <code>ApplicationContext</code> attempts to find a parent containing a
bean with the same name. If it does, it uses that bean as the <code>MessageSource</code>. If the
<code>ApplicationContext</code> cannot find any source for messages, an empty
<code>DelegatingMessageSource</code> is instantiated in order to be able to accept calls to the
methods defined above.</p>
</div>
<div class="paragraph">
<p>Spring provides two <code>MessageSource</code> implementations, <code>ResourceBundleMessageSource</code> and
<code>StaticMessageSource</code>. Both implement <code>HierarchicalMessageSource</code> in order to do nested
messaging. The <code>StaticMessageSource</code> is rarely used but provides programmatic ways to
add messages to the source. The <code>ResourceBundleMessageSource</code> is shown in the following
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ResourceBundleMessageSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">basenames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;list&gt;</span>
                                <span class="tag">&lt;value&gt;</span>format<span class="tag">&lt;/value&gt;</span>
                                <span class="tag">&lt;value&gt;</span>exceptions<span class="tag">&lt;/value&gt;</span>
                                <span class="tag">&lt;value&gt;</span>windows<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;/list&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example it is assumed you have three resource bundles defined in your classpath
called <code>format</code>, <code>exceptions</code> and <code>windows</code>. Any request to resolve a message will be
handled in the JDK standard way of resolving messages through ResourceBundles. For the
purposes of the example, assume the contents of two of the above resource bundle files
are&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span> in format.properties
message=Alligators rock!</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span> in exceptions.properties
argument.required=The {<span class="integer">0</span>} argument is required.</code></pre>
</div>
</div>
<div class="paragraph">
<p>A program to execute the <code>MessageSource</code> functionality is shown in the next example.
Remember that all <code>ApplicationContext</code> implementations are also <code>MessageSource</code>
implementations and so can be cast to the <code>MessageSource</code> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> message = resources.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Default</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);
        <span class="predefined-type">System</span>.out.println(message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting output from the above program will be&#8230;&#8203;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Alligators rock!</pre>
</div>
</div>
<div class="paragraph">
<p>So to summarize, the <code>MessageSource</code> is defined in a file called <code>beans.xml</code>, which
exists at the root of your classpath. The <code>messageSource</code> bean definition refers to a
number of resource bundles through its <code>basenames</code> property. The three files that are
passed in the list to the <code>basenames</code> property exist as files at the root of your
classpath and are called <code>format.properties</code>, <code>exceptions.properties</code>, and
<code>windows.properties</code> respectively.</p>
</div>
<div class="paragraph">
<p>The next example shows arguments passed to the message lookup; these arguments will be
converted into Strings and inserted into placeholders in the lookup message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>

        <span class="comment">&lt;!-- this MessageSource is being used in a web application --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ResourceBundleMessageSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">basename</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exceptions</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- lets inject the above MessageSource into this POJO --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.Example</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messages</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Example</span> {

        <span class="directive">private</span> MessageSource messages;

        <span class="directive">public</span> <span class="type">void</span> setMessages(MessageSource messages) {
                <span class="local-variable">this</span>.messages = messages;
        }

        <span class="directive">public</span> <span class="type">void</span> execute() {
                <span class="predefined-type">String</span> message = <span class="local-variable">this</span>.messages.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">argument.required</span><span class="delimiter">&quot;</span></span>,
                        <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">userDao</span><span class="delimiter">&quot;</span></span>}, <span class="string"><span class="delimiter">&quot;</span><span class="content">Required</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);
                <span class="predefined-type">System</span>.out.println(message);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting output from the invocation of the <code>execute()</code> method will be&#8230;&#8203;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The userDao argument is required.</pre>
</div>
</div>
<div class="paragraph">
<p>With regard to internationalization (i18n), Spring&#8217;s various <code>MessageSource</code>
implementations follow the same locale resolution and fallback rules as the standard JDK
<code>ResourceBundle</code>. In short, and continuing with the example <code>messageSource</code> defined
previously, if you want to resolve messages against the British (<code>en-GB</code>) locale, you
would create files called <code>format_en_GB.properties</code>, <code>exceptions_en_GB.properties</code>, and
<code>windows_en_GB.properties</code> respectively.</p>
</div>
<div class="paragraph">
<p>Typically, locale resolution is managed by the surrounding environment of the
application. In this example, the locale against which (British) messages will be
resolved is specified manually.</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in exceptions_en_GB.properties
argument.required=Ebagum lad, the {0} argument is required, I say, required.</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) {
        MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> message = resources.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">argument.required</span><span class="delimiter">&quot;</span></span>,
                <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">userDao</span><span class="delimiter">&quot;</span></span>}, <span class="string"><span class="delimiter">&quot;</span><span class="content">Required</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Locale</span>.UK);
        <span class="predefined-type">System</span>.out.println(message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting output from the running of the above program will be&#8230;&#8203;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ebagum lad, the 'userDao' argument is required, I say, required.</pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the <code>MessageSourceAware</code> interface to acquire a reference to any
<code>MessageSource</code> that has been defined. Any bean that is defined in an
<code>ApplicationContext</code> that implements the <code>MessageSourceAware</code> interface is injected with
the application context&#8217;s <code>MessageSource</code> when the bean is created and configured.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>As an alternative to <code>ResourceBundleMessageSource</code>, Spring provides a
<code>ReloadableResourceBundleMessageSource</code> class. This variant supports the same bundle
file format but is more flexible than the standard JDK based
<code>ResourceBundleMessageSource</code> implementation.</em> In particular, it allows for reading
files from any Spring resource location (not just from the classpath) and supports hot
reloading of bundle property files (while efficiently caching them in between). Check
out the <code>ReloadableResourceBundleMessageSource</code> javadocs for details.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-events"><a class="anchor" href="#context-functionality-events"></a>1.15.2. Standard and Custom Events</h4>
<div class="paragraph">
<p>Event handling in the <code>ApplicationContext</code> is provided through the <code>ApplicationEvent</code>
class and <code>ApplicationListener</code> interface. If a bean that implements the
<code>ApplicationListener</code> interface is deployed into the context, every time an
<code>ApplicationEvent</code> gets published to the <code>ApplicationContext</code>, that bean is notified.
Essentially, this is the standard <em>Observer</em> design pattern.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring 4.2, the event infrastructure has been significantly improved and offer
an <a href="#context-functionality-events-annotation">annotation-based model</a> as well as the
ability to publish any arbitrary event, that is an object that does not necessarily
extend from <code>ApplicationEvent</code>. When such an object is published we wrap it in an
event for you.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring provides the following standard events:</p>
</div>
<table id="beans-ctx-events-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. Built-in Events</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Event</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextRefreshedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is initialized or refreshed, for example,
using the <code>refresh()</code> method on the <code>ConfigurableApplicationContext</code> interface.
"Initialized" here means that all beans are loaded, post-processor beans are detected
and activated, singletons are pre-instantiated, and the <code>ApplicationContext</code> object is
ready for use. As long as the context has not been closed, a refresh can be triggered
multiple times, provided that the chosen <code>ApplicationContext</code> actually supports such
"hot" refreshes. For example, <code>XmlWebApplicationContext</code> supports hot refreshes, but
<code>GenericApplicationContext</code> does not.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStartedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is started, using the <code>start()</code> method on the
<code>ConfigurableApplicationContext</code> interface. "Started" here means that all <code>Lifecycle</code>
beans receive an explicit start signal. Typically this signal is used to restart beans
after an explicit stop, but it may also be used to start components that have not been
configured for autostart , for example, components that have not already started on
initialization.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStoppedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is stopped, using the <code>stop()</code> method on the
<code>ConfigurableApplicationContext</code> interface. "Stopped" here means that all <code>Lifecycle</code>
beans receive an explicit stop signal. A stopped context may be restarted through a
<code>start()</code> call.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextClosedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is closed, using the <code>close()</code> method on the
<code>ConfigurableApplicationContext</code> interface. "Closed" here means that all singleton
beans are destroyed. A closed context reaches its end of life; it cannot be refreshed
or restarted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A web-specific event telling all beans that an HTTP request has been serviced. This
event is published <em>after</em> the request is complete. This event is only applicable to
web applications using Spring&#8217;s <code>DispatcherServlet</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can also create and publish your own custom events. This example demonstrates a
simple class that extends Spring&#8217;s <code>ApplicationEvent</code> base class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListEvent</span> <span class="directive">extends</span> ApplicationEvent {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> address;
        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> test;

        <span class="directive">public</span> BlackListEvent(<span class="predefined-type">Object</span> source, <span class="predefined-type">String</span> address, <span class="predefined-type">String</span> test) {
                <span class="local-variable">super</span>(source);
                <span class="local-variable">this</span>.address = address;
                <span class="local-variable">this</span>.test = test;
        }

        <span class="comment">// accessor and other methods...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To publish a custom <code>ApplicationEvent</code>, call the <code>publishEvent()</code> method on an
<code>ApplicationEventPublisher</code>. Typically this is done by creating a class that implements
<code>ApplicationEventPublisherAware</code> and registering it as a Spring bean. The following
example demonstrates such a class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">EmailService</span> <span class="directive">implements</span> ApplicationEventPublisherAware {

        <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; blackList;
        <span class="directive">private</span> ApplicationEventPublisher publisher;

        <span class="directive">public</span> <span class="type">void</span> setBlackList(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; blackList) {
                <span class="local-variable">this</span>.blackList = blackList;
        }

        <span class="directive">public</span> <span class="type">void</span> setApplicationEventPublisher(ApplicationEventPublisher publisher) {
                <span class="local-variable">this</span>.publisher = publisher;
        }

        <span class="directive">public</span> <span class="type">void</span> sendEmail(<span class="predefined-type">String</span> address, <span class="predefined-type">String</span> text) {
                <span class="keyword">if</span> (blackList.contains(address)) {
                        BlackListEvent event = <span class="keyword">new</span> BlackListEvent(<span class="local-variable">this</span>, address, text);
                        publisher.publishEvent(event);
                        <span class="keyword">return</span>;
                }
                <span class="comment">// send email...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At configuration time, the Spring container will detect that <code>EmailService</code> implements
<code>ApplicationEventPublisherAware</code> and will automatically call
<code>setApplicationEventPublisher()</code>. In reality, the parameter passed in will be the Spring
container itself; you&#8217;re simply interacting with the application context via its
<code>ApplicationEventPublisher</code> interface.</p>
</div>
<div class="paragraph">
<p>To receive the custom <code>ApplicationEvent</code>, create a class that implements
<code>ApplicationListener</code> and register it as a Spring bean. The following example
demonstrates such a class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListNotifier</span> <span class="directive">implements</span> ApplicationListener&lt;BlackListEvent&gt; {

        <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress;

        <span class="directive">public</span> <span class="type">void</span> setNotificationAddress(<span class="predefined-type">String</span> notificationAddress) {
                <span class="local-variable">this</span>.notificationAddress = notificationAddress;
        }

        <span class="directive">public</span> <span class="type">void</span> onApplicationEvent(BlackListEvent event) {
                <span class="comment">// notify appropriate parties via notificationAddress...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that <code>ApplicationListener</code> is generically parameterized with the type of your
custom event, <code>BlackListEvent</code>. This means that the <code>onApplicationEvent()</code> method can
remain type-safe, avoiding any need for downcasting. You may register as many event
listeners as you wish, but note that by default event listeners receive events
synchronously. This means the <code>publishEvent()</code> method blocks until all listeners have
finished processing the event. One advantage of this synchronous and single-threaded
approach is that when a listener receives an event, it operates inside the transaction
context of the publisher if a transaction context is available. If another strategy for
event publication becomes necessary, refer to the javadoc for Spring&#8217;s
<code>ApplicationEventMulticaster</code> interface.</p>
</div>
<div class="paragraph">
<p>The following example shows the bean definitions used to register and configure each of
the classes above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">emailService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.EmailService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blackList</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d3b8bdbca4bdfda0a3b2bebeb6a193b6abb2bea3bfb6fdbca1b4">[email&#160;protected]</a><span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1d7673726a7333757c7e76786f5d78657c706d717833726f7a">[email&#160;protected]</a><span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8ce6e3e4e2a2e8e3e9cce9f4ede1fce0e9a2e3feeb">[email&#160;protected]</a><span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blackListNotifier</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.BlackListNotifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">notificationAddress</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="06646a67656d6a6f757246637e676b766a6328697461">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Putting it all together, when the <code>sendEmail()</code> method of the <code>emailService</code> bean is
called, if there are any emails that should be blacklisted, a custom event of type
<code>BlackListEvent</code> is published. The <code>blackListNotifier</code> bean is registered as an
<code>ApplicationListener</code> and thus receives the <code>BlackListEvent</code>, at which point it can
notify appropriate parties.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring&#8217;s eventing mechanism is designed for simple communication between Spring beans
within the same application context. However, for more sophisticated enterprise
integration needs, the separately-maintained
<a href="https://projects.spring.io/spring-integration/">Spring Integration</a> project provides
complete support for building lightweight,
<a href="http://www.enterpriseintegrationpatterns.com">pattern-oriented</a>, event-driven
architectures that build upon the well-known Spring programming model.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="context-functionality-events-annotation"><a class="anchor" href="#context-functionality-events-annotation"></a>Annotation-based Event Listeners</h5>
<div class="paragraph">
<p>As of Spring 4.2, an event listener can be registered on any public method of a managed
bean via the <code>EventListener</code> annotation. The <code>BlackListNotifier</code> can be rewritten as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListNotifier</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress;

        <span class="directive">public</span> <span class="type">void</span> setNotificationAddress(<span class="predefined-type">String</span> notificationAddress) {
                <span class="local-variable">this</span>.notificationAddress = notificationAddress;
        }

        <span class="annotation">@EventListener</span>
        <span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
                <span class="comment">// notify appropriate parties via notificationAddress...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see above, the method signature once again declares the event type it listens to,
but this time with a flexible name and without implementing a specific listener interface.
The event type can also be narrowed through generics as long as the actual event type
resolves your generic parameter in its implementation hierarchy.</p>
</div>
<div class="paragraph">
<p>If your method should listen to several events or if you want to define it with no
parameter at all, the event type(s) can also be specified on the annotation itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>({ContextStartedEvent.class, ContextRefreshedEvent.class})
<span class="directive">public</span> <span class="type">void</span> handleContextStart() {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to add additional runtime filtering via the <code>condition</code> attribute of the
annotation that defines a <a href="#expressions"><code>SpEL</code> expression</a> that should match to actually invoke
the method for a particular event.</p>
</div>
<div class="paragraph">
<p>For instance, our notifier can be rewritten to be only invoked if the <code>test</code> attribute of the
event is equal to <code>foo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>(condition = <span class="string"><span class="delimiter">&quot;</span><span class="content">#blEvent.test == 'foo'</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent blEvent) {
        <span class="comment">// notify appropriate parties via notificationAddress...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each <code>SpEL</code> expression evaluates again a dedicated context. The next table lists the items made
available to the context so one can use them for conditional event processing:</p>
</div>
<table id="context-functionality-events-annotation-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. Event SpEL available metadata</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Location</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The actual <code>ApplicationEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.event</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arguments array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arguments (as array) used for invoking the target</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.args[0]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Argument name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluation context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of any of the method arguments. If for some reason the names are not available
(e.g. no debug information), the argument names are also available under the <code>#a&lt;#arg&gt;</code>
where <em>#arg</em> stands for the argument index (starting from 0).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#blEvent</code> or <code>#a0</code> (one can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> notation as an alias).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that <code>#root.event</code> allows you to access to the underlying event, even if your method
signature actually refers to an arbitrary object that was published.</p>
</div>
<div class="paragraph">
<p>If you need to publish an event as the result of processing another, just change the
method signature to return the event that should be published, something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
        <span class="comment">// notify appropriate parties via notificationAddress and</span>
        <span class="comment">// then publish a ListUpdateEvent...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This feature is not supported for <a href="#context-functionality-events-async">asynchronous
listeners</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This new method will publish a new <code>ListUpdateEvent</code> for every <code>BlackListEvent</code> handled
by the method above. If you need to publish several events, just return a <code>Collection</code> of
events instead.</p>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-async"><a class="anchor" href="#context-functionality-events-async"></a>Asynchronous Listeners</h5>
<div class="paragraph">
<p>If you want a particular listener to process events asynchronously, simply reuse the
<a href="integration.html#scheduling-annotation-support-async">regular <code>@Async</code> support</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="annotation">@Async</span>
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
        <span class="comment">// BlackListEvent is processed in a separate thread</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware of the following limitations when using asynchronous events:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the event listener throws an <code>Exception</code> it will not be propagated to the caller,
check <code>AsyncUncaughtExceptionHandler</code> for more details.</p>
</li>
<li>
<p>Such event listener cannot send replies. If you need to send another event as the
result of the processing, inject <code>ApplicationEventPublisher</code> to send the event
manually.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-order"><a class="anchor" href="#context-functionality-events-order"></a>Ordering Listeners</h5>
<div class="paragraph">
<p>If you need the listener to be invoked before another one, just add the <code>@Order</code>
annotation to the method declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="annotation">@Order</span>(<span class="integer">42</span>)
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
        <span class="comment">// notify appropriate parties via notificationAddress...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-generics"><a class="anchor" href="#context-functionality-events-generics"></a>Generic Events</h5>
<div class="paragraph">
<p>You may also use generics to further define the structure of your event. Consider an
<code>EntityCreatedEvent&lt;T&gt;</code> where <code>T</code> is the type of the actual entity that got created. You
can create the following listener definition to only receive <code>EntityCreatedEvent</code> for a
<code>Person</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> <span class="type">void</span> onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Due to type erasure, this will only work if the event that is fired resolves the generic
parameter(s) on which the event listener filters on (that is something like
<code>class PersonCreatedEvent extends EntityCreatedEvent&lt;Person&gt; { &#8230;&#8203; }</code>).</p>
</div>
<div class="paragraph">
<p>In certain circumstances, this may become quite tedious if all events follow the same
structure (as it should be the case for the event above). In such a case, you can
implement <code>ResolvableTypeProvider</code> to <em>guide</em> the framework beyond what the runtime
environment provides:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">EntityCreatedEvent</span>&lt;T&gt;
                   <span class="directive">extends</span> ApplicationEvent <span class="directive">implements</span> ResolvableTypeProvider {

           <span class="directive">public</span> EntityCreatedEvent(T entity) {
                   <span class="local-variable">super</span>(entity);
           }

           <span class="annotation">@Override</span>
           <span class="directive">public</span> ResolvableType getResolvableType() {
                   <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(),
                                   ResolvableType.forInstance(getSource()));
           }
   }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This works not only for <code>ApplicationEvent</code> but any arbitrary object that you&#8217;d send as
an event.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-resources"><a class="anchor" href="#context-functionality-resources"></a>1.15.3. Convenient access to low-level resources</h4>
<div class="paragraph">
<p>For optimal usage and understanding of application contexts, users should generally
familiarize themselves with Spring&#8217;s <code>Resource</code> abstraction, as described in the chapter
<a href="#resources">Resources</a>.</p>
</div>
<div class="paragraph">
<p>An application context is a <code>ResourceLoader</code>, which can be used to load <code>Resource</code>s. A
<code>Resource</code> is essentially a more feature rich version of the JDK class <code>java.net.URL</code>,
in fact, the implementations of the <code>Resource</code> wrap an instance of <code>java.net.URL</code> where
appropriate. A <code>Resource</code> can obtain low-level resources from almost any location in a
transparent fashion, including from the classpath, a filesystem location, anywhere
describable with a standard URL, and some other variations. If the resource location
string is a simple path without any special prefixes, where those resources come from is
specific and appropriate to the actual application context type.</p>
</div>
<div class="paragraph">
<p>You can configure a bean deployed into the application context to implement the special
callback interface, <code>ResourceLoaderAware</code>, to be automatically called back at
initialization time with the application context itself passed in as the
<code>ResourceLoader</code>. You can also expose properties of type <code>Resource</code>, to be used to
access static resources; they will be injected into it like any other properties. You
can specify those <code>Resource</code> properties as simple String paths, and rely on a special
JavaBean <code>PropertyEditor</code> that is automatically registered by the context, to convert
those text strings to actual <code>Resource</code> objects when the bean is deployed.</p>
</div>
<div class="paragraph">
<p>The location path or paths supplied to an <code>ApplicationContext</code> constructor are actually
resource strings, and in simple form are treated appropriately to the specific context
implementation. <code>ClassPathXmlApplicationContext</code> treats a simple location path as a
classpath location. You can also use location paths (resource strings) with special
prefixes to force loading of definitions from the classpath or a URL, regardless of the
actual context type.</p>
</div>
</div>
<div class="sect3">
<h4 id="context-create"><a class="anchor" href="#context-create"></a>1.15.4. Convenient ApplicationContext instantiation for web applications</h4>
<div class="paragraph">
<p>You can create <code>ApplicationContext</code> instances declaratively by using, for example, a
<code>ContextLoader</code>. Of course you can also create <code>ApplicationContext</code> instances
programmatically by using one of the <code>ApplicationContext</code> implementations.</p>
</div>
<div class="paragraph">
<p>You can register an <code>ApplicationContext</code> using the <code>ContextLoaderListener</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context-param&gt;</span>
        <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
        <span class="tag">&lt;param-value&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="tag">&lt;/param-value&gt;</span>
<span class="tag">&lt;/context-param&gt;</span>

<span class="tag">&lt;listener&gt;</span>
        <span class="tag">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/listener-class&gt;</span>
<span class="tag">&lt;/listener&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The listener inspects the <code>contextConfigLocation</code> parameter. If the parameter does not
exist, the listener uses <code>/WEB-INF/applicationContext.xml</code> as a default. When the
parameter <em>does</em> exist, the listener separates the String by using predefined
delimiters (comma, semicolon and whitespace) and uses the values as locations where
application contexts will be searched. Ant-style path patterns are supported as well.
Examples are <code>/WEB-INF/*Context.xml</code> for all files with names ending with "Context.xml",
residing in the "WEB-INF" directory, and <code>/WEB-INF/**/*Context.xml</code>, for all such files
in any subdirectory of "WEB-INF".</p>
</div>
</div>
<div class="sect3">
<h4 id="context-deploy-rar"><a class="anchor" href="#context-deploy-rar"></a>1.15.5. Deploying a Spring ApplicationContext as a Java EE RAR file</h4>
<div class="paragraph">
<p>It is possible to deploy a Spring ApplicationContext as a RAR file, encapsulating the
context and all of its required bean classes and library JARs in a Java EE RAR deployment
unit. This is the equivalent of bootstrapping a standalone ApplicationContext, just hosted
in Java EE environment, being able to access the Java EE servers facilities. RAR deployment
is more natural alternative to scenario of deploying a headless WAR file, in effect, a WAR
file without any HTTP entry points that is used only for bootstrapping a Spring
ApplicationContext in a Java EE environment.</p>
</div>
<div class="paragraph">
<p>RAR deployment is ideal for application contexts that do not need HTTP entry points but
rather consist only of message endpoints and scheduled jobs. Beans in such a context can
use application server resources such as the JTA transaction manager and JNDI-bound JDBC
DataSources and JMS ConnectionFactory instances, and may also register with the
platform&#8217;s JMX server - all through Spring&#8217;s standard transaction management and JNDI
and JMX support facilities. Application components can also interact with the
application server&#8217;s JCA WorkManager through Spring&#8217;s <code>TaskExecutor</code> abstraction.</p>
</div>
<div class="paragraph">
<p>Check out the javadoc of the
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a>
class for the configuration details involved in RAR deployment.</p>
</div>
<div class="paragraph">
<p><em>For a simple deployment of a Spring ApplicationContext as a Java EE RAR file:</em> package
all application classes into a RAR file, which is a standard JAR file with a different
file extension. Add all required library JARs into the root of the RAR archive. Add a
"META-INF/ra.xml" deployment descriptor (as shown in <code>SpringContextResourceAdapter</code>s
javadoc) and the corresponding Spring XML bean definition file(s) (typically
"META-INF/applicationContext.xml"), and drop the resulting RAR file into your
application server&#8217;s deployment directory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Such RAR deployment units are usually self-contained; they do not expose components to
the outside world, not even to other modules of the same application. Interaction with a
RAR-based ApplicationContext usually occurs through JMS destinations that it shares with
other modules. A RAR-based ApplicationContext may also, for example, schedule some jobs,
reacting to new files in the file system (or the like). If it needs to allow synchronous
access from the outside, it could for example export RMI endpoints, which of course may
be used by other application modules on the same machine.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-beanfactory"><a class="anchor" href="#beans-beanfactory"></a>1.16. The BeanFactory</h3>
<div class="paragraph">
<p>The <code>BeanFactory</code> provides the underlying basis for Spring&#8217;s IoC functionality but it is
only used directly in integration with other third-party frameworks and is now largely
historical in nature for most users of Spring. The <code>BeanFactory</code> and related interfaces,
such as <code>BeanFactoryAware</code>, <code>InitializingBean</code>, <code>DisposableBean</code>, are still present in
Spring for the purposes of backward compatibility with the large number of third-party
frameworks that integrate with Spring. Often third-party components that can not use
more modern equivalents such as <code>@PostConstruct</code> or <code>@PreDestroy</code> in order to remain
compatible with JDK 1.4 or to avoid a dependency on JSR-250.</p>
</div>
<div class="paragraph">
<p>This section provides additional background into the differences between the
<code>BeanFactory</code> and <code>ApplicationContext</code> and how one might access the IoC container
directly through a classic singleton lookup.</p>
</div>
<div class="sect3">
<h4 id="context-introduction-ctx-vs-beanfactory"><a class="anchor" href="#context-introduction-ctx-vs-beanfactory"></a>1.16.1. BeanFactory or ApplicationContext?</h4>
<div class="paragraph">
<p>Use an <code>ApplicationContext</code> unless you have a good reason for not doing so.</p>
</div>
<div class="paragraph">
<p>Because the <code>ApplicationContext</code> includes all functionality of the <code>BeanFactory</code>, it is
generally recommended over the <code>BeanFactory</code>, except for a few situations such as in
embedded applications running on resource-constrained devices where memory consumption
might be critical and a few extra kilobytes might make a difference. However, for
most typical enterprise applications and systems, the <code>ApplicationContext</code> is what you
will want to use. Spring makes <em>heavy</em> use of the <a href="#beans-factory-extension-bpp"><code>BeanPostProcessor</code> extension point</a> (to effect proxying and so on). If you use only a
plain <code>BeanFactory</code>, a fair amount of support such as transactions and AOP will not take
effect, at least not without some extra steps on your part. This situation could be
confusing because nothing is actually wrong with the configuration.</p>
</div>
<div class="paragraph">
<p>The following table lists features provided by the <code>BeanFactory</code> and
<code>ApplicationContext</code> interfaces and implementations.</p>
</div>
<table id="context-introduction-ctx-vs-beanfactory-feature-matrix" class="tableblock frame-all grid-all spread">
<caption class="title">Table 9. Feature Matrix</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top"><code>BeanFactory</code></th>
<th class="tableblock halign-left valign-top"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bean instantiation/wiring</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanFactoryPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convenient <code>MessageSource</code> access (for i18n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEvent</code> publication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>To explicitly register a bean post-processor with a <code>BeanFactory</code> implementation,
you need to write code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();
<span class="comment">// populate the factory with bean definitions</span>

<span class="comment">// now register any needed BeanPostProcessor instances</span>
MyBeanPostProcessor postProcessor = <span class="keyword">new</span> MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

<span class="comment">// now start using the factory</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To explicitly register a <code>BeanFactoryPostProcessor</code> when using a <code>BeanFactory</code>
implementation, you must write code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(<span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// bring in some property values from a Properties file</span>
PropertyPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertyPlaceholderConfigurer();
cfg.setLocation(<span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc.properties</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// now actually do the replacement</span>
cfg.postProcessBeanFactory(factory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases, the explicit registration step is inconvenient, which is one reason why
the various <code>ApplicationContext</code> implementations are preferred above plain <code>BeanFactory</code>
implementations in the vast majority of Spring-backed applications, especially when
using <code>BeanFactoryPostProcessor</code>s and <code>BeanPostProcessor</code>s. These mechanisms implement
important functionality such as property placeholder replacement and AOP.</p>
</div>
</div>
</div>
</div>
</div>