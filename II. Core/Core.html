<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Core Technologies</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" /><style>article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]) {display:none;height:0}[hidden],template{display:none}script{display:none!important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root) {overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}meta.foundation-mq-small{font-family:"only screen and (min-width: 768px)";width:768px}meta.foundation-mq-medium{font-family:"only screen and (min-width:1280px)";width:1280px}meta.foundation-mq-large{font-family:"only screen and (min-width:1440px)";width:1440px}*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html,body{font-size:100%}body{background:#fff;color:#34302d;padding:0;margin:0;font-family:"Varela Round",sans-serif;font-weight:normal;font-style:normal;line-height:1;position:relative;cursor:auto}a:hover{cursor:pointer}img,object,embed{max-width:100%;height:auto}object,embed{height:100%}img{-ms-interpolation-mode:bicubic}#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}.left{float:left!important}.right{float:right!important}.text-left{text-align:left!important}.text-right{text-align:right!important}.text-center{text-align:center!important}.text-justify{text-align:justify!important}.hide{display:none}.antialiased{-webkit-font-smoothing:antialiased}img{display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px}select{width:100%}object,svg{display:inline-block;vertical-align:middle}.center{margin-left:auto;margin-right:auto}.spread{width:100%}p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#0b0a0a;font-weight:normal;margin-top:0;margin-bottom:.25em}div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}a{color:#548e2e;text-decoration:underline;line-height:inherit}a:hover,a:focus{color:#487a28}a img{border:none}p{font-family:inherit;font-weight:normal;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}p aside{font-size:.875em;line-height:1.35;font-style:italic}h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:Montserrat,sans-serif;font-weight:400;font-style:normal;color:#34302d;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#867c74;line-height:0}h1{font-size:2.125em}h2{font-size:1.6875em}h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}h4{font-size:1.125em}h5{font-size:1.125em}h6{font-size:1em}hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}em,i{font-style:italic;line-height:inherit}strong,b{font-weight:bold;line-height:inherit}small{font-size:60%;line-height:inherit}code{font-family:Monaco,Menlo,Consolas,"Courier New",monospace;font-weight:normal;color:rgba(0,0,0,.9)}ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}ul,ol{margin-left:1.5em}ul.no-bullet,ol.no-bullet{margin-left:1.5em}ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}ul.square{list-style-type:square}ul.circle{list-style-type:circle}ul.disc{list-style-type:disc}ul.no-bullet{list-style:none}ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}dl dt{margin-bottom:.3125em;font-weight:bold}dl dd{margin-bottom:1.25em}abbr,acronym{text-transform:uppercase;font-size:90%;color:#34302d;border-bottom:1px dotted #ddd;cursor:help}abbr{text-transform:none}blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}blockquote cite:before{content:"\2014 \0020"}blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}.vcard{display:inline-block;margin:0 0 1.25em 0;border:1px solid #ddd;padding:.625em .75em}.vcard li{margin:0;display:block}.vcard .fn{font-weight:bold;font-size:.9375em}.vevent .summary{font-weight:bold}.vevent abbr{cursor:auto;text-decoration:none;font-weight:bold;border:none;padding:0 .0625em}@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}h1{font-size:2.75em}h2{font-size:2.3125em}h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}table thead,table tfoot{background:#f7f8f7;font-weight:bold}table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:#34302d;text-align:left}table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:#34302d}table tr.even, table tr.alt, table tr:nth-of-type(even) {background:#f8f8f7}table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}body{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;tab-size:4}h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}.clearfix:after,.float-group:after{clear:both}*:not(pre) > code {font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}*:not(pre) > code.nobreak {word-wrap:normal}*:not(pre) > code.nowrap {white-space:nowrap}pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:Monaco,Menlo,Consolas,"Courier New",monospace;font-weight:normal;text-rendering:optimizeSpeed}em em{font-style:normal}strong strong{font-weight:normal}.keyseq{color:#6b625c}kbd{font-family:Monaco,Menlo,Consolas,"Courier New",monospace;display:inline-block;color:#34302d;font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2) , 0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2) , 0 0 0 .1em white inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}.keyseq kbd:first-child{margin-left:0}.keyseq kbd:last-child{margin-right:0}.menuseq,.menu{color:#191715}b.button:before,b.button:after{position:relative;top:-1px;font-weight:normal}b.button:before{content:"[";padding:0 3px 0 2px}b.button:after{content:"]";padding:0 2px 0 3px}p a>code:hover{color:rgba(0,0,0,.9)}#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom: 1;position:relative;padding-left:.9375em;padding-right:.9375em}#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}#header:after,#content:after,#footnotes:after,#footer:after{clear:both}#content{margin-top:1.25em}#content:before{content:none}#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) {border-bottom:1px solid #ddddd8;padding-bottom:8px}#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}#header .details span:first-child{margin-left:-.125em}#header .details span.email a{color:rgba(0,0,0,.85)}#header .details br{display:none}#header .details br+span:before{content:"\00a0\2013\00a0"}#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}#header .details br+span#revremark:before{content:"\00a0|\00a0"}#header #revnumber{text-transform:capitalize}#header #revnumber:after{content:"\00a0"}#content > h1:first-child:not([class]) {color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}#toc>ul{margin-left:.125em}#toc ul.sectlevel0>li>a{font-style:italic}#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}#toc ul{font-family:Montserrat,sans-serif;list-style-type:none}#toc li{line-height:1.3334;margin-top:.3334em}#toc a{text-decoration:none}#toc a:active{text-decoration:underline}#toctitle{color:#0b0a0a;font-size:1.2em}@media only screen and (min-width:768px){#toctitle{font-size:1.375em}body.toc2{padding-left:15em;padding-right:0}#toc.toc2{margin-top:0!important;background-color:#f1f1f1;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}#toc.toc2>ul{font-size:.9em;margin-bottom:0}#toc.toc2 ul ul{margin-left:0;padding-left:1em}#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}body.toc2.toc-right{padding-left:0;padding-right:15em}body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}#toc.toc2{width:20em}#toc.toc2 #toctitle{font-size:1.375em}#toc.toc2>ul{font-size:.95em}#toc.toc2 ul ul{padding-left:1.25em}body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#d7d7d7;margin-bottom:1.25em;padding:1.25em;background:#f1f1f1;-webkit-border-radius:4px;border-radius:4px}#content #toc>:first-child{margin-top:0}#content #toc>:last-child{margin-bottom:0}#footer{max-width:100%;background-color:#34302d;padding:1.25em}#footer-text{color:#cbcfd2;line-height:1.44}.sect1{padding-bottom:.625em}@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:normal}#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#34302d;text-decoration:none}#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#262321}.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Varela Round",sans-serif;font-size:1rem;font-style:italic}table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}.admonitionblock>table td.icon{text-align:center;width:80px}.admonitionblock>table td.icon img{max-width:initial}.admonitionblock>table td.icon .title{font-weight:bold;font-family:Montserrat,sans-serif;text-transform:uppercase}.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}.exampleblock>.content>:first-child{margin-top:0}.exampleblock>.content>:last-child{margin-bottom:0}.sidebarblock{border-style:solid;border-width:1px;border-color:#d7d7d7;margin-bottom:1.25em;padding:1.25em;background:#f1f1f1;-webkit-border-radius:4px;border-radius:4px}.sidebarblock>:first-child{margin-top:0}.sidebarblock>:last-child{margin-bottom:0}.sidebarblock>.content>.title{color:#0b0a0a;margin-top:0;text-align:center}.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint {background:#f5f5f5}.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint {background:#f2f1f1}.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{border:1px solid #ddd;-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f5f5f5;background-color:rgba(0,0,0,.9)}.listingblock pre.highlightjs{padding:0}.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}.listingblock>.content{position:relative}.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}.listingblock:hover code[data-lang]:before{display:block}.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}.listingblock.terminal pre .command:not([data-prompt]):before {content:"$"}table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}table.pyhltable td.code{padding-left:.75em;padding-right:0}pre.pygments .lineno, table.pyhltable td:not(.code) {color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}pre.pygments .lineno{display:inline-block;margin-right:.25em}table.pyhltable .linenodiv{background:none!important;padding-right:0!important}.quoteblock{margin:0 1em 1.25em 1.5em;display:table}.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}.quoteblock blockquote{margin:0;padding:0;border:0}.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#0b0a0a;text-shadow:0 1px 2px rgba(0,0,0,.1)}.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}.quoteblock .quoteblock blockquote:before{display:none}.verseblock{margin:0 1em 1.25em 1em}.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}.verseblock pre strong{font-weight:400}.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}.quoteblock .attribution br,.verseblock .attribution br{display:none}.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}.quoteblock.abstract{margin:0 0 1.25em 0;display:block}.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}table.tableblock{max-width:100%;border-collapse:separate}table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}table.frame-all{border-width:1px}table.frame-sides{border-width:0 1px}table.frame-topbot{border-width:1px 0}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}table thead th,table tfoot th{font-weight:bold}tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:#34302d;font-weight:bold}p.tableblock>code:only-child{background:none;padding:0}p.tableblock{font-size:1em}td>div.verse{white-space:pre}ol{margin-left:1.75em}ul li ol{margin-left:1.5em}dl dd{margin-left:1.125em}dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}ul.inline>li>*{display:block}.unstyled dl dt{font-weight:normal;font-style:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.hdlist>table,.colist>table{border:0;background:none}.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}td.hdlist1{font-weight:bold;padding-bottom:1.25em}.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}.colist>table tr>td:first-of-type img{max-width:initial}.colist>table tr>td:last-of-type{padding:.25em 0}.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}.imageblock>.title{margin-bottom:0}.imageblock.thumb,.imageblock.th{border-width:6px}.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}.image.left{margin-right:.625em}.image.right{margin-left:.625em}a.image{text-decoration:none;display:inline-block}a.image object{pointer-events:none}sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}sup.footnote a,sup.footnoteref a{text-decoration:none}sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}#footnotes .footnote:last-of-type{margin-bottom:0}#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}.gist .file-data>table td.line-data{width:99%}div.unbreakable{page-break-inside:avoid}.big{font-size:larger}.small{font-size:smaller}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa}.black{color:#000}.black-background{background-color:#000}.blue{color:#0000bf}.blue-background{background-color:#0000fa}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa}.gray{color:#606060}.gray-background{background-color:#7d7d7d}.green{color:#006000}.green-background{background-color:#007d00}.lime{color:#00bf00}.lime-background{background-color:#00fa00}.maroon{color:#600000}.maroon-background{background-color:#7d0000}.navy{color:#000060}.navy-background{background-color:#00007d}.olive{color:#606000}.olive-background{background-color:#7d7d00}.purple{color:#600060}.purple-background{background-color:#7d007d}.red{color:#bf0000}.red-background{background-color:#fa0000}.silver{color:#909090}.silver-background{background-color:#bcbcbc}.teal{color:#006060}.teal-background{background-color:#007d7d}.white{color:#bfbfbf}.white-background{background-color:#fafafa}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00}span.icon>.fa{cursor:default}.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#3f6a22}.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}.conum[data-value]{display:inline-block;color:#fff!important;background-color:#34302d;-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}.conum[data-value] *{color:#fff!important}.conum[data-value]+b{display:none}.conum[data-value]:after{content:attr(data-value)}pre .conum[data-value]{position:relative;top:-.125em}b.conum *{color:inherit!important}.conum:not([data-value]):empty {display:none}.admonitionblock{border-left:4px solid #6db33f;background-color:#ebf1e7;padding:1.2em 0;margin:30px 0;width:auto}#toc a:hover{text-decoration:underline}.admonitionblock>table{margin-bottom:0}.admonitionblock>table td.content{border-left:none}</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 .5em 0 .25em}.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}table.CodeRay td{vertical-align:top;line-height:1.45}table.CodeRay td.line-numbers{text-align:right}table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}table.CodeRay td.code{padding:0 0 0 .5em}table.CodeRay td.code>pre{padding:0}.CodeRay .debug{color:#fff!important;background:navy!important}.CodeRay .annotation{color:#007}.CodeRay .attribute-name{color:navy}.CodeRay .attribute-value{color:#700}.CodeRay .binary{color:#509}.CodeRay .comment{color:#998;font-style:italic}.CodeRay .char{color:#04d}.CodeRay .char .content{color:#04d}.CodeRay .char .delimiter{color:#039}.CodeRay .class{color:#458;font-weight:bold}.CodeRay .complex{color:#a08}.CodeRay .constant,.CodeRay .predefined-constant{color:teal}.CodeRay .color{color:#099}.CodeRay .class-variable{color:#369}.CodeRay .decorator{color:#b0b}.CodeRay .definition{color:#099}.CodeRay .delimiter{color:#000}.CodeRay .doc{color:#970}.CodeRay .doctype{color:#34b}.CodeRay .doc-string{color:#d42}.CodeRay .escape{color:#666}.CodeRay .entity{color:#800}.CodeRay .error{color:#808}.CodeRay .exception{color:inherit}.CodeRay .filename{color:#099}.CodeRay .function{color:#900;font-weight:bold}.CodeRay .global-variable{color:teal}.CodeRay .hex{color:#058}.CodeRay .integer,.CodeRay .float{color:#099}.CodeRay .include{color:#555}.CodeRay .inline{color:#000}.CodeRay .inline .inline{background:#ccc}.CodeRay .inline .inline .inline{background:#bbb}.CodeRay .inline .inline-delimiter{color:#d14}.CodeRay .inline-delimiter{color:#d14}.CodeRay .important{color:#555;font-weight:bold}.CodeRay .interpreted{color:#b2b}.CodeRay .instance-variable{color:teal}.CodeRay .label{color:#970}.CodeRay .local-variable{color:#963}.CodeRay .octal{color:#40e}.CodeRay .predefined{color:#369}.CodeRay .preprocessor{color:#579}.CodeRay .pseudo-class{color:#555}.CodeRay .directive{font-weight:bold}.CodeRay .type{font-weight:bold}.CodeRay .predefined-type{color:inherit}.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}.CodeRay .key{color:#808}.CodeRay .key .delimiter{color:#606}.CodeRay .key .char{color:#80f}.CodeRay .value{color:#088}.CodeRay .regexp .delimiter{color:#808}.CodeRay .regexp .content{color:#808}.CodeRay .regexp .modifier{color:#808}.CodeRay .regexp .char{color:#d14}.CodeRay .regexp .function{color:#404;font-weight:bold}.CodeRay .string{color:#d20}.CodeRay .string .string .string{background:#ffd0d0}.CodeRay .string .content{color:#d14}.CodeRay .string .char{color:#d14}.CodeRay .string .delimiter{color:#d14}.CodeRay .shell{color:#d14}.CodeRay .shell .delimiter{color:#d14}.CodeRay .symbol{color:#990073}.CodeRay .symbol .content{color:#a60}.CodeRay .symbol .delimiter{color:#630}.CodeRay .tag{color:teal}.CodeRay .tag-special{color:#d70}.CodeRay .variable{color:#036}.CodeRay .insert{background:#afa}.CodeRay .delete{background:#faa}.CodeRay .change{color:#aaf;background:#007}.CodeRay .head{color:#f8f;background:#505}.CodeRay .insert .insert{color:#080}.CodeRay .delete .delete{color:#800}.CodeRay .change .change{color:#66f}.CodeRay .head .head{color:#f4f}</style>
</head>
<body id="spring-core" class="book toc2 toc-left">
<div id="header">
<h1>核心技术</h1>
<div class="details">
<span id="revnumber">version 5.0.0.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#beans">1. IoC容器</a>
<ul class="sectlevel2">
<li><a href="#beans-introduction">1.1. Spring IoC 容器和 beans 介绍</a></li>
<li><a href="#beans-basics">1.2. 容器概述</a></li>
<li><a href="#beans-definition">1.3. Bean 概述</a></li>
<li><a href="#beans-dependencies">1.4. 依赖</a></li>
<li><a href="#beans-factory-scopes">1.5. Bean 的作用域</a></li>
<li><a href="#beans-factory-nature">1.6. 自定义 bean 的特性</a></li>
<li><a href="#beans-child-bean-definitions">1.7. Bean 定义的继承</a></li>
<li><a href="#beans-factory-extension">1.8. 容器的扩展点</a></li>
<li><a href="#beans-annotation-config">1.9. 基于注解的容器配置</a></li>
<li><a href="#beans-classpath-scanning">1.10. 类路径扫描和管理组件</a></li>
<li><a href="#beans-standard-annotations">1.11. 使用 JSR 330 标准注解</a></li>
<li><a href="#beans-java">1.12. 基于 Java 的容器配置</a></li>
<li><a href="#beans-environment">1.13. 环境抽象</a></li>
<li><a href="#context-load-time-weaver">1.14. 注册 LoadTimeWeaver</a></li>
<li><a href="#context-introduction">1.15. ApplicationContext 的其他作用</a></li>
<li><a href="#beans-beanfactory">1.16. BeanFactory</a></li>
</ul>
</li>
<li><a href="#resources">2. 资源</a>
<ul class="sectlevel2">
<li><a href="#resources-introduction">2.1. 简介</a></li>
<li><a href="#resources-resource">2.2. 资源接口</a></li>
<li><a href="#resources-implementations">2.3. 内置的资源实现</a></li>
<li><a href="#resources-resourceloader">2.4. ResourceLoader 接口</a></li>
<li><a href="#resources-resourceloaderaware">2.5. ResourceLoaderAware 接口</a></li>
<li><a href="#resources-as-dependencies">2.6. 资源依赖</a></li>
<li><a href="#resources-app-ctx">2.7. 应用上下文和资源路径</a></li>
</ul>
</li>
<li><a href="#validation">3. 验证、数据绑定和类型转换</a>
<ul class="sectlevel2">
<li><a href="#validation-introduction">3.1. 简介</a></li>
<li><a href="#validator">3.2. 使用 Spring 对的Validator 接口来进行数据验证</a></li>
<li><a href="#validation-conversion">3.3. 解析代码到对应错误信息</a></li>
<li><a href="#beans-beans">3.4. Bean 操作和 BeanWrapper</a></li>
<li><a href="#core-convert">3.5. Spring 类型转换</a></li>
<li><a href="#format">3.6. Spring 字段格式化</a></li>
<li><a href="#format-configuring-formatting-globaldatetimeformat">3.7. 配置全局日期和时间格式</a></li>
<li><a href="#validation-beanvalidation">3.8. Spring 验证</a></li>
</ul>
</li>
<li><a href="#expressions">4. Spring 表达式语言 (SpEL)</a>
<ul class="sectlevel2">
<li><a href="#expressions-intro">4.1. 简介</a></li>
<li><a href="#expressions-features">4.2. 功能概述</a></li>
<li><a href="#expressions-evaluation">4.3. 使用 Spring 表达式接口进行表达式运算</a></li>
<li><a href="#expressions-beandef">4.4. bean 定义的表达式支持</a></li>
<li><a href="#expressions-language-ref">4.5. 语言引用</a></li>
<li><a href="#expressions-example-classes">4.6. 例子用用到的类</a></li>
</ul>
</li>
<li><a href="#aop">5. 使用 Spring 进行面向切面编程</a>
<ul class="sectlevel2">
<li><a href="#aop-introduction">5.1. 接见</a></li>
<li><a href="#aop-ataspectj">5.2. @AspectJ 支持</a></li>
<li><a href="#aop-schema">5.3. 基于 Schema 的 AOP 支持</a></li>
<li><a href="#aop-choosing">5.4. 选择使用哪种 AOP 声明样式</a></li>
<li><a href="#aop-mixing-styles">5.5. 混合切面类型</a></li>
<li><a href="#aop-proxying">5.6. 代理机制</a></li>
<li><a href="#aop-aspectj-programmatic">5.7. 编程创建 @AspectJ 代理</a></li>
<li><a href="#aop-using-aspectj">5.8. 在 Spring 应用中使用 AspectJ</a></li>
<li><a href="#aop-resources">5.9. 更多资源</a></li>
</ul>
</li>
<li><a href="#aop-api">6. Spring AOP APIs</a>
<ul class="sectlevel2">
<li><a href="#aop-api-introduction">6.1. 简介</a></li>
<li><a href="#aop-api-pointcuts">6.2. Spring 中的切点（Pointcut） API</a></li>
<li><a href="#aop-api-advice">6.3. Spring 中的通知（Advice） API</a></li>
<li><a href="#aop-api-advisor">6.4. Spring 中的通知者（Advisor） 的 API</a></li>
<li><a href="#aop-pfb">6.5. 使用 ProxyFactoryBean 创建 AOP 代理</a></li>
<li><a href="#aop-concise-proxy">6.6. 精简的代理定义</a></li>
<li><a href="#aop-prog">6.7. 使用 ProxyFactory 编程创建爱你 AOP 代理</a></li>
<li><a href="#aop-api-advised">6.8. 操作被通知对象</a></li>
<li><a href="#aop-autoproxy">6.9. 使用自动代理（"auto-proxy"）功能</a></li>
<li><a href="#aop-targetsource">6.10. 使用 TargetSources</a></li>
<li><a href="#aop-extensibility">6.11. 定义新的通知（Advice）类型 </a></li>
<li><a href="#aop-api-resources">6.12. 耕作资源</a></li>
</ul>
</li>
<li><a href="#null-safety">7. Null 安全（NPE空指针异常）</a>
<ul class="sectlevel2">
<li><a href="#use-cases">7.1. 使用用例</a></li>
<li><a href="#jsr-305-meta-annotations">7.2. JSR 305 元注解</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>参考文档的这个部分的涵盖了 Spring 框架中所有最重要的技术。</p>
</div>
<div class="paragraph">
<p>这其中重中之重是 Spring 框架的控制反转（IoC）容器。对 Spring 框架的 IoC 容器的彻底处理表现在紧随其后的 Spring 的面向切面编程（AOP）技术的全面覆盖。Spring 框架有它自己的 AOP 框架，它在概念上很容易理解，而且它在 Java 企业级开发中成功的以最佳方式解决了80%的 AOP 需求点。</p>
</div>
<div class="paragraph">
<p>它还提供了Spring 集成 AspectJ (目前在Java企业开发届最丰富的 - 从功能的角度 - 当然也是最成熟的 AOP 实现) 的覆盖。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans"><a class="anchor" href="#beans"></a>1. IoC 容器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="beans-introduction"><a class="anchor" href="#beans-introduction"></a>1.1. Spring IoC 容器和 beans 介绍</h3>
<div class="paragraph">
<p>本章涵盖了所有控制反转（IoC）<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>原则的 Spring 框架实现。IoC 也被称为
<em>依赖注入</em>（DI）。这是对象定义它们依赖关系的一个过程，即，与它们一起运作的其他对象，只有通过构造器参数、传递参数给工厂方法，或者在对象实例构造完成或工厂方法返回对象实例之后才能设置对象属性。然后当创建bean时，容器再将那些依赖对象<em>注入</em> 进去。 这个过程从根本上颠倒了bean本身通过使用类的直接构建或者通过一种机制例如<em>服务定位</em> 模式来控制依赖对象的实例化或定位，因此叫做<em>控制反转</em>（IoC）。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring 框架 IoC 容器的基础。
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a>
接口提供了一种能管理任何类型对象的高级配置机制。
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>
是 <code>BeanFactory</code> 的一个子接口。 它更容易与以下功能集成：Spring 的AOP功能；消息资源处理（用于国际化）；事件发布；应用层特定上下文如 <code>WebApplicationContext</code> 在Web应用中的使用。</p>
</div>
<div class="paragraph">
<p>总之， <code>BeanFactory</code> 提供了配置框架和基本功能， <code>ApplicationContext</code> 添加了更多企业级专用功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个全面超集, 在本章专门用来叙述 Spring 的 IoC 容器。想要了解更多有关用 <code>BeanFactory</code> 代替 <code>ApplicationContext</code> 的信息，请参考<a href="#beans-beanfactory">The BeanFactory</a>。</p>
</div>
<div class="paragraph">
<p>在 Spring 中，构成应用程序主干并由 Spring IoC <em>容器</em> 管理的对象称为 <em>beans</em>。Bean 是由 Spring IoC 容器实例化、组装或者管理的对象。否则，bean 仅仅只是应用程序中许多对象中的一个。Beans 和它们之间的<em>依赖</em> 关系都反映在容器使用的<em>配置元数据</em> 中了。</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-basics"><a class="anchor" href="#beans-basics"></a>1.2. 容器概述</h3>
<div class="paragraph">
<p> <code>org.springframework.context.ApplicationContext</code> 接口代表了 Spring IoC 容器并且负责初始化，配置，装配上述的 beans。容器通过读取配置元数据获取关于实例化、配置和装配的操作指南。配置元数据以XML, Java注解，或者Java代码的形式表示。它展示了组成你的应用程序的对象和这些对象之间丰富的相互依赖关系。</p>
</div>
<div class="paragraph">
<p> Spring 提供了几个开箱即用的 <code>ApplicationContext</code> 接口的实现。在独立的应用程序中，常见的做法是创建 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a>
或者 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"><code>FileSystemXmlApplicationContext</code></a> 接口的实例。考虑到XML已经成为定义配置元数据的传统文件格式，你可以引导容器使用Java注解或者以元数据格式呈现的代码，这是通过提供少量用于声明对这些额外元数据格式支持的XML配置来实现的。</p>
</div>
<div class="paragraph">
<p>在大多数应用场景中，不需要显式用户代码来实例化一个或多个 Spring IoC 容器。举个例子，在一个web应用场景中，一个含有八行（左右）的<code>web.xml</code>模板web描述XML文件就足够了（点击查看 <a href="#context-create">web应用的简单 ApplicationContext 实例化</a>）。如果你在 Eclipse 驱动的开发环境中使用<a href="https://spring.io/tools/sts">Spring 工具套装</a>，那么点几下鼠标或敲几下键盘就能很容易创建这个模板配置文件。</p>
</div>
<div class="paragraph">
<p>下图高度概括了 Spring 的工作原理。 应用程序中的类会跟配置元数据结合起来以便在 <code>ApplicationContext</code> 创建和初始化以后，你可以得到一个完全配置好而且可执行的系统或者应用。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/container-magic.png" alt="container magic">
</div>
<div class="title">Figure 1. Spring IoC 容器</div>
</div>
<div class="sect3">
<h4 id="beans-factory-metadata"><a class="anchor" href="#beans-factory-metadata"></a>1.2.1. 配置元数据</h4>
<div class="paragraph">
<p> 正如前图所示，Spring IoC 容器使用这样一种<em>配置元数据</em> 形式：此配置元数据展示了作为应用开发者，你是如何告诉 Spring 容器来实例化，配置和组装应用中的对象的。</p>
</div>
<div class="paragraph">
<p>配置元数据传统上使用既简单又直观的XML格式，本章大多数时候使用它来传递 pring IoC 容器核心概念和功能特点。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>基于XML的元数据并<em>不是</em> 唯一允许的配置元数据格式。Spring IoC 容器本身与配置元数据实际的编写格式是<em>完全</em> 解耦的。目前，许多开发者选择<a href="#beans-java">基于 Java 代码的配置</a> 为他们的 Spring 应用配置元数据。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关对 Spring 容器使用其他格式的元数据，请参见： </p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-annotation-config">基于注解的配置</a>: Spring 2.5 引入了对基于注解配置元数据的支持。</p>
</li>
<li>
<p><a href="#beans-java">基于Java 代码的配置</a>：从 Spring 3.0 开始，JavaConfig 项目提供的很多功能成为了 Spring 框架核心的一部分。因此你可以使用Java而不使用XML文件在你的应用程序类之外定义 beans。要使用这些新功能，请参见<code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code> 和 <code>@DependsOn</code> 注解。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring 配置由容器必须管理的至少一个且通常不止一个的bean定义组成。基于XML的配置元数据配置中展示了这些 beans 被配置为顶层的 <code>&lt;beans/&gt;</code> 标签中的<code>&lt;bean/&gt;</code> 元素。Java 配置往往在有<code>@Configuration</code> 注解的类中使用 <code>@Bean</code> 注解的方法来配置。</p>
</div>
<div class="paragraph">
<p>这些bean定义与构成你的应用程序的实际对象相对应。通常你会在其中定义服务层对象，数据访问对象（DAOs），视图对象如 Struts <code>Action</code> 实例，基础架构对象如 Hibernate
  <code>SessionFactories</code>, JMS <code>Queues</code>, 等等。 容器中通常不会配置细粒度的与对象，因为创建和加载域对象通常是 DAOs 和 业务逻辑的责任。 不过你可以使用集成了 AspectJ 的 Spring 来配置那些在 IoC 容器控制范围之外创建的对象。参见 <a href="#aop-atconfigurable">在 Spring 中使用 AspectJ 对域对象进行依赖注入</a>.</p>
</div>
<div class="paragraph">
<p>下例表示了基于XML的配置元数据的基本结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>属性 <code>id</code> 是用来标识唯一 bean 定义的字符串。
属性 <code>class</code>  定义 bean 的类型并且使用的是全限定类型。id 的值表示的是协作对象。在本例中没有展示用于引用协作对象的XML；更多相关信息参见<a href="#beans-dependencies">依赖</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-instantiation"><a class="anchor" href="#beans-factory-instantiation"></a>1.2.2. 容器的实例化</h4>
<div class="paragraph">
<p>Spring IoC 容器的实例化非常直截了当。向 <code>ApplicationContext</code> 构造器提供的某个定位路径或者多个路径实际上都是资源字符串，通过这些字符串，容器从各种外部资源--如本地文件系统，Java <code>CLASSPATH</code> 等等--加载配置元数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在你了解了Spring 的 IoC 容器之后，您可能想了解更多关于 Spring 的资源抽象的内容，正如在 <a href="#resources">资源</a> 里描述的，它提供了一种的从某种URI形式的地址中读取输入流的便捷机制。尤其是，<code>资源</code> 路径用于构建应用上下文，如在<a href="#resources-app-ctx">应用上下文和资源路径</a>描述的那样。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的例子表示的是服务层对象 <code>(services.xml)</code> 的配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- services --&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">petStore</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.services.PetStoreServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的例子表示的是数据访问对象 <code>daos.xml</code> 的配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.dao.jpa.JpaItemDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前一个例子中，服务层由 <code>PetStoreServiceImpl</code> 和两个 <code>JpaAccountDao</code> 和 <code>JpaItemDao</code> （基于 JPA 对象/关系映射标准）类型的数据访问对象组成。
 <code>property name</code> 元素指的是这个 JavaBean 的属性名，<code>ref</code> 元素指的是另一个 bean 定义的名字。在 <code>id</code> 和 <code>ref</code> 之间的这种联系表示的是协作对象之间的依赖关系。有关配置对象的依赖关系的详细信息，参见
<a href="#beans-dependencies">依赖</a>。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-xml-import"><a class="anchor" href="#beans-factory-xml-import"></a>基于XML的配置元数据文件的组合</h5>
<div class="paragraph">
<p>将 bean 定义分别放在在多个XML文件中是很有用的。通常每个单独的XML配置文件对应应用架构中的每一个逻辑层或者每一个模块。</p>
</div>
<div class="paragraph">
<p>你可以利用应用上下文构造器来加载来自所有这些XML片段中的 bean 定义。这个构造器接受多个 <code>资源</code> 地址，就像前一小节中展示的那样。或者，使用一个或多个 <code>&lt;import/&gt;</code> 元素来加载其他一个或多个文件中的 bean 定义。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">resources/messageSource.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/resources/themeSource.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，外部的 bean 定义从三个文件被加载进来:
<code>services.xml</code>，<code>messageSource.xml</code> 和 <code>themeSource.xml</code>。对于进行导入操作的定义文件来说，所有的地址路径都是相对路径，所以 <code>services.xml</code> 必须与做导入操作的文件放在同一个目录或者同一个类路径，而 <code>messageSource.xml</code> 和 <code>themeSource.xml</code> 必须放在做导入操作的文件地址的下层 <code>resource</code> 地址中。如您所见，最前面的斜杠可以忽略不写，不过鉴于这些都是相对路径，最好彻底抛弃使用这个斜杠。这些被导入文件的内容，包括最顶层的 <code>&lt;beans/&gt;</code> 元素，也必须满足 Spring Schema 的有效定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以使用相对路径 “../” 来引用父目录中的文件，不过我们不推荐这么做。这么做会创建当前应用之外的文件依赖关系。尤其是我们不推荐对 "classpath:" URLs （比如，"classpath:../services.xml"）使用这种引用，因为运行时解析过程会选择它最近的类路径根目录然后查看他的父目录。类路径配置的更改会导致解析过程中选择的目录是其他错误的目录。</p>
</div>
<div class="paragraph">
<p>你应该始终使用完全限定资源地址而不是相对路径：比如，"file:C:/config/services.xml" 或者 "classpath:/config/services.xml"。但是，请注意这么做会把你应用程序的配置和具体的绝对路径耦合起来。通常对于此类绝对路径，举个例子，我们会使用在JVM 系统运行时的属性解析的 "${&#8230;&#8203;}" 占位符，达到解耦的目的。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Import 导入指令是 beans 命名空间本身提供的一个功能。除了普通的 bean 定义，其他跟多配置功能定义在 Spring 提供的 “context” 和 “util” 命名空间中。</p>
</div>
</div>
<div class="sect4">
<h5 id="groovy-bean-definition-dsl"><a class="anchor" href="#groovy-bean-definition-dsl"></a>Groovy Bean 定义的 DSL</h5>
<div class="paragraph">
<p>再如对于外部配置元数据，bean 定义还可以通过 Spring 的 Groovy Bean 定义 DSL，这种方式在 Grails 框架中被大家熟知。通常，这样的配置将以如下结构存在于“.groovy”扩展名文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">beans {
    dataSource(BasicDataSource) {
        driverClassName = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.hsqldb.jdbcDriver</span><span class="delimiter">&quot;</span></span>
        url = <span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:hsqldb:mem:grailsDB</span><span class="delimiter">&quot;</span></span>
        username = <span class="string"><span class="delimiter">&quot;</span><span class="content">sa</span><span class="delimiter">&quot;</span></span>
        password = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>
        settings = [mynew:<span class="string"><span class="delimiter">&quot;</span><span class="content">setting</span><span class="delimiter">&quot;</span></span>]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean -&gt;
            dataSource = dataSource
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种配置风格基本上等同于XML bean 定义，它甚至还支持 Spring XML配置的命名空间。另外它也允许通过 “importBeans” 导入指令导入XML bean 定义文件。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-client"><a class="anchor" href="#beans-factory-client"></a>1.2.3. 容器的使用</h4>
<div class="paragraph">
<p><code>ApplicationContext</code> 是一个高级工厂接口，它维护不同的 beans 及其依赖的注册表。使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> 可以获取 bean 实例。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 能让你用以下方式读取 bean 定义及访问 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// create and configure beans</span>
ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// retrieve configured instance</span>
PetStoreService service = context.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">petStore</span><span class="delimiter">&quot;</span></span>, PetStoreService.class);

<span class="comment">// use configured instance</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; userList = service.getUsernameList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 Groovy 配置，引导过程看起来非常相似，只是上下文实现不同，它是 Groovy 感知的（但也能理解XML bean 定义）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.groovy</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.groovy</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>最灵活是与reader代理如相对于XML文件的<code>XmlBeanDefinitionReader</code> 结合起来的 <code>GenericApplicationContext</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();
<span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);
   context.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用 Groovy 文件对应的<code>GroovyBeanDefinitionReader</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();
<span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.groovy</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.groovy</span><span class="delimiter">&quot;</span></span>);
   context.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要的话，这些reader代理可以在同一个 <code>ApplicationContext</code> 中混合匹配，这样就可以从不同的配置源读取 bean 定义了。</p>
</div>
<div class="paragraph">
<p>然后你就可以使用 <code>getBean</code> 方法获取你的 bean 实例了。 <code>ApplicationContext</code> 接口还有其他几个获取 bean 实例的方法，但是在理想情况下，你的应用程序代码不应该使用它们。事实上，你的应用程序代码完全不应该调用 <code>getBean()</code> 方法，这样也就完全没有对 Spring API的依赖了。举个例子，Spring 与 web 框架的集成提供了对各种web框架组件如 controller 和 JSF 托管 bean 的依赖注入，允许你通过元数据（如：一个自动装配注解）声明对某一具体 bean 的依赖。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-definition"><a class="anchor" href="#beans-definition"></a>1.3. Bean 概述</h3>
<div class="paragraph">
<p>Spring IoC 容器管理一个或多个 <em>bean</em>。这些bean是由您提供给容器的配置元数据创建的。例如，以XML中
<code>&lt;bean/&gt;</code> 的形式定义。</p>
</div>
<div class="paragraph">
<p>在容器本身内部，这些 bean 的定义表现为 <code>BeanDefinition</code> 对象，它们包括（among other information）以下元数据：:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>包限定类名：</em> 一般是被定义 bean 的实际实现类的类名。</p>
</li>
<li>
<p>跟 bean 行为有关的配置元素，这些元素说明 bean 在容器中如何行事（作用域，生命周期回调等等）。</p>
</li>
<li>
<p> 对 bean 完成自身行为需要的其他 bean 的引用；这些引用也被称为 <em>写协作者</em> 或者 <em>依赖项</em>。</p>
</li>
<li>
<p>在新创建的对象中设置的其他配置设定，例如，在管理连接池的 bean 中使用的连接数，池的大小限制。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此元数据被转换为构成每个 bean 定义的以一组属性。</p>
</div>
<table id="beans-factory-bean-definition-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. The bean definition</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Explained in&#8230;&#8203;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">实例化 bean</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-beanname">bean 的命名</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">scope</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes">Bean 的作用域</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor arguments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">autowiring mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-autowire">自动装配协作者</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lazy-initialization mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lazy-init">懒加载的 bean</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">initialization method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-initializingbean">初始化回调</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">destruction method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-disposablebean">销毁回调</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了包含如何创建具体 bean 信息的 bean 定义， <code>ApplicationContext</code> 实现类们还允许注册用户在容器之外的地方创建的现存的 bean。这是通过调用 ApplicationContext BeanFactory 接口 <code>getBeanFactory()</code> 方法实现的， 这个方法会返回 BeanFactory 的实现类 <code>DefaultListableBeanFactory</code>。 <code>DefaultListableBeanFactory</code> 支持通过 <code>registerSingleton(..)</code> 和<code>registerBeanDefinition(..)</code> 注册bean。不过，典型的应用程序只使用通过元数据定义的 bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bean 元数据和手动提供的单例实例应该尽可能早地注册，以便容器在自动注入和其他内省步骤能恰当地使用它们。虽然在一定程度上支持对现有元数据和单例实例的覆盖，但在运行时（对工厂的并发调用）对新的 bean 的注册并没有被正式支持，因为这可能导致并发访问异常，和/或 bean 容器的状态不一致。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-beanname"><a class="anchor" href="#beans-beanname"></a>1.3.1. Bean 的命名</h4>
<div class="paragraph">
<p>每个 bean 有一个或多个标识符。这些标识符在 bean 的宿主容器内必须是唯一的。bean 通常只有一个标识符，但如果它需要多个标识符，那么那些其他标识符就会被视为别名。</p>
</div>
<div class="paragraph">
<p>在基于XML的配置元数据中，你可以使用 <code>id</code> 和/或 <code>name</code> 属性来指定 bean 的标识符。<code>id</code> 属性允许你唯一确定一个id。按照惯例，这些名字都是由字母数字（‘myBean’，‘fooService',等等）组成的，但是也有可嗯呢该包含特殊字符。如果你想对 bean 引入其他别名，也可以在 <code>name</code> 属性中指定它们，它们之间用逗号（<code>,</code>），分号（<code>;</code>），或者空格分隔。
 作为历史记录，在 Spring 3.1 版本之前，<code>id</code> 属性被定义成 <code>xsd:ID</code> 类型，它对组成id的字符作了限制。对于 3.1 版本，属性被定义成 <code>xsd:string</code> 类型。注意虽然 bean <code>id</code> 的唯一性不在被XML解析器强制要求，但容器依然强制要求它的唯一性。</p>
</div>
<div class="paragraph">
<p>为 bean 提供一个name或者id不是强制要求的。如果 bean 没有被显示提供name或者id，那么容器会为它生成一个唯一的名称。但是，如果你想要利用 <code>ref</code> 元素或者 <a href="#beans-servicelocator">服务定位器</a> 模式查询通过对名称查询来指向那个 bean，那么你必须向 bean 提供一个name。不向 bean 提供名称 的动机与使用 <a href="#beans-inner-beans"> 内部 bean</a> 和 <a href="#beans-factory-autowire">自动装配协作者</a> 相关，换句话说在使用 <a href="#beans-inner-beans"> 内部 bean</a> 和 <a href="#beans-factory-autowire">自动装配协作者</a> 的时候才会选择不向 bean 提供名称。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bean 的命名规范</div>
<div class="paragraph">
<p>这个规范就是在对 bean 命名时，采用标准 Java 规范对实例字段命名。即，bean 的名字以小写字母开头，之后采用驼峰式命名法。举几个这样的例子（不包括引号）<code>'accountManager'</code>，
  <code>'accountService'</code>， <code>'userDao'</code>，<code>'loginController'</code> 等等。</p>
</div>
<div class="paragraph">
<p>Bean 命名的一致性会使你的配置信息更易于阅读和理解，如果你用的是 Spring AOP，那么在对一组name相关的 bean 配置advice通知的时候一致性会有很大的帮助。（这里说的不是很清楚，个人理解是不是aop的时候方便些通配符对同一组name的bean拦截比较方便。或者说是否跟 Spring 操作bean的时候用到反射的比较方便。请大神补充。）</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 会在类路径组件扫描过程中根据上面的规则为未命名的组件生成 bean 的name：基本上是先取简单类名并将其首字母转换成小写。不过，在前两个都是大写字母的（不常见的）特殊情况下，将会保留原来的大小写格式。这些跟 <code>java.beans.Introspector.decapitalize</code> 定义的用了相同的规则（也就是 Spring 在这里用到的）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-beanname-alias"><a class="anchor" href="#beans-beanname-alias"></a>在 bean 定义之外添加 bean 的别名</h5>
<div class="paragraph">
<p>对 bean 定义本身来说，你可以给 bean 的 <code>id</code> 属性指定一个名称，给 <code>name</code> 属性指定多个名称，这样就为 bean 提供了多个名称。这些名称对着同一个 bean 来说都是等效的别名而且在某些情况下很有用，例如，允许应用程序中每个组件通过使用特定于该组件本身的 bean 名称来引用一个公共依赖项。（不是很明白这句话的意思。）</p>
</div>
<div class="paragraph">
<p>在 bean 实际定义的地方制定所有别名并不总是满足需求的。有时候也需要为在别处定义的 bean 引入别名。在大型系统中是很常见的，配置文件被分割开来放入每个子系统中，每个子系统拥有一套它自己的对象定义集。在基于XML的配置元数据中，你可以使用 <code>&lt;alias/&gt;</code>  元素来达到这个目的。/p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fromName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">toName</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，同一容器中被命名为 <code>fromName</code> 的 bean，在使用了别名定义之后，也可以用 <code>toName</code> 来代指。</p>
</div>
<div class="paragraph">
<p>例如，子系统A的配置元数据可以通过 <code>subsystemA-dataSource</code> 来指向DataSource。子系统B的配置元数据可以通过 <code>subsystemB-dataSource</code> 来指向DataSource。当组合使用这个两个子系统的主应用程序时，主程序可以通过 <code>myApp-dataSource</code> 来指向DataSource。要使者三个名称指向同一个对象，你应该在MyApp的配置元数据中添加如下别名定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemB-dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myApp-dataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样每个组件和主应用程序就能通过一个独一无二并且保证不会和其他定义（有效地创建一个命名空间）冲突的名称来指向dataSource，而且他们指向的是同一个 bean。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Java 配置</div>
<div class="paragraph">
<p>如果你使用的是 Java 配置，可以用 <code>@Bean</code> 注解来设置 bean 的别名，详情参见 <a href="#beans-java-bean-annotation">使用 @Bean 注解</a>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-class"><a class="anchor" href="#beans-factory-class"></a>1.3.2. 实例化 bean</h4>
<div class="paragraph">
<p>Bean 定义本质上其实就是创建对象的配方（蓝图）。容器在收到请求的时候会查找这个已经被命名的 bean 的蓝图，然后使用 bean 定义封装的配置元数据来创建（或者获取）这个 bean 对应的真正的对象实例。</p>
</div>
<div class="paragraph">
<p>如果你使用基于XML的配置元数据，则需要在 <code>&lt;bean/&gt;</code> 元素的 <code>class</code> 属性中指定需要被实例化的对象的具体类型（或者类）。这个 <code>class</code> 属性在 <code>BeanDefinition</code> 内部是一个 <code>Class</code> property，它通常是强制要求的
 （对于异常情况，请参见 <a href="#beans-factory-class-instance-factory-method">使用实例工厂方法实例化 bean</a> 和 <a href="#beans-child-bean-definitions">Bean 定义的继承</a>。）。
有两种方式使用 <code>Class</code> property：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常情况下，容器本身直接通过反射调用对应构造器来创建这个 bean 对象，这有点类似于在 Java 中使用 <code>new</code>  操作符来创建对象。</p>
</li>
<li>
<p>另一种少见的情况是，指定包含用于创建对象的 <code>静态</code> 工厂方法的实际类，容器会通过调用类的 <code>静态</code> <em>工厂</em> 方法来创建 bean。从 <code>静态</code> 工厂方法调用中返回的对象类型可能是同一个类或者完全不同的类。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<div class="title">内部类名称</div>
<p>如果你想在 bean 定义中配置一个 <code>静态</code> 嵌套类，你必须使用这个嵌套类的 <em>二进制</em> 类名。</p>
</div>
<div class="paragraph">
<p>例如，在 <code>com.example</code> 包下有个叫做 <code>Foo</code> 的类，并且这个 <code>Foo</code> 类有一个叫做  <code>Bar</code> 的 <code>静态</code> 嵌套类，那么这个 bean 定义的 <code>'class'</code>
属性值就应该是 &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><code>com.example.Foo$Bar</code></p>
</div>
<div class="paragraph">
<p>注意名称中的 <code>$</code> 字符将嵌套类名与外部类名分隔开。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-ctor"><a class="anchor" href="#beans-factory-class-ctor"></a>使用构造器实例化</h5>
<div class="paragraph">
<p>当你通过构造器创建 bean 时，所有正常类对 Spinrg 都是可用的，并且都与 Spring 兼容。也就是说，正在开发的类不需要实现任何特定的接口，也不需要以特定方式编码。只要指定 bean 的类就足够了。但是，因为它会依赖于你使用的 IoC 类型，所以你需要一个默认的（空）构造器。</p>
</div>
<div class="paragraph">
<p>Spring IoC 容器几乎可以管理你想让它管理的 <em>任何</em> 类；而不仅仅限于管理真正的 JavaBeans。大部分 Spring 用户更愿意为容器中的 JavaBeans 提供一个默认的（无参）构造器，和get、set方法。你还可以在容器中使用更多外来的非bean风格的类。例如，即使你需要使用一个完全不遵循 JavaBean 规范的遗留连接池，Spring 也能管理它。</p>
</div>
<div class="paragraph">
<p>你可以在基于XML的配置元数据中庸一下方式配置 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBeanTwo</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关给构造器提供参数（如有必要）和在对象构造完成之后设置对象实例属性的机制，参见 <a href="#beans-factory-collaborators">依赖注入</a>。</p>
  
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-static-factory-method"><a class="anchor" href="#beans-factory-class-static-factory-method"></a>使用静态工厂方法实例化</h5>
<div class="paragraph">
<p>在定义你用静态工厂方法创建的 bean 时，你可以使用 <code>class</code> 属性来指定包含 <code>静态</code> 工厂方法的类和用来配置工厂方法名称的名为 <code>factory-method</code> 的属性。你应该能够调用此方法（如稍后所述的可选参数）并且返回一个活动的对象，然后将它视为是通过构造器创建的对象。这种用法通常是为了在遗留代码中调用 <code>静态</code> 工厂。</p>
</div>
<div class="paragraph">
<p>下面的 bean 定义指明了这个 bean 会被工厂方法所创建。该定义没有指定返回对象的类型（类），只说明这个类包含这个工厂方法。在本例中，<code>createInstance()</code> 方法必须是一个 <em>静态</em> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ClientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ClientService</span> {
        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();
        <span class="directive">private</span> ClientService() {}

        <span class="directive">public</span> <span class="directive">static</span> ClientService createInstance() {
                <span class="keyword">return</span> clientService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于向工厂方法提供（可选）参数和在对象从工厂返回之后设置对象属性的机制，参见 <a href="#beans-factory-properties-detailed">依赖和配置的详情</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-instance-factory-method"><a class="anchor" href="#beans-factory-class-instance-factory-method"></a>使用实例工厂方法实例化</h5>
<div class="paragraph">
<p>与通过 <a href="#beans-factory-class-static-factory-method">静态工厂方法</a>实例化类似，实例工厂方法实例化从容器中调用已存在的 bean 的非静态方法来创建新的 bean。要使用这种机制，让 <code>class</code> 属性为空，对于 <code>factory-bean</code> 属性，配置某个当前（或者 父/祖先）容器中的 bean 的名称，改 bean 包含可以被调用来创建对象的实例方法。在 <code>factory-method</code> 属性中配置工厂方法本身的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.DefaultServiceLocator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createClientServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> {

        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();

        <span class="directive">public</span> ClientService createClientServiceInstance() {
                <span class="keyword">return</span> clientService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个工厂类也可以配置多个工厂方法，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.DefaultServiceLocator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createClientServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createAccountServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> {

        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();

        <span class="directive">private</span> <span class="directive">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();

        <span class="directive">public</span> ClientService createClientServiceInstance() {
                <span class="keyword">return</span> clientService;
        }

        <span class="directive">public</span> AccountService createAccountServiceInstance() {
                <span class="keyword">return</span> accountService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法表明，工厂 bean 本身可以通过依赖注入（DI）被管理和配置。 参见 <a href="#beans-factory-properties-detailed">依赖和配置的详情</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 Spring 文档中 <em> factory bean</em> 指的是在 Spring 容器中配置的 bean，该 bean 将会通过 <a href="#beans-factory-class-instance-factory-method">实例</a> 或者
  <a href="#beans-factory-class-static-factory-method">静态</a> 工厂方法创建对象。相比之下，<code>FactoryBean</code> （注意大小写）特指 Spring 的 <a href="#beans-factory-extension-factorybean"><code>FactoryBean</code> </a>。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-dependencies"><a class="anchor" href="#beans-dependencies"></a>1.4. 依赖</h3>
<div class="paragraph">
<p>典型的企业级应用程序不是由一个简单的对象（或者 Spring 属于中的 bean）组成的。即使是最简单的应用也会有几个对象协作，来将它作为一个连贯的应用程序呈现给终端用户。下一节讲解释如何从定义独立的 bean 到定义其对象可以相互协作已经实现某个目标的应用。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-collaborators"><a class="anchor" href="#beans-factory-collaborators"></a>1.4.1. 依赖注入</h4>
<div class="paragraph">
<p><em>依赖注入</em> (DI)  是对象定义它们依赖关系的一个过程，即，与它们一起运作的其他对象，只有通过构造器参数、传递参数给工厂方法，或者在对象实例构造完成或工厂方法返回对象实例之后才能设置对象属性。然后当创建bean时，容器再将那些依赖对象<em>注入</em> 进去。 这个过程从根本上颠倒了bean本身通过使用类的直接构建或者通过一种机制例如<em>服务定位</em> 模式来控制依赖对象的实例化或定位，因此叫做<em>控制反转</em>（IoC）。
</div>
<div class="paragraph">
<p>符合 DI 原则的代码会更简洁，且当我们知道对象之间的以依赖关系时，解耦也会更有效率。对象不会试图查询它的依赖项，也不知道依赖项的地址或者类。 因此，你的类会变得更容易测试，特别是当依赖项是接口或者抽象基类时你可以在单元测试中使用stub或者mock实现。</p>
</div>
<div class="paragraph">
<p>DI 存在两种形式，<a href="#beans-constructor-injection">基于构造器的依赖注入</a> 和 <a href="#beans-setter-injection">基于setter的依赖注入</a>。</p>
</div>
<div class="sect4">
<h5 id="beans-constructor-injection"><a class="anchor" href="#beans-constructor-injection"></a>基于构造器的依赖注入</h5>
<div class="paragraph">
<p><em>基于构造器</em> 的依赖注入是由容器调用一个带有多个参数的构造函数来完成的，每个参数代表一个依赖项。调用具有特定参数的 <code>静态</code> 工厂方法来构造 bean 与调用构造器几乎是一样的，这与对构造器参数和 <code>静态</code> 工厂方法的讨论差不多。下面的例子给出了一个只能通过构造器注入来实现依赖注入的类。注意这个类并没有什么 <em>特别之处</em>，它是一个不依赖与容器特定接口，基类或者注解的普通POJO。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span>
        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span>
        <span class="directive">public</span> SimpleMovieLister(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-ctor-arguments-resolution"><a class="anchor" href="#beans-factory-ctor-arguments-resolution"></a>构造器参数解析</h6>
<div class="paragraph">
<p>构造器使用参数类型的匹配来进行参数解析。如果 bean 定义的构造器参数中不存在潜在的歧义，那么 bean 定义中配置的构造器的参数顺序就是这个 bean 实例化的时候向它适配的构造器提供参数的顺序。
 考虑下面这个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">x.y</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">public</span> Foo(Bar bar, Baz baz) {
                <span class="comment">// ...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不存在潜在的歧义，假设 <code>Bar</code> 类和 <code>Baz</code> 类不存在继承关系。那么下面的配置没有问题，而且你不用在 <code>&lt;constructor-arg/&gt;</code> 元素中显式说明构造器的参数索引且/或类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当引用另一个 bean 时，类型是已知的，匹配正确（像前一个例子一样）。当使用简单类型比如 <code>&lt;value&gt;true&lt;/value&gt;</code>时，Spring 就确定不了这个值的类型了，因此也就无法匹配类型了。考虑下面的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">examples</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// Number of years to calculate the Ultimate Answer</span>
        <span class="directive">private</span> <span class="type">int</span> years;

        <span class="comment">// The Answer to Life, the Universe, and Everything</span>
        <span class="directive">private</span> <span class="predefined-type">String</span> ultimateAnswer;

        <span class="directive">public</span> ExampleBean(<span class="type">int</span> years, <span class="predefined-type">String</span> ultimateAnswer) {
                <span class="local-variable">this</span>.years = years;
                <span class="local-variable">this</span>.ultimateAnswer = ultimateAnswer;
        }
}</code></pre>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-type"></a>构造器参数类型匹配</div>
<div class="content">
<div class="paragraph">
<p>在前一个场景中，如果你用 <code>type</code> 属性显式指定了构造器参数的类型，容器就 <em>可以</em> 对简单类型进行类型匹配。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">int</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java.lang.String</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-index"></a>构造器参数索引</div>
<div class="content">
<div class="paragraph">
<p>使用 <code>index</code> 属性来显式指定构造器参数的索引。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了解决多个简单类型值的歧义性之外，指定索引还解决了构造器参数具有两个相同类型参数的歧义性。注意索引是从 0 开始的。</p>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-name"></a>构造器参数名称</div>
<div class="content">
<div class="paragraph">
<p>你还可以使用构造器形参来消除值的歧义性问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">years</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ultimateAnswer</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>记住为了让它顺利起作用，你的代码必须使用debug模式编译，以便 Spring 可以从构造器中查找形参名称。如果不能（或者不想）用debug模式编译，你可以使用 <a href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> JDK 注解来显式命名你的构造器参数。样例类如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">examples</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// Fields omitted</span>

        <span class="annotation">@ConstructorProperties</span>({<span class="string"><span class="delimiter">&quot;</span><span class="content">years</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">ultimateAnswer</span><span class="delimiter">&quot;</span></span>})
        <span class="directive">public</span> ExampleBean(<span class="type">int</span> years, <span class="predefined-type">String</span> ultimateAnswer) {
                <span class="local-variable">this</span>.years = years;
                <span class="local-variable">this</span>.ultimateAnswer = ultimateAnswer;
        }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-setter-injection"><a class="anchor" href="#beans-setter-injection"></a>基于 Setter 的依赖注入</h5>
<div class="paragraph">
<p><em>基于 Setter</em> 的依赖注入是在调用 bean 无参构造器或者无参 <code>静态</code> 工厂方法实例化之后，由容器调用 bean 的 setter 实现的。</p>
</div>
<div class="paragraph">
<p>下面的例子给出了一个只能通过纯 setter 注入来进行以依赖注入的类。这是个传统的 Java 类。它是一个不依赖与容器特定接口，基类或者注解的普通POJO。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span>
        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 对它管理的 bean 支持基于构造器的依赖注入和基于 setter 的依赖注入。它还支持在一些依赖已经通过构造器方式注入以后，再用基于 seter 的方式进行依赖注入。使用 <code>BeanDefinition</code> 形式进行依赖配置，结合 <code>PropertyEditor</code> 实例可以对属性的格式进行转换。不过，大多数 Spring 用户不直接操作这些类(比如，以编程方式)，而是使用XML的 <code>bean</code> 定义，组件注解（比如：使用了<code>@Component</code>，<code>@Controller</code> 等注解的类），或者对带有 <code>@Configuration</code> 注解的 Java 类使用 <code>@Bean</code> 方法。然后这些在内部转换为 <code>BeanDefinition</code> 的实例且被用来加载到整个 Spring IoC 容器实例。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">使用基于构造器的依赖注入还是基于 setter 的依赖注入？</div>
<div class="paragraph">
<p>由于你可以混合使用基于构造器的依赖注入还是基于 setter 的依赖注入，有经验的做法是将构造器用于配置 <em>强制依赖项</em>，将 setter 方法用于配置 <em>可选依赖项</em>。注入在 setter 方法使用 <a href="#beans-required-annotation">@Required</a> 注解会使得这个属性被检查是否注入的必要依赖项。</p>
</div>
<div class="paragraph">
<p>Spring 团队通常提倡使用构造器注入，因为它可以使得应用组件成为 <em>不可变对象</em>，且可以确保所需的依赖不为 <code>null</code>。而且基于构造器注入的组件总是会以一个已经完全初始化好的状态返回给客户端（调用）代码。附注，含有大量构造器参数的代码是一种很不好的代码风格，这意味着这个类可能包含太多的职责了，应该对它进行重构以更好进行职责分离。</p>
</div>
<div class="paragraph">
<p>如果对可选的依赖项提供合理的默认值，那么建议只采用基于 Setter 的注入。否则必须对每处使用依赖项的代码都必须进行非空检查。setter 注入的一个好处是 setter 方法使得类的对象实例很容易再配置或者再注入。<a href="integration.html#jmx">JMX MBeans</a> 的管理就是 setter 注入的一个极佳的例子。
</div>
<div class="paragraph">
<p>对具体类应该使用最适合它的依赖注入方式。有时候，当遇到没有源码的第三方类时，它已经为了做好了选择。例如，如果一个第三方类没有暴露任何 setter 方法，那么用构造器注入进行依赖注入就是你唯一的选择了。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-dependency-resolution"><a class="anchor" href="#beans-dependency-resolution"></a>依赖解析过程</h5>
<div class="paragraph">
<p>容器进行 bean 依赖解析的步骤如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根据描述所有 bean 的配置元数据创建并初始化 <code>ApplicationContext</code>。配置元数据可以是XML，Java 代码，或者注解。</p>
</li>
<li>
<p>对于每一个 bean，它的依赖项会以属性，构造器参数，或者静态工厂方法（如果你用静态工厂方法代替普通构造器）参数。这些依赖项会在 <em>bean 真正被创建的时候</em> 提供给 bean。</p>
</li>
<li>
<p>每一个属性或者构造器参数其实都是根据实际定义set的值或者是对容器中另一个 bean 的引用。</p>
</li>
<li>
<p>每一个属性或者构造器参数都会从它们的指定形式转换成那个属性或者构造器参数的实际类型。默认情况下，Spring
能将 string 类型的值转换为所有内建类型，比如 <code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code>，等等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring 容器被创建以后会验证每个 bean 的配置。不过 bean 的属性直到 bean <em>被真正创建</em> 才会被设置。那些被设置为需要预实例化（默认设置）的单例 bean  会在容器创建之后创建。作用域在 <a href="#beans-factory-scopes">Bean scopes</a> 中定义。否则，只有在被请求是 bean 才会被创建。bean 的创建可能会导致它的依赖项、他的依赖的依赖项（以此类推）创建和赋值。注意依赖关系之间的解析匹配错误可能会在之后出现，即，受影响的 bean 第一次创建的时候。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">循环依赖</div>
<div class="paragraph">
<p>如果你使用构造器注入，可能会出现无法处理的循环依赖的情况。</p>
</div>
<div class="paragraph">
<p>例如：类需要通过构造器注入B类的实例，B类需要通过构造器注入A类的实例。如果你为A类和B类相互注入对方的实例，Spring IoC 容器会在运行时检测到循环引用，然后抛出 <code>BeanCurrentlyInCreationException</code> 异常。</p>
</div>
<div class="paragraph">
<p>一个解决方案是修改某个类的源代码使其通过 setter 而不是构造器注入。或者，避免使用构造器注入，仅用 setter 注入。换句话说你可以用 setter 注入来处理循环依赖，虽然不推荐这么做。</p>
</div>
<div class="paragraph">
<p>与 <em>通常情况</em> （不含循环依赖）不同，bean A 和 bean B 之间的循环依赖迫使其中一个 bean 在完全初始化之前就注入到另一个 bean 中（经典的先有鸡还是先有蛋的问题）。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以信任 Spring 会正确解决这个问题。它会在加载时检测配置问题，如对不存在的 bean 的引用和循环依赖。Spring 会在 bean 被真正创建后尽可能晚地设置 bean 的属性和解析 bean 之间的依赖关系。这意味着对于已经正确加载的 Spring 容器，当你之后向容器请求一个对象时，如果创建这个对象或者它的至少一个依赖项出现问题，那么容器还是会抛出异常。例如，bean 可能会因为缺少属性值或者属性值无效而抛出异常。这个对某些配置问题潜在的延迟可见性问题正是为什么 <code>ApplicationContext</code> 默认实现单例 bean 预实例化的原因。在这些 bean 真正被需要之前，当 <code>ApplicationContext</code> 创建的时候会花费一些时间和内存使得你能够尽早发现配置问题，而不是在 bean 被请求之后。当然你仍然可以覆盖这个默认行为而把 bean 设置成懒加载模式而不是预实例化模式。</p>
</div>
<div class="paragraph">
<p>如果不存在循环依赖，那么当一个或多个协作 bean 被注入到依赖它们的 bean 时，每个协作 bean 都会在被注入之前 <em>完全</em> 配置好。这意味着如果 bean A 依赖 bean B，那么 Spring IoC 会在调用 bean A 的 setter 将 bean B 注入之前先将 bean B 完全配置好。换句话说，当一个 bean 完成实例化（如果不是一个预实例化模式的单例 bean），那么久说明它所有的依赖项都配设置好了，相关的生命周期方法（如 <a href="#beans-factory-lifecycle-initializingbean">配置初始化方法</a> 或者 <a href="#beans-factory-lifecycle-initializingbean">初始化 bean 回调方法</a>）也已经被调用了。
</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-some-examples"><a class="anchor" href="#beans-some-examples"></a>依赖注入举例</h5>
<div class="paragraph">
<p>下面的例子使用基于XML的配置元数据来配置基于 setter 的依赖注入。Spring XML 配置文件的其中一小部分详述了一些 bean 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>

        <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanTwo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">integerProperty</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">private</span> AnotherBean beanOne;

        <span class="directive">private</span> YetAnotherBean beanTwo;

        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">public</span> <span class="type">void</span> setBeanOne(AnotherBean beanOne) {
                <span class="local-variable">this</span>.beanOne = beanOne;
        }

        <span class="directive">public</span> <span class="type">void</span> setBeanTwo(YetAnotherBean beanTwo) {
                <span class="local-variable">this</span>.beanTwo = beanTwo;
        }

        <span class="directive">public</span> <span class="type">void</span> setIntegerProperty(<span class="type">int</span> i) {
                <span class="local-variable">this</span>.i = i;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面个的例子中，setter 方法声明与XML文件中具体指定的属性匹配。下面的例子使用基于构造器的依赖注入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span>
        <span class="tag">&lt;constructor-arg&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/constructor-arg&gt;</span>

        <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">int</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">private</span> AnotherBean beanOne;

        <span class="directive">private</span> YetAnotherBean beanTwo;

        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">public</span> ExampleBean(
                AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i) {
                <span class="local-variable">this</span>.beanOne = anotherBean;
                <span class="local-variable">this</span>.beanTwo = yetAnotherBean;
                <span class="local-variable">this</span>.i = i;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>bean 定义中指定的构造器参数会被作为 <code>ExampleBean</code> 构造器参数使用。</p>
</div>
<div class="paragraph">
<p>现在考虑这个例子的一个变形，Spring 被告知调用 <code>静态</code> 工厂方法而不使用构造器来返回这个对象实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createInstance</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// a private constructor</span>
        <span class="directive">private</span> ExampleBean(...) {
                ...
        }

        <span class="comment">// a static factory method; the arguments to this method can be</span>
        <span class="comment">// considered the dependencies of the bean that is returned,</span>
        <span class="comment">// regardless of how those arguments are actually used.</span>
        <span class="directive">public</span> <span class="directive">static</span> ExampleBean createInstance (
                AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i) {

                ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);
                <span class="comment">// some other operations...</span>
                <span class="keyword">return</span> eb;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>&lt;constructor-arg/&gt;</code> 元素向 <code>静态</code> 工厂方法提供参数，这与使用构造器注入配置一模一样。工厂方法返回的对象的类类型不必与包含此 <code>静态</code> 工厂方法的类类型一致，虽然在这个例子中它们是一样的。实例（非静态）工厂方法的使用本质上完全一样（除了使用 <code>factory-bean</code> 属性代替<code>class</code> 属性之外），所以其细节不在这里讨论了。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-properties-detailed"><a class="anchor" href="#beans-factory-properties-detailed"></a>1.4.2. 依赖和配置详情</h4>
<div class="paragraph">
<p>如前一节所述，你可以将 bean 的属性和构造器参数定义为对其他托管 bean （协作者）的引用，或者定义为内联值。为了实现这个功能，Spring 的基于XML的配置元数据在它的 <code>&lt;property/&gt;</code> 和 <code>&lt;constructor-arg/&gt;</code> 元素中支持子元素类型。</p>
</div>
<div class="sect4">
<h5 id="beans-value-element"><a class="anchor" href="#beans-value-element"></a>直接值（基本类型，String类型，等等）。</h5>
<div class="paragraph">
<p><code>&lt;property/&gt;</code> 元素的 <code>value</code> 属性指定了一个属性或构造器参数作为可读的字符串表示。Spring 的 <a href="#core-convert-ConversionService-API">转换服务</a> 将这些值从 <code>String</code> 转成属性或参数的真实类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">driverClassName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mysql.jdbc.Driver</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:mysql://localhost:3306/mydb</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">root</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterkaoli</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的例子为了更简洁的XML配置使用了<a href="#beans-p-namespace">p-namespace</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
        <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:driverClassName</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mysql.jdbc.Driver</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:url</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:mysql://localhost:3306/mydb</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:username</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">root</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:password</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterkaoli</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的XML更加简洁；不过，其中的拼写错误是在运行时发现而不是在编写设计的时候，除非你使用像<a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> 或者 <a href="https://spring.io/tools/sts">Spring Tool Suite</a> (STS) 这样在创建 bean 定义的时候有自动属性补全功能的IDE。我们非常推荐这样的IDE辅助功能。</p>
</div>
<div class="paragraph">
<p>你还可以这样配置 <code>java.util.Properties</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>
                        jdbc.driver.className=com.mysql.jdbc.Driver
                        jdbc.url=jdbc:mysql://localhost:3306/mydb
                <span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过 JavaBeans 的 <code>PropertyEditor</code> 机制将 <code>&lt;value/&gt;</code> 元素内的文本转换成 <code>java.util.Properties</code> 实例。这是个很好的快捷方式，也是为数不多的几个 Spring 团队更愿意使用嵌入的 <code>&lt;value/&gt;</code> 元素而不是 <code>value</code> 属性风格的地方。</p>
</div>
<div class="sect5">
<h6 id="beans-idref-element"><a class="anchor" href="#beans-idref-element"></a>idref 元素</h6>
<div class="paragraph">
<p><code>idref</code> 元素是在容器中将 <em>id</em> （字符串--不是引用）传递到 <code>&lt;constructor-arg/&gt;</code> 或者 <code>&lt;property/&gt;</code> 的一种简单的错误检测方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theClientBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetName</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;idref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的 bean 定义片段与下面的片段 <em>完全</em> 相等（在运行时）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">client</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第一种配置形式优于第二种，因为 <code>idref</code> 标签允许容器 <em>在部署阶段</em> 验证被引用的，被命名的 bean 是否真实存在。在第二种形式中，传递给 <code>client</code> bean 的 <code>targetName</code> 属性的值不会被验证。拼写错误只有当 <code>client</code> bean 真正实例化完成之后才会被发现（最可能的致命后果）。如果 <code>client</code> bean 是一个 <a href="#beans-factory-scopes">原型</a> bean，拼写错误和产生的异常可能只有在容器部署很长时间之后才会被发现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>idref</code> 元素的 <code>local</code> 属性在4.0 beans xsd 中不再被支持，因为它不再为 <code>bean</code> 引用提供值。当升级到 4.0 模式的时候，你可以轻松将 <code>idref local</code> 引用改成  <code>idref bean</code> 引用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ProxyFactoryBean</code> bean 定义中的 <a href="#aop-pfb-1">AOP 拦截器</a> 配置是 <code>&lt;idref/&gt;</code> 元素传递值常见的地方（至少在 Spring 2.0 以前的版本中）。在指定拦截器名字的时候使用 <code>&lt;idref/&gt;</code> 元素可以防止误拼写拦截器id。</p>
</div>
</div>
</div>
<div class="sect4">-/-/---
<h5 id="beans-ref-element"><a class="anchor" href="#beans-ref-element"></a>对其他 bean 的引用（协作者）</h5>
<div class="paragraph">
<p><code>ref</code> 元素是 <code>&lt;constructor-arg/&gt;</code> 或者 <code>&lt;property/&gt;</code>
定义元素的最终元素。在这个元素中，设置 bean 的指定属性值，值为对容器管理的另一个 bean （一个协作者）的引用。被引用 bean 是这个 bean 的一个依赖，这个 bean 的属性需要被设置，而且在属性设置之前会根据需要对其进行初始化。（如果协作者是一个单例 bean，它有可能已经被容器初始化。）所有引用最终都是对另一个对象的引用。作用域和验证功能取决于你是否通过对象的 <code>bean</code>, <code>local,</code> 或者 <code>parent</code> 属性指定它的 id/name。</p>
</div>
<div class="paragraph">
<p>通过 <code>&lt;ref/&gt;</code> 标签的 bean 属性指定目标 bean 是最普遍的形式，这允许你在统一容器或父容器中创建对任何 bean 的引用，不论它是否在同一个XML文件中。 <code>bean</code> 属性的值可能与目标 bean 的 <code>id</code> 属性相同，或者是目标 bean 的多个 <code>name</code> 属性之一。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>parent</code> 属性指定目标 bean 会创建一个对当前容器的父容器中 bean 的引用。 <code>parent</code> 属性的值可能与目标 bean 的 <code>id</code> 属性相同，或者与目标 bean 的多个 <code>name</code> 属性其中之一相同，且目标 bean 必须位于当前容器的父容器中。当你有多个层次划分的容器或者需要将某个父容器中已存在的 bean 包装成与它同名的代理 bean 的时候，可以使用此 bean 引用变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- in the parent context --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.SimpleAccountService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- in the child (descendant) context --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="error">&lt;</span><span class="error">!</span><span class="attribute-name">--</span> <span class="attribute-name">bean</span> <span class="attribute-name">name</span> <span class="attribute-name">is</span> <span class="attribute-name">the</span> <span class="attribute-name">same</span> <span class="attribute-name">as</span> <span class="attribute-name">the</span> <span class="attribute-name">parent</span> <span class="attribute-name">bean</span> <span class="attribute-name">--</span><span class="tag">&gt;</span>
        class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;<span class="error">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span> <span class="comment">&lt;!-- notice how we refer to the parent bean --&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ref</code> 元素的 <code>local</code> 属性在 4.0 beans xsd 中不再被支持，因为它在再为 <code>bean</code> 引用提供值。当升级到 4.0 模式的时候，你可以轻松将 <code>idref local</code> 引用改成  <code>idref bean</code> 引用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-inner-beans"><a class="anchor" href="#beans-inner-beans"></a>内部 bean</h5>
<div class="paragraph">
<p>在 <code>&lt;property/&gt;</code> 或者 <code>&lt;constructor-arg/&gt;</code> 元素中定义的 bean 称为 <em>内部 bean</em> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">outer</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Fiona Apple</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">25</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>内部 bean 定义不要求定义 id 或 name；即使指定了，容器也不会用它来作为标识符。容器也会在创建时忽略 <code>scope</code> 标志：内部 bean <em>总是</em> 匿名的，且 <em>总是 </em>由外部 bean 创建的。除了被注入到封闭的 bean 中或者单独访问它们，不可能将内部 bean 注入到协作 bean 中。</p>
</div>
<div class="paragraph">
<p>一种很少见到的情况是，有可能从自定义作用域中收到销毁回调方法，例如对于一个包含在单例 bean 中的 request 作用域内部 bean 来说：内部 bean 的创建过程会与包含它的 bean 绑定在一起，但销毁回调方法允许它参与到 request 域的生命周期中。这并不是一个常见的应用场景；内部 bean 的作用域通常跟包含它的 bean 作用域一样。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-collection-elements"><a class="anchor" href="#beans-collection-elements"></a>集合</h5>
<div class="paragraph">
<p>在<code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;props/&gt;</code> 元素中，分别对应设置 Java <code>Collection</code> 类型的 <code>List</code>, <code>Set</code>, <code>Map</code>, and <code>Properties</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">moreComplexObject</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ComplexObject</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;props&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">administrator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2b3b6bfbbbcbba1a6a0b3a6bda092b7aab3bfa2beb7fcbda0b5">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a7d4d2d7d7c8d5d3e7c2dfc6cad7cbc289c8d5c0">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d6b2b3a0b3bab9a6bbb3b8a296b3aeb7bba6bab3f8b9a4b1">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                <span class="tag">&lt;/props&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someList</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>a list element followed by a reference<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someMap</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;map&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">an entry</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">just some string</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> =<span class="string"><span class="delimiter">&quot;</span><span class="content">a ref</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/map&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someSet</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;value&gt;</span>just some string<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>map类型的key或者value，set类型的value值可以是以下元素的任意一种：</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">bean | ref | idref | list | set | map | props | value | null</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-merging"><a class="anchor" href="#beans-collection-elements-merging"></a>集合合并</h6>
<div class="paragraph">
<p>Spring 容器还支持集合的 <em>合并</em>。应用开发者可以定义父集合类型的 <code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code> 或 <code>&lt;props/&gt;</code> 元素，也可以定义能够继承和覆盖服集合元素值的子类型集合元素 <code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code> 或 <code>&lt;props/&gt;</code>。也就是说，子类型集合的值是合并父类型集合元素和子类型集合元素的结果，其中子类型集合元素覆盖父类型集合中指定的值。</p>
</div>
<div class="paragraph">
<p><em>关于合并的这节讨论了父-子 bean 的机制。对父-子 bean 定义不熟悉的读者在继续下面的学习之前可以去阅读 <a href="#beans-child-bean-definitions">相关章节</a>。</em></p>
</div>
<div class="paragraph">
<p>下面的例子展示了集合的合并：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ComplexObject</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;props&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">administrator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c2d28212522253f383e2d38233e0c29342d213c2029622f2321">administrator@example.com</a><span class="tag">&lt;/prop&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5f2c2a2f2f302d2b1f3a273e322f333a713c3032">support@example.com</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;/props&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">child</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span>
                        <span class="tag">&lt;props</span> <span class="attribute-name">merge</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sales</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2251434e475162475a434f524e470c414d4f">sales@example.com</a><span class="tag">&lt;/prop&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="295a5c5959465b5d694c51484459454c074a46075c42">support@example.co.uk</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;/props&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意 <code>child</code> bean 定义中 <code>adminEmails</code> 属性的 <code>&lt;props/&gt;</code> 元素使用了 <code>merge=true</code> 属性。当容器解析并实例化 <code>child</code> bean 的时候，由此产生的实例包含一个 <code>adminEmails</code> <code>Properties</code> 集合，这个集合是 child <code>adminEmails</code> 集合和 parent <code>adminEmails</code> 集合合并的结果。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</pre>
</div>
</div>
<div class="paragraph">
<p>child <code>Properties</code> 集合中的值继承了parent <code>&lt;props/&gt;</code> 的所有 property 元素，而 child 的 <code>support</code> 值覆盖了 parent 集合中的值。</p>
</div>
<div class="paragraph">
<p><code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>，和 <code>&lt;set/&gt;</code>集合类型中的合并与上面类似。对于特定的 <code>&lt;list/&gt;</code> 元素，语义与 <code>List</code> 集合类型相关，即，保留集合的<code>有序性</code>；父集合的值先于子集合中的所有值。对于 <code>Map</code>, <code>Set</code>，和 <code>Properties</code> 集合类型，不存在有序性。因此，对于容器内部使用的与 <code>Map</code>, <code>Set</code>，和 <code>Properties</code> 实现相关的集合类型，排序语义是无效的。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-merge-limitations"><a class="anchor" href="#beans-collection-merge-limitations"></a>集合合并的局限性</h6>
<div class="paragraph">
<p>不能合并不同的集合类型（如 <code>Map</code> 和 <code>List</code>），如果你视图这么做，那么程序将会抛出相应的 <code>异常</code>。<code>merge</code> 属性必须在更低级别的，继承的，自定义中指定；在父集合定义中指定 <code>merge</code> 属性是冗余的，而且不会进行你想要的合并。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-strongly-typed"><a class="anchor" href="#beans-collection-elements-strongly-typed"></a>强类型集合</h6>
<div class="paragraph">
<p>随着 Java 5 中泛型的引入，你可以使用强类型集合。也就是说，你可以声明一个只能包含 <code>String</code> 元素（举个例子）的 <code>Collection</code> 类型。如果你使用 Spring 的依赖注入将强类型 <code>Collection</code> 注入到 bean 中，你可以利用 Spring 的类型转换支持，在将元素添加在 <code>Collection</code> 之前，将强类型 <code>Collection</code> 实例转换为适当的类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Float</span>&gt; accounts;

        <span class="directive">public</span> <span class="type">void</span> setAccounts(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Float</span>&gt; accounts) {
                <span class="local-variable">this</span>.accounts = accounts;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accounts</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;map&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">9.99</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2.75</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">six</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.99</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;/map&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>foo</code> bean 的 <code>accounts</code> 属性准备注入时，可以通过反射获得强类型 <code>Map&lt;String, Float&gt;</code> 的元素类型信息。这样 Spring 的类型转换底层模块就能将各种不同的值元素识别为 <code>Float</code> 类型，将字符串值 <code>9.99, 2.75</code>，和 <code>3.99</code> 转换成真正的 <code>Float</code> 类型。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-null-element"><a class="anchor" href="#beans-null-element"></a>Null和空字符串值</h5>
<div class="paragraph">
<p>Spring 将属性的空参数都处理为空字符串（empty <code>Strings</code>）。下面基于XML的配置元数据片段将电子邮件属性设置为空字符串 <code>String</code> 值（""）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的例子与下面的Java代码是等价的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;null/&gt;</code> 元素处理 <code>null</code> 值。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;null</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的配置与下面的Java代码等价：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail(<span class="predefined-constant">null</span>)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-p-namespace"><a class="anchor" href="#beans-p-namespace"></a>使用 p-namespace 的XML简化配置</h5>
<div class="paragraph">
<p>p-namespace 可以让你 <code>bean</code> 元素的属性而不是嵌套 <code>&lt;property/&gt;</code> 元素来描述属性值和/或协作 bean。</p>
</div>
<div class="paragraph">
<p>Spring 支持含有 <a href="appendix.html#xsd-configuration">命名空间</a> 的扩展配置，命名空间是基于XML Schema 定义的。本章讨论的 <code>beans</code> 配置形势是在XML Schema 文件中定义的。但是 p-namespace 不在XSD文件中定义而只存在于 Spring core 中。</p>
</div>
<div class="paragraph">
<p>下面的例子给出了两个解析结果相同的XML片段：第一个使用标准XML形势，第二个使用了 p-namespace。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classic</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo@bar.com</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">p-namespace</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.ExampleBean</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:email</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo@bar.com</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子显示在 bean 定义中p-namespace 中有个一个叫 email 的属性。这会告知 Spring 包含一个 property 声明。如前面所述，p-namespace 没有 schema 定义，因此你可以将特性值名（attribute）设到属性值（property）上。</p>
</div>
<div class="paragraph">
<p>下面的例子包括两个 bean 定义，它们都引用了另一个 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">john-classic</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">John Doe</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">spouse</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">john-modern</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">John Doe</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:spouse-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Jane Doe</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所见，这个例子不仅包含使用 p-namespace 的属性值，还使用了一种特殊形式来声明属性值引用。第一个 bean 定义使用 <code>&lt;property name="spouse" ref="jane"/&gt;</code> 来创建从 bean <code>john</code> 到 bean <code>jane</code> 的引用，而第二个 bean 定义将 <code>p:spouse-ref="jane"</code> 作为一个特性值使用来定义从 bean <code>john</code> 到 bean <code>jane</code> 的引用。在这个例子中，<code>spouse</code> 是属性名，而 <code>-ref</code> 部分表示这不是一个直接值而是一个对其他 bean 的引用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>p-namespace 不像标准XML形式那么灵活。例如，声明属性引用的形式会与以 <code>Ref</code> 结尾的属性冲突，而标准XML形式并不会。我们建议你谨慎选择使用哪种形式并及时与你的团队沟通，以避免输出同时使用三种配置形式的XML文档。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-c-namespace"><a class="anchor" href="#beans-c-namespace"></a>使用 c-namespace 的XML简化配置</h5>
<div class="paragraph">
<p>与 <a href="#beans-p-namespace">使用 p-namespace 的XML简化配置</a>类似，<em>c-namespace</em> 在 Spring 3.1中被引入，它允许使用内联属性配置构造器参数而不是嵌套的 <code>constructor-arg</code> 元素。</p>
</div>
<div class="paragraph">
<p>回顾一下 <a href="#beans-constructor-injection">基于构造器的依赖注入</a> 中使用的 <code>c:</code> 命名空间：/p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:c</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/c</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- traditional declaration --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="62040d0d220003104c010d0f">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- c-namespace declaration --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:bar-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:baz-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:email</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82e4ededc2e0e3f0ace1edef">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c:</code> 命名空间使用与 <code>p:</code> 命名空间相同的协议，通过名字（如果是 bean 引用添加 <code>-ref</code> 后缀）设置构造器参数。同样，它也需要被声明，虽然它不在XSD Schema 中定义（但是存在于 Spring core 中）。</p>
</div>
<div class="paragraph">
<p>对于无法使用构造函数参数名称的罕见情况（通常如果字节码编译没有调试信息），可以降级使用参数索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:_0-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:_1-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于XML语法的要求，索引前面需要加上 <code>_</code> 下划线前缀，因为XML是属性名不能以数字开头（即使某些IDE允许）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在实践中，构造器解析 <a href="#beans-factory-ctor-arguments-resolution">机制</a> 在匹配参数方面非常高效，所以如无必要，我们建议在所有配置中都使用名称符号。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-compound-property-names"><a class="anchor" href="#beans-compound-property-names"></a>复合属性名</h5>
<div class="paragraph">
<p>当设置 bean 属性时，你可以使用复合或者嵌套的属性名，只要路径中除了最后的属性名所有其他部分都不为 <code>null</code>。考虑以下 bean 定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fred.bob.sammy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p> <code>foo</code> bean 有一个 <code>fred</code> 属性， <code>fred</code> 有一个 <code>bob</code>属性， <code>bob</code> 属性有一个 <code>sammy</code> 属性，最后的 <code>sammy</code> 属性设置值为 <code>123</code>。为了成功这样配置，<code>foo</code> 的 <code>fred</code> 属性和 <code>fred</code> 的 <code>bob</code> 属性在 bean 创建之后必须是非 <code>null</code> 的，否则会抛出 <code>NullPointerException</code> 异常。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-dependson"><a class="anchor" href="#beans-factory-dependson"></a>1.4.3. 使用 depends-on</h4>
<div class="paragraph">
<p>如果一个 bean 是另一个 bean 的依赖项，那么这通常意味着这个 bean 被设置为另一个 bean 的属性。通常使用基于XML的配置元数据的 <a href="#beans-ref-element"><code>&lt;ref/&gt;</code> 元素</a> 来实现。但有时 bean 之间的依赖是间接的；例如，类中的静态初始化程序需要被如数据库驱动注册这样的"bean"触发。<code>depends-on</code> 特性可以显式强制一个或多个 bean 在他的使用者 bean 初始化之前完成初始化。下面的例子使用 <code>depends-on</code> 特性表示对单个 bean 的依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ManagerBean</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了表示对多个 bean 的依赖关系，你需要提供一个 bean 名字列表作为 <code>depends-on</code> 特性的值，中间用逗号，空格或者分号隔开，作为有效的分隔符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager,accountDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ManagerBean</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.jdbc.JdbcAccountDao</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bean 定义中的 <code>depends-on</code> 特性既可以指定初始化时依赖也可以指定仅对 <a href="#beans-factory-scopes-singleton">单例</a> bean 有效的销毁时依赖。依赖 bean 定义了一个于给定 bean 之间 的 <code>depends-on</code> 关系，依赖 bean 会在给定 bean 销毁之前先行销毁。因此 <code>depends-on</code> 还可以控制shutdown的顺序。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-lazy-init"><a class="anchor" href="#beans-factory-lazy-init"></a>1.4.4. 懒加载 bean</h4>
<div class="paragraph">
<p>默认情况下，<code>ApplicationContext</code> 接口的各种实现以一种“饥渴”态度将所有 <a href="#beans-factory-scopes-singleton">单例</a> bean 作为初始化过程的一部分进行创建和配置。一般来说，这种预实例化是可取的，因为配置或者周围环境中的错误会被立即发现，而不是几小时后甚至几天后才发现。当这种行为 <em>不</em> 必要时，你可以通过将此单例 bean 定义标记为“懒加载”来防止它被预实例化。配置为懒加载的 bean 会告知 IoC 容器在第一次被请求是才创建对象，而不是在应用程序启动时。</p>
</div>
<div class="paragraph">
<p>在 XML 配置中，懒加载行为通过对 <code>&lt;bean/&gt;</code> 元素的 <code>lazy-init</code> 特性的控制来实现；例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lazy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.ExpensiveToCreateBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">lazy-init</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">not.lazy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>ApplicationContext</code> 读入上面的配置后，<code>ApplicationContext</code> 启动时名字为 <code>lazy</code> 的 bean 不会进行预实例化，而名字为 <code>not.lazy</code> 的 bean 就会进行预实例化。</p>
</div>
<div class="paragraph">
<p>不过，当一个懒加载 bean 是另一个 <em>非</em> 懒加载单例 bean 的依赖的时候，<code>ApplicationContext</code> 还是会在启动阶段创建此懒加载 bean，因为它必须满足成为这些单例 bean 依赖的要求。懒加载 bean 会被注入到在某处的其他非懒加载的单例 bean 中。</p>
</div>
<div class="paragraph">
<p>你也可以在容器级别使用 <code>&lt;beans/&gt;</code> 元素的 <code>default-lazy-init</code> 特性控制懒加载特性；例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-lazy-init</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-autowire"><a class="anchor" href="#beans-factory-autowire"></a>1.4.5. 自动装配协作者</h4>
<div class="paragraph">
<p>Spring 容器可以 <em>自动装配</em> 协作 bean 之间的关系。你可以允许 Spring 通过检查 <code>ApplicationContext</code> 的内容来为你的 bean 自动解析它的协作者（其他 bean）。自动装备具有以下优势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动装配可以显著减少需要指定的属性或者构造器参数。（其他机制例如 <a href="#beans-child-bean-definitions">本章其它地方</a> 讨论过的 bean 模板在这方面也很有价值。）</p>
</li>
<li>
<p>自动装配可以在对象变化时更新配置。例如，如果你需要增加一个类的依赖项，依赖项会满足自动装配需求而不需要你去修改配置。因此自动装配在开发阶段尤其有用，而且在基础代码更加稳定时可以切换为显式装配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在使用基于 XML 的配置元数据时<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup>，你可以通过 <code>&lt;bean/&gt;</code> 元素的 <code>autowire</code> 特性为一个 bean 定义指定自动装配模式。自动装配功能有四种模式。 你可以单独指定每个 bean 的自动装配模式且选择自动装配那些 bean。</p>
</div>
<table id="beans-factory-autowiring-modes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. 自动装配模式</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">模式</th>
<th class="tableblock halign-left valign-top">对应解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认） 不自动装配。Bean 引用必须通过 <code>ref</code> 元素来定义。更改默认配置不推荐用于较大的部署，因为显示指定协作者更易控制且更清晰。从某种程度上说，它记录了系统的结构。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过属性名称自动装配。Spring 寻找与需要自动装配的属性同名的 bean。例如，如果一个 bean 被设置为通过名称自动装配，且它有一个 <em>master</em> 属性（也就是说，它有一个 <em>setMaster(..)</em> 方法），Spring 会寻找名为 <code>master</code> 的 bean 定义，并用它来设置属性值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果容器中恰有一个某属性类型的 bean，那么就允许属性通过类型自动装配这个 bean。如果此类型的 bean 不止一个，那么就会抛出致命异常，说明你不能使用 <em>byType</em> 来自动装配那个 bean。如果没有匹配到 bean，则不会有任何错误产生；属性也不会被设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 <em>byType</em> 类似，但适用于构造器参数。如果容器中没有与此构造器参数匹配的 bean，就会抛出致命异常。 </p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用 <em>byType</em> 或者 <em>constructor</em> 自动装配模式，你可以装配数组和类型确定的集合。在这些情况下，容器内 <em>所有</em> 匹配期望类型的自动装配候选都会被提供以满足依赖性。如果期望的键类型是 <code>String</code>，你可以自动装配强类型的 Map。所有匹配期望类型的 Map 值组成所有 bean 实例，所有对应的 bean 名称组成这些 Map 的键。</p>
</div>
<div class="paragraph">
<p>你可以讲依赖检查与自动装配结合起来，依赖检查会在自动装配完成后进行。</p>
</div>
<div class="sect4">
<h5 id="beans-autowired-exceptions"><a class="anchor" href="#beans-autowired-exceptions"></a>自动装配的局限性的劣势</h5>
<div class="paragraph">
<p>当自动装配在整个工程中一致使用时其效果最好。如果普遍情况没有使用自动装配，仅仅在一两个 bean 定义中使用自动装配可能会让开发者感到困惑。</p>
</div>
<div class="paragraph">
<p>思考一下自动装配的局限性的劣势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>property</code> 和 <code>constructor-arg</code> 的显式设置总是会覆盖自动装配。 你不能自动装配所谓的  <em>简单</em> 属性如原子类型，<code>Strings</code>，和 <code>Classes</code>（以及这些简单类型的数组）。这是设计上的限制。</p>
</li>
<li>
<p>自动装配比显式装配更具有不确定性。如上表所述，尽管 Spring 可以小心地尽量避免对有可能导致无法预料结果的歧义性情况进行猜测，但 Spring 管理的对象之间的关系已经不再被显示的记录。</p>
</li>
<li>
<p>对于 Spring 容器中用于生成文档的工具来说，装配信息可能不能被获取。</p>
</li>
<li>
<p>容器中的多个 bean 定义可能会匹配 setter 方法或者构造器参数指定的需要自动装配的类型。对于数组，集合或者 Map 来说，这不一定是个问题。不过对于期望单个值的依赖项而言，这种歧义性并不能被随意消除。如果没有一个唯一 bean 被匹配到，那么将会抛出异常。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在后面的场景中，你有几个选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>抛弃自动装配而支持显式装配。</p>
</li>
<li>
<p>像下一节描述的那样通过设置 bean 定义的 <code>autowire-candidate</code> 特性为 <code>false</code> 来避免自动装配。</p>
</li>
<li>
<p>通过设置 <code>&lt;bean/&gt;</code> 元素的 <code>primary</code> 特性为 <code>true</code> 来指定某个 bean 定义为 <em>主</em> 候选 bean。</p>
</li>
<li>
<p>通过基于注解的配置来实现更多细粒度的控制，如 <a href="#beans-annotation-config">基于注解的容器配置</a> 中所描述的。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-autowire-candidate"><a class="anchor" href="#beans-factory-autowire-candidate"></a>将某个 bean 排除出自动装配</h5>
<div class="paragraph">
<p>基于对每个 bean 都操作的策略，你可以把某个 bean 排除出自动装配。在 Spring 的XML形式中，将 <code>&lt;bean/&gt;</code> 元素的 <code>autowire-candidate</code> 特性设置为 <code>false</code>；容器会使得此指定的 bean 定义对于自动装配基础模块不可用（包括注解风格的配置如 <a href="#beans-autowired-annotation"><code>@Autowired</code></a>）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>autowire-candidate</code> 特性被设计成只对基于类型的自动装配产生影响。它不会影响基于名称装配的显式引用。结果就是，基于名称的自动装配仍然会将名称匹配的 bean 注入进去。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你也可以根据 bean 名称的匹配模式限制自动装配的候选 bean。顶层 <code>&lt;beans/&gt;</code> 元素的 <code>default-autowire-candidates</code> 特性接受一个或多个模式。例如，为了限制任何以 <em>Repository</em> 结尾的自动装配候选 bean，可以提供一个 *Repository 值。对于多个模式，可以定义一个逗号为分隔符的列表。对 bean 定义的 <code>autowire-candidate</code> 特性显示设置的值 <code>true</code> 或者 <code>false</code> 优先级最高，对于这些 bean 来说，模式匹配规则不起作用。</p>
</div>
<div class="paragraph">
<p>对于那些你不想要通过自动装配注入到其它 bean 的 bean 来说，这些技术是很有用的。这不是说某个被排除的 bean 自身不能通过自动装配来进行配置。更确切地说，这个 bean 本身就不是一个为了自动装配到其它 bean 的候选 bean。
</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-method-injection"><a class="anchor" href="#beans-factory-method-injection"></a>1.4.6. 方法注入</h4>
<div class="paragraph">
<p>在大多数应用场景中，容器中大部分 bean 都是 <a href="#beans-factory-scopes-singleton">单例 bean</a>。当一个单例 bean 需要与其他单例 bean 协作时，或者当一个非单例 bean 需要与其他非单例 bean 协作时，你通常通过将一个 bean 定义为另一个 bean 的属性来达到这种依赖关系。但是当 bean 的生命周期不同时问题就出现了。假设单例 bean A 需要使用（可能 A 中每个方法的调用都会使用）非单例（原型） bean B。容器只会创建单例 bean A 一次，所以只有一次设置 A 的属性的机会。容器无法在每次需要的时候向 bean A 提供一个 bean B 的新实例。</p>
</div>
<div class="paragraph">
<p>这个问题的一种解决方案是放弃一些控制反转。你可以通过让 bean A 实现 <code>ApplicationContextAware</code> 接口使它能 <a href="#beans-factory-aware">感知容器</a>，然后当每次 bean A 需要 bean B 的时候通过 <a href="#beans-factory-client">对容器调用 getBean("B") 方法</a> 请求（通常是新得）bean B 的实例。下面是使用这个方法的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span>
<span class="keyword">package</span> <span class="namespace">fiona.apple</span>;

<span class="comment">// Spring-API imports</span>
<span class="keyword">import</span> <span class="include">org.springframework.beans.BeansException</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContextAware</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">CommandManager</span> <span class="directive">implements</span> ApplicationContextAware {

        <span class="directive">private</span> ApplicationContext applicationContext;

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Map</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="directive">protected</span> Command createCommand() {
                <span class="comment">// notice the Spring API dependency!</span>
                <span class="keyword">return</span> <span class="local-variable">this</span>.applicationContext.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">command</span><span class="delimiter">&quot;</span></span>, Command.class);
        }

        <span class="directive">public</span> <span class="type">void</span> setApplicationContext(
                        ApplicationContext applicationContext) <span class="directive">throws</span> BeansException {
                <span class="local-variable">this</span>.applicationContext = applicationContext;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的例子其实是不可取的，因为它将业务代码与 Spring 框架耦合起来了，并且业务代码能感知 Spring 框架。作为 Spring IoC 某种程度上的高级特性，方法注入就用了一种简洁的方式处理这个问题。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>你可以在 <a href="https://spring.io/blog/2004/08/06/method-injection/">这个博客</a> 中了解跟多关于犯法注入的动机。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lookup-method-injection"><a class="anchor" href="#beans-factory-lookup-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>查找方法注入是容器的一种覆盖 <em>其管理的 bean</em> 中的方法的能力，它可以返回容器中对另一个命名 bean 的查找结果。 查找通常会涉及原型 bean，如前一小节描述的场景中那样。Spring 框架通过使用 GBLIB 库实现这个方法注入，CGLIB 库的字节码生成功能会动态生成一个覆盖这个方法的子类。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>为了使这个动态子类正常工作，这个被 Spring bean 容器子类化的类不能是 <code>final</code> 的，且那些会被覆盖的方法也不能是 <code>final</code> 的。</p>
</li>
<li>
<p>对一个含有 <code>abstract</code> 方法的类进行单元测试，要求你对这个类进行子类化，并且还要提供这个 <code>abstract</code> 方法的 stub 实现。</p>
</li>
<li>
<p>对于要求获得具体类的组建扫描，具体方法也是必要的。</p>
</li>
<li>
<p>另一个关键限制是查找方法不适用于工厂方法，特别是不适用于配置类中的 <code>@Bean</code> 方法，因为容器并不负责在这种情况下创建实例，因此也不能在如此快速的过程中创建一个子在运行时生成的子类。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>看一下前一个代码片段中的 <code>CommandManager</code> 类，可以看到 Spring 容器会动态地覆盖 <code>createCommand()</code> 方法的实现。<code>CommandManager</code> 类将不会有任何 Spring 依赖，重写的例子如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">fiona.apple</span>;

<span class="comment">// no more Spring imports!</span>

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command interface</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="comment">// okay... but where is the implementation of this method?</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户类包含要被注入的方法（这个例子中是 <code>CommandManager</code>），将要被注入的方法需要以下格式的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;public</span><span class="error">|</span><span class="attribute-name">protected</span><span class="tag">&gt;</span> [abstract] <span class="tag">&lt;return-type&gt;</span> theMethodName(no-arguments);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这个方法是 <code>abstract</code>的，那么动态生成的子类会实现这个方法。否则，动态生成的子类会覆盖原始类中定义的具体方法。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fiona.apple.AsyncCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">commandManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fiona.apple.CommandManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;lookup-method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <em>commandManager</em> bean 在任何需要 <em>myCommand</em> bean 的实例时，它都会调用自己的 <code>createCommand()</code> 方法。如果确实需要的话，你必须仔细将 <code>myCommand</code> bean 作为原型 bean 来部署。如果它是作为 <a href="#beans-factory-scopes-singleton">原型</a> bean 部署的，那么每次都会返回同一个 <code>myCommand</code> 实例。</p>
</div>
<div class="paragraph">
<p>另一种选择，在基于注解的组件模型中，你可以通过 <code>@Lookup</code> 注解声明一个查找方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                Command command = createCommand();
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="annotation">@Lookup</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再或者，还有一种更地道的方式，你可以依靠被解析的目标 bean 的查找方法的声明返回类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                MyCommand command = createCommand();
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="annotation">@Lookup</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> MyCommand createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>需要注意的是对于使用注解的这些方法，你需要提供他们的基础实现，以便兼容 Spring 的组件扫描规则，因为 Spring 的组件扫描规则默认会忽略抽象类。不过对于显式注册或者显式导入的 bean 类没有这个限制。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>另一种可以访问不同作用域的目标 bean  是通过 <code>ObjectFactory</code>/<code>Provider</code> 注入点。查看 <a href="#beans-factory-scopes-other-injection">Scoped beans as dependencies</a>。</p>
</div>
<div class="paragraph">
<p>感兴趣的读者可能会发现 <code>ServiceLocatorFactoryBean</code> (在 <code>org.springframework.beans.factory.config</code> 包中) 使用的就是这种方法。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-arbitrary-method-replacement"><a class="anchor" href="#beans-factory-arbitrary-method-replacement"></a>任意方法替换</h5>
<div class="paragraph">
<p>对 bean 中任意方法替换的能力是另一种相比查找方法注入更少使用的方法注入形式，这种能力能将被管理 bean 的任意方法替换为另一个方法实现。用户可以安全跳过本小节剩余部分直到真正用到这个功能的时候再来看。</p>
</div>
<div class="paragraph">
<p>在基于XML的配置元数据中，对于一个已经部署的 bean，你可以使用 <code>replaced-method</code> 元素将现有的方法实现替换为其他方法实现。考虑下面的类，有一个我们想要覆盖的 computeValue 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyValueCalculator</span> {

        <span class="directive">public</span> <span class="predefined-type">String</span> computeValue(<span class="predefined-type">String</span> input) {
                <span class="comment">// some real code...</span>
        }

        <span class="comment">// some other methods...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现了 <code>org.springframework.beans.factory.support.MethodReplacer</code> 接口的类提供了一个新的方法定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ReplacementComputeValue</span> <span class="directive">implements</span> MethodReplacer {

        <span class="directive">public</span> <span class="predefined-type">Object</span> reimplement(<span class="predefined-type">Object</span> o, <span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// get the input value, work with it, and return a computed result</span>
                <span class="predefined-type">String</span> input = (<span class="predefined-type">String</span>) args[<span class="integer">0</span>];
                ...
                return ...;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>部署的原始类及其指定要覆盖的方法的 bean 定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myValueCalculator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.z.MyValueCalculator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span>
        <span class="tag">&lt;replaced-method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">computeValue</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">replacer</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replacementComputeValue</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;arg-type&gt;</span>String<span class="tag">&lt;/arg-type&gt;</span>
        <span class="tag">&lt;/replaced-method&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replacementComputeValue</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">a.b.c.ReplacementComputeValue</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在 <code>&lt;replaced-method/&gt;</code> 元素中使用一个或者多个 <code>&lt;arg-type/&gt;</code> 元素来区别需要覆盖的方法的方法签名。只有在类中进行了方法重载且有多个重载变形的时候，参数的签名才是必需的。方便起见，string类型的参数可能是全限定名的一个子串。例如，下面所有形式都能匹配 <code>java.lang.String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">java.lang.String
<span class="predefined-type">String</span>
Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为参数的数量经常已经足够区分每个可能的选择，这个允许给出匹配参数类型的最短字符串的快捷方式会让你少打很多字。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-scopes"><a class="anchor" href="#beans-factory-scopes"></a>1.5. Bean 的作用域</h3>
<div class="paragraph">
<p>当你创建一个 bean 定义，你就通过 bean 定义创建了一个用于创建类的真实实例的一个 <em>recipe</em>。把 bean 定义当做一个 recipe， 这个想法很重要，因为这意味着，对于同一个类，你可以从它的同一个 recipe 中创建许多对象实例。</p>
</div>
<div class="paragraph">
<p>你不仅可以控制要插入到对象种的各种依赖项和配置值，而且还能管理对象的 <em>作用域</em>，这里的对象都是由特定 bean 定义创建的。这个方法很强大而且很灵活，你可以用过配置文件 <em>选择</em> 你创建的这些对象的作用域，而不是在 Java 类级别的内置对象作用域。Bean 定义的时候，可以在多个作用域中选择一种，对它进行部署：Spring 框架支持6中开箱即用的作用域，其中5中当且仅当你使用能感知web的 <code>ApplicationContext</code> 时才可用。</p>
</div>
<div class="paragraph">
<p>下面的作用域是支持开箱即用的。你也可以创建 <a href="#beans-factory-scopes-custom">自定义作用域。</a></p>
</div>
<table id="beans-factory-scopes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Bean 作用域</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">作用域</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-singleton">singleton（单例）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认）对于每个 Spring IoC 容器，其中单个 bean 定义对应创建单个对应的单个对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-prototype">prototype（原型）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义可以创建任意个数个对应的对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-request">request（请求域）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为单个 HTTP 请求的生命周期；也就是说，每个 HTTP 请求都有属于它自己的根据 bean 定义创建的对象实例。只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-session">session（会话域）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为单个 HTTP 会话的生命周期；只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-application">application</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为<code>ServletContext</code> 的生命周期；只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#websocket-stomp-websocket-scope">websocket</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为<code>WebSocket</code> 的生命周期；只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 3.0 中可以用 <em>thread scope</em> ，但默认情况下没有注册。更多信息，请参看文档 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code>SimpleThreadScope</code></a>。关于如何注册 <em>thread scope</em> 或者任何其他自定义作用域的指南，参看 <a href="#beans-factory-scopes-custom-using">使用自定义作用域</a>。
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-singleton"><a class="anchor" href="#beans-factory-scopes-singleton"></a>1.5.1. singleton 单例作用域</h4>
<div class="paragraph">
<p>单例 bean 只管理一个 <em>共享</em> 实例，所有对 id 与 bean 定义匹配的 bean 的请求都会由 Spring 容器返回同一个特定的实例。</p>
</div>
<div class="paragraph">
<p>换言之，当你定一个了一个作用域为单例的 bean 定义时，Spring IoC 容器会根据 bean 定义创建一个 <em>唯一确定</em> 的对象实例。这个单独的实例会被存储在专门存放这些单例 bean 的缓存中，接下来对这个已命名 bean 的 <em>所有后续请求和应用</em> 都会返回缓存中的那个对象实例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/singleton.png" alt="singleton">
</div>
</div>
<div class="paragraph">
<p>Spring 中的单例 bean 概念不同于《设计模式》书中定义的单例模式。设计模式中的单例是对对象的作用域进行硬编码，这样每个类加载器 <em>只能创建一个</em> 特定类的实例。对 Spring 单例作用域最好的叙述是 <em>每个容器每个类</em>。意思就是如果你在一个 Spring 容器中为一个特定的类定义了一个 bean，Spring 就只会根据这个 bean 定义只创建这个类的唯一一个对象实例。<em>单例作用域是 Spring 的默认作用域</em>。想要在XML中定义一个单例 bean，你可以按照下面的例子编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-prototype"><a class="anchor" href="#beans-factory-scopes-prototype"></a>1.5.2. prototype 原型作用域</h4>
<div class="paragraph">
<p>对 bean 部署非单例的原型作用域会导致每次对特定 bean 的请求都会 <em>产生一个新的 bean 对象实例</em>。也就是说，这个 bean 会被注入到另一个 bean 中或者你通过调用容器得得 <code>getBean()</code> 方法来请求它。作为一种通用规则，通常原型作用域适用于所有有状态 bean，单例作用域适用于无状态 bean。</p>
</div>
<div class="paragraph">
<p>下图阐释了 Spring 的原型作用域。<em>数据访问对象（DAO）通常不会被配置为原型 bean，因为典型的 DAO 不会有任何会话状态；对这个作者来说单例 bean 图的核心的重用更容易。</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/prototype.png" alt="prototype">
</div>
</div>
<div class="paragraph">
<p>下面的例子在XML中定义了一个原型 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他作用域相比，Spring 不负责管理原型 bean 的整个生命周期：容器会初始化，配置，要不然就是装配原型对象，并将其传递给客户代码，之后不再对此原型实例跟踪记录。因此，虽然不管什么作用域 <em>初始化</em> 阶段的回调方法都会在所有对象上执行，但在原型 bean 的情况下不会调用配置的 <em>销毁</em> 回调方法。客户代码必须手动清理原型作用域对象并释放这个原型 bean 拥有的高代价资源。为了使 Spring 容器释放原型作用域 bean 拥有的资源，可以试试使用自定义的 <a href="#beans-factory-extension-bpp">bean post-processor</a>，它有用对需要清理的 bean 的引用。</p>
</div>
<div class="paragraph">
<p>在某些方面，对于原型作用域的 bean，Spring 容器的角色就像 Java 中 <code>new</code> 操作符的替代品。所有在这个节点之后的声明周期管理都必须有客户代码处理。（关于更多 Spring 容器中 bean 的生命周期的细节，参见 <a href="#beans-factory-lifecycle">生命周期回调</a>。）</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-sing-prot-interaction"><a class="anchor" href="#beans-factory-scopes-sing-prot-interaction"></a>1.5.3. 含有原型 bean 依赖项的单例 bean</h4>
<div class="paragraph">
<p>当你使用含有原型 bean 依赖项的单例作用域 bean 时，注意 <em>依赖解析发生在实例化时间</em>。那么如果你使用依赖注入将原型作用域 bean 注入到单例作用域 bean 时，将会实例化一个新的原型 bean 并将它注入到这个单例 bean 中。The prototype instance is the sole instance that is ever supplied to the ingleton-scoped bean.（不知何意）。</p>
</div>
<div class="paragraph">
<p>但是，假设要在运行时让单例作用域 bean 不断重复获取原型作用域 bean 的新实例。你不能把原型作用域 bean 注入到你的单例 bean 中，因为注入只在 Spring 容器实例化单例 bean 和解析并注入它的依赖项的时候发生一次。如果你在运行时不止一次需要原型 bean 的新实例，参见 <a href="#beans-factory-method-injection">方法注入</a></p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-other"><a class="anchor" href="#beans-factory-scopes-other"></a>1.5.4. Request（请求作用域）, session（会话作用域）, application（应用作用域）, and WebSocket（websocket作用域）</h4>
<div class="paragraph">
<p><code>request</code>, <code>session</code>, <code>application</code>，和<code>websocket</code> 作用域只在你使用有 web 感知能力的 Spring <code>ApplicationContext</code> 实现时可用（如 <code>XmlWebApplicationContext</code>）。如果你在普通的 Spring IoC 容器如 <code>ClassPathXmlApplicationContext</code> 中使用这些作用域，会有 <code>IllegalStateException</code> 异常抛出，向你投诉你使用了未知的 bean 作用域。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-web-configuration"><a class="anchor" href="#beans-factory-scopes-other-web-configuration"></a>初始化 web 配置</h5>
<div class="paragraph">
<p>为了支持 <code>request</code>, <code>session</code>, <code>application</code>，和
  <code>websocket</code> 作用域级别的 bean（web 作用域 bean），在你定义 bean 之前需要进行一些小的初始化配置。（这个初始化设置对于标准作用域 <code>singleton</code> 和 <code>prototype</code> 是不需要的。）</p>
</div>
<div class="paragraph">
<p>如何完成这个初始化设置取决于你使用的特定的 Servlet 环境。</p>
</div>
<div class="paragraph">
<p>如果你在 Spring Web MVC 中访问具有作用域的 bean，实际上也就是在请求内部由 Spring <code>DispatcherServlet</code> 来处理，那么不需要特殊的设置：<code>DispatcherServlet</code> 已经暴露了所有相关的状态。</p>
</div>
<div class="paragraph">
<p>如果你使用 Servlet 2.5 web 容器，请求在Spring <code>DispatcherServlet</code> 之外被处理（例如，当使用 JSF 或者 Struts 的时候），你需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于 Servlet 3.0+，这可以通过 <code>WebApplicationInitializer</code> 接口编码实现。或者，对于更早的容器，在 web 应用程序的 <code>web.xml</code> 文件中添加如下声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        ...
        <span class="tag">&lt;listener&gt;</span>
                <span class="tag">&lt;listener-class&gt;</span>
                        org.springframework.web.context.request.RequestContextListener
                <span class="tag">&lt;/listener-class&gt;</span>
        <span class="tag">&lt;/listener&gt;</span>
        ...
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>再或者，如果你的监听器配置有点问题，可以考虑使用 Spring 的 <code>RequestContextFilter</code>。过滤器映射依赖于周围的 web 应用配置，因此你需要的时候你不得不适当的修改之。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        ...
        <span class="tag">&lt;filter&gt;</span>
                <span class="tag">&lt;filter-name&gt;</span>requestContextFilter<span class="tag">&lt;/filter-name&gt;</span>
                <span class="tag">&lt;filter-class&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/filter-class&gt;</span>
        <span class="tag">&lt;/filter&gt;</span>
        <span class="tag">&lt;filter-mapping&gt;</span>
                <span class="tag">&lt;filter-name&gt;</span>requestContextFilter<span class="tag">&lt;/filter-name&gt;</span>
                <span class="tag">&lt;url-pattern&gt;</span>/*<span class="tag">&lt;/url-pattern&gt;</span>
        <span class="tag">&lt;/filter-mapping&gt;</span>
        ...
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code>, <code>RequestContextListener</code>，和<code>RequestContextFilter</code> 完成的都是同样的工作，也就是将 HTTP 请求对象绑定到为这个请求提供服务的 <code>线程</code> 上。这使得具有 request 作用域和 session 作用域的 bean 在之后调用链中都是可用的。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-request"><a class="anchor" href="#beans-factory-scopes-request"></a>Request 作用域</h5>
<div class="paragraph">
<p>考虑以下 bean 定义的 XML 配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">loginAction</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.LoginAction</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">request</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过使用 <code>loginAction</code> bean 定义为每一个 HTTP 请求创建一个新的 <code>LoginAction</code> bean 实例。也就是说，<code>loginAction</code> bean 是具有 HTTP request 级别作用域的 bean。对于这个创建好的实例的内部状态，你可以想怎么改变就怎么改变，因为其他根据这同一个 <code>loginAction</code> bean 定义创建出来的实例根本看不到这些状态的改变；他们对于每一个不同的请求都是独有的。当请求处理完成时，这个处于请求作用域级别的 bean 就会被销毁。</p>
</div>
<div class="paragraph">
<p>当你使用注解驱动的组件或者 Java Config 时，添加了 <code>@RequestScope</code> 注解的组件会具有  <code>request</code> 作用域。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@RequestScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginAction</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-session"><a class="anchor" href="#beans-factory-scopes-session"></a>Session 作用域</h5>
<div class="paragraph">
<p>考虑以下 bean 定义的 XML 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过使用 <code>userPreferences</code> bean 定义为每一个 HTTP 请求 <code>Session</code> 生命周期创建一个新的 <code>UserPreferences</code> bean 实例。也就是说，<code>userPreferences</code> bean 是具有对应 HTTP <code>Session</code> 级别作用域的 bean。正如具有 <code>request</code> 作用域 的 bean，对于这个创建好的实例的内部状态，你可以想怎么改变就怎么改变，须知其他根据这同一个 <code>userPreferences</code> bean 定义创建出来的实例也看不到这些状态的改变，他们对于每一个不同的 HTTP <code>Session</code> 都是独有的。当 HTTP <code>Session</code> 最终销毁的时候，作用域与之对应的 bean 也就销毁了。</p>
</div>
<div class="paragraph">
<p>当你使用注解驱动的组件或者 Java Config 时，添加了 <code>@SessionScope</code> 注解的组件会具有  <code>session</code> 作用域。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@SessionScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">UserPreferences</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-application"><a class="anchor" href="#beans-factory-scopes-application"></a>Application 作用域</h5>
<div class="paragraph">
<p>考虑以下 bean 定义的 XML 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">appPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.AppPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">application</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过使用 <code>appPreferences</code> bean 定义为整个个 web 应用创建一个新的 <code>AppPreferences</code> bean 实例。也就是说，<code>appPreferences</code> bean 是具有 <code>ServletContext</code> 级别作用域的 bean，它作为一个正则 <code>ServletContext</code> 特性被存储起来。某种程度上讲，这与 Spring 的单例 bean 有点类似，但在两个重要方面有所不同：他是对于每个  <code>ServletContext</code> 的单例，而不是对于每个 Spring 'ApplicationContext' （任何给定的 web 应用中可能会有不止一个 ApplicationContext）的单例，它真正是作为一个 <code>ServletContext</code> 特性而被暴露出来也因此可见。</p>
</div>
<div class="paragraph">
<p>当你使用注解驱动的组件或者 Java Config 时，添加了 <code>@ApplicationScope</code> 注解的组件会具有  <code>application</code> 作用域。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@ApplicationScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppPreferences</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-injection"><a class="anchor" href="#beans-factory-scopes-other-injection"></a>作为依赖项的作用域 bean</h5>
<div class="paragraph">
<p>Spring IoC 容器不仅管理你的对象（bean） 的实例化，也管理协作者（或者依赖项）的装配。如果你想要将（例如）一个具有 HTTP request 作用域的 bean 注入到另一个具有更长生命周期作用域的 bean 中，你可以选择注入这个作用域 bean 的 AOP 代理。即，你需要注入一个与此作用域对象暴露相同公共接口的代理对象，但还能从相关作用域（如一个 HTTP request）获取真实的目标对象并且对代理方法的调用能作用于真正的对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你也可以在 <code>singleton</code> 作用域的 bean 之间使用 <code>&lt;aop:scoped-proxy/&gt;</code>，通过一个中间代理应用进行序列化，并且能通过反序列化重新获取目标单例 bean。</p>
</div>
<div class="paragraph">
<p>如果对 <code>prototype</code> 作用域的 bean 声明 <code>&lt;aop:scoped-proxy/&gt;</code> ，对这个共享代理的每次方法调用都会导致一次（调用朝向的？）目标 bean 新实例的创建。</p>
</div>
<div class="paragraph">
<p>而且，作用域代理并不是唯一以生命周期安全形式访问小作用域 bean 的方式。你也可以简单地声明你的注入点（例如，构造器/setter 参数或者自动装配域）为 <code>ObjectFactory&lt;MyTargetBean&gt;</code>，允许每次需要的时候通过 <code>getObject()</code> 调用按需获取当前实例————这里并没有对其进行保持或者分开存储。</p>
</div>
<div class="paragraph">
<p>作为一个扩展变形，你可以声明 <code>ObjectProvider&lt;MyTargetBean&gt;</code>，他提供了几个附加的访问变形，包括 <code>getIfAvailable</code> 和 <code>getIfUnique</code>。</p>
</div>
<div class="paragraph">
<p>JSR-330 中称它为 <code>Provider</code>，对于每次获取尝试使用 <code>Provider&lt;MyTargetBean&gt;</code> 声明和对应 <code>get()</code> 调用。关于JSR-330整体的更多细节请看 <a href="#beans-standard-annotations">此处</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>虽然下面例子中的配置只有一行，但对于理解它背后的“why”和“how”很重要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop</span>
                <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- instructs the container to proxy the surrounding bean --&gt;</span>
                <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.SimpleUserService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- a reference to the proxied userPreferences bean --&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过将一个子 <code>&lt;aop:scoped-proxy/&gt;</code> 元素插入到一个定义域 bean 定义（参见 <a href="#beans-factory-scopes-other-injection-proxies">选择要创建的代理类型</a> 和
  <a href="appendix.html#xsd-configuration">基于 Schema 的XML配置</a>）来创建这样一个代理。为什么具有<code>request</code>，<code>session</code> 和自定义作用域级别的 bean 定义需要 <code>&lt;aop:scoped-proxy/&gt;</code> 元素呢？让我们查看一下下面的单例 bean 定义并将它与你需要定义的为面所述的定义域比较一下（注意下面的 <code>userPreferences</code> bean 定义是不完整的）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中，具有 HTTP <code>Session</code> 作用域的 bean <code>userPreferences</code> 被注入到单例 bean <code>userManager</code> 中。这里的要点是 <code>userManager</code> bean 是一个单例 bean；每个容器只会对它进行 <em>一次</em> 实例化，他的依赖项（这个例子中只有一个，就是 <code>userPreferences</code> bean）也只会被注入一次。这意味着 <code>userManager</code> bean 将只能对确定的同一个 <code>userPreferences</code> 对象进行操作，也就是说最初被注入的那个对象。</p>
</div>
<div class="paragraph">
<p>当你将一个短生命周期的作用域 bean 注入到一个长生命周期的作用域 bean 时，这不是你想要它们表现出来的行为，例如将一个具有 HTTP <code>Session</code> 作用域的协作 bean 作为依赖项注入到一个单例 bean 中。当然，你需要一个单一的 <code>userManager</code> 对象，而对于 HTTP <code>Session</code> 的生命周期，你需要一个与具体所谓 HTTP <code>Session</code> 对应的 <code>userPreferences</code> 对象。因此，容器创建了一个与 <code>UserPreferences</code> 类（理想情况下应该是一个 <code>UserPreferences</code> 实例）暴露相同公共接口的对象，可以通过作用域机制（HTTP request，<code>Session</code>，等等）获取真正的 <code>UserPreferences</code> 对象。容器将这个代理对象注入到 <code>userManager</code> bean 中，而 <code>userManager</code> bean 不会感知 <code>UserPreferences</code> 引用其实是一个代理。在这里例子中，当 <code>UserManager</code> 实例调用依赖注入的 <code>UserPreferences</code> 对象方法时，它其实调用的是代理对象的方法。之后代理对象从 HTTP <code>Session</code> 中获取真正的 <code>UserPreferences</code> 对象，然后将方法调用委托给已经获取的真正 <code>UserPreferences</code> 对象。/p>
</div>
<div class="paragraph">
<p>因此当你将具有 <code>request</code> 和 <code>session</code> 作用域 bean 注入到协作对象中时，你需要以下正确的完整的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-scopes-other-injection-proxies"><a class="anchor" href="#beans-factory-scopes-other-injection-proxies"></a>选择要创建的代理类型</h6>
<div class="paragraph">
<p>默认情况下，当容器为具有 <code>&lt;aop:scoped-proxy/&gt;</code> 元素标记的 bean 创建代理时，会创建一个基于 GBLIB 的代理。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>GBLIB 代理只拦截共有方法调用。不要在这个代理上调用非共有方法；这些调用不会被委托给具有作用域的目标对象。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另一种选择，你可以将 Spring 容器配置为为此类具有作用域的 bean 创建标准 JDK 的基于接口的代理，这是通过将 <code>&lt;aop:scoped-proxy/&gt;</code> 元素的 <code>proxy-target-class</code> 特性设为  <code>false</code> 实现的。使用 JDK 的基于接口的代理意味着你不需要在你的应用程序类路径中添加额外的库来支持这种代理。不过，这也意味着具有作用域 bean 的类必须实现至少一个接口，且注入这个作用域 bean 的所有协作者都必须通过它自身的某个接口来引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultUserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;aop:scoped-proxy</span> <span class="attribute-name">proxy-target-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>更多关于对基于类对的代理或者基于接口的代理的选择，参见<a href="#aop-proxying">代理机制</a>。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-custom"><a class="anchor" href="#beans-factory-scopes-custom"></a>1.5.5. 自定义作用域</h4>
<div class="paragraph">
<p>Bean 的作用域机制是可扩展的；你可以定义你自己的作用域，或者可以对现存的作用域进行重定义，尽管后者被认为是一种不好的实践，你不能覆盖内置的 <code>singleton</code> 和 <code>prototype</code> 作用域。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-creating"><a class="anchor" href="#beans-factory-scopes-custom-creating"></a>创建自定义作用域</h5>
<div class="paragraph">
<p>要将你的自定义作用域集成到 Spring 容器，你需要实现 <code>org.springframework.beans.factory.config.Scope</code> 接口，一节将叙述这个接口。对于怎样实现你自己的作用域，参见 Spring 框架本身和 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html"><code>Scope</code> javadocs</a> 提供的实现，里面有更多你需要实现这些方法的细节。</p>
</div>
<div class="paragraph">
<p><code>Scope</code> 接口有四个可以从作用域中取对象，删对象和允许他们被销毁的方法。i</p>
</div>
<div class="paragraph">
<p>下面的方法从其作用域返回对象。以 session 作用域为例，它返回具有 session 作用域的 bean（如果它不存在，方法就会返回这个 bean 的新实例，然后将它绑定到 sesion 中以便以后引用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Object</span> get(<span class="predefined-type">String</span> name, <span class="predefined-type">ObjectFactory</span> objectFactory)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的方法从其作用域删除对象。以 session 作用域为例，它从其作用域中删除具有 session 作用域的 bean。此对象应该被返回，但如果指定名字的对象那个没找到会返回 null。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Object</span> remove(<span class="predefined-type">String</span> name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当作用域被销毁或者当作用域中指定的对象被销毁时，下面的方法会注册作用域应该执行的回调方法。关于销毁回调犯法的更多信息参见 javadocs 或者 Spring 作用域实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerDestructionCallback(<span class="predefined-type">String</span> name, <span class="predefined-type">Runnable</span> destructionCallback)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的方法从其作用域获得会话标识符。每个作用域的标识符都是不同的。对于 session 作用域实现，这个标识符就是 session 标识符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> getConversationId()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-using"><a class="anchor" href="#beans-factory-scopes-custom-using"></a>Using a custom scope</h5>
<div class="paragraph">
<p>在你编写或测试一个或者多个自定义 <code>Scope</code> 实现之后，你需要使 Spring 容器能够感知这些新作用域。下面的方法是在 Spring 容器中注册新 <code>Scope</code> 的核心方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerScope(<span class="predefined-type">String</span> scopeName, Scope scope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法在 <code>ConfigurableBeanFactory</code> 接口中声明，这个接口在与 Spring 通过 BeanFactory 属性装载到一起的大多数具体的 <code>ApplicationContext</code> 实现中是可用的。</p>
</div>
<div class="paragraph">
<p><code>registerScope(..)</code> 方法的第一个实参是与作用域相关的唯一的名字；Spring 容器本身就有这些名字的例子如 <code>singleton</code> 和 <code>prototype</code>。registerScope(..)</code> 方法的第二个实参是你想注册和使用的自定义 <code>Scope</code> 实现的真正实例。</p>
</div>
<div class="paragraph">
<p>假设你编写了你自定义的 <code>Scope</code> 实现，并按一下方式注册。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面例子使用的 <code>SimpleThreadScope</code> 已经包含在 Spring 中，但默认没有注册。用法与你自己的自定义 <code>Scope</code> 实现一样。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Scope threadScope = <span class="keyword">new</span> SimpleThreadScope();
beanFactory.registerScope(<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span>, threadScope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后创建具有你自定义 <code>Scope</code> 规则的 bean 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于自定义 <code>Scope</code> 实现，你不受限于只能通过编程注册。你还可以使用声明式的 <code>Scope</code> 注册，采用 <code>CustomScopeConfigurer</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop</span>
                <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.CustomScopeConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scopes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;map&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.SimpleThreadScope</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;/entry&gt;</span>
                        <span class="tag">&lt;/map&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当你在 <code>FactoryBean</code> 实现中配置 <code>&lt;aop:scoped-proxy/&gt;</code> 时，表示的是这个工厂 bean 本身具有作用域，而不是只通过 <code>getObject()</code> 方法返回的对象。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-nature"><a class="anchor" href="#beans-factory-nature"></a>1.6. 对 bean 的性质进行自定义</h3>
<div class="sect3">
<h4 id="beans-factory-lifecycle"><a class="anchor" href="#beans-factory-lifecycle"></a>1.6.1. 生命周期回调</h4>
<div class="paragraph">
<p>为了能与容器对 bean 生命周期管理交互，你可以实现 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。容器在初始化 bean 时会调用 <code>InitializingBean</code> 的 <code>afterPropertiesSet()</code> 方法，在销毁 bean 时会调用 <code>DisposableBean</code> 的 <code>destroy()</code>方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR-250 的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解通常被认为是在现代 Spring 应用中接收声明周期回调的最佳实践。使用这些注解意味着你的 bean 与特定的 Spring 接口不再耦合在一起了。关于细节参见<a href="#beans-postconstruct-and-predestroy-annotations">@PostConstruct 和 @PreDestroy</a>。</p>
</div>
<div class="paragraph">
<p>如果你不想使用 JSR-250 注解但仍寻求消除耦合，那么可以考虑使用 init-method 和 destroy-method 对象定义元数据。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 Spring 内部，Spring 框架使用 <code>BeanPostProcessor</code> 实现来处理任何它能发现的回调接口并调用合适的方法。如果你需要自定义 Spring 不能提供的开箱即用的功能或其他生命周期行为，你可以自己实现一个 <code>BeanPostProcessor</code> 接口。关于更多信息，参见 <a href="#beans-factory-extension">容器扩展点</a>。</p>
</div>
<div class="paragraph">
<p>除了初始化回调方法和销毁毁掉方法，Spring 管理的对象也可以实现 <code>Lifecycle</code> 接口以便这些对象能参与到容器自身生命周期驱动的启动和关闭过程。</p>
</div>
<div class="paragraph">
<p>这小节叙述了生命周期回调的接口。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-initializingbean"><a class="anchor" href="#beans-factory-lifecycle-initializingbean"></a>初始化回调</h5>
<div class="paragraph">
<p><code>org.springframework.beans.factory.InitializingBean</code> 接口允许 bean 在容器对它设置完所有必须属性之后执行初始化工作。<code>InitializingBean</code> 接口指定了一个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterPropertiesSet() <span class="directive">throws</span> <span class="exception">Exception</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>建议你不要使用 <code>InitializingBean</code> 接口，因为它将代码与 Spring 进行了不必要的耦合。作为替代方法，你可以使用 <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a> 注解或者指定一个 POJO 初始化方法。对于基于XML的配置元数据，你可以使用 <code>init-method</code> 特性来指定一个返回值为 void 的无入参方法的方法名。对于 Java 配置，你可以使用 <code>@Bean</code> 的 <code>initMethod</code> 特性，参见 <a href="#beans-java-lifecycle-callbacks">接收声明周期回调</a>。 例如，下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="comment">// do some initialization work</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;等价于&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">AnotherExampleBean</span> <span class="directive">implements</span> InitializingBean {

        <span class="directive">public</span> <span class="type">void</span> afterPropertiesSet() {
                <span class="comment">// do some initialization work</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但没有将代码与 Spring 耦合起来。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-disposablebean"><a class="anchor" href="#beans-factory-lifecycle-disposablebean"></a>销毁回调</h5>
<div class="paragraph">
<p>实现 <code>org.springframework.beans.factory.DisposableBean</code> 接口允许 bean 在包含它的容器销毁时得到一个回调方法。<code>DisposableBean</code> 接口指定了一个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> destroy() <span class="directive">throws</span> <span class="exception">Exception</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>建议你不要使用 <code>DisposableBean</code> 接口，因为它将代码与 Spring 进行了不必要的耦合。作为替代方法，你可以使用 <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a> 接口或者指定一个 bean 定义支持的通用方法。对于基于XML的配置元数据，你可以使用 <code>&lt;bean/&gt;</code> 元素的 <code>destroy-method</code> 特性。对于 Java 配置，你可以使用 <code>@Bean</code> 的 <code>destroyMethod</code> 特性，参见 <a href="#beans-java-lifecycle-callbacks">接收声明周期回调</a>。例如，下面的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">cleanup</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">public</span> <span class="type">void</span> cleanup() {
                <span class="comment">// do some destruction work (like releasing pooled connections)</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">AnotherExampleBean</span> <span class="directive">implements</span> DisposableBean {

        <span class="directive">public</span> <span class="type">void</span> destroy() {
                <span class="comment">// do some destruction work (like releasing pooled connections)</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但没有将代码与 Spring 耦合起来。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;bean&gt;</code> 元素的 <code>destroy-method</code> 特性会被赋予一个特殊值 <code>(inferred)</code>，它会引导 Spring 自动检测指定 bean 类的公有 <code>close</code> 或者
<code>shutdown</code> 方法（可以匹配任何实现 <code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的类）。为了将此行为应用到一个完整的 bean 集合中，这个特殊<code>(inferred)</code> 值也可以被设置到 <code>&lt;beans&gt;</code> 元素的 <code>default-destroy-method</code> 特性上（参见 <a href="#beans-factory-lifecycle-default-init-destroy-methods">默认初始化和销毁方法</a>）。注意着也是 Java 配置的默认行为。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-default-init-destroy-methods"><a class="anchor" href="#beans-factory-lifecycle-default-init-destroy-methods"></a> 默认初始化和销毁方法</h5>
<div class="paragraph">
<p>如果你不使用 Spring 指定的 <code>InitializingBean</code> 和 <code>DisposableBean</code> 回调接口编写初始化和销毁方法回调，你可以编写名为 <code>init()</code>，<code>initialize()</code>，<code>dispose()</code> 等等这样的方法。这些生命周期回调方法的名字应该在从整个工程中都是标准化的，这样所有开发者都能使用同样的方法名也能保证一致性。</p>
</div>
<div class="paragraph">
<p>你可以对 Spring 容器进行配置，使它能查找每个 bean 的初始化和销毁回调方法。这意味着作为一个应用开发者，你可以编写你自己的应用类并使用名为 <code>init()</code> 的初始化回调方法，而不必在每个 bean 定义真配置一个 <code>init-method="init"</code> 特性。Spring IoC 容器会在 bean 创建的时候告诉那个方法（按照前面叙述的标准生命周期回调约定）。这个特性也强迫初始化和销毁方法回调的命名规则必须有一致性约束。</p>
</div>
<div class="paragraph">
<p>假设你的初始化回调方法名为 <code>init()</code>，销毁回调方法名为 <code>destroy()</code>。你的类会与下面例子类似。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultBlogService</span> <span class="directive">implements</span> BlogService {

        <span class="directive">private</span> BlogDao blogDao;

        <span class="directive">public</span> <span class="type">void</span> setBlogDao(BlogDao blogDao) {
                <span class="local-variable">this</span>.blogDao = blogDao;
        }

        <span class="comment">// this is (unsurprisingly) the initialization callback method</span>
        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="keyword">if</span> (<span class="local-variable">this</span>.blogDao == <span class="predefined-constant">null</span>) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">The [blogDao] property must be set.</span><span class="delimiter">&quot;</span></span>);
                }
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultBlogService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogDao</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>位于顶层 <code>&lt;beans/&gt;</code> 元素的 <code>default-init-method</code> 特性会让 Spring IoC 容器将 bean 中名为 <code>init</code> 的方法识别为初始化回调方法。当 bean 被创建和装配的时候，如果它又这么一个方法，那么它将会在适当的时候被调用。</p>
</div>
<div class="paragraph">
<p>类似的，你可以在顶层 <code>&lt;beans/&gt;</code> 元素的 <code>default-destroy-method</code> 特性（在XML中）中配置销毁方法回调。</p>
</div>
<div class="paragraph">
<p>在现有 bean 类已经有不符合命名规范的回调方法的情况下，你可以（在XML中）通过在 <code>&lt;bean/&gt;</code> 的 <code>init-method</code> 和 <code>destroy-method</code> 特性中方法名来覆盖默行为。</p>
</div>
<div class="paragraph">
<p> Spring 容器保证一旦 bean 被提供所有依赖项后，它就会立即执行配置的初始化回调。因此初始化回调会在原始 bean 引用上调用，这意味着这个时候 AOP 拦截器等还不能应用到这个 bean 中。首先目标 bean 被完整创建出来，然后才会应用带有拦截器链的 AOP 代理（举个例子）。如果目标 bean 和代理分别被独立定义了，那么你的的代码甚至能绕过代理直接与原始目标 bean 进行交互。因此将拦截器应用到初始化方法上可能会导致不一致性，因为这么做会使目标 bean 的生命周期与它的代理/拦截器互相耦合，且当你的代码与原始目标 bean 交互时导致出现奇怪的语义。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-combined-effects"><a class="anchor" href="#beans-factory-lifecycle-combined-effects"></a>组合生命周期机制</h5>
<div class="paragraph">
<p>从 Spring 2.5 开始，你有三个选择来控制 bean 的声明周期行为：<a href="#beans-factory-lifecycle-initializingbean"><code>InitializingBean</code></a> 和
<a href="#beans-factory-lifecycle-disposablebean"><code>DisposableBean</code></a> 回调接口；自定义
<code>init()</code> 和 <code>destroy()</code> 方法；<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解</a>。你可以将这些机制结合起来控制一个给定的 bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果一个 bean 配置了多种生命周期机制，且每种机制都配置了不同的方法名，那么每个配置的方法都会按下表所列的顺序分别执行。但是，如果不同机制配置了相同的方法名——例如，在不止一个生命周期机制中配置了同名的初始化方法 <code>init()</code> ——那么这个方法就会像前一小节说的那样只执行一次。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于同一个 bean，配置了多个声明周期，并有不同的初始化方法，那么他们的调用顺序如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有 <code>@PostConstruct</code> 注解的方法</p>
</li>
<li>
<p><code>InitializingBean</code> 回调接口定义的 <code>afterPropertiesSet()</code> 方法</p>
</li>
<li>
<p>自定义的 <code>init()</code> 方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>销毁方法也以相同的顺序调用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有 <code>@PreDestroy</code> 注解的方法</p>
</li>
<li>
<p><code>DisposableBean</code> 回调接口定义的 <code>destroy()</code> 方法</p>
</li>
<li>
<p>自定义的 <code>destroy()</code> 方法</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-processor"><a class="anchor" href="#beans-factory-lifecycle-processor"></a>启动和关闭回调方法</h5>
<div class="paragraph">
<p><code>Lifecycle</code> 接口为任何有用它自己生命周期需求的对象定义了一些必备的基本方法（例如开始和停止某个后台处理过程）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lifecycle</span> {

        <span class="type">void</span> start();

        <span class="type">void</span> stop();

        <span class="type">boolean</span> isRunning();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何 Spring 管理的对象都可以实现那个接口。当 <code>ApplicationContext</code> 本身接收到开始和停止信号时，例如运行时的停止/重启场景，它会级联调用所有上下文中定义的 <code>Lifecycle</code> 实现。这个功能是通过将 <code>LifecycleProcessor</code> 作为委托来完成的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">LifecycleProcessor</span> <span class="directive">extends</span> Lifecycle {

        <span class="type">void</span> onRefresh();

        <span class="type">void</span> onClose();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>LifecycleProcessor</code> 本身是 <code>Lifecycle</code> 接口的继承接口。另外它还添加了另外两个方法来响应上下文的刷新和关闭。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意常规的 <code>org.springframework.context.Lifecycle</code> 接口只是一个显式的开始/停止通知的协议，并不意味着上下文刷新时的自动启动。考虑实现 <code>org.springframework.context.SmartLifecycle</code> 接口而不是通过指定 bean 的自动启动来进行细粒度的控制(包括启动阶段)。还要注意的是停止通知并不保证一定会在销毁之前到来：在正常关闭的时候，所有 <code>Lifecycle</code> bean 会在通用销毁回调传递之前首先收到停止通知；但是对于上下文生命周期的热刷新和取消刷新尝试，只有调用销毁方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>启动和关闭调用的顺序是很重要的。如果任何两个对象之间存在一个依赖关系，那么依赖方会在它的依赖项之后启动，且会在它的依赖项之前停止。但是，有时候直接依赖关系是未知的。你可能只知道某个类型的对象应该在另一个类型的对象之前启动。在那种情况下，<code>SmartLifecycle</code> 定义了另一种选择，即在它的父接口 <code>Phased</code> 中定义了 <code>getPhase()</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Phased</span> {

        <span class="type">int</span> getPhase();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">SmartLifecycle</span> <span class="directive">extends</span> Lifecycle, Phased {

        <span class="type">boolean</span> isAutoStartup();

        <span class="type">void</span> stop(<span class="predefined-type">Runnable</span> callback);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>启动的时候，最低 phase 的对象先启动，停止的时候，正好相反，最高 phase 的对象先停止。因此对于一个实现了 <code>SmartLifecycle</code> 接口的对象，如果它的 <code>getPhase()</code> 方法返回 <code>Integer.MIN_VALUE</code>，那么它就会最先启动，最后停止。在 phase 范围的另一端，一个 <code>Integer.MAX_VALUE</code> 值表明对象应该最后启动，最先停止（可能是因为它依赖其他正在运行的进程）。当考虑 phase 值的设定时，还有一点很重要，那就是说任何没有实现 <code>SmartLifecycle</code> 接口的“正常”对象的 phase 默认值是0。因此，任何为负值的 phase 值意味着此对象应该在标准组件启动之前启动（在它们停止之后停止）；当phase 为正值的时候刚好相反。</p>
</div>
<div class="paragraph">
<p>正如你所见，<code>SmartLifecycle</code> 定义的 stop 方法接收一个回调。任何实现在实现的关闭进程完成之后都必须调用那个回调的 <code>run()</code> 方法。这使得在需要是可以进行异步关闭，因为 <code>LifecycleProcessor</code> 接口的默认实现 <code>DefaultLifecycleProcessor</code> 会为一组对象的每个阶段等待直到超时，然后调用回调方法。默认的每个阶段的超时时间是30秒。你可以通过在上下文中定一个名为“lifecycleProcessor”的 bean 来覆盖默认的生命周期处理器（lifecycle processor）实例。如果你只是想修改超时值，那么下面的定义就足够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lifecycleProcessor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.DefaultLifecycleProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">timeoutPerShutdownPhase</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如上面提到的，<code>LifecycleProcessor</code> 接口为上下文的刷新和关闭也定义了回调。后者会简单地驱动关闭进程就像显式调用了 <code>stop()</code> 方法，但它只会在上下文关闭的时候执行。另一方面，refresh 回调使 <code>SmartLifecycle</code> bean 的另一个特性可用。回调会在上下文刷新的时候（在所有对象实例化和初始化完成之后）被调用，默认生命周期处理器会在那个时间点检查每个 <code>SmartLifecycle</code> 对象的 <code>isAutoStartup()</code> 方法返回的布尔值。如果返回的是“true”，那么对象就会立即启动而不是等待上下文的显式调用或者它自己的 <code>start()</code> 方法（与上下文刷新不同，对于一个标准的上下文实现，它的启动不会自动发生）。与依赖关系一样，“phase” 值也会以前面叙述的相同方式来决定启动顺序。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-shutdown"><a class="anchor" href="#beans-factory-shutdown"></a>在非web应用中优雅地关闭 Spring IoC 容器</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本节只适用于非 web 应用。Spring 的基于web的 code>ApplicationContext</code> 实现已经有相关代码来处理当相关的web应用关闭时，如何优雅地关闭 Spring IoC 容器。h</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你正在一个非web应用环境中使用 Spring IoC 容器；例如，在一个富客户端桌面环境中；你可以在 JVM 中注册一个关闭 hook。这么做保证了一次优雅的关闭且会调用所有单例 bean 的相关销毁方法以便释放所有资源。当然你仍然必须正确配置和实现这些销毁回调方法。</p>
</div>
<div class="paragraph">
<p>为注册一个关闭 hook，你可以调用 <code>ConfigurableApplicationContext</code> 接口中声明的 <code>registerShutdownHook()</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context.ConfigurableApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);

                <span class="comment">// add a shutdown hook for the above context...</span>
                ctx.registerShutdownHook();

                <span class="comment">// app runs here...</span>

                <span class="comment">// main method exits, hook is called prior to the app shutting down...</span>
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-aware"><a class="anchor" href="#beans-factory-aware"></a>1.6.2. ApplicationContextAware 和 BeanNameAware</h4>
<div class="paragraph">
<p>当 <code>ApplicationContext</code> 创建了一个实现了 <code>org.springframework.context.ApplicationContextAware</code> 接口的对象实例，这个实例会拥有一个指向那个 <code>ApplicationContext</code> 的引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ApplicationContextAware</span> {

        <span class="type">void</span> setApplicationContext(ApplicationContext applicationContext) <span class="directive">throws</span> BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此 bean 可以通过 <code>ApplicationContext</code> 接口，或者通过将这个接口（如暴露额外功能的 <code>ConfigurableApplicationContext</code>）强转成它已知子类的引用来以编码方式操控创建它们的 <code>ApplicationContext</code>。这种能力的其中一个用途是可以以编程方式对其他 bean 进行检索。有时候这种能力很有用；但是一般情况下你应该避免使用它，因为它将代码与 Spring  合起来了，而且也没有遵守控制反转风格，在控制反转中协作者是作为属性提供给 bean 的。<code>ApplicationContext</code> 的其他方法有提供文件资源访问的，发布应用事件的，访问 <code>MessageSource</code> 的。这些额外特性在 <a href="#context-introduction">ApplicationContext 的额外能力</a> 叙述。</p>
</div>
<div class="paragraph">
<p>从Spring 2.5 开始，自动装备成为另一种获取 <code>ApplicationContext</code> 引用的备用选择。“传统的”  <code>constructor</code> 和 <code>byType</code> 自动装配模式（如 <a href="#beans-factory-autowire">自动装配协作者</a> 中叙述的那样) 可以分别为构造器实参和 setter 方法形参提供 <code>ApplicationContext</code> 类型的依赖项。使用新的基于注解的自动装配特性会更加具有灵活性，包括自动装配域的能力和自动装配多参数方法的能力。如果你这么做，那么 <code>ApplicationContext</code> 就会被自动装配到域中，构造器实参或方法形参中，如果此问题中的域，构造器实参或方法形参都期望获得 <code>ApplicationContext</code> 类型以依赖并带有 <code>@Autowired</code> 注解。更多信息，参见 <a href="#beans-autowired-annotation">@Autowired</a>。</p>
</div>
<div class="paragraph">
<p>当 <code>ApplicationContext</code> 创建了一个实现了 <code>org.springframework.beans.factory.BeanNameAware</code> 接口的类，这个类会拥有与它相关的对象定义中定义的名称的引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeanNameAware</span> {

        <span class="type">void</span> setBeanName(<span class="predefined-type">String</span> name) <span class="directive">throws</span> BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个回调会在很多正常 bean 属性设置之后，但是在如 <code>InitializingBean</code> 的 <em>afterPropertiesSet</em> 或者自定义 init-method 这样的初始化调用之前被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="aware-list"><a class="anchor" href="#aware-list"></a>1.6.3. 其他 Aware 接口</h4>
<div class="paragraph">
<p>除了上面讨论的 <code>ApplicationContextAware</code> 和 <code>BeanNameAware</code>，Spring 还提供了一系列 <code>Aware</code> 接口，这些接口允许 bean 向表明他们需要一个确定的基础结构依赖项。下面总结了一些最重要的 <code>Aware</code> 接口 —— 作为通用规则，依赖项的名字是推断他们是什么类型依赖的一个很好的依据：</p>
</div>
<table id="beans-factory-nature-aware-list" class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. Aware 接口</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名字</th>
<th class="tableblock halign-left valign-top">注入的依赖项</th>
<th class="tableblock halign-left valign-top">具体解释入口</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEventPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event publisher of the enclosing <code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the ApplicationContext</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanClassLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class loader used to load the bean classes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">Instantiating beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanFactoryAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>BeanFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanNameAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the declaring bean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BootstrapContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in
JCA aware <code>ApplicationContext</code>s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#cci">JCA CCI</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LoadTimeWeaverAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defined <em>weaver</em> for processing class definition at load time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#aop-aj-ltw">Load-time weaving with AspectJ in the Spring Framework</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageSourceAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured strategy for resolving messages (with support for parametrization and
internationalization)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the ApplicationContext</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotificationPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring JMX notification publisher</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#jmx-notifications">Notifications</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured loader for low-level access to resources</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#resources">Resources</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletConfigAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>再次提醒注意，对这些接口的使用将会使你的代码与 Spring API 绑定在一起，而且这不符合控制反转风格。因此，建议只对那些需要以编程方式访问容器的基础结构 bean 使用这种方式。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-child-bean-definitions"><a class="anchor" href="#beans-child-bean-definitions"></a>1.7. Bean definition inheritance</h3>
<div class="paragraph">
<p>Bean 定义中可以包含很多配置信息，包括构造器参数，属性值，容器相关的特定信息如初始化方法，静态工厂方法名等等。子定义会继承父定义的配置数据。子定义可以按需覆盖一些值，或者添加一些其他值。使用父子 bean 定义会重用很多代码，节省很多打字时间。实际上，这也是模板的一种形式。</p>
</div>
<div class="paragraph">
<p>如果你以编程方式使用 <code>ApplicationContext</code> 接口，那么子 bean 定义就可以通过<code>ChildBeanDefinition</code> 类来表示。大多数用于不会在这个层级使用它们，而是在某种像 <code>ClassPathXmlApplicationContext</code> 这样的组件中以声明的方式配置 bean 定义。当你是用基于XML的配置元数据时，你可以使用 <code>parent</code> 特性来表示这是个子 bean 定义，父 bean 就被指定为这个特性的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.TestBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritsWithDifferentClass</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.DerivedTestBean</span><span class="delimiter">&quot;</span></span>
                <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBean</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialize</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">override</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果子 bean 定义没有指定，那么它就会使用父定义中的 bean 定义，而且子定义还可以覆盖符定义。在后一种情况下，子定义必须与父定义兼容，也就是它必须接受父定义的属性值。</p>
</div>
<div class="paragraph">
<p>子 bean 定义会从父定义中继承作用域，构造器参数值，属性值，可以覆盖父定义中的方法，可以增加添加新值的选择。任何你指定的作用域，初始化方法，销毁方法，和/或 <code>静态</code> 工厂方法设置都将会覆盖相应的父定义中的配置。</p>
</div>
<div class="paragraph">
<p>其他剩下的设置 <em>都是</em> 从子定义获取的：<em>依赖</em>，<em>自动装配模式</em>，<em>依赖项检测</em>，<em>单例</em>，<em>懒加载</em>。</p>
</div>
<div class="paragraph">
<p>前面的例子显式地通过 <code>abstract</code> 特性将父 bean 定义标记为抽象的。如果父定义没有指定具体的类，那么将父 bean 定义标记为 <code>abstract</code> 是必须的，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBeanWithoutClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritsWithClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.DerivedTestBean</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBeanWithoutClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialize</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">override</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>父 bean 定义不能仅仅靠它自己实例化，因为它是不完整的，而且显式地被标记为 <code>抽象的</code>。如果某个定义是<code>abstract</code>，那么它只能作为一个纯净的 bean 定义模板，也就是专门为子定义服务的父定义。如果你试图通过将它作为另一个 bean 的引用属性值来单独使用这样一个 <code>abstract</code> 父 bean，或者用这个父 bean id 显式地调用<code>getBean()</code>，那么程序将会返回一个错误。类似地，容器内部的 <code>preInstantiateSingletons()</code> 方法也会忽略抽象 bean 定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ApplicationContext</code> 默认预实例化所有单例 bean。因此，如果你有一个已经指定了一个具体的类（父）bean 定义，且你只想要将它作为一个模板，那么你必须确保将它的 <em>abstract</em> 特性设置成 <em>true</em>（至少对于单例 bean 这是很重要的），否则应用上下文会（试图）预实例化这个 <code>abstract</code> bean。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-extension"><a class="anchor" href="#beans-factory-extension"></a>1.8. 容器的扩展点</h3>
<div class="paragraph">
<p>通常，应用开发者不需要使用继承 <code>ApplicationContext</code> 实现类的子类。相反，Spring IoC 容器可以通过插入特定集成接口的实现类来进行扩展。接下来的计小节将会叙述这些集成接口。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-bpp"><a class="anchor" href="#beans-factory-extension-bpp"></a>1.8.1. 使用 BeanPostProcessor 来自定义 bean</h4>
<div class="paragraph">
<p><code>BeanPostProcessor</code> 接口定义了一些 <em>回调方法</em>，你可以在这些方法中实现你自己的（或者副高容器默认的）实例化逻辑，依赖解析逻辑等等。如果你想要在 Spring 容器完成实例化，配置，和初始化 bean 工作之后实现某些自定义逻辑，你可以插入一个或者多个 <code>BeanPostProcessor</code> 实现。</p>
</div>
<div class="paragraph">
<p>你可以配置多个 <code>BeanPostProcessor</code> 实例，而且可以通过设置 <code>order</code> 属性控制这些 <code>BeanPostProcessor</code> 的执行顺序。不过只有实现 <code>Ordered</code> 接口的 <code>BeanPostProcessor</code> 实现才能设置这个属性；如果你编写自己的 <code>BeanPostProcessor</code> 实现，你也应该考虑实现 <code>Ordered</code> 接口。详情咨询 <code>BeanPostProcessor</code> 和 <code>Ordered</code> 接口的 javadoc。也可以参见下面的 <a href="#beans-factory-programmatically-registering-beanpostprocessors">编程方式注册 <code>BeanPostProcessor</code></a> 笔记。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>BeanPostProcessor</code> 对 bean（或者对象）<em>实例</em> 进行操作；也就是说，首先 Spring IoC 容器实例化一个 bean 实例，然后 <code>BeanPostProcessor</code> 完成它们的工作。</p>
</div>
<div class="paragraph">
<p><code>BeanPostProcessor</code> 的作用域是绑定到每个容器上的，也是说它的作用域就是它所在容器的声明周期。只有你在使用容器分层的情况下，才会可能于此相关。如果你在一个容器中定义了一个 <code>BeanPostProcessor</code>，它只会对那个容器中的 bean 进行 post-process 操作。换句话说，某个容器中定义的 bean 不会被另一个容器中定义的 <code>BeanPostProcessor</code> 执行 post-process 操作，即使这两个容器是同一容器家族一部分。</p>
</div>
<div class="paragraph">
<p>为了修改真正的 bean 定义（例如，定义 bean 的 <em>blueprint</em> ），你需要使用 <a href="#beans-factory-extension-factory-postprocessors">使用 BeanFactoryPostProcessor 自定义配置元数据</a> 中描述的 <code>BeanFactoryPostProcessor</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口恰好由两个回调方法组成。当这个类在容器中注册为 post-processor 时，对于容器创建的每个 bean 实例，在容器初始化方法（如 InitializingBean 的 <em>afterPropertiesSet()</em> 和任何声明的初始化方法）调用 <em>之前</em>，以及在任何 bean 初始化回调之后，post-processor 都会从容器中得到一个回调。post-processor 可以对这个 bean 实例采取任何操作，包括完全忽略回调方法。 bean 的 post-processor 通常会检查回调接口或者将 bean 包装成一个代理。某些 Spring AOP 基础接口类也会以 bean post-processors 的形式实现以便提供代理包装逻辑。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 会对配置元数据中实现 <code>BeanPostProcessor</code> 接口的任何 bean 进行 <em>自动检测</em>。<code>ApplicationContext</code> 将这些 bean 注册为 post-processors，这样就能在后面创建这些 bean 时调用它们。Bean post-processors 可以像其他任何 bean 一样被部署到容器当中。</p>
</div>
<div class="paragraph">
<p>注意当你在一个配置类上使用 <code>@Bean</code> 工厂方法声明 <code>BeanPostProcessor</code> 时，工厂方法返回的类型应该是实现类本身或者至少是 <code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口，这样就能清晰地表明那个 bean 的 post-processor 特性。否则 <code>ApplicationContext</code> 不会再完全创建好它之前就通过类型对它进行自动检测。因为 <code>BeanPostProcessor</code> 需要很早实例化以便能够在上下文中应用到其他 bean 的初始化过程，所以早起的类型检测是非常关键的。</p>
</div>
<div id="beans-factory-programmatically-registering-beanpostprocessors" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">编程方式注册 BeanPostProcessors</div>
<div class="paragraph">
<p>虽然推荐的 <code>BeanPostProcessor</code> 注册的方式是通过 <code>ApplicationContext</code> 的自动检测（如上所述），但你也可以通过使用 <code>ConfigurableBeanFactory</code> 的 <code>addBeanPostProcessor</code> 方法来以编程的方式来注册它。当你需要在注册之前对它进行条件逻辑的评估时，或者需要在上下文层级中夸上下文复制 bean 的后处理器，这是很有用的。注意用编程方式添加 <code>BeanPostProcessor</code> 不需要考虑 <code>Ordered</code> 接口。这里 <em>注册顺序</em> 就规定了执行顺序。还要注意的是以编程方式注册的 <code>BeanPostProcessor</code> 永远都在那些通过自动检测注册的 <code>BeanPostProcessor</code> 之前执行，无论任何显式的指定顺序是怎么样的。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">BeanPostProcessors 和 AOP 自动代理</div>
<div class="paragraph">
<p>实现了 <code>BeanPostProcessor</code> 接口的类是特殊的且会被容器区别对待。 所有 <code>BeanPostProcessor</code> 和它们直接引用的 bean 会被当做 <code>ApplicationContext</code> 特殊启动阶段的一部分在启动时就被实例化。之后，所有的 <code>BeanPostProcessor</code> 都会以有序形式注册，并适用于容器中所有之后的 bean。因为 AOP 自动代理是作为 <code>BeanPostProcessor</code> 本身实现的，所以无论是 <code>BeanPostProcessor</code> 还是他们直接引用的 bean 都没有资格进行自动代理，因此自动代理也就无法织入它们。</p>
</div>
<div class="paragraph">
<p>对于任何此类 bean，你会看到一条信息日志消息：“<em>Bean foo 没有资格被所有 BeanPostProcessor 接口处理（例如：不适合自动代理）</em>”。</p>
</div>
<div class="paragraph">
<p>注意如果你有 bean 通过自动装配或者 <code>@Resource</code> 注解（可能降级到自动装配）注入到 <code>BeanPostProcessor</code> 中，当搜索类型匹配依赖候选 bean 时，Spring 可能会访问未预料到的 bean，因此要使它们没有资格被自动代理或者被其他类型的bean post-processing 处理。例如，如果你有一个注解为 <code>@Resource</code> 的依赖项，它的 field/setter 名并没有与声明的 bean 直接对应且也没有使用 name 特性，那么 Spring 就会通过类型匹配去访问其他 bean。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的例子展示了如何在 <code>ApplicationContext</code> 中编写，注册和使用 <code>BeanPostProcessor</code>。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-hw"><a class="anchor" href="#beans-factory-extension-bpp-examples-hw"></a>Example: Hello World, BeanPostProcessor-style</h5>
<div class="paragraph">
<p>这第一个例子阐述了基本用法。这个例子展示了一个自定义 <code>BeanPostProcessor</code> 实现，其中调用了每个 bean 的 <code>toString()</code> 方法，它它们被容器创建时将结果字符串打印在系统控制台上。</p>
</div>
<div class="paragraph">
<p>下面是自定义 <code>BeanPostProcessor</code> 实现类定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">scripting</span>;

<span class="keyword">import</span> <span class="include">org.springframework.beans.factory.config.BeanPostProcessor</span>;
<span class="keyword">import</span> <span class="include">org.springframework.beans.BeansException</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">InstantiationTracingBeanPostProcessor</span> <span class="directive">implements</span> BeanPostProcessor {

        <span class="comment">// simply return the instantiated bean as-is</span>
        <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessBeforeInitialization(<span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) {
                <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span>
        }

        <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessAfterInitialization(<span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Bean '</span><span class="delimiter">&quot;</span></span> + beanName + <span class="string"><span class="delimiter">&quot;</span><span class="content">' created : </span><span class="delimiter">&quot;</span></span> + bean.toString());
                <span class="keyword">return</span> bean;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:lang</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/lang</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/lang</span>
                <span class="content">http://www.springframework.org/schema/lang/spring-lang.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;lang:groovy</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messenger</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">script-source</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:org/springframework/scripting/groovy/Messenger.groovy</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;lang:property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Fiona Apple Is Just So Dreamy.</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/lang:groovy&gt;</span>

        <span class="comment">&lt;!--
        when the above bean (messenger) is instantiated, this custom
        BeanPostProcessor implementation will output the fact to the system console
        --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scripting.InstantiationTracingBeanPostProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>InstantiationTracingBeanPostProcessor</code> 是怎样被简单定义的。它甚至都没有名字，但因为它是个 bean 所有它能像其他任何 bean 一样被依赖注入。（前面的配置还定义了一个由 Groovy 脚本支持的 bean。Spring 动态语言支持在 <a href="integration.html#dynamic-language">动态语言支持</a> 中进行了详细的阐述。）</p>
</div>
<div class="paragraph">
<p>下面的简单 Java 应用执行了前面的代码和配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.scripting.Messenger</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">scripting/beans.xml</span><span class="delimiter">&quot;</span></span>);
                Messenger messenger = (Messenger) ctx.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">messenger</span><span class="delimiter">&quot;</span></span>);
                <span class="predefined-type">System</span>.out.println(messenger);
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的应用输出结果如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-rabpp"><a class="anchor" href="#beans-factory-extension-bpp-examples-rabpp"></a>Example: The RequiredAnnotationBeanPostProcessor</h5>
<div class="paragraph">
<p>使用与自定义 <code>BeanPostProcessor</code> 实现结合的回调接口或者注解是扩展 Spring IoC 容器的一种常见手段。其中一个例子是 Spring 的 <code>RequiredAnnotationBeanPostProcessor</code> ——一个附带在 Spring 分发包中的 <code>BeanPostProcessor</code> 实现，它能保证 bean 上所有带有（任意）注解的 JavaBean 属性都能真正（配置成）用值进行依赖注入。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factory-postprocessors"><a class="anchor" href="#beans-factory-extension-factory-postprocessors"></a>1.8.2. BeanFactoryPostProcessor 中的自定义配置元数据</h4>
<div class="paragraph">
<p>下一个我们要关注的扩展点是 <code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。这个接口的语义与其他 The semantics of <code>BeanPostProcessor</code> 类似，但有一个主要不同点：<code>BeanFactoryPostProcessor</code> 可以操作 <em>bean 配置元数据 </em>；也就是，Spring IoC 容器允许 <code>BeanFactoryPostProcessor</code> 读取配置元数据，并且允许它在容器实例化任何 bean（<code>BeanFactoryPostProcessor</code> 本身除外）之前修改它。</p>
</div>
<div class="paragraph">
<p>你可以配置多个 <code>BeanFactoryPostProcessor</code>，并通过设置 <code>order</code> 属性控制他们执行的顺序。不过只有当 <code>BeanFactoryPostProcessor</code> 实现 <code>order</code> 接口后你才能设置这个属性。如果你编写你自己的 <code>BeanFactoryPostProcessor</code>，你也应该考虑实现 <code>BeanFactoryPostProcessor</code> 接口。更多细节咨询 <code>BeanFactoryPostProcessor</code> 和 <code>Ordered</code> 接口的 javadoc。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你要修改真正的 bean <em>实例</em>（例如，从配置元数据创建的对象），那你应该使用 <code>BeanPostProcessor</code>（在上面的<a href="#beans-factory-extension-bpp">使用 BeanPostProcessor 自定义 bean</a> 中有阐述）。虽然在 <code>BeanFactoryPostProcessor</code> 中处理 bean 实例在技术上是可行的（例如，使用 <code>BeanFactory.getBean()</code>），但是这么做会导致 bean 的过早是实例化，违反标准的容器生命周期。这可能会造成负面影响，如跳过 bean 的 post processing。</p>
</div>
<div class="paragraph">
<p><code>BeanFactoryPostProcessor</code> 的作用域是绑定到每个容器上的，也是说它的作用域就是它所在容器的生命周期。只有你在使用容器分层的情况下，才会可能于此相关。如果你在一个容器中定义了一个 <code>BeanFactoryPostProcessor</code>，它只适用于那个容器中的 bean定义。某个容器中定义的 bean 不会被另一个容器中定义的 <code>BeanFactoryPostProcessor</code> 执行 post-process 操作，即使这两个容器是同一容器家族一部分。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了使对定义容器的配置元数据的修改生效，当一个 bean 工厂 post-processor 在 <code>ApplicationContext</code> 中声明时，它就会自动执行。Spring 包含许多预定义好的 bean 工厂 post-processors，如 <code>PropertyOverrideConfigurer</code> 和
  <code>PropertyPlaceholderConfigurer</code>。举个例子，为了注册自定义的属性编辑器，你也可以使用自定义的 <code>BeanFactoryPostProcessor</code>。</p>
</div>
<div id="null" class="paragraph">
<p><code>ApplicationContext</code> 会自动检测任何部署在它上面的实现了 <code>BeanFactoryPostProcessor</code> 接口的 bean。在适当的时间，它会将它们作为 bean 工厂 post-processor 使用。你可以想其它任何你使用的 bean 那样部署这些 post-processor bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>和 <code>BeanPostProcessor</code> 一样，通常你不会将 <code>BeanFactoryPostProcessor</code> 配置成懒加载模式。如果没有其它 bean 引用 <code>Bean(Factory)PostProcessor</code>，那么作为 post-processor 这个 <code>Bean(Factory)PostProcessor</code>  根本不会被实例化。因此，将它标记为懒加载也会被忽略，即使你在声明 <code>&lt;beans /&gt;</code> 元素的时候，将它的 <code>default-lazy-init</code> 特性设置为 <code>true</code>，<code>Bean(Factory)PostProcessor</code> 也会被急切地实例化。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-factory-placeholderconfigurer"><a class="anchor" href="#beans-factory-placeholderconfigurer"></a>Example: the Class name substitution PropertyPlaceholderConfigurer</h5>
<div class="paragraph">
<p>你可以谁使用 <code>PropertyPlaceholderConfigurer</code> 读取单独配置文件具体化 bean 定义中的属性值，这样的单独文件使用标准的 Java <code>Properties</code> 格式。这么做可以让部署者可以自定义环境相关的属性值如数据库 URL 和密码，而屏蔽了对容器主要 XML 定义文件的修改的复杂性，及其带来的风险。</p>
</div>
<div class="paragraph">
<p>考虑下面基于XML的配置元数据片段，其中定义了一个带有占位符的 <code>DataSource</code>。这个例子展示了外部 <code>Properties</code> 文件配置属性。在运行时，<code>PropertyPlaceholderConfigurer</code> 会应用与这个元数据，然后替换 DataSource 的一些属性。这些需要替换的值会以 <code>${property-name}</code> 的占位符形式指定，遵循 Ant /  log4j / JSP EL 风格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">locations</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/foo/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">driverClassName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.driverClassName}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>真正的值来自另一个用标准 Java <code>Properties</code> 格式写的文件：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre>
</div>
</div>
<div class="paragraph">
<p>因此，<code>${jdbc.username}</code> 字符串会在运行时用‘sa’代替，其它与属性文件中的key匹配的占位符值也会以同样方式被替换。<code>PropertyPlaceholderConfigurer</code> 会检查 bean 定义中大多数属性和特性的占位符。此外，占位符的前缀和后缀都可以自定义。</p>
</div>
<div class="paragraph">
<p>自从 Spring 2.5 引入了 <code>context</code> 命名空间， 可以用一个专门的配置元素来配置属性占位符。<code>location</code> 特性中可以配置属性文件的地址，多个地址之间用逗号隔开。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/foo/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PropertyPlaceholderConfigurer</code> 不仅能查找指定的 <code>Properties</code> 文件中的属性。默认情况下，如果它没有在指定属性文件中找到需要的属性，它就会查找 Java <code>System</code> 属性。你可以通过设置配置器的 <code>systemPropertiesMode</code> 属性自定义查找行为，属性支持下面三个整形值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>never</em> (0): 不检查系统属性</p>
</li>
<li>
<p><em>fallback</em> (1): 如果没有在指定文件中解析成功就检查系统属性。这也是默认设置。</p>
</li>
<li>
<p><em>override</em> (2): 在查找指定属性文件之前，先检查系统属性。这使得系统属性可以覆盖任何其他属性源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consult the <code>PropertyPlaceholderConfigurer</code> javadocs for more information.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当你在运行时需要选择一个特殊的实现类的时候，使用 <code>PropertyPlaceholderConfigurer</code> 来替换类名就变得很有用了。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">locations</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>classpath:com/foo/strategy.properties<span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>custom.strategy.class=com.foo.DefaultStrategy<span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceStrategy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${custom.strategy.class}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果某个类在运行时不能被解析为一个有效类，那么在 <code>ApplicationContext</code> 的 <code>preInstantiateSingletons()</code> 阶段如果它不是一个懒加载类，当它要被创建的时候，就会解析失败。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-overrideconfigurer"><a class="anchor" href="#beans-factory-overrideconfigurer"></a>Example: the PropertyOverrideConfigurer</h5>
<div class="paragraph">
<p><code>PropertyOverrideConfigurer</code> 是另一个与 <code>PropertyPlaceholderConfigurer</code> 类似的 bean 工厂 post-processor，但与后者不同，原始定义的 bean 属性可以有默认值也可以完全没有值。如果用于覆盖的 <code>Properties</code> 文件没有找到某个 bean 属性的入口，那么就会使用默认的上下文定义。</p>
</div>
<div class="paragraph">
<p>注意 bean definition 并不会感知到被覆盖了，所以不能从XML定义文件中马上明显地得知正在使用用于覆盖的配置器。在多个 <code>PropertyOverrideConfigurer</code> 实例为同一个 bean 属性定义了不同值的情况下，根据覆盖机制，最后一个有效。</p>
</div>
<div class="paragraph">
<p>属性文件配置行格式如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>beanName.property=value</pre>
</div>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre>
</div>
</div>
<div class="paragraph">
<p>这个例子文件可以在一个包含名为 <em>dataSource</em> 的 bean 的容器定义中使用，<em>dataSource</em> 有 <em>driver</em> 和 <em>driver</em> 属性。</p>
</div>
<div class="paragraph">
<p>复合属性名也是被支持的，只要保证除了属性名的最后部分其他每部分都是非空的（假设有构造器初始化）。在本例中：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>foo.fred.bob.sammy=123</pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><code>foo</code> bean 有一个 <code>fred</code> 属性，<code>fred</code> 属性有一个 <code>bob</code> 属性， <code>bob</code> 有一个 <code>sammy</code> 属性，最后将 <code>bob</code> 设置为标量值 <code>123</code>。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>指定的覆盖值总是字面值（literal values）；它们不会被转换成对 bean 的引用。就算XML bean 定义的原始值指定的是对 bean 的引用，这个规范也同样适用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>随着 <code>context</code> 命名空间在 Spring 2.5 中被引入，使用专用配置元素配置属性覆盖也成为了可能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:property-override</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:override.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factorybean"><a class="anchor" href="#beans-factory-extension-factorybean"></a>1.8.3. 使用 FactoryBean 自定义实例化逻辑</h4>
<div class="paragraph">
<p>使那些本身是工厂的对象实现 <code>org.springframework.beans.factory.FactoryBean</code> 接口。</p>
</div>
<div class="paragraph">
<p><code>FactoryBean</code> 接口是 Spring IoC 容器实例化逻辑的一个可插入点。如果你的初始化代码很复杂，相比用大量（潜在）冗余的XML来描述，选择用 Java 代码来描述会更好，那么你可以创建你自己的 <code>FactoryBean</code>，在其中编写复杂的初始化逻辑，然后再将这个自定义 <code>FactoryBean</code> 插入到容器中。</p>
</div>
<div class="paragraph">
<p><code>FactoryBean</code> 接口中有三个方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object getObject()</code>：返回一个词工厂创建的对象实例。这个实例可以被共享，当然这取决于工厂返回的是单例对象实例还是原型对象实例。</p>
</li>
<li>
<p><code>boolean isSingleton()</code>：如果这个 <code>FactoryBean</code> 返回单例实例，那么就返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
<li>
<p><code>Class getObjectType()</code>：返回 <code>getObject()</code> 方法返回的对象的类型，或者如果事先不知道类型就返回 <code>null</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>FactoryBean</code> 的概念和接口在 Spring 框架很多地方都用到了；Spring 本身附带了超过50个 <code>FactoryBean</code> 接口的实现。</p>
</div>
<div class="paragraph">
<p>当你需要向容器请求一个真正的 <code>FactoryBean</code> 实例本身而不是它生产的 bean 时，在你调用 <code>ApplicationContext</code> 的 <code>getBean()</code> 方法时，需要在 bean 的 id 前面加上一个 ampersand 符号（<code>&amp;</code>）。所以给定一个 id 为 <code>myBean</code> 的 <code>FactoryBean</code>，在容器中调用 <code>getBean("myBean")</code> 会返回 <code>FactoryBean</code> 生产的 bean；而调用 <code>getBean("&amp;myBean")</code> 会返回 <code>FactoryBean</code> 实例本身。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-annotation-config"><a class="anchor" href="#beans-annotation-config"></a>1.9. 基于注解的容器配置</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">注解配置 Spring 比 XML 配置更好吗？</div>
<div class="paragraph">
<p>基于注解的配置引出了这样一个问题：这种方式是否比XML配置更好。给个简短的答案那就是 <em>那得看情况</em>（废话，老外也学会辩证唯物了？）。长一点的回答是每种方式都有它的有优缺点，通常由开发者决定更适合的策略。由于他们不同的定义方式，注解会在声明中提供很多少下文，导致配置更精简。但是，在不接触源码或者重新编译的情况下装配组件方面，XML更有优势。一些开发者更倾向于装配配置更接近于源代码，而另一些人认为带有注解的类已经不再是 POJO 类了，此外，这使得配置变得去中心化和更难以控制。</p>
</div>
<div class="paragraph">
<p>无论你怎么选择，Spring 能同事适应这两种风格，甚至你可以将它们混合使用。值得说明的是，Spring 通过其 <a href="#beans-java">JavaConfig</a> 选项允许注解以一种非入侵的方式被使用，而不用接触目标组件的源代码，也不涉及哪些工具，所有的配置风格都由 <a href="https://spring.io/tools/sts">Spring Tool Suite</a> 支持。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>基于注解的配置是一种可以代替 XML 设置的方式，它依赖于字节码元数据来装配组件，而不是用尖括号声明。 开发者通过将注解配置在相关类，方法或者字段声明上，将配置移动到组件类本身中，一次代替用XML描述 bean 的装配。正如
  <a href="#beans-factory-extension-bpp-examples-rabpp">Example: The RequiredAnnotationBeanPostProcessor</a> 里描述的，使用 <code>BeanPostProcessor</code> 与注解结合是扩展 Spring IoC 容器的常+用方式。例如，Spring 2.0 引入了强制需求属性值的 <a href="#beans-required-annotation">@Required</a> 注解。Spring 2.5 使以同样的通用方式驱动 Spring 的依赖注入变为可能。本质上讲，<code>@Autowired</code> 注解提供了与 <a href="#beans-factory-autowire">自动装配协作者</a> 中描述的同样的能力，但是它具有更细粒度的控制能力和更广泛的适用性。Spring 2.5 还增加了对 JSR-250 注解的支持，如 <code>@PostConstruct</code> 和 <code>@PreDestroy</code>。Spring 3.0 增加了对包含在 javax.inject 包中的 JSR-330 （Java 的依赖注入）注解的支持，如 <code>@Inject</code> 和 <code>@Named</code>。更多这些注解的细节参见 <a href="#beans-standard-annotations">相关章节</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注解注入在XML注入之前执行，因此对于通过两种方式装配的属性，XML配置会覆盖注解配置。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与以往一样，您可以将它们注册为单独的 bean 定义，也可以通过在基于XML的 Spring 配置（注意 <code>context</code> 命名空间的引入）中包含以下标记进行隐式注册：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>（隐式注册的 post-processors 包括
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a>，
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a>，
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a>，
以及前面提到的
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a>。）</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;context:annotation-config/&gt;</code> 只会对定义它的应用上下文中的 bean 进行注解查找。这意味着，如果你为 <code>DispatcherServlet</code> 在 <code>WebApplicationContext</code> 中配置了 <code>&lt;context:annotation-config/&gt;</code>，它只会在你的控制器中检测带有 <code>@Autowired</code> 的 bean，而不会检测服务层。更多细节参见 <a href="web.html#mvc-servlet">DispatcherServlet</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-required-annotation"><a class="anchor" href="#beans-required-annotation"></a>1.9.1. @Required</h4>
<div class="paragraph">
<p><code>@Required</code> 注解应用于属性的 setter 方法，如下面的例子所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Required</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个注解简单明了地表明受影响的 bean 属性（也就是被注解配置的 bean 属性）必须在配置阶段通过 bean 定义中显式的属性值或者通过自动装配进行设置。如果受影响的 bean 属性没有设置，容器会抛出异常；这相当于它具有快速失败特性，从而避免出现 <code>NullPointerException</code> 或者之后出现此类其他异常。不过我们仍然建议你在 bean 类本身内部加入断言，例如，在初始化方法中。这么做可以强制那些引用和值成功配置，甚至你都可以在容器外部使用它们也不用担心出现异常。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation"><a class="anchor" href="#beans-autowired-annotation"></a>1.9.2. @Autowired</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面的一些例子使用了 JSR 330 的 <code>@Inject</code> 注解代替  Spring 的 <code>@Autowired</code> 注解。更多细节参见 <a href="#beans-standard-annotations">这里</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以将 <code>@Autowired</code> 注解用于构造器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="directive">final</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从 Spring Framework 4.3 开始，如果目标 bean 只定义了一个构造器，那么在这样的构造器上配置 <code>@Autowired</code> 就变得不再必要。但如果有好几个构造器可用，那么至少有一个需要被注解以便告诉容器使用哪一个。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>不出所料，你还可以将 <code>@Autowired</code> 注解应用于“传统的” setter 方法： </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以将注解应用到具有任何名字的方法和/或多个参数上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> prepare(MovieCatalog movieCatalog,
                        CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.movieCatalog = movieCatalog;
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以将 <code>@Autowired</code> 应用于字段上，甚至于构造器混合使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="directive">final</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保你在使用 <code>@Autowired</code> 注解注入的点的时候，对目标组件（例如， <code>MovieCatalog</code>，<code>CustomerPreferenceDao</code>）的类型声明的一致性。否则注入可能会由于在运行时找不到类型匹配而失败。</p>
</div>
<div class="paragraph">
<p>对于通过类路径扫描到的基于XML定义的 bean 或者 组件类，容器通常都会预先知道它们的实际类型。不过对于 <code>@Bean</code> 工厂方法，你需要确保声明的返回类型足够表达对象本身的信息。对于实现多个接口的组件或者可能被它们的实现类类型所引用的组件，考虑在工厂方法中声明符合要求的最具体的返回烈性。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过给期望获得数组类型的字段或方法添加注解，也可以从 <code>ApplicationContext</code> 中获得此特定类型的所有 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog<span class="type">[]</span> movieCatalogs;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这同样适用于集合类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">Set</span>&lt;MovieCatalog&gt; movieCatalogs;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs(<span class="predefined-type">Set</span>&lt;MovieCatalog&gt; movieCatalogs) {
                <span class="local-variable">this</span>.movieCatalogs = movieCatalogs;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你希望数组或列表中的项按特定顺序排列，你可以让你的 bean 实现 <code>org.springframework.core.Ordered</code> 接口或者使用 <code>@Order</code> 或者标准 <code>@Priority</code> 注解。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>甚至类型化的 Map 也能被自动装配，只要它的 key 是 <code>String</code> 类型的。Map 的所有 value 会包括所有期望类型的 bean，所有的 key 都包括对应的 bean 名字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, MovieCatalog&gt; movieCatalogs;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, MovieCatalog&gt; movieCatalogs) {
                <span class="local-variable">this</span>.movieCatalogs = movieCatalogs;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，如果没有候选bean 是可用的，那么自动装配就会失败；默认行为将带有注解的方法，构造器，字段作为已经指明了 <em>required</em> 的依赖项。可以通过下面展示的方式改变这种行为。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>(required = <span class="predefined-constant">false</span>)
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每个类只有一个被注解构造器可以用 <em>required</em> 标记，不过可以注解多个非必须的构造器。在那种情况下，每个构造器都在候选之列，且 Spring 会使用那个满足依赖的 <em>最贪婪</em> 的构造器，也就是那个入参最多的构造器。</p>
</div>
<div class="paragraph">
  <p><code>相比于直接使用 @Required 注解，我们更建议你使用 @Autowired 的 <em>required</em> 特性</code>。<em>required</em> 特性表示对于自动装配此属性是不必须的，如果它不能被自动装配，那它就会被忽略。另一方面，<code>@Required</code> 的语义会更强，它强制由容器支持的任何方式都必须设置这个属性。如果没有值被注入，就会抛出相应异常。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以将 <code>@Autowired</code> 用于那些众所周知的可解析依赖接口： <code>BeanFactory</code>，<code>ApplicationContext</code>，<code>Environment</code>，<code>ResourceLoader</code>，
<code>ApplicationEventPublisher</code>，和 <code>MessageSource</code>。这些接口和它们的扩展类（如 <code>ConfigurableApplicationContext</code> 或者 <code>ResourcePatternResolver</code>）可以被自动解析，而不需要特殊的设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> ApplicationContext context;

        <span class="directive">public</span> MovieRecommender() {
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Autowired</code>，<code>@Inject</code>，<code>@Resource</code>，和 <code>@Value</code> 注解都是由 Spring <code>BeanPostProcessor</code> 实现处理的，这反过来意味着在你自己的 <code>BeanPostProcessor</code> 或 <code>BeanFactoryPostProcessor</code> 类型中你不能使用这些注解（如果有的话）。这些类型必须显式地通过XML或者通过使用 Spring <code>@Bean</code> 方法来 ‘wired up’。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-primary"><a class="anchor" href="#beans-autowired-annotation-primary"></a>1.9.3. 使用 @Primary 对基于注解的自动装配进行微调</h4>
<div class="paragraph">
<p>因为根据类型自动装配会出现有多个候选的问题，所以常常需要对这个选择过程进行更多的控制。其中一种方式是采用 Spring 的 <code>@Primary</code> 注解。<code>@Primary</code> 表示当一个单值依赖项具有多个候选 bean 时，某个指定的 bean 具有更高的优先级。如果刚好一个‘primary’ bean 存在于候选中，那么它就会是那个被自动装配的值。</p>
</div>
<div class="paragraph">
<p>下设如下配置将 <code>firstMovieCatalog</code> 定义为 <em>primary</em> <code>MovieCatalog</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieConfiguration</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Primary</span></strong>
        <span class="directive">public</span> MovieCatalog firstMovieCatalog() { ... }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> MovieCatalog secondMovieCatalog() { ... }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据这个配置，下面的 <code>MovieRecommender</code> 将会自动装配 <code>firstMovieCatalog</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对应的 bean 定义如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span> <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">primary</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-qualifiers"><a class="anchor" href="#beans-autowired-annotation-qualifiers"></a>1.9.4. 使用 @qualifier 对基于注解的自动装配进行微调</h4>
<div class="paragraph">
<p>当自动装配过程中有多个实例需要确定其中一个主要候选时，<code>@Primary</code> 是一种按类型自动装配的有效方式。 如果对这个选择过程需要更多的控制时，可以使用 Spring 的 <code>@Qualifier</code> 注解。为了将类型匹配集合收窄到每个参数对应一个特定的 bean ，你可以将 qualifier 的值与特定的值关联起来。最简单的情况下，这可以是一个纯描述的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Qualifier</code> 注解也可以配置构造器参数或者方法参数上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> prepare(<strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>)</strong>MovieCatalog movieCatalog,
                        CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.movieCatalog = movieCatalog;
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对应的 bean 定义如下。限定符值为 “main” 的 bean 会通过和它具有相同值的构造器参数装配起来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>

                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>

                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于匹配的回退，bean 名字会被作为默认的限定值。因此你可以定义一个 id 为“main”的 bean 来代替嵌套的限定符元素，匹配结果是一样的。不过，尽管你可以使用这个约定来根据名字引用特定的 bean，但是从根本上讲，<code>@Autowired</code> 是使用可选语义限定符进行类型驱动注入的。这意味着限定符的值，即使退化到 bean 的名字，也总是会从语义上收窄匹配集合；他们没有从语义上将引用表示为最一个唯一 bean id 的引用。像“main”或者“EMEA”或者“persistent”这样的就算是好的限定符值，他们表达了独立于 bean <code>id</code> 的特定组件的特性，即使前面例子中像这个 bean 一样的匿名bean会自动生成 id。</p>
</div>
<div class="paragraph">
<p>如上面讨论的，限定符也可用于类型化的集合上，比如 <code>Set&lt;MovieCatalog&gt;</code>。在这个例子中，根据声明限定符匹配的所有 bean 会以集合形式被注入。这暗示了限定符不一定是要唯一的；它们只是简单地构成过滤规则。例如，你可以定义多个具有同一个限定符值“action”的 code>MovieCatalog</code> bean，所有这些 bean 都会被注入到带有 <code>@Qualifier("action")</code> 注解的 <code>Set&lt;MovieCatalog&gt;</code> 中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你想通过名字表示注解驱动注入，不要以使用 <code>@Autowired</code> 为主，即使在技术上能够通过 <code>@Qualifier</code> 值来引用 bean 名字。相反，你应该使用 JSR-250 <code>@Resource</code> 注解，它在语义上被定义为根据组件唯一的名字来定位一个特定目标组件，声明的类型与匹配过称无关。<code>@Autowired</code> 则具有不同的语义：在根据类型选择候选 bean 之后，这个特定的 String 限定符值被认为只在被选类型的候选 bena 中，例如，在具有相同限定符标签的 bean 中匹配一个“account”限定符。</p>
</div>
<div class="paragraph">
<p>对于那些本身被定义为集合/map 或者数组类型的 bean 来说，<code>@Resource</code> 是个很好的解决方案，适用于根据唯一名字区分的特定集合或者数组。也就是说，从 Spring 4.3 起，集合/map 或者数组类也可以通过 Spring 的 <code>@Autowired</code> 类型匹配算法，只要元素的类型信息在 <code>@Bean</code> 的返回类型签名或者集合继承家族中保存了。在这种情况下，限定符值可以用来在相同类型的集合中区分，如前一段概括的那样。</p>
</div>
<div class="paragraph">
<p>从 Spring 4.3 开始，<code>@Autowired</code> 也支持自我引用注入，例如，将当前注入的 bean 引用返回给 bean 自己。注入自我注入只是一个备用方案；对其他组件的正常依赖总是优先考虑的。在那个意义上，自我引用并不会参与到正常的候选选择且因此也不会成为主要方式；相反，他们具有最低优先级。在实践中，自我引用只是最后的手段，例如，通过bean的事务代理调用同一实例的其它方法：在考虑抽取受影响方法来隔离代理 bean 的场景中。或者，使用 <code>@Resource</code> 来根据 bean 的唯一名字将当前 bean 的代理返回给当前 bean。</p>
</div>
<div class="paragraph">
<p><code>@Autowired</code> 可以应用于字段，构造器，多参数方法，这会在参数级别通过限定符注解缩减候选项，相比之下， <code>@Resource</code> 只支持字段和 bean 属性单参数 setter 方法。因此，如果你的注入目标是构造器或者多参数方法，必须使用限定符。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以创建你自己的自定义限定符注解。简单定义一个注解，在你自己的定义中提供 @Qualifier 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<strong><span class="annotation">@Qualifier</span></strong>
<span class="directive">public</span> <span class="annotation">@interface</span> Genre {

        <span class="predefined-type">String</span> value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后你就可以在自动装配的字段和参数上使用这个自定义限定符了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">private</span> MovieCatalog actionCatalog;

        <span class="directive">private</span> MovieCatalog comedyCatalog;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setComedyCatalog(<strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)</strong> MovieCatalog comedyCatalog) {
                <span class="local-variable">this</span>.comedyCatalog = comedyCatalog;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，提供候选 bean 定义的信息。你可以在 <code>&lt;bean/&gt;</code> 标签中添加 <code>&lt;qualifier/&gt;</code> 作为子元素，然后指定 <code>type</code> 和 <code>value</code> 以匹配你的自定义限定符注解。类型通过注解的全限定类名来匹配。或者，如果没有名字冲突的风险，使用短类名更加方便。两种方式都在下面的例子中呈现了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.Genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <a href="#beans-classpath-scanning">类路径扫描和被管理的组件</a> 中，你会看到一种代替在XML中提供限定符元数据的基于注解的方法。特别参见 <a href="#beans-scanning-qualifiers">使用注解提供限定符元数据</a>。</p>
</div>
<div class="paragraph">
<p>在某些情况下，可能使用不带值的注解就够用了。这在为了某个更加通用的目的使用注解时会非常有用，而且可以应用于多个夸类型的依赖项上。例如，当因特网不可用时，你可能会想要提供一个 <em>offline</em> 目录供搜索。首先定义一个简单的注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Qualifier</span>
<span class="directive">public</span> <span class="annotation">@interface</span> Offline {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将这个注解添加到要被自动装配的字段或者属性上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Offline</span></strong>
        <span class="directive">private</span> MovieCatalog offlineCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，bean 定义至于要一个限定符类型 <code>type</code> 就够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Offline</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以自定义一个接受额外命名特性或者代替这个简单 <code>value</code> 特性的限定符注解。如果要被自动注入的字段或者参数指定了多个值，那么 bean 定义必须匹配所有这些被当做自动装配选项的特性值。考虑下面的注解定义例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Qualifier</span>
<span class="directive">public</span> <span class="annotation">@interface</span> MovieQualifier {

        <span class="predefined-type">String</span> genre();

        <span class="predefined-type">Format</span> format();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子中，<code>Format</code> 是一个枚举类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> <span class="predefined-type">Format</span> {
        VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要自动装配的字段都用自定义限定符注解了，且包含了两个属性的值：<code>genre</code> 和 <code>format</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.VHS, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog actionVhsCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.VHS, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog comedyVhsCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.DVD, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog actionDvdCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.BLURAY, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog comedyBluRayCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，bean 定义应该包括所有匹配的限定符值。这个例子还展示了 bean 的 <em>meta</em> 特性可以用来代替 <code>&lt;qualifier/&gt;</code> 子元素。如果 <code>&lt;qualifier/&gt;</code> 可用，它和它的特性优先级更高，但是如果没有这样限定符，那么自动装配机制会将 <code>&lt;meta/&gt;</code> 标签中的值作为备用，如下面例子中后面两个 bean 的定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MovieQualifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">VHS</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/qualifier&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MovieQualifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">VHS</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/qualifier&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">DVD</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">BLURAY</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-generics-as-qualifiers"><a class="anchor" href="#beans-generics-as-qualifiers"></a>1.9.5. 将泛型作为自动装配限定符使用</h4>
<div class="paragraph">
<p>除了 <code>@Qualifier</code> 注解，也可以使用 Java 泛型类型作为限定符的一种隐式方式。例如，假设有如下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> StringStore stringStore() {
                <span class="keyword">return</span> <span class="keyword">new</span> StringStore();
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> IntegerStore integerStore() {
                <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设上面的 bean 实现了一个泛型接口，例如 <code>Store&lt;String&gt;</code> 和
<code>Store&lt;Integer&gt;</code>，你可以 <code>@Autowire</code> <code>Store</code> 接口，<em>泛型</em> 就会被当做限定符使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span>
<span class="directive">private</span> Store&lt;<span class="predefined-type">String</span>&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span>

<span class="annotation">@Autowired</span>
<span class="directive">private</span> Store&lt;<span class="predefined-type">Integer</span>&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>泛型限定符也适用于在自动装配 Lists，Maps 和 Arrays 时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span>
<span class="comment">// Store&lt;String&gt; beans will not appear in this list</span>
<span class="annotation">@Autowired</span>
<span class="directive">private</span> <span class="predefined-type">List</span>&lt;Store&lt;<span class="predefined-type">Integer</span>&gt;&gt; s;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-custom-autowire-configurer"><a class="anchor" href="#beans-custom-autowire-configurer"></a>1.9.6. CustomAutowireConfigurer</h4>
<div class="paragraph">
<p>The
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a>
是一个 <code>BeanFactoryPostProcessor</code>，它使你可以注册你自己的自定义限定符注解类型，即使他们没有使用 Spring <code>@Qualifier</code> 注解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customAutowireConfigurer</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.annotation.CustomAutowireConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customQualifierTypes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;value&gt;</span>example.CustomQualifier<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AutowireCandidateResolver</code> 通过以下方式决定自动装配的候选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个 bean 定义的 <code>autowire-candidate</code> 值</p>
</li>
<li>
<p><code>&lt;beans/&gt;</code> 元素任意可用的 <code>default-autowire-candidates</code> 模式</p>
</li>
<li>
<p> <code>@Qualifier</code> 注解和任何在 <code>CustomAutowireConfigurer</code> 注册的自定义注解</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当多个 bean 都有资格成为自动装配候选 bean 时，“primary” bean 的决定规则如下：如果候选项中恰好有一个 bean 定义有一个设置为 <code>true</code> 的 <code>primary</code> 特性，它就会被选为 “primary” bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-resource-annotation"><a class="anchor" href="#beans-resource-annotation"></a>1.9.7. @Resource</h4>
<div class="paragraph">
<p>Spring 也支持对字段或者 bean 属性 setter 方法使用 JSR-250 <code>@Resource</code> 注解。这在Java EE 5和6中的一种常见模式，例如在 JSF 1.2 管理的 bean 或者 JAX-WS 2.0 端点。Spring 对它自己管理的对象也支持这种模式。</p>
</div>
<div class="paragraph">
<p><code>@Resource</code> 接受一个名称特性，默认情况下，Spring 将该值理解为要注入的 bean 的名字。换句话说，它遵循 <em>根据名字注入</em> 的语义，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <strong><span class="annotation">@Resource</span>(name=<span class="string"><span class="delimiter">&quot;</span><span class="content">myMovieFinder</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有显式指定名字，默认名字就会从字段名或者 setter 方法获取。如果是字段，就接受字段名；如果是 setter 方法，就接受 bean 属性名。所以下面的例子将把名为“movieFinder”的 bean 注入到它的 setter 方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <strong><span class="annotation">@Resource</span></strong>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>被注解的名字被有 <code>CommonAnnotationBeanPostProcessor</code> 感知能力的 <code>ApplicationContext</code> 解析成为 bean 的名字。如果你显式地配置了 Spring 的 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>，则这些名字可以通过 JNDI 被解析。不过还是建议你依赖默认行为，简单实用 Spring 的 JNDI 查找功能来保持间接级别。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在使用 <code>@Resource</code> 而没有显式指定名字的情况下，与 <code>@Autowired</code> 类似，<code>@Resource</code> 会找到主要类型类匹配而不是特定的被命名 bean，并且解析已知的可解析依赖： <code>BeanFactory</code>，<code>ApplicationContext</code>，<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>，和 <code>MessageSource</code> 接口。</p>
</div>
<div class="paragraph">
<p>因此在下面的例子中，<code>customerPreferenceDao</code> 字段首先查找名为 customerPreferenceDao 的 bean，然后退化到查找 <code>CustomerPreferenceDao</code> 类型的 primary 类型匹配。“context” 字段是基于已知可解析依赖类型 <code>ApplicationContext</code> 注入的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Resource</span>
        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Resource</span>
        <span class="directive">private</span> ApplicationContext context;

        <span class="directive">public</span> MovieRecommender() {
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-postconstruct-and-predestroy-annotations"><a class="anchor" href="#beans-postconstruct-and-predestroy-annotations"></a>1.9.8. @PostConstruct and @PreDestroy</h4>
<div class="paragraph">
<p><code>CommonAnnotationBeanPostProcessor</code> 不仅能识别 <code>@Resource</code> 注解，也能识别 JSR-250 <em>生命周期</em> 注解。对在 Spring 2.5 引入的这些注解的支持，也提供了另一种可以代替在
<a href="#beans-factory-lifecycle-initializingbean">初始化回调</a> 和
<a href="#beans-factory-lifecycle-disposablebean">销毁回调</a> 中描述的那些方法的注解。假设在 Spring 中注册 <code>CommonAnnotationBeanPostProcessor</code>，携带这些注解其中之一的方法所谓对应的 Spring 生命周期接口方法或者显式声明的回调方法在生命周期的同一点被调用。在下面的例子中，缓存在在初始化的时候被预先填充，会在销毁的时候被清除。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CachingMovieLister</span> {

        <span class="annotation">@PostConstruct</span>
        <span class="directive">public</span> <span class="type">void</span> populateMovieCache() {
                <span class="comment">// populates the movie cache upon initialization...</span>
        }

        <span class="annotation">@PreDestroy</span>
        <span class="directive">public</span> <span class="type">void</span> clearMovieCache() {
                <span class="comment">// clears the movie cache upon destruction...</span>
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关于各种生命周期机制组合的细节，参见<a href="#beans-factory-lifecycle-combined-effects">组合生命周期机制</a>。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-classpath-scanning"><a class="anchor" href="#beans-classpath-scanning"></a>1.10. 类路径扫描和被管理的组件</h3>
<div class="paragraph">
<p>本章大多数示例都是用XML来指定在 Spring 容器中生成的每个 <code>BeanDefinition</code> 的配置元数据。前一小节（<a href="#beans-annotation-config">基于注解的配置</a>）展示了如果通过源代码级别的注解提供大量配置元数据。但是，即使在哪些示例中，"基本"的 bean 定义也是在XML文件中显式定义的，注解只是驱动依赖注入。本小节描述了一种通过类路径扫描隐式检测候选组件的方法。候选组件是符合过滤规则的类，且在容器中注册有响应的 bean 定义。这消除了使用XML来执行 bean 注册的需要；相反，你可以使用注解（例如 <code>@Component</code>），AspectJ 类型表达式，或者你自己的自定义过滤规则来选择将哪些类作为 bean 定义注册到容器中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能都成为 Spring 框架核心的一部分。这使得你可以使用 Java 来定义 bean 而不是传统的XML文件。参见 <code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code>，和 <code>@DependsOn</code> 注解的示例，了解如何使用这些新功能。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-stereotype-annotations"><a class="anchor" href="#beans-stereotype-annotations"></a>1.10.1. @Component 以及更多 stereotype 注解</h4>
<div class="paragraph">
<p><code>@Repository</code> 注解是任何实现数据存储角色或者原型的标记（也被称为数据访问对象或者 DAO）。这个注解的用法是自动异常翻译，如 <a href="data-access.html#orm-exception-translation">4.2.2 Exception translation</a> 中所述。</p>
</div>
<div class="paragraph">
<p>Spring 提供了更多的 stereotype 注解：<code>@Component</code>，<code>@Service</code>，<code>@Controller</code>。<code>@Component</code> 是任何受 Spring 管理组件的通用形式。<code>@Repository</code>，<code>@Service</code>，和<code>@Controller</code> 是 对 <code>@Component</code> 的更具体的特殊化，分别对应持久层，服务层和展示层。因此，你可以用 <code>@Component</code> 来注解你的组件类，但是如果你用 <code>@Repository</code>，<code>@Service</code>，或者 <code>@Controller</code> 来代替 <code>@Component</code> 的话，你的类将更适合于被各种工具处理，或者更适合于在具体切面之间的关联。例如，这些 stereotype 注解为切入点提供了理想的目标。<code>@Repository</code>，<code>@Service</code>，和 <code>@Controller</code> 也可能在 Spring 框架以后的版本中携带额外的语义。因此，如果你正在你的服务层使用
<code>@Component</code> 还是 <code>@Service</code> 选择，<code>@Service</code> 明显是更好的选择。同样，如上所述，作为一个标记，<code>@Repository</code> 已经被支持在你的持久层中进行自动异常翻译。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-meta-annotations"><a class="anchor" href="#beans-meta-annotations"></a>1.10.2. 元注解</h4>
<div class="paragraph">
<p>Spring 提供的许多注解都可以在你自己的代码中当做元注解使用。元注释仅仅就是是一个可以用于另一个注解的注解。例如，上面提到的 <code>@Service</code> 注解就是被 <code>@Component</code> 进行元注解的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.TYPE)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Documented</span>
<strong><span class="annotation">@Component</span></strong> <span class="comment">// Spring will see this and treat @Service in the same way as @Component</span>
<span class="directive">public</span> <span class="annotation">@interface</span> Service {

        <span class="comment">// ....</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>元注解还可以被结合使用来创建 <em>组合注解</em>。例如，Spring MVC 的 <code>@RestController</code> 注解就是由 <code>@Controller</code> 和 <code>@ResponseBody</code> 结合创建的。</p>
</div>
<div class="paragraph">
<p>此外，组合注解可以选择性地重新声明元注解属性来允许用户实现自定义操作。当你只想暴露元注解属性的一部分子集时，这会特别有用。例如，Spring 的 <code>@SessionScope</code> 注解将作用域名硬编码为 <code>session</code> 但仍然允许对 <code>proxyMode</code> 的自定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.TYPE, <span class="predefined-type">ElementType</span>.METHOD})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Documented</span>
<span class="annotation">@Scope</span>(WebApplicationContext.SCOPE_SESSION)
<span class="directive">public</span> <span class="annotation">@interface</span> SessionScope {

        <span class="comment">/**
         * Alias for {@link Scope#proxyMode}.
         * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
         */</span>
        <span class="annotation">@AliasFor</span>(annotation = Scope.class)
        ScopedProxyMode proxyMode() <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后使用 <code>@SessionScope</code> 的时候就不用声明 <code>proxyMode</code> 了，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<strong><span class="annotation">@SessionScope</span></strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SessionScopedService</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者为 <code>proxyMode</code> 赋一个覆盖的值，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<strong><span class="annotation">@SessionScope</span>(proxyMode = ScopedProxyMode.INTERFACES)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SessionScopedUserService</span> <span class="directive">implements</span> UserService {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于更多细节，咨询<a href="appendix.html#annotation-programming-model">Spring 注解编程模型</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-autodetection"><a class="anchor" href="#beans-scanning-autodetection"></a>1.10.3. 自动检测类和注册 bean 定义</h4>
<div class="paragraph">
<p>Spring 能自动检测 stereotyped 类并将相应的 <code>BeanDefinition</code> 注册到 <code>ApplicationContext</code>。例如，一下两个类都可以使用这种自动检测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> SimpleMovieLister(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">JpaMovieFinder</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// implementation elided for clarity</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了自动检测这些类且注册相应的 bean，你需要将 <code>@ComponentScan</code> 添加到你的 <code>@Configuration</code> 类中，其中 <code>basePackages</code> 特性是这两个类的公共父包。（或者，你可以指定由一个逗号/分号/空格分隔的包括每个类的父包的列表。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了简介起见，上面的配置可以使用注解的 <code>value</code> 特性，例如 <code>@ComponentScan("org.example")</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面是使用XML的替代方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对 <code>&lt;context:component-scan&gt;</code> 的使用隐式地启用了<code>&lt;context:annotation-config&gt;</code> 的功能。当使用 <code>&lt;context:component-scan&gt;</code> 是，通常不需要包含 <code>&lt;context:annotation-config&gt;</code> 元素。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对类路径包的扫描要求类路径中存在相应的目录入口。当你使用 Ant 构建 JAR 时，确保不要激活 JAR 任务的 files-only 开关。此外，在某些环境中，基于安全策略类路径目录可能不会暴露出来，例如， JDK 1.7.0_45 及更高版本上的独立应用程序（这需要在你的 manifest 中设置可信库‘Trusted-Library’；参见<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>而且，当你使用 component-scan 元素时，<code>AutowiredAnnotationBeanPostProcessor</code> 和
<code>CommonAnnotationBeanPostProcessor</code> 都是隐式包含的。这意味着这两个组件会被自动检测且装配在一起——所有这些都在没有XML提供任何 bean 配置元数据的情况下实现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以通过将 <em>annotation-config</em>  特性的值设置为 false 来禁用<code>AutowiredAnnotationBeanPostProcessor</code> 和 <code>CommonAnnotationBeanPostProcessor</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-filters"><a class="anchor" href="#beans-scanning-filters"></a>1.10.4. 使用过滤器来自定义扫描</h4>
<div class="paragraph">
<p>默认情况下，使用 <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>，或者本身使用 <code>@Component</code> 注解的自定义注解是唯一被检测到的候选组件。不过，你只需应用自定义过滤器即可修改和扩展此行为。将它们添加为 <code>@ComponentScan</code> 注解的 <em>includeFilters</em> 或者 <em>excludeFilters</em> 参数（或者作为<code>@ComponentScan</code> 元素的 <em>include-filter</em> 或者 <em>exclude-filter</em> 的子元素）。每个过滤器元素都需要 <code>type</code> 和 <code>expression</code> 特性。下表介绍了过滤选项。</p>
</div>
<table id="beans-scanning-filters-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. 过滤类型</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">过滤类型</th>
<th class="tableblock halign-left valign-top">示例表达式</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">annotation （默认）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeAnnotation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">目标组件中呈现的类型级别的注解。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以被目标组件赋值（或者继承/实现）的类（或者接口）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectj</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example..*Service+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个由目标组件匹配的 AspectJ 类型表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org\.example\.Default.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由目标组件类名称匹配的正则表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.MyTypeFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.core.type.TypeFilter</code> 接口的自定义实现。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下示例展示了忽略所有 <code>@Repository</code> 注解的配置，改用“stub” repository。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
   <span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>,
                   includeFilters = <span class="annotation">@Filter</span>(type = FilterType.REGEX, pattern = <span class="string"><span class="delimiter">&quot;</span><span class="content">.*Stub.*Repository</span><span class="delimiter">&quot;</span></span>),
                   excludeFilters = <span class="annotation">@Filter</span>(Repository.class))
   <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用XML的等价配置如下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;context:include-filter</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">regex</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">.*Stub.*Repository</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;context:exclude-filter</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">annotation</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.stereotype.Repository</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/context:component-scan&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你也可以通过在注解中设置 <code>useDefaultFilters=false</code> 或者在 <code>&lt;component-scan/&gt;</code> 元素中设置 <code>use-default-filters="false"</code> 来禁用默认过滤器。这会禁用对带有 <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>，或者 <code>@Configuration</code> 注解类的自动检测。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factorybeans-annotations"><a class="anchor" href="#beans-factorybeans-annotations"></a>1.10.5. 在组件中定义 bean 元数据</h4>
<div class="paragraph">
<p>Spring 组件也可以将 bean 定义元数据提供给容器。你可以使用这同一个 <code>@Bean</code> 注解来定义 <code>@Configuration</code> 注解类中的 bean 元数据。下面是个简单的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="annotation">@Bean</span>
        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean publicInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">publicInstance</span><span class="delimiter">&quot;</span></span>);
        }

        <span class="directive">public</span> <span class="type">void</span> doWork() {
                <span class="comment">// Component method implementation omitted</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个 Spring 组件类，他的 <code>doWork()</code> 方法中包含了与应用相关的业务代码。它还提供了一个具有指向 <code>publicInstance()</code> 工厂方法的 bean 定义。<code>@Bean</code> 注解通过 <code>@Qualifier</code> 注解来标识工厂方法和其他 bean 定义属性，如限定符值。其他可以指定的方法级注解有 <code>@Scope</code>，<code>@Lazy</code>，和自定义限定符注解。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除了用于组件初始化的角色之外，<code>@Lazy</code> 注解还可以用在标记 <code>@Autowired</code> 或者 <code>@Inject</code> 的注入点上。在这种上下文中，它会注入一个懒解析代理。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如前所述，注解支持自动装配的字段和方法，另外还支持 <code>@Bean</code> 方法的自动装配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="directive">private</span> <span class="directive">static</span> <span class="type">int</span> i;

        <span class="annotation">@Bean</span>
        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean publicInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">publicInstance</span><span class="delimiter">&quot;</span></span>);
        }

        <span class="comment">// use of a custom qualifier and autowiring of method parameters</span>
        <span class="annotation">@Bean</span>
        <span class="directive">protected</span> TestBean protectedInstance(
                        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>) TestBean spouse,
                        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{privateInstance.age}</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> country) {
                TestBean tb = <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">protectedInstance</span><span class="delimiter">&quot;</span></span>, <span class="integer">1</span>);
                tb.setSpouse(spouse);
                tb.setCountry(country);
                <span class="keyword">return</span> tb;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">private</span> TestBean privateInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">privateInstance</span><span class="delimiter">&quot;</span></span>, i++);
        }

        <span class="annotation">@Bean</span>
        <span class="annotation">@RequestScope</span>
        <span class="directive">public</span> TestBean requestScopedInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">requestScopedInstance</span><span class="delimiter">&quot;</span></span>, <span class="integer">3</span>);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该示例将另一个名为 <code>privateInstance</code> 的 bean 的 <code>Age</code> 属性值自动装配到<code>String</code> 方法参数 <code>country</code> 中。属性的值通过 Spring 表达式的 <code>#{ &lt;expression&gt; }</code> 符号来定义。对于 <code>@Value</code> 注解，表达式解析器会被预先配置以便它在解析表达式文本是查找 bean 的名字。</p>
</div>
<div class="paragraph">
<p>从 Spring Framework 4.3 开始，你还可以声明一个 <code>InjectionPoint</code> 类型的工厂方法参数（或者 <code>DependencyDescriptor</code> 更具体的子类），以便访问触发创建当前 bean 的请求注入点。注意这只适用于实际的 bean 实例创建，而不适用于现有实例的注入。因此，这个特性对原型作用域 bean 来说是很有意义的。对于其他作用域来说，工厂方法将只会看到触发在给定作用域内创建新的 bean 实例的注入点：例如，触发创建懒加载单例 bean 的依赖项。Use the provided injection point metadata with semantic care in such scenarios（？？）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="annotation">@Bean</span> <span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean prototypeInstance(InjectionPoint injectionPoint) {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototypeInstance for </span><span class="delimiter">&quot;</span></span> + injectionPoint.getMember());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对常规 Spring 组件的 <code>@Bean</code> 方法的处理方式与 Spring <code>@Configuration</code> 类中对应方法的处理方式是不同的。不同之处在于 <code>@Component</code> 类不使用GGLIB来拦截方法和字段的调用。CGLIB 代理是通过在 <code>@Configuration</code> 类中的 <code>@Bean</code> 方法中调用方法或字段来创建对协作对象的 bean 元数据引用；此类方法不是用普通 Java 语义调用的，而是通过容器来提供对 Spring bean 常用的生命周期管理和代理，甚至当通过编程方式调用 <code>@Bean</code> 方法来引用其它 bean 的时候。相比之下，在一个具有标准 Java 语义的普通 <code>@Component</code> 类的 <code>@Bean</code> 方法中调用方法和字段，不会有特殊的 CGLIB 树立和其他约束条件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以将 <code>@Bean</code> 方法声明为 <code>static</code>，从而允许在不创建包含它们的配置类实例的情况下也可以调用它们。这在定义 post-processor bean 如 <code>BeanFactoryPostProcessor</code> 或者
  <code>BeanPostProcessor</code> 时特别有用，因为这类 bean 会在容器的早期生命周期就被初始化，并且会会在那一刻避免触发配置的其它部分。</p>
</div>
<div class="paragraph">
<p>注意对静态 <code>@Bean</code> 方法的调用永远不会被容器拦截，即使在 <code>@Configuration</code> 类中也是如此（参见上文）。这是由于技术上的限制：CGLIB 子类只能覆盖非静态方法。因此，对另一个 <code>@Bean</code> 的直接调用会产生标准 Java 语义，结果就是工厂方法本身直接返回一个独立的实例。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 方法对于 Java 语言的可见性不会对 Spring 容器中 bean 的定义结果产生直接的影响。就像你可以在非 <code>@Configuration</code> 类任何地方看到的，你可以自由地声明工厂方法，静态方法也一样。 但是，<code>@Configuration</code>类中常规的 <code>@Bean</code> 方法需要被覆盖，比如，它们不能被声明为 <code>private</code> 或是 <code>final</code> 的。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 方法会在给定组件或者是配置类的基类上，以及 Java 8 中被组件或者配置类实现的接口的默认方法上见到。这为构建复杂的配置布局提供了很大的灵活性，甚至从 Spring 4.2 起，通过 Java 8 实现多重继承也是可能的。</p>
</div>
<div class="paragraph">
<p>最后，注意同一个类可能会为同一个 bean 持有多个 <code>@Bean</code> 办法，这是根据运行时可用依赖关系来使用多个工厂方法的一种布局。这与在其他配置场景中选择“最贪婪的”构造器或工厂方法的算法相同：容器将会在构建时选择具有最多可满足依赖项的那个，类似于容器如何在多个 <code>@Autowired</code> 构造器中进行选择。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-name-generator"><a class="anchor" href="#beans-scanning-name-generator"></a>1.10.6. 自动检测组件的命名</h4>
<div class="paragraph">
<p>当组件作为扫描过程的一部分被自动检测时，它的 bean 名字会有该扫描器已知的 <code>BeanNameGenerator</code> 策略生成。默认情况下，Spring 的任何包含 <em>name</em> <code>value</code> 的 stereotype 注解（<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，和 <code>@Controller</code>）都会将此 name 作为名字提供给相应的 bean 定义。</p>
</div>
<div class="paragraph">
<p>如果此类注解不包含任何 <em>name</em> <code>value</code> 或者对于其他任何检测到的组件（如自定义过滤器发现的那些），那么默认的 bean 名字生成器会返回一个小写字母开头的非限定类名。例如，如果一下两个组件被检测到，他们的名字将会是 <code>myMovieLister</code> 和 <code>movieFinderImpl</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">myMovieLister</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieFinderImpl</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你不想依赖默认的 bean 命名策略，你可以提供一个自定义 bean 命名策略。首先，实现 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a> 接口，并且确保实现包含一个默认的无参构造器。然后，在配置扫描器的时候提供全限定类名：</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
   <span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, nameGenerator = MyNameGenerator.class)
   <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">name-generator</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.MyNameGenerator</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一般规则就是：只要当其他组件可能正在对其进行显式引用时，考虑用注解指定名字。另一方面，只要是容器负责装配，那么自动生成的名字就足够满足使用了。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-scope-resolver"><a class="anchor" href="#beans-scanning-scope-resolver"></a>1.10.7. 提供自动检测组件的作用域</h4>
<div class="paragraph">
<p>与一般的 Spring 管理的组件一样，自动检测组件的默认和最常见的作用域是 <code>singleton</code>。但是，有时候你会需要通过 <code>@Scope</code> 注解来指定其他不同的作用域。只需在注解中提供作用域名即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieFinderImpl</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于与 web 有关的特定作用域，参见 <a href="#beans-factory-scopes-other">Request, session, application 和 WebSocket 作用域</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要为作用域解析提供一个自定义策略而不依赖基于注解的方式，需要实现 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a> 接口，并且确保实现中有一个默认的无参构造器。然后，在配置扫描器的时候提供全限定类名：</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, scopeResolver = MyScopeResolver.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">scope-resolver</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.MyScopeResolver</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用某些非单例作用域时，可能需要为作用域对象生成代理。原因在 <a href="#beans-factory-scopes-other-injection">作为依赖项的作用域 bean</a> 中阐述了。为此，component-scan 元素提供了可用的 <em>scoped-proxy</em> 特性。三个可选的值是：no，interfaces 和 targetClass。例如，下面的配置会最终产生标准 JDK 动态代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, scopedProxy = ScopedProxyMode.INTERFACES)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">scoped-proxy</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interfaces</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-qualifiers"><a class="anchor" href="#beans-scanning-qualifiers"></a>1.10.8. 限定符元数据注解</h4>
<div class="paragraph">
<p><code>@Qualifier</code> 已经在 <a href="#beans-autowired-annotation-qualifiers">使用 @qualifier 对基于注解的自动装配进行微调</a> 讨论过了。本节中的示例演示在你解析自动装配候选项时如何通过 <code>@Qualifier</code> 注解和自定义限定符来实现细粒度控制。因为这些例子都是基于 XML bean 定义的，所以提供给候选 bean 定义的限定符元数据在这里也是通过使用 XML 中 <code>bean</code> 元素的 <code>qualifier</code> 或者 <code>元</code> 子元素来实现的。当你用类路径扫描来对组件进行自动检测时，就在候选类上配置类型级别的限定符元数据注解。以下三个例子展示了这种技术：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ActionMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ActionMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Offline</span></strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CachingMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与大多数基于注解的代替方案一样，记住注解元数据是与类定义本身绑定在一起的，而XML中的注解允许多个相同类型的  bean 提供其限定符元数据的变体，因为这种情况下，元数据是与每个实例一一对应的，而不是与每个类一一对应。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-index"><a class="anchor" href="#beans-scanning-index"></a>1.10.9. 生成候选组件的索引</h4>
<div class="paragraph">
<p>虽然类路径扫描速度非常快，但通过在编译时创建静态候选列表，可以提高大型应用程序的启动性能。在这种模式下，应用程序的所有模块都必须使用这种机制，当 <code>ApplicationContext</code> 检测到这样的索引时，它将自动使用这个索引而不是扫描类路径。</p>
</div>
<div class="paragraph">
<p>要生成索引，只需向每个包含组件扫描指令的目标组件的模块添加一个附加依赖项即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
                <span class="tag">&lt;groupId&gt;</span>org.springframework<span class="tag">&lt;/groupId&gt;</span>
                <span class="tag">&lt;artifactId&gt;</span>spring-context-indexer<span class="tag">&lt;/artifactId&gt;</span>
                <span class="tag">&lt;version&gt;</span>5.0.0.RELEASE<span class="tag">&lt;/version&gt;</span>
                <span class="tag">&lt;optional&gt;</span>true<span class="tag">&lt;/optional&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;/dependencies&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，对于 Gradle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
        compileOnly(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework:spring-context-indexer:5.0.0.RELEASE</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此过程将生成会被包含在这个 jar 文件中的 <code>META-INF/spring.components</code> 文件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当在你的IDE中使用这个模式是，必须将 <code>spring-context-indexer</code> 注册为注解处理器，以确保候选组件更新时索引是最新的（不过时）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当在类路径上找到 <code>META-INF/spring.components</code> 时，索引会自动启动。如果索引对于某些库（或者某些用例）是部分可用的，而不是对整个应用可用，那么你可以通过将作为系统属性的或者在类路径根目录的 <code>spring.properties</code>文件中的 <code>spring.index.ignore</code> 设置为 <code>true</code> 来回退到使用常规的类路径布局（例如，完全没有索引）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-standard-annotations"><a class="anchor" href="#beans-standard-annotations"></a>1.11. 使用 JSR 330 标准注解</h3>
<div class="paragraph">
<p>从 Spring 3.0 开始，Spring 提供对 JSR-330 标准注解（依赖注入）的支持。这些注解的扫描方式与 Spring 注解相同。你只需要在你的类路径中添加相关的 jar 包就行了。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您正在使用Maven，则可以在标准Maven存储库（http://repo1.maven.org/maven2/javax/inject/javax.inject/1/）中使用 <code>javax.inject</code> artifact。你可以将以下依赖项添加到你的pom.xml 文件中：
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>javax.inject<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>javax.inject<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>1<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-inject-named"><a class="anchor" href="#beans-inject-named"></a>1.11.1. 用 @Inject 和 @Named 进行依赖注入</h4>
<div class="paragraph">
<p>可以使用 <code>@javax.inject.Inject</code> 来代替 <code>@Autowired</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="directive">public</span> <span class="type">void</span> listMovies() {
                <span class="local-variable">this</span>.movieFinder.findMovies(...);
                ...
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>@Autowired</code> 一样，你可以在字段级别，方法级别和构造器参数级别使用 <code>@Inject</code>。 此外，你可以将注入点声明为 <code>Provider</code>，允许按需访问较短作用域的 bean，或者通过 <code>Provider.get()</code> 调用对其他 bean 的惰性访问。作为以上示例的一个变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Provider</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> <span class="predefined-type">Provider</span>&lt;MovieFinder&gt; movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(<span class="predefined-type">Provider</span>&lt;MovieFinder&gt; movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="directive">public</span> <span class="type">void</span> listMovies() {
                <span class="local-variable">this</span>.movieFinder.get().findMovies(...);
                ...
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想为应该注入的依赖项使用限定名，则应该按如下方式使用 <code>@Named</code> 注释</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>) MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-named"><a class="anchor" href="#beans-named"></a>1.11.2. @Named 和 @ManagedBean: @Component 注解的标准等价注解</h4>
<div class="paragraph">
<p><code>@javax.inject.Named</code> 或者 <code>javax.annotation.ManagedBean</code> 可以用来代替 <code>@Component</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">movieListener</span><span class="delimiter">&quot;</span></span>)  <span class="comment">// @ManagedBean(&quot;movieListener&quot;) could be used as well</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>@Component</code> 而不指定组件的名称是很常见的。<code>@Named</code> 可以以类似的方式使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="annotation">@Named</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>@Named</code> 或 <code>@ManagedBean</code> 时，可以像使用 Spring 注解一样使用组件扫描：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与 <code>@Component</code> 相比，JSR-330 <code>@Named</code> 和 JSR-250 code>ManagedBean</code> 注解是不可组合的。 请使用 Spring 的 stereotype 模型来构建自定义组件注解。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-standard-annotations-limitations"><a class="anchor" href="#beans-standard-annotations-limitations"></a>1.11.3.JSR-330 标准注解的局限性</h4>
<div class="paragraph">
<p>当你使用标准注解时，重要的是要知道下表中所示的一些重要特性是不可用的：</p>
</div>
<table id="annotations-comparison" class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. Spring 组件模型元素 vs. JSR-330 变体</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring</th>
<th class="tableblock halign-left valign-top">javax.inject.*</th>
<th class="tableblock halign-left valign-top">javax.inject 限制 / 注释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Autowired</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Inject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Inject</code> 没有 ‘required’ 特性；可以用 Java 8 的 <code>Optional</code> 代替。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Component</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Named / @ManagedBean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330 不提供可组合模型，只是别名命名组件的一种方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Scope("singleton")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Singleton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330 的默认作用域就像 Spring 的 <code>prototype</code> 原型作用域。但是，为了保持与 Spring 的一般默认值一致，Spring 容器中声明的 JSR-330 bean 默认是 code>singleton</code> 单例。为了使用除 <code>singleton</code> 单例之外的作用域，您应该使用 Spring 的 <code>@Scope</code> 注解。<code>javax.inject</code> 还提供了 <a href="http://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a> 注解。 不过，这只是为了用来创建自己的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier / @Named</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Qualifier</code> 只是用来构建自定义限定符的元注解。具体的字符串限定符（如 Spring 的具有值的 <code>@Qualifier</code> ）可以通过 <code>javax.inject.Named</code> 关联。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无等价注解</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无等价注解</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Lazy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无等价注解</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provider</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Provider</code> 是 Spring 的 <code>ObjectFactory</code> 的一个直接替代者，只不过它使用一个较短的 <code>get()</code> 方法名。它也可以与 Spring 的 <code>@Autowired</code> 或者带有非注解构造器和setter 方法结合使用。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-java"><a class="anchor" href="#beans-java"></a>1.12. 基于 Java 代码的容器配置</h3>
<div class="sect3">
<h4 id="beans-java-basic-concepts"><a class="anchor" href="#beans-java-basic-concepts"></a>1.12.1. 基本概念: @Bean 和 @Configuration</h4>
<div class="paragraph">
<p>Spring 新的 Java 配置支持中的中心构件是 <code>@Configuration</code> 注解的类和 <code>@Bean</code> 注解的方法。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 注解用于表示一个用来实例化，配置和初始化一个新的对象的方法，对象是由 Spring IoC 容器管理的。对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code> XML配置的人来说，<code>@Bean</code> 注解和 <code>&lt;bean/&gt;</code> 元素具有相同的作用。你可以对任何 Spring <code>@Component</code> 使用 <code>@Bean</code> 注解的方法，但是它们通常和 <code>@Configuration</code> bean 一起使用。</p>
</div>
<div class="paragraph">
<p>用 <code>@Configuration</code> 注解的类表明它的主要目的是作为 bean 定义的来源。此外，<code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 之间的依赖关系。最简单的 <code>@Configuration</code> 类将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> MyService myService() {
                <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的 <code>AppConfig</code> 类将等同于下面的 Spring <code>&lt;beans/&gt;</code> XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.services.MyServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Full @Configuration vs ‘lite’ @Beans 模式？</div>
<div class="paragraph">
<p>当 <code>@Bean</code> 方法在没有使用 <code>@Configuration</code> 注释的类中声明时，它们被称为在“lite”模式下处理。例如，<code>@Component</code> 中声明的 bean 方法或者一个普通的旧类中的 bean 方法将被视为“lite”。</p>
</div>
<div class="paragraph">
<p>与 full <code>@Configuration</code> 不同，lite @Bean <code>@Bean</code> 方法不能轻易地声明 bean 间的依赖关系。通常，一个 <code>@Bean</code> 方法在'lite'模式下运行时不应该调用另一个 <code>@Bean</code> 方法。</p>
</div>
<div class="paragraph">
<p>仅在 <code>@Configuration</code> 类中使用 <code>@Bean</code> 方法是确保始终使用“full”模式的推荐方法。 这将防止同一个 <code>@Bean</code> 方法被意外调用多次，并有助于减少在“lite”模式下操作时难以追踪的细微错误。</p>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@Bean</code> 和 <code>@Configuration</code> 注解将在下面的章节中深入讨论。首先，我们将介绍使用基于Java的配置创建 Spring 容器的各种方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-instantiating-container"><a class="anchor" href="#beans-java-instantiating-container"></a>1.12.2. 使用 AnnotationConfigApplicationContext 创建 Spring 容器</h4>
<div class="paragraph">
<p>下面的章节介绍了 Spring 3.0 的新特性————<code>AnnotationConfigApplicationContext</code>。这种多功能的 <code>ApplicationContext</code> 实现不仅可以接受作为输入的 <code>@Configuration</code> 类，还可以接受用 JSR-330 元数据注解的类和普通的 <code>@Component</code> 类。</p>
</div>
<div class="paragraph">
<p>当用 <code>@Configuration</code> 类作为输入时，<code>@Configuration</code> 类本身会被注册成为一个 bean 定义，且类中所有声明为 <code>@Bean</code> 的方法也会被注册为 bean 定义。</p>
</div>
<div class="paragraph">
<p>当用 <code>@Component</code> 注解类和 JSR-330 类作为输入时，它们被注册为 bean 定义，且假定在必要时这些类中使用了 DI 元数据（例如 <code>@Autowired</code> 或 <code>@Inject</code>）。 </p>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-contstructor"><a class="anchor" href="#beans-java-instantiating-container-contstructor"></a>简单构建</h5>
<div class="paragraph">
<p>在实例化 <code>AnnotationConfigApplicationContext</code> 时，<code>@Configuration</code> 类可以作为输入参数使用，这与实例化 <code>ClassPathXmlApplicationContext</code> 时使用 Spring XML 文件的方式大致相同。 这使得 Spring 容器可以完全无需使用 XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所述，<code>AnnotationConfigApplicationContext</code> 不仅限于可以使用 <code>@Configuration</code> 类。 任何 <code>@Component</code> 或 JSR-330 注解类都可以作为输入提供给构造器。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面假设 <code>MyServiceImpl</code>，<code>Dependency1</code> 和 <code>Dependency2</code> 使用 Spring 依赖注入注解，例如 <code>@Autowired</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-register"><a class="anchor" href="#beans-java-instantiating-container-register"></a>以编程方式使用 register(Class&lt;?&gt;&#8230;&#8203;) 来构建容器</h5>
<div class="paragraph">
<p><code>AnnotationConfigApplicationContext</code> 可以使用无参数构造器实例化，然后使用 register() 方法进行配置。以编程方式构建 <code>AnnotationConfigApplicationContext</code> 时，此方法特别有用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
        ctx.register(AppConfig.class, OtherConfig.class);
        ctx.register(AdditionalConfig.class);
        ctx.refresh();
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-scan"><a class="anchor" href="#beans-java-instantiating-container-scan"></a>使用 scan(String&#8230;&#8203;) 启用组建扫描</h5>
<div class="paragraph">
<p>要启用组件扫描，只需按如下方式注解你的 <code>@Configuration</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有经验的 Spring 用户会很熟悉下面等价的使用 Spring context:namespace 的XML声明</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在上面的示例中，<code>com.acme</code> 包会被扫描，以查找任何 <code>@Component</code> 注解的类，这些类将在容器中注册为 Spring bean 定义。<code>AnnotationConfigApplicationContext</code> 暴露 <code>scan(String&#8230;&#8203;)</code> 方法以允许你使用相同的组件扫描功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
        ctx.scan(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span>);
        ctx.refresh();
        MyService myService = ctx.getBean(MyService.class);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请记住 <code>@Configuration</code> 类是使用 <code>@Component</code> 进行 <a href="#beans-meta-annotations">元注解</a> 的，所以它们是组件扫描的候选对象！在上面的例子中，假设 <code>AppConfig</code> 是在 <code>com.acme</code> 包（或在它的子包）中声明的，它将在调用 <code>scan()</code> 期间被获取，并且在 <code>refresh()</code> 后，其所有的 <code>@Bean</code> 方法都会被执行且在容器中注册为 bean 定义。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-web"><a class="anchor" href="#beans-java-instantiating-container-web"></a>使用 AnnotationConfigWebApplicationContext 对 Web 应用程序的支持</h5>
<div class="paragraph">
<p><code>AnnotationConfigApplicationContext</code> 的 <code>WebApplicationContext</code> 变体可用于 <code>AnnotationConfigWebApplicationContext</code>。当配置Spring <code>ContextLoaderListener</code> servlet 监听器，Spring MVC <code>DispatcherServlet</code> 等时，可以使用 <code>AnnotationConfigWebApplicationContext</code>。接下来是配置典型 Spring MVC Web 应用程序的 web.xml 代码片段。注意 <code>contextClass</code> context-param 和 init-param 的使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
                instead of the default XmlWebApplicationContext --&gt;</span>
        <span class="tag">&lt;context-param&gt;</span>
                <span class="tag">&lt;param-name&gt;</span>contextClass<span class="tag">&lt;/param-name&gt;</span>
                <span class="tag">&lt;param-value&gt;</span>
                        org.springframework.web.context.support.AnnotationConfigWebApplicationContext
                <span class="tag">&lt;/param-value&gt;</span>
        <span class="tag">&lt;/context-param&gt;</span>

        <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited
                fully-qualified @Configuration classes. Fully-qualified packages may also be
                specified for component-scanning --&gt;</span>
        <span class="tag">&lt;context-param&gt;</span>
                <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
                <span class="tag">&lt;param-value&gt;</span>com.acme.AppConfig<span class="tag">&lt;/param-value&gt;</span>
        <span class="tag">&lt;/context-param&gt;</span>

        <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span>
        <span class="tag">&lt;listener&gt;</span>
                <span class="tag">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/listener-class&gt;</span>
        <span class="tag">&lt;/listener&gt;</span>

        <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span>
        <span class="tag">&lt;servlet&gt;</span>
                <span class="tag">&lt;servlet-name&gt;</span>dispatcher<span class="tag">&lt;/servlet-name&gt;</span>
                <span class="tag">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/servlet-class&gt;</span>
                <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
                        instead of the default XmlWebApplicationContext --&gt;</span>
                <span class="tag">&lt;init-param&gt;</span>
                        <span class="tag">&lt;param-name&gt;</span>contextClass<span class="tag">&lt;/param-name&gt;</span>
                        <span class="tag">&lt;param-value&gt;</span>
                                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
                        <span class="tag">&lt;/param-value&gt;</span>
                <span class="tag">&lt;/init-param&gt;</span>
                <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited
                        and fully-qualified @Configuration classes --&gt;</span>
                <span class="tag">&lt;init-param&gt;</span>
                        <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
                        <span class="tag">&lt;param-value&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/param-value&gt;</span>
                <span class="tag">&lt;/init-param&gt;</span>
        <span class="tag">&lt;/servlet&gt;</span>

        <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span>
        <span class="tag">&lt;servlet-mapping&gt;</span>
                <span class="tag">&lt;servlet-name&gt;</span>dispatcher<span class="tag">&lt;/servlet-name&gt;</span>
                <span class="tag">&lt;url-pattern&gt;</span>/app/*<span class="tag">&lt;/url-pattern&gt;</span>
        <span class="tag">&lt;/servlet-mapping&gt;</span>
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-bean-annotation"><a class="anchor" href="#beans-java-bean-annotation"></a>1.12.3. 使用 @Bean 注解</h4>
<div class="paragraph">
<p><code>@Bean</code> 是一个方法级注解且直接模拟XML的 <code>&lt;bean/&gt;</code> 元素。注解支持 <code>&lt;bean/&gt;</code> 提供的一些特性，比如：<a href="#beans-factory-lifecycle-initializingbean">init-method</a>，<a href="#beans-factory-lifecycle-disposablebean">destroy-method</a>，<a href="#beans-factory-autowire">autowiring</a> 和 <code>name</code>。</p>
</div>
<div class="paragraph">
<p>你可以在 <code>@Configuration</code> 注解类或 <code>@Component</code> 注解类中使用 <code>@Bean</code> 注解。</p>
</div>
<div class="sect4">
<h5 id="beans-java-declaring-a-bean"><a class="anchor" href="#beans-java-declaring-a-bean"></a>bean 声明</h5>
<div class="paragraph">
<p>要声明一个 bean，只需使用@Bean注释来注释一个方法即可。 您可以使用此方法在 <code>ApplicationContext</code> 中注册一个类型指定为方法返回类型的bean 定义。默认情况下，这个 bean 的名字和方法名相同。 以下是一个 <code>@Bean</code> 方法声明的简单示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferServiceImpl transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述配置完全等同于以下 Spring XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transferService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.TransferServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这两种声明都在 <code>ApplicationContext</code> 中创建了一个名为 <code>transferService</code> 的 bean，它与 TransferServiceImpl 类型的对象实例绑定在一起：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>transferService -&gt; com.acme.TransferServiceImpl</pre>
</div>
</div>
<div class="paragraph">
<p>你也可以用接口（或基类）声明你的 <code>@Bean</code> 方法的返回类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这会将提前类型预测的可见性限制为指定的接口类型（<code>TransferService</code>），因为一旦实例化受影响的单例bean，只有容器知道完整类型（<code>TransferServiceImpl</code>）。非懒加载模式的单例 bean 根据它们的声明顺序被实例化，所以你可能会看到不同的类型匹配结果，这取决于另一个组件试图通过一个非声明类型来匹配（比如 code>@Autowired TransferServiceImpl</code>，一旦 “transferService” bean 已经被实例化它才会解析）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你始终通过声明的服务接口来引用你的类型，那么你的 <code>@Bean</code> 返回类型可以安全地加入该设计决策。但是，对于实现多个接口的组件或可能由其实现类型引用的组件，声明最具体的可能返回类型（至少与引用您的bean 的注入点要求相同）会更加安全。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-dependencies"><a class="anchor" href="#beans-java-dependencies"></a>Bean 依赖项</h5>
<div class="paragraph">
<p><code>@Bean</code> 注解方法可以有任意数量的参数来描述构建 bean 所需的依赖关系。例如，如果我们的 <code>TransferService</code> 需要一个 <code>AccountRepository</code> ，我们可以通过一个方法参数实现这个依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService(AccountRepository accountRepository) {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析机制与基于构造器的依赖注入非常相似，请参阅 <a href="#beans-constructor-injection">相关章节</a> 了解更多细节。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-lifecycle-callbacks"><a class="anchor" href="#beans-java-lifecycle-callbacks"></a>接收生命周期回调</h5>
<div class="paragraph">
<p>任何使用 <code>@Bean</code> 注解定义的类都支持常规生命周期回调，并且可以使用 JSR-250 中的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解，请参阅 <a href="#beans-postconstruct-and-predestroy-annotations">JSR-250 annotations</a> 注解以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>常规的Spring <a href="#beans-factory-nature">生命周期</a> 回调也被完全支持。如果一个 bean 实现了<code>InitializingBean</code>，<code>DisposableBean</code> 或者 <code>Lifecycle</code>，容器会调用相应的方法。</p>
</div>
<div class="paragraph">
<p>  诸如 <a href="#beans-beanfactory">BeanFactoryAware</a>，<a href="#beans-factory-aware">BeanNameAware</a>，<a href="#context-functionality-messagesource">MessageSourceAware</a>，<a href="#beans-factory-aware">ApplicationContextAware</a> 等的 <code>*Aware</code> 接口的标准集合也完全受支持。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 注解支持指定任意的初始化和销毁回调方法，就像 Spring XML bean 元素的  <code>init-method</code> 和 <code>destroy-method</code> 属性一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="comment">// initialization logic</span>
        }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Bar</span> {

        <span class="directive">public</span> <span class="type">void</span> cleanup() {
                <span class="comment">// destruction logic</span>
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(initMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }

        <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">cleanup</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Bar bar() {
                <span class="keyword">return</span> <span class="keyword">new</span> Bar();
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，使用具有 public <code>close</code> 或 <code>shutdown</code> 方法的使用 Java 配置定义的 bean 将自动获得一个销毁回调。如果你有一个public <code>close</code> 或 <code>shutdown</code> 方法，并且你不希望在容器关闭的时候调用它，只需要在你的bean定义中添加@Bean（destroyMethod =“”）来禁用默认<code>（inferred）</code>模式。</p>
</div>
<div class="paragraph">
<p>你可能希望为通过 JNDI 获取的资源默认执行此操作，因为对其生命周期的管理在应用程序之外。尤其是，确保始终对<code>DataSource</code> 执行此操作，因为在 Java EE 应用程序服务器上，这是已知的问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">NamingException</span> {
        <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) jndiTemplate.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">MyDS</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，在 <code>@Bean</code> 方法中，通常会选择使用编程式 JNDI 查找：使用 Spring 的 <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> helpers 或直接使用 JNDI <code>InitialContext</code>，而不使用 <code>JndiObjectFactoryBean</code> 变体，因为它会强制你将返回类型声明为 <code>FactoryBean</code> 类型，而不是实际的目标类型，这使得对其他用来引用所提供的资源的 <code>@Bean</code> 方法的交叉引用调用更加困难。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当然，就上面的 <code>Foo</code> 而言，在构造过程中直接调用 <code>init()</code> 方法同样有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Foo foo() {
                Foo foo = <span class="keyword">new</span> Foo();
                foo.init();
            <span class="keyword">return</span> foo;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当您直接使用 Java 时，您可以对对象进行任何操作，而不总是需要依靠容器的生命周期！</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-specifying-bean-scope"><a class="anchor" href="#beans-java-specifying-bean-scope"></a>指定 bean 作用域</h5>
<div class="sect5">
<h6 id="beans-java-available-scopes"><a class="anchor" href="#beans-java-available-scopes"></a>使用 @Scope 注解</h6>
<div class="paragraph">
<p>你可以指定使用 <code>@Bean</code> 注解定义的 bean 应该具有特定的作用域。你可以使用 <a href="#beans-factory-scopes">Bean 作用域</a> 章节中指定的任何标准范围。</p>
</div>
<div class="paragraph">
<p>默认作用域是 <code>singleton</code>，但你可以用 <code>@Scope</code> 注解来覆盖它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> Encryptor encryptor() {
                <span class="comment">// ...</span>
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-scoped-proxy"><a class="anchor" href="#beans-java-scoped-proxy"></a>@Scope 和作用域代理</h6>
<div class="paragraph">
<p>Spring 提供了一个通过 <a href="#beans-factory-scopes-other-injection">作用域代理</a> 来处理作用域依赖的方便方法。使用 XML 配置时创建这种代理的最简单方法是使用 <code>&lt;aop:scoped-proxy/&gt;</code> 元素。在 Java 中配置 bean 的时候使用 @Scope 注解与 proxyMode 特性的支持是等效的。 默认是没有代理（<code>ScopedProxyMode.NO</code>），但您可以指定 <code>ScopedProxyMode.TARGET_CLASS</code> 或 <code>ScopedProxyMode.INTERFACES</code>。</p>
</div>
<div class="paragraph">
<p>如果你将作用域代理示例从 XML 参考文档（请参阅前面的链接）移植到我们使用 Java 的 <code>@Bean</code> 中，它将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span>
<span class="annotation">@Bean</span>
<strong><span class="annotation">@SessionScope</span></strong>
<span class="directive">public</span> UserPreferences userPreferences() {
        <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();
}

<span class="annotation">@Bean</span>
<span class="directive">public</span> Service userService() {
        UserService service = <span class="keyword">new</span> SimpleUserService();
        <span class="comment">// a reference to the proxied userPreferences bean</span>
        service.setUserPreferences(userPreferences());
        <span class="keyword">return</span> service;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-customizing-bean-naming"><a class="anchor" href="#beans-java-customizing-bean-naming"></a>自定义 bean 命名</h5>
<div class="paragraph">
<p>默认情况下，配置类使用 <code>@Bean</code> 方法的名字作为结果 bean 的名字。不过，这个功能可以通过 <code>name</code> 特性来覆盖。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">myFoo</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-aliasing"><a class="anchor" href="#beans-java-bean-aliasing"></a>Bean 别名</h5>
<div class="paragraph">
<p>正如在 <a href="#beans-beanname">bean 的命名</a> 中所讨论的，有时候需要给一个 bena 赋予多个名字，也被称为<em>bean 的别名</em>。为此，<code>@Bean</code> 注解的 <code>name</code> 特性可以接受一个 String 数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(name = { <span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemB-dataSource</span><span class="delimiter">&quot;</span></span> })
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// instantiate, configure and return DataSource bean...</span>
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-description"><a class="anchor" href="#beans-java-bean-description"></a>Bean 描述</h5>
<div class="paragraph">
<p>有时候提供一个更详细的 bean 文本描述是很有帮助的。当 bean 被暴露（可能通过JMX）用于监听目的时，这会特别有用。</p>
</div>
<div class="paragraph">
<p>要向 <code>@Bean</code> 添加描述，可以使用 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Description</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Provides a basic example of a bean</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-configuration-annotation"><a class="anchor" href="#beans-java-configuration-annotation"></a>1.12.4. 使用 @Configuration 注解</h4>
<div class="paragraph">
<p><code>@Configuration</code> 是一个类级别注解，它表明某个对象是某个 bean 定义的来源。<code>@Configuration</code> 类通过 public <code>@Bean</code> 注解方法声明 bean。对 <code>@Configuration</code> 类的 <code>@Bean</code> 方法的调用也可以用来定义 bean 之间的依赖关系。关于基本介绍，参见 <a href="#beans-java-basic-concepts">Basic concepts: @Bean 和 @Configuration</a>。</p>
</div>
<div class="sect4">
<h5 id="beans-java-injecting-dependencies"><a class="anchor" href="#beans-java-injecting-dependencies"></a>Bean 之间依赖关系的注入</h5>
<div class="paragraph">
<p>当 <code>@Bean</code> 之间彼此依赖时，表达这种依赖关系就像调用另一个 bean 方法那样简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Bar bar() {
                <span class="keyword">return</span> <span class="keyword">new</span> Bar();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，<code>foo</code> bean通过构造器注入接收到对 <code>bar</code> 的引用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种声明 bean 间依赖关系的方法只有在 <code>@Configuration</code> 类中声明 <code>@Bean</code> 方法时才起作用。你不能用简单的 <code>@Configuration</code> 类声明 bean 间的依赖关系。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-method-injection"><a class="anchor" href="#beans-java-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>如前所述，<a href="#beans-factory-method-injection">查找方法注入</a> 是一个高级特性，你应该很少使用它。它在一个单例 bean 对原型 bean 依赖时是有用的。使用 Java 对这种类型进行配置提供了一种自然的方式实现这一模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {
        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command interface</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="comment">// okay... but where is the implementation of this method?</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用Java配置支持，您可以创建 <code>CommandManager</code> 的子类，其中抽象 <code>createCommand()</code> 方法被重写，以便查找新的（原型）command 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
<span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> AsyncCommand asyncCommand() {
        AsyncCommand command = <span class="keyword">new</span> AsyncCommand();
        <span class="comment">// inject dependencies here as required</span>
        <span class="keyword">return</span> command;
}

<span class="annotation">@Bean</span>
<span class="directive">public</span> CommandManager commandManager() {
        <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span>
        <span class="comment">// to return a new prototype Command object</span>
        <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() {
                <span class="directive">protected</span> Command createCommand() {
                        <span class="keyword">return</span> asyncCommand();
                }
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-further-information-java-config"><a class="anchor" href="#beans-java-further-information-java-config"></a>有关基于 Java 的配置如何在内部工作的更多信息</h5>
<div class="paragraph">
<p>以下示例显示了一个被调用了两次的 <code>@Bean</code> 注解方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientService clientService1() {
                ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();
                clientService.setClientDao(clientDao());
                <span class="keyword">return</span> clientService;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientService clientService2() {
                ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();
                clientService.setClientDao(clientDao());
                <span class="keyword">return</span> clientService;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientDao clientDao() {
                <span class="keyword">return</span> <span class="keyword">new</span> ClientDaoImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientDao()</code> 在 <code>clientService1()</code> 中被调用一次，在 <code>clientService2()</code> 中也被调用一次。由于此方法创建 <code>ClientDaoImpl</code> 的一个新实例并返回它，通常期望有2个实例（每个 service 一个）。这肯定会有问题：在Spring中，实例化的 bean 默认情况下具有单例 <code>singleton</code> 作用域。下面就是 Spring 魔法所在：所有的 <code>@Configuration</code> 类在 <code>CGLIB</code> 启动时被分类。在子类中，child 方法在调用父方法并创建一个新实例之前首先检查容器是否有缓存的（作用域）bean。请注意，从 Spring 3.2 开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已经在<code>org.springframework.cglib</code> 下重新打包，并直接包含在 Spring-Core JAR 包中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种行为可能会根据您的 bean 的作用域而有所不同。我们在这里讨论单例 bean。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于 CGLIB 在启动时动态添加功能，因此有一些限制，特别是配置类不能是 final 的。但是，从 Spring 4.3 开始，任何构造函数都可以在配置类上使用，包括使用 <code>@Autowired</code>或对默认注入使用单个非默认构造器声明。</p>
</div>
<div class="paragraph">
<p>如果您希望避免任何 CGLIB 限制，请考虑在非 <code>@Configuration</code> 类上声明 <code>@Bean</code> 方法，例如使用简单的 <code>@Component</code> 类。 <code>@Bean</code> 方法之间的跨方法调用将不会被拦截，因此你必须完全依赖于构造器或方法级别的依赖注入。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-composing-configuration-classes"><a class="anchor" href="#beans-java-composing-configuration-classes"></a>1.12.5. 构建基于 Java 的配置</h4>
<div class="sect4">
<h5 id="beans-java-using-import"><a class="anchor" href="#beans-java-using-import"></a>使用 @Import 注解</h5>
<div class="paragraph">
<p>就像在 Spring XML 文件中使用 <code>&lt;import/&gt;</code> 元素来帮助实现配置的模块化一样，<code>@Import</code> 注解允许从另一个配置类加载 <code>@Bean</code> 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigA</span> {

         <span class="annotation">@Bean</span>
        <span class="directive">public</span> A a() {
                <span class="keyword">return</span> <span class="keyword">new</span> A();
        }

}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>(ConfigA.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigB</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> B b() {
                <span class="keyword">return</span> <span class="keyword">new</span> B();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在实例化上下文时，不需要同时指定 <code>ConfigA.class</code> 和 <code>ConfigB.class</code>，只需要显式地提供 <code>ConfigB</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);

        <span class="comment">// now both beans A and B will be available...</span>
        A a = ctx.getBean(A.class);
        B b = ctx.getBean(B.class);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法简化了容器的实例化，因为只有一个类需要处理，而不是要求开发人员在构建过程中记住大量的 <code>@Configuration</code> 类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 4.2开始，<code>@Import</code> 还支持对常规组件类的引用，类似 <code>AnnotationConfigApplicationContext.register</code> 方法。如果您想避免组件扫描，将一些配置类作为明确定义所有组件的入口点，这个支持特别有用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="beans-java-injecting-imported-beans"><a class="anchor" href="#beans-java-injecting-imported-beans"></a>被导入的 @Bean 定义的依赖注入</h6>
<div class="paragraph">
<p>上面的例子可以正常工作，不过是简单的。在大多数实际情况中，bean 将在配置类之间相互依赖。当使用 XML 时，这本身不算是个问题，因为没有涉及到编译器，只需声明 <code>ref="someBean"</code> 并相信 Spring 将在容器初始化期间解决它。当然，在使用 <code>@Configuration</code> 类时，Java 编译器会在配置模型上设置约束，因为对其他 bean 的引用必须是有效的 Java 语法。</p>
</div>
<div class="paragraph">
<p>幸运的是，解决这个问题很简单。<a href="#beans-java-dependencies">正如我们已经讨论过的</a>，<code>@Bean</code> 方法可以有任意数量的描述 bean 依赖关系的参数。考虑一个更现实的场景，其中有几个<code>@Configuration</code> 类，每个类都依赖于在其他类中声明的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService(AccountRepository accountRepository) {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">RepositoryConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository(<span class="predefined-type">DataSource</span> dataSource) {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, RepositoryConfig.class})
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return new DataSource</span>
        }
}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        <span class="comment">// everything wires up across configuration classes...</span>
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有另一种方法可以达到同样的结果。记住，<code>@Configuration</code> 类最终只是容器中的另外一个 bean：这意味着他们可以像其他任何 bean 一样利用 <code>@Autowired</code>和 <code>@Value</code> 注入等等！</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保以这种方式注入的依赖关系只是最简单的一种。 <code>@Configuration</code> 类在上下文的初始化过程的很早起就会被处理，而且强制依赖以这种方式被注入可能会导致未预料的早期初始化。只要有可能，就应该像上面的例子那样，采取基于参数的注入。</p>
</div>
<div class="paragraph">
<p>此外，对 <code>@Bean</code> 注解的 <code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 定义要特别小心。这些应该通常被声明为 <code>static @Bean</code> 方法，而不是触发其包含的配置类的实例化。否则，<code>@Autowired</code> 和 <code>@Value</code> 将不能在配置类本身上工作，因为它太早就被创建为一个 bean 实例。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> AccountRepository accountRepository;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">RepositoryConfig</span> {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">DataSource</span> dataSource;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> RepositoryConfig(<span class="predefined-type">DataSource</span> dataSource) {
                <span class="local-variable">this</span>.dataSource = dataSource;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, RepositoryConfig.class})
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return new DataSource</span>
        }
}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        <span class="comment">// everything wires up across configuration classes...</span>
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Configuration</code> 类中的构造器注入仅在 Spring Framework 4.3 及以上版本中受支持。 另请注意，如果目标 bean 只定义了一个构造器，则不需要指定 <code>@Autowired</code>; 在上面的例子中，<code>RepositoryConfig</code> 的构造器不需要 <code>@Autowired</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-injecting-imported-beans-fq"></a>便于导航的全限定导入 bean</div>
<div class="content">
<div class="paragraph">
<p>在上面的场景中，使用 <code>@Autowired</code> 运行良好，并提供了所需的模块化，但是确定自动装配的 bean 定义的确切位置仍然有些模糊。例如，作为一名开发人员查看一下 <code>ServiceConfig</code>，你如何确切知道 <code>@Autowired AccountRepository</code> bean 的声明位置？这在代码中并不明确，这个例子可能刚好是 OK 的。记住，<a href="https://spring.io/tools/sts">Spring Tool Suite</a> 提供的工具可以渲染拓扑图，显示所有组件是怎么连接起来的 - 这可能就是您所需要的。另外，您的Java IDE可以轻松找到 <code>AccountRepository</code> 类型的所有声明和用法，并且会快速向您显示返回该类型的 <code>@Bean</code> 方法的位置。</p>
</div>
<div class="paragraph">
<p>如果这种歧义是不可接受的，并且你希望从 IDE 中的一个 <code>@Configuration</code> 类直接导航到另一个 <code>@Configuration</code>类，请考虑自动装配配置类本身：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> RepositoryConfig repositoryConfig;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="comment">// navigate 'through' the config class to the @Bean method!</span>
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的情况中，在定义 <code>AccountRepository</code> 的地方非常明确。但是，<code>ServiceConfig</code> 与 <code>RepositoryConfig</code> 就非常紧耦合了;这就是一种妥协。通过使用基于接口的或基于抽象类的 <code>@Configuration</code> 类，可以稍微缓解这种紧密耦合。 考虑以下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> RepositoryConfig repositoryConfig;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">RepositoryConfig</span> {

        <span class="annotation">@Bean</span>
        AccountRepository accountRepository();
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultRepositoryConfig</span> <span class="directive">implements</span> RepositoryConfig {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(...);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, DefaultRepositoryConfig.class})  <span class="comment">// import the concrete config!</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return DataSource</span>
        }

}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，<code>ServiceConfig</code> 与具体的 <code>DefaultRepositoryConfig</code> 耦合就比较松散，内置的 IDE 工具仍然有用：开发人员可以轻松获得 <code>RepositoryConfig</code> 实现的类型层次结构。通过这种方式，导航 <code>@Configuration</code> 类及其依赖关系与通常的基于接口的代码导航过程没有区别。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-conditional"><a class="anchor" href="#beans-java-conditional"></a>有条件地包含 @Configuration 类或 @Bean 方法</h5>
<div class="paragraph">
<p>根据系统的不同状态，有时候需要有条件地启用或禁用完整的 <code>@Configuration</code> 类，甚至单个的 <code>@Bean</code> 方法。 一个常见的例子是，只有在 Spring <code>Environment</code> 中启用了特定的 profile 时，才使用 <code>@Profile</code> 注释来激活bean（有关详细信息，请参阅 <a href="#beans-definition-profiles"> Bean 定义 profile</a>）。</p>
</div>
<div class="paragraph">
<p><code>@Profile</code> 注释实际上是使用一个更为灵活的注解 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a> 来实现的。<code>@Conditional</code> 注解表示特定的 <code>org.springframework.context.annotation.Condition</code> 实现，它会在<code>@Bean</code> 注册之前被引用参考。</p>
</div>
<div class="paragraph">
<p><code>Condition</code> 接口的实现只是提供一个返回 <code>true</code> 或 <code>false</code> 的 <code>matches(&#8230;&#8203;)</code> 方法。例如，下面是用于 <code>@Profile</code> 的某个实际 <code>Condition</code> 实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        <span class="keyword">if</span> (context.getEnvironment() != <span class="predefined-constant">null</span>) {
                <span class="comment">// Read the @Profile annotation attributes</span>
                MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
                <span class="keyword">if</span> (attrs != <span class="predefined-constant">null</span>) {
                        <span class="keyword">for</span> (<span class="predefined-type">Object</span> value : attrs.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>)) {
                                <span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(((<span class="predefined-type">String</span><span class="type">[]</span>) value))) {
                                        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
                                }
                        }
                        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
                }
        }
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html">
  <code>@Conditional</code> javadocs</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-combining"><a class="anchor" href="#beans-java-combining"></a>结合 Java 和 XML 配置</h5>
<div class="paragraph">
<p>Spring 对 <code>@Configuration</code> 类的支持并不是瞄准要成为 Spring XML 的 100％完全的替代方案这个目标。Spring XML 的命名空间等一些工具仍然是配置容器的理想方法。在使用 XML 更方便或必要的情况下，您可以选择：使用 <code>ClassPathXmlApplicationContext</code> 的“以 XML 配置为中心”的方式实例化容器，或者使用 <code>AnnotationConfigApplicationContext</code> 和用 <code>@ImportResource</code> 注解根据需要导入 XML 的“以Java 代码注解为中心”的方式实例化容器 。</p>
</div>
<div class="sect5">
<h6 id="beans-java-combining-xml-centric"><a class="anchor" href="#beans-java-combining-xml-centric"></a>以 XML 配置为中心使用 @Configuration 类</h6>
<div class="paragraph">
<p>最好用 XML 配置文件启动 Spring 容器，并以特定方式包含 <code>@Configuration</code> 类。 例如，在使用Spring XML 的大型现有代码库中，根据需要创建 <code>@Configuration</code> 类并将其包含到现有的 XML 文件中会更容易。下面你会看到在这种“以 XML 配置为中心”的情况下使用<code>@Configuration</code> 类的选择。</p>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-declare-as-bean"></a>将 @Configuration 类声明为普通的 Spring <code>&lt;bean/&gt;</code> 元素。</div>
<div class="content">
<div class="paragraph">
<p>记住，<code>@Configuration</code> 类最终只是容器中的 bean 定义。在这个例子中，我们创建了一个名为<code>AppConfig</code> 的 <code>@Configuration</code> 类，并将其作为 <code>&lt;bean/&gt;</code> 定义包含在 <code>system-test-config.xml</code> 中。由于开启了 <code>&lt;context:annotation-config/&gt;</code>，容器将识别 <code>@Configuration</code> 注解 并正确处理在 <code>AppConfig</code> 中声明的@Bean方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> <span class="predefined-type">DataSource</span> dataSource;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>system-test-config.xml</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span>
        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.AppConfig</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.jdbc.datasource.DriverManagerDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>jdbc.properties</strong>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/system-test-config.xml</span><span class="delimiter">&quot;</span></span>);
        TransferService transferService = ctx.getBean(TransferService.class);
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在上面的 <code>system-test-config.xml</code> 中，<code>AppConfig</code> <code>&lt;bean/&gt;</code> 没有声明一个 <code>id</code> 元素。这样做是可以接受的，这也没有必要因为其他bean 将不会引用它，并且也不可能让容器通过名字获取它。同样，对于 <code>DataSource</code> bean，它只能通过类型自动装配，所以不需要显式的bean <code>id</code>。/p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-component-scan"></a> 使用 &lt;context:component-scan/&gt; 来获取 <code>@Configuration</code> 类</div>
<div class="content">
<div class="paragraph">
<p>因为 <code>@Configuration</code> 是用 <code>@Component</code> 注解的元注解，所以 <code>@Configuration</code> 注解的类会自动成为组件扫描的候选对象。与上面的场景一样，我们可以重新定义 <code>system-test-config.xml</code> 来利用组件扫描带来优势。注意，在这种情况下，我们不需要显式声明 <code>&lt;context:annotation-config/&gt;</code>，因为 <code>&lt;context:component-scan/&gt;</code> 启用了相同的功能。</p>
</div>
<div class="paragraph">
<p><strong>system-test-config.xml</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.jdbc.datasource.DriverManagerDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-combining-java-centric"><a class="anchor" href="#beans-java-combining-java-centric"></a>使用 @ImportResource 将 XML 引入到以 @Configuration 类为中心的配置</h6>
<div class="paragraph">
<p>在以 <code>@Configuration</code> 类为配置容器的主要机制的应用程序中，仍然可能有必要使用一些 XML。在这些场景中，只需使用 <code>@ImportResource</code>，并根据需要定义 XML 的数量。这样做既实现了“以Java为中心”的方式来配置容器，又将 XML 的使用保持在最低限度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ImportResource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/properties-config.xml</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> url;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> username;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> password;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">properties-config.xml
<span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);
        TransferService transferService = ctx.getBean(TransferService.class);
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-environment"><a class="anchor" href="#beans-environment"></a>1.13. 环境抽象</h3>
<div class="paragraph">
<p> <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/Environment.html"><code>环境</code></a> 是一个容器中的抽象模型，它模拟了应用程序环境的两个关键方面：<a href="#beans-definition-profiles"><em>profiles</em></a> 和 <a href="#beans-property-source-abstraction"><em>properties</em></a>。</p>
</div>
<div class="paragraph">
<p><em>profile</em> 是一个命名的 bean 定义逻辑组合，当一个给定的 profile 被激活时它可以被注册到容器中。Bean 可能会通过 XML 或者注解赋值给 profile。与 profile 有关的 <code>Environment</code> 对象角色取决于哪个 profile（如果有的话）当前被激活，哪个 profile（如果有的话）应该默认被激活。</p>
</div>
<div class="paragraph">
<p> Properties 几乎在所有的应用中起着重要作用，并可能来自各种来源：properties 文件，JVM 的系统属性，系统环境变量，JNDI，servlet 上下文参数，特定 properties 对象，Map，等等。<code>Environment</code> 对象的角色与 property 相关，它的作用是为用户提供一个方便的服务接口，用于配置属性源并解析它们。</p>
</div>
<div class="sect3">
<h4 id="beans-definition-profiles"><a class="anchor" href="#beans-definition-profiles"></a>1.13.1. Bean 定义 profile</h4>
<div class="paragraph">
<p>Bean 定义 profile 是核心容器中的一种机制，允许在不同的环境中注册不同的 bean。<em>environment</em> 这个词对于不同的用户来说有不同的含义，这个特性可以很多情况都有用，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在开发环境中使用内存数据源 vs 在 QA 或者生产环境中用 JNDI 寻找相同数据源</p>
</li>
<li>
<p>仅在将应用程序部署到某个性能测试环境时注册监听基础组件</p>
</li>
<li>
<p>为客户 A 注册自定义 bean 实现 vs. 为客户 B 注册自定义 bean 实现</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑需要实际应用中的使用 <code>DataSource</code> 的第一个例子。在测试环境中，配置可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-schema.sql</span><span class="delimiter">&quot;</span></span>)
                .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-test-data.sql</span><span class="delimiter">&quot;</span></span>)
                .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们考虑如何将这个应用程序部署到 QA 或生产环境中，假设应用程序的数据源将被注册到生产应用程序服务器的JNDI 目录中。我们的 <code>dataSource</code> bean 现在看起来是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
        <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题是如何根据当前的环境来切换使用这两种变体。随着时间的推移，Spring 用户设计了许多方法来处理这个问题，通常依赖于系统环境变量和包含 <code>${placeholder}</code> 的 XML <code>&lt;import/&gt;</code> 语句的组合，它们根据环境变量值解析正确的配置文件路径。Bean 定义 profile 作为一个核心容器功能为这个问题提供了一种解决方案。</p>
</div>
<div class="paragraph">
<p>如果我们概括一下上面这个特定于环境的 bean 定义的用例，我们最终需要在特定的上下文中注册特定的 bean 定义，而不是在其他上下文中。你可以说你想在场景 A 中注册一个特定的 bean 定义 profile，而在场景 B 中需要注册一个不同的配置文件。我们先看看如何更新我们的配置来反映这个需求。</p>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-java"><a class="anchor" href="#beans-definition-profiles-java"></a>@Profile</h5>
<div class="paragraph">
<p>当一个或多个指定的profile 被激活时，<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a> 注解允许你指定其中一个组件可以被注册。使用我们上面的例子，我们可以如下重写 <code>dataSource</code> 配置： </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">StandaloneDataConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">JndiDataConfig</span> {

        <span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
                <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
                <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如前所述，通常会在有 <code>@Bean</code> 方法的情况下选择使用编程JNDI查找：使用 Spring 的 <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> 帮助程序或上面展示的直接的 JNDI <code>InitialContext</code> 用法，但不能是 <code>JndiObjectFactoryBean</code> 变体，这会强制你将返回类型声明为 <code>FactoryBean</code> 类型。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p> <code>@Profile</code> 可以被当做 <a href="#beans-meta-annotations">元注释</a> 用于创建自定义 <em>组合注解</em>。以下示例定义了可以直接替代 <code>@Profile("production")</code> 自定义 <code>@Production</code> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.TYPE)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="annotation">@interface</span> Production {
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果某个 <code>@Configuration</code> 类用了 <code>@Profile</code> 注解，则除非一个或多个指定的 profile 处于激活状态，否则与该类关联的所有 <code>@Bean</code> 方法和 <code>@Import</code> 注解将被绕过（忽略）。 如果一个 <code>@Component</code> 或者 <code>@Configuration</code> 类被标记为 <code>@Profile({"p1", "p2"})</code>，那么这个类将不会被注册/处理，除非 profile 'p1'和/或'p2'被激活。如果一个给定的 profile 以NOT运算符（<code>!</code>）为前缀，那么如果该 profile 没有被激活，注解的元素将被注册。例如，给定 <code>@Profile({"p1", "!p2"})</code>，如果配置文件“p1”处于激活状态或配置文件“p2”未激活，则会发生注册。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Profile</code> 可以在方法级被声明，包括只有一个特定 bean 的 configuration 类，例如，同一个特定 bean 的变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>)
        <strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> standaloneDataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }

        <span class="annotation">@Bean</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>)
        <strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> jndiDataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
                <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
                <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <code>@Bean</code> 方法上使用 <code>@Profile</code> 时，可能会遇到一个特殊情况：对于重载的方法名相同的 <code>@Bean</code> 方法（类似于构造器重载），必须在所有重载的方法上一致地声明 <code>@Profile</code> 条件。如果条件不一致，那么只有重载方法中第一个声明的条件会有用。因此 <code>@Profile</code> 不能被用使用特定的参数签名来区分重载方法；同一个 bean 的所有工厂方法之间的解析在创建时遵循 Spring 的构造器解析算法。</p>
</div>
<div class="paragraph">
<p>如果您想定义具有不同 profile 的备用 bean，应该使用不同的 Java 方法名，通过 <code>@Bean</code> 的 name 特性指向同一个 bean 名字，就像上例所示。如果参数签名都是相同的（例如，所有的变体都有无参工厂方法），这是在 Java 类中表示这种布局的唯一方法（因为对特定相同的方法名和参数签名只有一个方法有效）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-xml"><a class="anchor" href="#beans-definition-profiles-xml"></a>XML bean 定义 profiles</h5>
<div class="paragraph">
<p>在 XML 中与 profile 注解对应的是 <code>&lt;beans&gt;</code> 元素的 <code>profile</code> 特性。上面的示例配置可以重写为下面两个 XML 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jdbc</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jdbc</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;jdbc:embedded-database</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/jdbc:embedded-database&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jee</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;jee:jndi-lookup</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">jndi-name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以将这些配置放在同一个文件中以避免使用分割和嵌套的 <code>&lt;beans/&gt;</code> 元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jdbc</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jdbc</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jee</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- other bean definitions --&gt;</span>

        <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jdbc:embedded-database</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/jdbc:embedded-database&gt;</span>
        <span class="tag">&lt;/beans&gt;</span>

        <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jee:jndi-lookup</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">jndi-name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/beans&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>spring-bean.xsd</code> 被限制为只允许这些元素作为文件中的最后一个元素出现。这在不对 XML 文件造成混乱的前提下提供了灵活性。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-enable"><a class="anchor" href="#beans-definition-profiles-enable"></a>激活 profile</h5>
<div class="paragraph">
<p>现在我们已经更新了配置，我们仍然需要指示 Spring 哪个 profile 处于激活状态。如果我们现在启动我们的示例应用程序，我们会看到一个 <code>NoSuchBeanDefinitionException</code> 异常抛出，因为容器找不到名为 <code>dataSource</code> 的 Spring bean。</p>
</div>
<div class="paragraph">
<p>激活一个 profile 可以通过几种方式来完成，但最直接的方法是通过 <code>ApplicationContext</code> 的 <code>Environment</code> API 对其进行编程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，profile 还可以通过 <code>spring.profiles.active</code> 属性声明式地激活，该属性可能通过系统环境变量，JVM 系统属性，web.xml 中的 servlet 上下文参数，甚至作为 JNDI 中的条目来指定（请参阅 <a href="#beans-property-source-abstraction">PropertySource 抽象</a>）。在集成测试中，可以通过 <code>spring-test</code> 模块中的 <code>@ActiveProfiles</code> 注解声明来激活 profile（请参阅 <a href="testing.html#testcontext-ctx-management-env-profiles">用环境 profile 进行上下文配置</a>）。</p>
</div>
<div class="paragraph">
<p>注意，profile 不是一个“非此即彼”的或命题; 一次可以激活多个配置文件。采用编程方式，只需向 <code>setActiveProfiles()</code> 方法提供多个 profile 名字，该方法接受<code>String&#8230;&#8203;</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ctx.getEnvironment().setActiveProfiles(<span class="string"><span class="delimiter">&quot;</span><span class="content">profile1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">profile2</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果是声明式方式，<code>spring.profiles.active</code> 可以接受逗号分隔的 profile 名列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">-Dspring.profiles.active=<span class="string"><span class="delimiter">&quot;</span><span class="content">profile1,profile2</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-default"><a class="anchor" href="#beans-definition-profiles-default"></a>默认 profile</h5>
<div class="paragraph">
<p><em>默认</em> profile 表示默认启用的 profile。考虑下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">default</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultDataConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 profile 被激活，上面的 <code>dataSource</code> 将被创建; 这可以看作是为一个或多个 bean 提供 <em>默认</em> 定义的一种方式。如果启用了任何 profile，则不会应用 <em>默认</em> profile。</p>
</div>
<div class="paragraph">
<p>默认 profile 的名称可以用 <code>Environment</code> 中的 <code>setDefaultProfiles()</code> 更改，或者使用 <code>spring.profiles.default</code> 属性进行声明式更改。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-property-source-abstraction"><a class="anchor" href="#beans-property-source-abstraction"></a>1.13.2. PropertySource 抽象</h4>
<div class="paragraph">
<p>Spring 的 <code>Environment</code> 抽象提供了对属性资源的可配置层次结构的搜索操作。为了充分解释，考虑下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();
Environment env = ctx.getEnvironment();
<span class="type">boolean</span> containsFoo = env.containsProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Does my environment contain the 'foo' property? </span><span class="delimiter">&quot;</span></span> + containsFoo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码片段中，我们看到了一个高级的方式来询问 Spring 是否为当前环境定义了 <code>foo</code> 属性。为了回答这个问题，<code>Environment</code> 对象对一组 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a> 对象执行搜索。<code>PropertySource</code> 是对任意 key-value 键值对的一个简单抽象，Spring 的 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a> 配置了两个PropertySource 对象，一个表示一组 JVM 系统属性（访问方式 System.getProperties()），一个表示一组系统环境 变量（访问方式 System.getenv()）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这些在 <code>StandardEnvironment</code> 中的默认属性源会用于独立应用程序。<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a> 填充了额外的默认属性源，包括 servlet 配置和 servlet 上下文参数。 它可以选择性地启用 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a> 。有关详细信息，请参阅相关 javadoc。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>具体来说，当你使用 <code>StandardEnvironment</code> 时，如果在运行时时刻存在 <code>foo</code> 系统属性或 <code>foo</code> 环境变量，则对 <code>env.containsProperty("foo")</code> 的调用将返回true。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>搜索的执行是分层进行的。默认情况下，系统属性优先于环境变量，所以如果在调用 <code>env.getProperty("foo")</code> 的时候，<code>foo</code> 属性碰巧在两个地方都有设置，那么系统属性值就“赢了”，并会优先于环境变量而返回。注意，属性值不会被合并，而是被优先级高的 entry 完全覆盖。</p>
</div>
<div class="paragraph">
<p>对于常见的 <code>StandardServletEnvironment</code>，完整的层次结构如下所示，最高优先级 entry 在最上面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ServletConfig 参数（如果适用，例如 在 <code>DispatcherServlet</code> 上下文的情况下）</p>
</li>
<li>
<p>ServletContext 参数 (web.xml context-param entries)</p>
</li>
<li>
<p>JNDI 环境变量 ("java:comp/env/" entries)</p>
</li>
<li>
<p>JVM 系统属性 ("-D" command-line 参数)</p>
</li>
<li>
<p>JVM 系统环境 (操作系统环境变量)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最重要的是，这整个机制是可配置的。也许你有一个自定义的属性来源，你想将他集成到这个搜索过程中。没问题 - 只需实现并实例化您自己的 <code>PropertySource</code> 并将其添加到当前  <code>Environment</code> 的 <code>PropertySources</code> 集合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConfigurableApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(<span class="keyword">new</span> MyPropertySource());</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码中，<code>MyPropertySource</code> 在搜索中的优先级最高。如果它包含 <code>foo</code> 属性，则这个属性会在任何其他  <code>PropertySource</code> 中的 <code>foo</code> 属性之前被检测到并返回。<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a> API 暴露了许多允许精确操作属性源集的方法。.</p>
</div>
</div>
<div class="sect3">
<h4 id="propertysource"><a class="anchor" href="#propertysource"></a>1.13.3. @PropertySource</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> 注解提供了一个便捷的声明机制，用于将一个 <code>PropertySource</code> 添加到Spring的 <code>Environment</code> 中。</p>
</div>
<div class="paragraph">
<p>给定一个包含键/值对 <code>testbean.name=myTestBean</code> 的文件“app.properties”，下面的 <code>@Configuration</code> 类使用了<code>@PropertySource</code>，以便对 <code>testBean.getName()</code> 的调用返回“myTestBean”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@PropertySource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/myco/app.properties</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

 <span class="annotation">@Autowired</span>
 Environment env;

 <span class="annotation">@Bean</span>
 <span class="directive">public</span> TestBean testBean() {
  TestBean testBean = <span class="keyword">new</span> TestBean();
  testBean.setName(env.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">testbean.name</span><span class="delimiter">&quot;</span></span>));
  <span class="keyword">return</span> testBean;
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何在 <code>@PropertySource</code> 资源定位中的 <code>${&#8230;&#8203;}</code> 占位符都会被解析，用于在环境中注册的一组属性源，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@PropertySource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/${my.placeholder:default/path}/app.properties</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

 <span class="annotation">@Autowired</span>
 Environment env;

 <span class="annotation">@Bean</span>
 <span class="directive">public</span> TestBean testBean() {
  TestBean testBean = <span class="keyword">new</span> TestBean();
  testBean.setName(env.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">testbean.name</span><span class="delimiter">&quot;</span></span>));
  <span class="keyword">return</span> testBean;
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设“my.placeholder”存在于已经注册的一个属性源中，例如系统属性或环境变量，占位符将被解析为相应的值。 如果没有找到，则默认使用“default/path”路径。如果没有指定默认值，而且无法解析属性，则会抛出 <code>IllegalArgumentException</code> 异常。</p>
</div>
</div>
<div class="sect3">
<h4 id="placeholder-resolution-in-statements"><a class="anchor" href="#placeholder-resolution-in-statements"></a>1.13.4. 语句中的占位符解析</h4>
<div class="paragraph">
<p>从历史上看，元素中占位符的值只能根据 JVM 系统属性或环境变量来解决。现在这种情况已经不复存在。由于环境抽象被集成到整个容器中，通过它可以轻松地路由占位符的解析。这意味着你可以用任何你喜欢的方式配置解析过程：改变搜索系统属性和环境变量的优先级，或者完全删除它们; 根据需要添加您自己的属性源来混合使用。</p>
</div>
<div class="paragraph">
<p>具体而言，只要在 <code>Environment</code> 中可用，无论 <code>customer</code> 属性是在哪里定义的，以下语句都可以正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com/bank/service/${customer}-config.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context-load-time-weaver"><a class="anchor" href="#context-load-time-weaver"></a>1.14. 注册 LoadTimeWeaver</h3>
<div class="paragraph">
<p>当类被加载到 Java 虚拟机（JVM）的时候，Spring 使用 <code>LoadTimeWeaver</code> 对它们进行动态转换。</p>
</div>
<div class="paragraph">
<p>要启用加载时织入，可以将 <code>@EnableLoadTimeWeaving</code> 添加到其中一个 <code>@Configuration</code> 类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableLoadTimeWeaving</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，对于 XML 配置，使用上下文：<code>context:load-time-weaver</code>元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:load-time-weaver</span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦配置了 <code>ApplicationContext</code>，该 <code>ApplicationContext</code> 中的任何 bean 都可以实现 <code>LoadTimeWeaverAware</code>，从而接收对加载时 weaver 实例的引用。这与 <a href="data-access.html#orm-jpa">Spring 的 JPA 支持</a> 相结合是非常有用的，JPA 类转换可能需要加载时织入。 有关更多详细信息，请参阅 <code>LocalContainerEntityManagerFactoryBean</code> javadoc。有关 AspectJ 加载时织入的更多信息，请参阅 <a href="#aop-aj-ltw">Spring 框架中使用 AspectJ 进行加载时织入</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="context-introduction"><a class="anchor" href="#context-introduction"></a>1.15. ApplicationContext 的其他附加功能</h3>
<div class="paragraph">
<p>正如本章简介中所讨论的，<code>org.springframework.beans.factory</code> 包提供了用于管理和操作 bean 的基本功能，包括以编程的方式。<code>org.springframework.context</code> 包添加了扩展了 <code>BeanFactory</code> 接口的 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a> 接口，并扩展了其他接口，以更多的面向应用程序框架的风格提供附加功能。很多人以完全声明的方式使用 <code>ApplicationContext</code> ，甚至不是以编程方式创建它，而是依赖诸如 <code>ContextLoader</code> 之类的支持类自动实例化 <code>ApplicationContext</code> ，并将它作为 Java EE Web 应用程序正常启动过程的一部分。</p>
</div>
<div class="paragraph">
<p>为了以更加面向框架的风格增强 <code>BeanFactory</code> 功能，上下文包还提供了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过 <code>MessageSource</code> 接口，<em>以国际化风格访问消息</em>。</p>
</li>
<li>
<p>通过 <code>ResourceLoader</code> 接口 <em>访问资源</em>，例如 URL 和文件。</p>
</li>
<li>
<p>通过使用 <code>ApplicationEventPublisher</code> 接口，将 <em>Event 发布</em> 到实现 <code>ApplicationListener</code> 接口的 bean。</p>
</li>
<li>
<p>通过 <code>HierarchicalBeanFactory</code> 接口 <em>加载多个（层次）上下文</em>，允许每个上下文关注一个特定的层，例如应用程序的 web 层。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="context-functionality-messagesource"><a class="anchor" href="#context-functionality-messagesource"></a>1.15.1. 使用 MessageSource 实现国际化</h4>
<div class="paragraph">
<p><code>ApplicationContext</code> 接口扩展了一个名为 <code>MessageSource</code> 的接口，且提供了国际化（i18n）功能。Spring 还提供了 <code>HierarchicalMessageSource</code> 接口，它可以分层解析消息。这些接口一起为 Spring 消息解析提供了基础。这些接口上定义的方法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从 <code>MessageSource</code> 中检索消息的基本方法。当找不到指定语言环境的消息时，将使用默认消息。</p>
</li>
<li>
<p><code>String getMessage(String code, Object[] args, Locale loc)</code>：基本上与前面的方法相同，但有一点不同：不能指定默认消息; 如果无法找到消息，则抛出 <code>NoSuchMessageException</code> 异常。</p>
</li>
<li>
<p><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面的方法中使用的所有属性也都包装在一个名为 <code>MessageSourceResolvable</code> 的类中，您可以在该方法中使用它。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当一个 <code>ApplicationContext</code> 被加载时，它会自动搜索上下文中定义的 <code>MessageSource</code> bean。该 bean 的名字必须为 <code>messageSource</code>。如果能找到这样一个 bean，所有对前面方法的调用都被委托给这个消息源。如果没有找到消息源，则 <code>ApplicationContext</code> 将尝试查找父容器中包含的同名 bean 。如果找到了这样的 bean，它将使用该 bean 作为 <code>MessageSource</code>。如果 <code>ApplicationContext</code> 找不到任何消息源，就会实例化一个空的 <code>DelegatingMessageSource</code>，以便能够接受对上面定义的方法的调用。</p>
</div>
<div class="paragraph">
<p>Spring 提供了两个 <code>MessageSource</code> 实现，<code>ResourceBundleMessageSource</code> 和
  <code>StaticMessageSource</code>。两者都实现了  <code>HierarchicalMessageSource</code> 以进行消息的嵌套传递。 <code>StaticMessageSource</code> 很少使用，但它提供了以编程方式来添加消息到源的功能。以下示例中显示了 <code>ResourceBundleMessageSource</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ResourceBundleMessageSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">basenames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;list&gt;</span>
                                <span class="tag">&lt;value&gt;</span>format<span class="tag">&lt;/value&gt;</span>
                                <span class="tag">&lt;value&gt;</span>exceptions<span class="tag">&lt;/value&gt;</span>
                                <span class="tag">&lt;value&gt;</span>windows<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;/list&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，假设你在你的类路径中定义了三个 resource bundle ，分别叫做 <code>format</code>，<code>exceptions</code> 和 <code>windows</code>。任何解析消息的请求都将以 JDK 标准方式通过 ResourceBundles 解析消息。为了达到这个例子的目的，假设前两个 resource bundle 文件的内容是...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span> in format.properties
message=Alligators rock!</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span> in exceptions.properties
argument.required=The {<span class="integer">0</span>} argument is required.</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例中显示了执行 <code>MessageSource</code> 功能的程序。记住，所有 <code>ApplicationContext</code> 实现也是 <code>MessageSource</code> 实现，因此可以转换为 <code>MessageSource</code>接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> message = resources.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Default</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);
        <span class="predefined-type">System</span>.out.println(message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面这个程序的输出结果应该是这样的...</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Alligators rock!</pre>
</div>
</div>
<div class="paragraph">
<p>所以总结一下，<code>MessageSource</code> 被定义在一个名为 <code>beans.xml</code> 的文件中，该文件存在于你的类路径的根目录下。<code>messageSource</code> bean 定义通过其 <code>basenames</code> 属性来引用许多 resource bundle。在列表中传递给 <code>basenames</code> 属性的三个文件存在于类路径的根目录下，分别名为<code>format.properties</code>，<code>exceptions.properties</code>，和 <code>windows.properties</code>。</p>
</div>
<div class="paragraph">
<p>下一个示例展示了参数用于消息查找; 这些参数将被转换为字符串并插入到查找消息中的占位符中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>

        <span class="comment">&lt;!-- this MessageSource is being used in a web application --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ResourceBundleMessageSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">basename</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exceptions</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- lets inject the above MessageSource into this POJO --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.Example</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messages</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Example</span> {

        <span class="directive">private</span> MessageSource messages;

        <span class="directive">public</span> <span class="type">void</span> setMessages(MessageSource messages) {
                <span class="local-variable">this</span>.messages = messages;
        }

        <span class="directive">public</span> <span class="type">void</span> execute() {
                <span class="predefined-type">String</span> message = <span class="local-variable">this</span>.messages.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">argument.required</span><span class="delimiter">&quot;</span></span>,
                        <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">userDao</span><span class="delimiter">&quot;</span></span>}, <span class="string"><span class="delimiter">&quot;</span><span class="content">Required</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);
                <span class="predefined-type">System</span>.out.println(message);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用 <code>execute()</code> 方法的结果输出将是...</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The userDao argument is required.</pre>
</div>
</div>
<div class="paragraph">
<p>关于国际化（i18n），Spring 的各种 <code>MessageSource</code> 实现遵循与标准的 JDK <code>ResourceBundle</code>相同的 locale 解析和回退规则。简而言之，继续前面定义的 <code>messageSource</code> 示例，如果要解析 British（en-GB）locale 的消息，则需要分别创建名为 <code>format_en_GB.properties</code>，<code>exceptions_en_GB.properties</code> 和 <code>windows_en_GB.properties</code> 的三个文件。</p>
</div>
<div class="paragraph">
<p>通常，locale 解析由应用程序的所处的环境决定。在这个例子中，（British）消息将被解析的本地化是手动指定的。</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in exceptions_en_GB.properties
argument.required=Ebagum lad, the {0} argument is required, I say, required.</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) {
        MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> message = resources.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">argument.required</span><span class="delimiter">&quot;</span></span>,
                <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">userDao</span><span class="delimiter">&quot;</span></span>}, <span class="string"><span class="delimiter">&quot;</span><span class="content">Required</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Locale</span>.UK);
        <span class="predefined-type">System</span>.out.println(message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行上面的程序得到的输出结果是...</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ebagum lad, the 'userDao' argument is required, I say, required.</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>MessageSourceAware</code> 接口来获取对已定义的任何 <code>MessageSource</code> 的引用。 任何在实现 <code>MessageSourceAware</code> 接口的 <code>ApplicationContext</code>  中定义的 bean 在被创建和配置的时候都会被应用程序上下文中的 <code>MessageSource</code>注入。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
  <p><em>作为 <code>ResourceBundleMessageSource</code> 的替代着，Spring 提供了一个 <code>ReloadableResourceBundleMessageSource</code> 类。这个变体支持相同的 bundle 文件格式，但比标准的基于 JDK 的 <code>ResourceBundleMessageSource</code> 实现更加灵活。</em> 特别是，它允许从任何 Spring 资源路径（而不仅仅是从类路径）读取文件，并支持热重新加载 bundle 属性文件（同时高效地缓存它们之间）。查看 <code>ReloadableResourceBundleMessageSource</code> javadoc 获取详细信息。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-events"><a class="anchor" href="#context-functionality-events"></a>1.15.2. 标准事件和自定义事件</h4>
<div class="paragraph">
<p><code>ApplicationContext</code> 中的事件处理是通过 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口提供的。如果一个实现 <code>ApplicationListener</code> 接口的 bean 被部署到上下文中，则每当 <code>ApplicationEvent</code> 发布到 <code>ApplicationContext</code> 时，都会通知该 bean。实质上，这是标准的 <em>Observer</em> 设计模式。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从 Spring 4.2 开始，事件基础架构得到了显着的改进，并提供了 <a href="#context-functionality-events-annotation">基于注解的模型</a> 以及发布任意事件的能力，这个事件对象不一定是 <code>ApplicationEvent</code> 的扩展对象。当这样的事件对象发布时，我们会将它包装在一个事件中再向你提供。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring 提供一下标准事件：</p>
</div>
<table id="beans-ctx-events-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. 内置事件</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">事件</th>
<th class="tableblock halign-left valign-top">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextRefreshedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 初始化或刷新时发布，例如在 <code>ConfigurableApplicationContext</code> 接口中使用 <code>refresh()</code> 方法。这里的“初始化”指的是所有 bean 都加载完成，所有 post-processor bean 被检测和激活，所有单例 bean 被预实例化，且 <code>ApplicationContext</code> 处于使用就绪状态。只要上下文没有被关闭，如果所选的 <code>ApplicationContext</code> 实际上支持这种“热”刷新，那么 refresh 就可以被多次触发。例如，<code>XmlWebApplicationContext</code> 支持热刷新，而 <code>GenericApplicationContext</code> 就不支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStartedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 启动的时候发布，使用 <code>ConfigurableApplicationContext</code> 接口的 <code>start()</code> 方法。这里的“启动”意思是所有的 <code>Lifecycle</code> bean 接收到显式的启动信号。通常这个信号用于在显式停止后对 bean 的后重新启动，但它也有可能用于启动那些未配置为自动启动的组件，例如在初始化阶段没有启动的组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStoppedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 停止的时候发布，使用 <code>ConfigurableApplicationContext</code> 接口的 <code>stop()</code> 方法。这里的“停止”意思是所有的 <code>Lifecycle</code> bean 接收到显式的停止信号。已经停止的上下文可以通过对 <code>start()</code> 的调用来重新启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextClosedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 关闭的时候发布，使用 <code>ConfigurableApplicationContext</code> 接口的 <code>close()</code> 方法。这里的“关闭”意思是所有的单例 bean 都被销毁。一个关闭的上下文已经走到其生命的终点；它不能被刷新或者重启。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个特定的 web 相关事件，它告诉所有 bean 已经对某个 HTTP 请求进行服务。这个时间会在这个请求完成 <em>之后</em> 发布。此事件只适用于使用 Spring 的 <code>DispatcherServlet</code> 的 web 应用程序。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你也可以创建并发布你的自定义事件。本例演示了一个扩展了 Spring 的 <code>ApplicationEvent</code> 基类的简单类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListEvent</span> <span class="directive">extends</span> ApplicationEvent {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> address;
        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> test;

        <span class="directive">public</span> BlackListEvent(<span class="predefined-type">Object</span> source, <span class="predefined-type">String</span> address, <span class="predefined-type">String</span> test) {
                <span class="local-variable">super</span>(source);
                <span class="local-variable">this</span>.address = address;
                <span class="local-variable">this</span>.test = test;
        }

        <span class="comment">// accessor and other methods...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要发布自定义 <code>ApplicationEvent</code> ，需要在 <code>ApplicationEventPublisher</code> 上调用 <code>publishEvent()</code> 方法。通常这是通过创建一个实现了 <code>ApplicationEventPublisherAware</code> 的类并将其注册为一个 Spring bean 来完成的。 下面的例子演示了这样一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">EmailService</span> <span class="directive">implements</span> ApplicationEventPublisherAware {

        <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; blackList;
        <span class="directive">private</span> ApplicationEventPublisher publisher;

        <span class="directive">public</span> <span class="type">void</span> setBlackList(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; blackList) {
                <span class="local-variable">this</span>.blackList = blackList;
        }

        <span class="directive">public</span> <span class="type">void</span> setApplicationEventPublisher(ApplicationEventPublisher publisher) {
                <span class="local-variable">this</span>.publisher = publisher;
        }

        <span class="directive">public</span> <span class="type">void</span> sendEmail(<span class="predefined-type">String</span> address, <span class="predefined-type">String</span> text) {
                <span class="keyword">if</span> (blackList.contains(address)) {
                        BlackListEvent event = <span class="keyword">new</span> BlackListEvent(<span class="local-variable">this</span>, address, text);
                        publisher.publishEvent(event);
                        <span class="keyword">return</span>;
                }
                <span class="comment">// send email...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在配置时，Spring 容器会检测到 <code>EmailService</code> 实现了 <code>ApplicationEventPublisherAware</code> ，并且会自动调用 <code>setApplicationEventPublisher()</code>。实际上，传入的参数是 Spring 容器本身; 你只需通过 <code>ApplicationEventPublisher</code> 接口与应用程序上下文交互即可。</p>
</div>
<div class="paragraph">
<p>要接收自定义的 <code>ApplicationEvent</code>，需要创建一个实现了 <code>ApplicationListener</code> 的类，并将其注册为一个 Spring bean。下面的例子演示了这样一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListNotifier</span> <span class="directive">implements</span> ApplicationListener&lt;BlackListEvent&gt; {

        <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress;

        <span class="directive">public</span> <span class="type">void</span> setNotificationAddress(<span class="predefined-type">String</span> notificationAddress) {
                <span class="local-variable">this</span>.notificationAddress = notificationAddress;
        }

        <span class="directive">public</span> <span class="type">void</span> onApplicationEvent(BlackListEvent event) {
                <span class="comment">// notify appropriate parties via notificationAddress...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>ApplicationListener</code> 是用你的自定义事件 <code>BlackListEvent</code> 的类型来泛型参数化的。这意味着 <code>onApplicationEvent()</code> 方法可以保持类型安全，避免任何向下转换的需要。你可以根据需要注册多个事件监听器，但注意默认情况下，事件监听器采用同步方式接收事件。这意味着 <code>publishEvent()</code> 方法将会阻塞，直到所有监听器完成事件处理。这种同步和单线程方法的一个优点是，当某个监听器接收到事件时，如果事务上下文可用，它会发布者的事务上下文内运行。如果需要另一个事件发布策略，请参阅Spring的 <code>ApplicationEventMulticaster</code> 接口的 javadoc。</p>
</div>
<div class="paragraph">
<p>以下示例展示了用于注册和配置上述每个类的 bean 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">emailService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.EmailService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blackList</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>known.spammer@example.org<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>known.hacker@example.org<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>john.doe@example.org<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blackListNotifier</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.BlackListNotifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">notificationAddress</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blacklist@example.org</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>综合起来，当调用 <code>emailService</code> bean 的 <code>sendEmail()</code> 方法时，如果有任何应该列入黑名单的电子邮件地址，就会发布 <code>BlackListEvent</code> 类型的自定义事件。<code>blackListNotifier</code> bean 被注册为一个 <code>ApplicationListener</code>，并且因此接收到 <code>BlackListEvent</code> ，并同时按需通知各方。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 的事件机制是为了在同一个应用上下文中的 Spring bean 之间进行简单的通信而设计的。但是，对于更复杂的企业集成需求，独立维护的 <a href="https://projects.spring.io/spring-integration/">Spring Integration</a> 项目提供了完整的支持，以构建基于众所周知的 Spring 编程模型的轻量级，<a href="http://www.enterpriseintegrationpatterns.com">面向模式</a> 的事件驱动体系结构。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="context-functionality-events-annotation"><a class="anchor" href="#context-functionality-events-annotation"></a>基于注解的事件监听器</h5>
<div class="paragraph">
<p>从 Spring 4.2 开始，可以通过 <code>EventListener</code> 注解在被托管 bean 的任何公共方法上注册一个事件监听器。<code>BlackListNotifier</code> 可以被重写如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListNotifier</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress;

        <span class="directive">public</span> <span class="type">void</span> setNotificationAddress(<span class="predefined-type">String</span> notificationAddress) {
                <span class="local-variable">this</span>.notificationAddress = notificationAddress;
        }

        <span class="annotation">@EventListener</span>
        <span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
                <span class="comment">// notify appropriate parties via notificationAddress...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所见，方法签名再次声明了它监听的事件类型，但是这次使用了灵活的名字而并未实现特定的监听器接口。事件类型也可以通过泛型来缩小范围，只要实际事件类型在其实现层次结构中可以解析泛型参数即可。</p>
</div>
<div class="paragraph">
<p>如果你的方法需要监听好几个事件，或者如果你想要不带任何参数来定义它，那么也可以在注解本身上指定事件类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>({ContextStartedEvent.class, ContextRefreshedEvent.class})
<span class="directive">public</span> <span class="type">void</span> handleContextStart() {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以通过注解的 <code>condition</code>  特性添加额外的运行时过滤，该属性定义了一个 <a href="#expressions"><code>SpEL</code> 表达式</a>，如果该表达式匹配就会调用针对特定事件的这个方法。</p>
</div>
<div class="paragraph">
<p>例如，我们的通知器可以被重写为仅在事件的 <code>test</code> 特性等于 <code>foo</code> 的时候被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>(condition = <span class="string"><span class="delimiter">&quot;</span><span class="content">#blEvent.test == 'foo'</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent blEvent) {
        <span class="comment">// notify appropriate parties via notificationAddress...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 <code>SpEL</code>  表达式都会重新评估一个专用的上下文。下表列出了可用于上下文的项目，以便上下文可以将它们用于条件事件处理：</p>
</div>
<table id="context-functionality-events-annotation-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. 事件 SpEL 可用的元数据</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名字</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">事件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实际的 <code>ApplicationEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.event</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于调用目标的参数（数组）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.args[0]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>参数名</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评估上下文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意方法参数名。如果因某些情况参数名不可用（例如，没有调试信息），参数名在 <code>#a&lt;#arg&gt;</code> 下也是可用的，<em>#arg</em> 代表参数索引（从0开始）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#blEvent</code> or <code>#a0</code> (one can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> notation as an alias).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意，<code>#root.event</code> 允许您访问基础事件，即使您的方法签名实际上是指已经发布的任意对象。</p>
</div>
<div class="paragraph">
<p>如果您需要发布一个作为处理另一个事件的结果事件，只需更改方法签名以返回应该发布的事件，如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
        <span class="comment">// notify appropriate parties via notificationAddress and</span>
        <span class="comment">// then publish a ListUpdateEvent...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#context-functionality-events-async">异步监听器</a> 不支持这个功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这个新方法将为每个由上述方法处理的 <code>BlackListEvent</code> 发布一个新的 <code>ListUpdateEvent</code> 。如果您需要发布多个事件，则只需返回事件的 <code>集合</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-async"><a class="anchor" href="#context-functionality-events-async"></a>异步监听器</h5>
<div class="paragraph">
<p>如果你希望某个特定的侦听器对事件进行异步处理，只需重用 <a href="integration.html#scheduling-annotation-support-async">常规 <code>@Async</code> 作为支持</a> 即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="annotation">@Async</span>
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
        <span class="comment">// BlackListEvent is processed in a separate thread</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用异步事件时请注意以下限制：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果事件监听器抛出 <code>异常</code>，它不会被传播给调用者，请查看 <code>AsyncUncaughtExceptionHandler</code> 以获取更多详细信息。</p>
</li>
<li>
<p>这样的事件监听器不能发送回复。如果您需要发送另一个事件作为处理的结果，需要注入 <code>ApplicationEventPublisher</code> 手动发送事件。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-order"><a class="anchor" href="#context-functionality-events-order"></a>监听器排序</h5>
<div class="paragraph">
<p>如果你需要某个监听器在另一个监听器之前被调用，只需在方法生命中添加 <code>@Order</code> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="annotation">@Order</span>(<span class="integer">42</span>)
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
        <span class="comment">// notify appropriate parties via notificationAddress...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-generics"><a class="anchor" href="#context-functionality-events-generics"></a>泛型事件</h5>
<div class="paragraph">
<p>您也可以使用泛型来进一步定义事件的结构。考虑对于 <code>EntityCreatedEvent&lt;T&gt;</code>，其中 <code>T</code> 是创建的实际实体的类型。您可以创建以下侦听器定义用于只接收 <code>Person</code> <code>EntityCreatedEvent</code> 事件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> <span class="type">void</span> onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为类型擦除，只有当被触发的事件正确解析了事件监听器过滤的泛型参数时（这与类PersonCreatedEvent 继承 EntityCreatedEvent <Person> {...}类似）才会有效。</p>
</div>
<div class="paragraph">
<p>在某些情况下，如果所有事件都遵循相同的结构（如上面的事件），则这可能变得非常繁琐。在这种情况下，您可以实现 <code>ResolvableTypeProvider</code> 来引导框架超出运行时环境提供的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">EntityCreatedEvent</span>&lt;T&gt;
                   <span class="directive">extends</span> ApplicationEvent <span class="directive">implements</span> ResolvableTypeProvider {

           <span class="directive">public</span> EntityCreatedEvent(T entity) {
                   <span class="local-variable">super</span>(entity);
           }

           <span class="annotation">@Override</span>
           <span class="directive">public</span> ResolvableType getResolvableType() {
                   <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(),
                                   ResolvableType.forInstance(getSource()));
           }
   }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这不仅适用于 <code>ApplicationEvent</code>，而且适用于作为事件发送的任意对象。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-resources"><a class="anchor" href="#context-functionality-resources"></a>1.15.3. 方便地访问低级资源</h4>
<div class="paragraph">
<p>为了对应用程序上下文的使用和理解达到最佳效果，用户通常应该熟悉 Spring 的 <code>Resource</code> 抽象，如 <a href="#resources">Resources</a> 一章所述。</p>
</div>
<div class="paragraph">
<p>应用程序上下文也是一个 <code>ResourceLoader</code> ，可以用来加载 <code>Resource</code>。<code>Resource</code> 本质上是 JDK 类 <code>java.net.URL</code> 的一个功能更丰富的版本，实际上，<code>Resource</code> 的实现是在适当的情况下包装了一个 <code>java.net.URL</code> 的实例。<code>Resource</code> 可以以透明的方式从几乎任何位置获取低级资源，包括类路径，文件系统位置，任何可用标准 URL 描述的地方以及其他一些变体。如果资源位置字符串是一个没有任何特殊前缀的简单路径，那么这些资源来自特定且适合于实际应用上下文类型。</p>
</div>
<div class="paragraph">
<p>你可以配置一个部署到应用程序上下文中的 bean，以实现特殊的回调接口 <code>ResourceLoaderAware</code>，以便它在初始化时自动回调，同时应用程序上下文本身作为 <code>ResourceLoader</code> 传入。你还可以暴露<code>Resource</code> 类型的属性，用于访问静态资源;他们将像其他任何属性一样被注入。您可以将这些 <code>Resource</code> 属性指定为简单的字符串路径，并依靠能被上下文自动注册的特殊 JavaBean <code>PropertyEditor</code> 将这些文本字符串转换为实际的 <code>Resource</code> 对象。</p>
</div>
<div class="paragraph">
<p>提供给 <code>ApplicationContext</code> 构造器的位置路径实际上是资源字符串，并以简单的形式被视为特定的上下文实现。<code>ClassPathXmlApplicationContext</code> 将简单的位置路径视为类路径位置。你也可以使用带有特殊前缀的位置路径（资源字符串）来强制从类路径或 URL 中加载定义，无论实际的上下文是什么类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-create"><a class="anchor" href="#context-create"></a>1.15.4. web应用的简单 ApplicationContext 实例化</h4>
<div class="paragraph">
<p>你可以使用例如 <code>ContextLoader</code> 以声明方式创建 <code>ApplicationContext</code> 实例。当然，你也可以通过使用 <code>ApplicationContext</code> 的某个实现以编程方式创建 <code>ApplicationContext</code> 实例。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>ContextLoaderListener</code> 注册 <code>ApplicationContext</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context-param&gt;</span>
        <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
        <span class="tag">&lt;param-value&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="tag">&lt;/param-value&gt;</span>
<span class="tag">&lt;/context-param&gt;</span>

<span class="tag">&lt;listener&gt;</span>
        <span class="tag">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/listener-class&gt;</span>
<span class="tag">&lt;/listener&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>监听器会检查 <code>contextConfigLocation</code> 参数。如果该参数不存在，那么监听器将 <code>/WEB-INF/applicationContext.xml</code> 作为默认值使用。 当参数确实存在时，监听器使用预定义的分隔符（逗号，分号和空格）分隔字符串，并将这些值作为搜索应用程序上下文的位置。Ant 样式的路径模式也被支持。例如 <code>/WEB-INF/*Context.xml</code> 表示所有以 “Context.xml” 结尾的 “WEB-INF” 目录中的所有文件，<code>/WEB-INF/**/*Context.xml</code> 表示所有 “WEB-INF” 任何子目录中的文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-deploy-rar"><a class="anchor" href="#context-deploy-rar"></a>1.15.5.将 Spring ApplicationContext 部署为 Java EE RAR 文件</h4>
<div class="paragraph">
<p> 你可以将 Spring ApplicationContext 部署为 RAR 文件，只要将上下文及其所有必需的 bean 类和库 JAR 封装在 Java EE RAR 部署单元中即可。这相当于引导了一个独立的 ApplicationContext，只不过它是在 Java EE 环境中托管，能够访问 Java EE 服务器设施。实际上，部署无头 WAR 文件的场景中，如果只是要在 Java EE 环境中引导 Spring ApplicationContext， RAR 部署比不含任何 HTTP 入口的 WAR 文件更为自然。</p>
</div>
<div class="paragraph">
<p>RAR 部署非常适合不需要 HTTP 入口，仅由消息终结点和定时任务组成的应用程序上下文。在这种情况下，bean 可以使用 JTA 事务管理器和 JNDI 绑定的 JDBC DataSources 和 JMS ConnectionFactory 实例等应用服务器资源，也可以通过 Spring 的标准事务管理和 JNDI 及 JMX 支持的工具向平台的 JMX 服务器注册。应用程序组件还可以通过Spring的 <code>TaskExecutor</code> 抽象与应用程序服务器的 JCA WorkManager 进行交互。</p>
</div>
<div class="paragraph">
<p>查看 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a> 类的 javadoc，了解 RAR 部署中涉及的配置细节。</p>
</div>
<div class="paragraph">
<p><em>对于将 Spring ApplicationContext 简单部署为 Java EE RAR 文件：</em> 将所有应用程序类打包到 RAR 文件中, RAR 文件是具有不同文件扩展名的标准 JAR 文件。将所有必需的 JAR 库添加到 RAR 的归档根目录中。 添加一个 “META-INF/ra.xml” 部署描述符（如 <code>SpringContextResourceAdapter</code> javadoc 中所示）和相应的 Spring XML bean 定义文件（通常为“META-INF/applicationContext.xml”），然后将生成的 RAR 文件丢到到您的应用程序服务器的部署目录即可。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种 RAR 部署单位通常是独立的; 它们不会向外界暴露组件，甚至不会暴露给同一应用程序的其他模块。与基于 RAR 的 ApplicationContext 的交互通常通过与其他模块共享的 JMS 目标进行。基于 RAR 的 ApplicationContext 也可以调度一些作业，对文件系统中新增文件（或诸如此类）作出反应。如果需要允许从外部进行同步访问，则可以导出 RMI 端点，这当然也可以被同一机器上的其他应用模块使用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-beanfactory"><a class="anchor" href="#beans-beanfactory"></a>1.16. The BeanFactory</h3>
<div class="paragraph">
<p><code>BeanFactory</code> 为 Spring 的 IoC 功能提供了基础，但是它只能直接用于与其他第三方框架的集成，对Spring 的大多数用户来说，具有悠久的历史。在 Spring 中，<code>BeanFactory</code> 和相关接口（如 <code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>）仍然存在，目的是向后兼容大量与 Spring 集成的第三方框架。 为了与 JDK 1.4 保持兼容或避免依赖 JSR-250，通常第三方组件不能使用更多的现代的新特性，例如 <code>@PostConstruct</code> 或 <code>@PreDestroy</code>。</p>
</div>
<div class="paragraph">
<p>本节提供了 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 之间差异的另一个背景，以及如何通过经典的单例查找直接访问 IoC 容器。</p>
</div>
<div class="sect3">
<h4 id="context-introduction-ctx-vs-beanfactory"><a class="anchor" href="#context-introduction-ctx-vs-beanfactory"></a>1.16.1. BeanFactory 还是 ApplicationContext？</h4>
<div class="paragraph">
<p>尽量使用 <code>ApplicationContext</code>，除非你有充分的理由不这样做。</p>
</div>
<div class="paragraph">
<p>因为 <code>ApplicationContext</code> 包含了 <code>BeanFactory</code> 的所有功能，所以通常推荐使用 <code>BeanFactory</code>，除了一些情况，例如在资源受限的设备上运行的嵌入式应用程序，这些设备的内存消耗可能很重要，少数多余的 KB 可能就会对系统产生影响。 但是，对于大多数典型的企业应用程序和系统，<code>ApplicationContext</code> 才是你想要使用的。 Spring 会大量使用 <a href="#beans-factory-extension-bpp"><code>BeanPostProcessor</code> 扩展点</a>（以影响代理等等）。如果只使用一个普通的 <code>BeanFactory</code> ，那么在您没有采取额外步骤的情况下，相当数量的功能（如事务和AOP）将不会生效。这种情况可能会令人困惑，因为配置没有任何问题。</p>
</div>
<div class="paragraph">
<p>下表列出了 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 接口和实现提供的功能。</p>
</div>
<table id="context-introduction-ctx-vs-beanfactory-feature-matrix" class="tableblock frame-all grid-all spread">
<caption class="title">Table 9. 特性表</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">特性</th>
<th class="tableblock halign-left valign-top"><code>BeanFactory</code></th>
<th class="tableblock halign-left valign-top"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bean instantiation/wiring</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanFactoryPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convenient <code>MessageSource</code> access (for i18n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEvent</code> publication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要使用 <code>BeanFactory</code> 实现显式注册 bean post-processor，您需要编写如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();
<span class="comment">// populate the factory with bean definitions</span>

<span class="comment">// now register any needed BeanPostProcessor instances</span>
MyBeanPostProcessor postProcessor = <span class="keyword">new</span> MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

<span class="comment">// now start using the factory</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在使用 <code>BeanFactory</code> 实现时显式注册 <code>BeanFactoryPostProcessor</code>，必须编写如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(<span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// bring in some property values from a Properties file</span>
PropertyPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertyPlaceholderConfigurer();
cfg.setLocation(<span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc.properties</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// now actually do the replacement</span>
cfg.postProcessBeanFactory(factory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，显式注册步骤都不方便，这就是为什么各种 <code>ApplicationContext</code> 实现比大多数 Spring 支持的应用程序中的纯 <code>BeanFactory</code> 实现更受欢迎的原因之一，特别是在使用 <code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 时。这些机制实现了诸如属性占位符替换和AOP 等重要功能。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resources"><a class="anchor" href="#resources"></a>2. 资源</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="resources-introduction"><a class="anchor" href="#resources-introduction"></a>2.1. 简介</h3>
<div class="paragraph">
<p>对于不同的 URL 前缀，很不幸 Java 的标准 <code>java.net.URL</code> 类和标准处理器并不足够访问低级资源。例如， 没有标准化的 <code>URL</code> 实现可以用来访问类路径或者 <code>ServletContext</code> 相对路径以便获取资源。尽管可以为专门的 URL 前缀注册新的处理器（类似于诸如 <code>http:</code> 之类的前缀的现有处理器），但这通常相当复杂，并且 URL 接口仍然缺少某些期望的功能，例如检查被指向的资源是否存在。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-resource"><a class="anchor" href="#resources-resource"></a>2.2. 资源接口</h3>
<div class="paragraph">
<p>Spring 的 <code>Resource</code> 接口的使命是成为一个用于抽象对低级别资源访问的更加强大的接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Resource</span> <span class="directive">extends</span> InputStreamSource {

        <span class="type">boolean</span> exists();

        <span class="type">boolean</span> isOpen();

        <span class="predefined-type">URL</span> getURL() <span class="directive">throws</span> <span class="exception">IOException</span>;

        <span class="predefined-type">File</span> getFile() <span class="directive">throws</span> <span class="exception">IOException</span>;

        Resource createRelative(<span class="predefined-type">String</span> relativePath) <span class="directive">throws</span> <span class="exception">IOException</span>;

        <span class="predefined-type">String</span> getFilename();

        <span class="predefined-type">String</span> getDescription();

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InputStreamSource</span> {

        <span class="predefined-type">InputStream</span> getInputStream() <span class="directive">throws</span> <span class="exception">IOException</span>;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Resource</code> 接口中一些最重要的方法是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInputStream()</code>：定位并打开资源，返回一个从资源读取的 <code>InputStream</code> 流。 预计每个调用都会返回一个新的 <code>InputStream</code>。调用方有责任关闭该流。</p>
</li>
<li>
<p><code>exists()</code>：返回一个 <code>boolean</code> 值，表明这个资源是否以物理形式真实存在。</p>
</li>
<li>
<p><code>isOpen()</code>: 返回一个 <code>boolean</code> 值，表示资源是否正在被一个打开的流处理。如果返回值为 <code>true</code>，则 <code>InputStream</code> 不能被多次读取，且只能被读取一次然后关闭以防资源泄露。对于所有常规的资源实现，将返回 <code>false</code>，除了 <code>InputStreamResource</code>。</p>
</li>
<li>
<p><code>getDescription()</code>：返回这个资源的描述符，用于处理资源时的错误输出。这通常是全限定的文件名或资源的实际 URL。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其他方法允许您获取表示资源的实际 <code>URL</code> 或 <code>File</code> 对象（如果底层实现兼容并支持该功能）。</p>
</div>
<div class="paragraph">
<p>当资源被请求时，<code>Resource</code> 抽象以许多方法签名参数的形式在 Spring 本身中被广泛使用。在一些Spring API （比如各种 <code>ApplicationContext</code> 实现的构造函数）的其他方法中，它们接收 <code>String</code> 使用简单或者粗糙的形式创建一个适合于上下文实现的<code>Resource</code>  ，或者通过 <code>String</code> 路径上的特殊前缀，允许调用者指定必须创建和使用特定的 <code>Resource</code> 实现。</p>
</div>
<div class="paragraph">
<p>虽然 <code>Resource</code> 接口被 Spring 和在 Spring 中大量使用，但是在自己的代码中，将作为一个用来访问资源的通用工具类是很有用的，甚至你的代码可以不感知或者不关心 Spring 的其他部分。虽然这会将你的代码与 Spring 耦合起来，但它实际上只是将它与这一小组工具类耦合，这些工具类可以更好地替代 <code>URL</code>，并且可以被认为与你为此目的使用的任何其他库相同。</p>
</div>
<div class="paragraph">
<p>值得注意的是，<code>Resource</code> 抽象并不取代功能：它只是尽可能包装它。例如，<code>UrlResource</code> 包装一个<code>URL</code>，并使用包装的 <code>URL</code> 来完成其工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-implementations"><a class="anchor" href="#resources-implementations"></a>2.3. 内置资源能实现</h3>
<div class="paragraph">
<p>Spring 中有很多 <code>Resource</code> 实现是开箱即用的：</p>
</div>
<div class="sect3">
<h4 id="resources-implementations-urlresource"><a class="anchor" href="#resources-implementations-urlresource"></a>2.3.1. UrlResource</h4>
<div class="paragraph">
<p><code>UrlResource</code> 包装一个 <code>java.net.URL</code>，可以用来访问通常通过 URL 访问的任何对象，如文件，HTTP 目标，FTP 目标等。所有的 URL 都有一个标准化的 <code>String</code> 表示，使用适当的标准化前缀来表示来区分 URL 类型。这包括用于访问文件系统路径的 <code>file:</code>，http：用于通过HTTP协议访问资源的 <code>http:</code>，用于通过FTP访问资源的 <code>ftp:</code> 等。</p>
</div>
<div class="paragraph">
<p><code>UrlResource</code> 是由 Java 代码使用 <code>UrlResource</code> 构造函数显式创建的，但是当你调用一个接受 <code>String</code> 参数的 API 方法时，通常会隐式地创建 <code>UrlResource</code> 来表示路径。对于后一种情况，JavaBean <code>PropertyEditor</code> 会最终将决定创建哪种类型的 <code>Resource</code>。如果路径字符串包含一些众所周知的（就是这样的）前缀，比如 <code>classpath:</code>，它将为该前缀创建适当的专用 <code>Resource</code> 。但是，如果它不能识别前缀，它会认为这只是一个标准的 URL 字符串，并会创建一个 <code>UrlResource</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-classpathresource"><a class="anchor" href="#resources-implementations-classpathresource"></a>2.3.2. ClassPathResource</h4>
<div class="paragraph">
<p>这个类代表了一个应该从类路径中获得的资源。这使用线程上下文类加载器，给定的类加载器或给定的类来加载资源。</p>
</div>
<div class="paragraph">
<p>如果类路径资源驻留在文件系统中， 而不是驻留在 jar 中且尚未扩展（通过servlet引擎或任何环境）的到文件系统中，则此 <code>Resource</code> 实现支持解析为 <code>java.io.File</code>。 为了解决这个问题，各种资源实现总是支持解析为 <code>java.net.URL</code>。</p>
</div>
<div class="paragraph">
<p><code>ClassPathResource</code>  是由 Java 代码使用 <code>ClassPathResource</code> 构造函数显式创建的，但是当你调用一个接受 <code>String</code> 参数的 API 方法时，通常会隐式地创建 <code>ClassPathResource</code> 来表示路径。对于后一种情况，JavaBeans <code>PropertyEditor</code> 将识别字符串路径上的特殊前缀 <code>classpath:</code> 并在此情况下创建一个<code>ClassPathResource</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-filesystemresource"><a class="anchor" href="#resources-implementations-filesystemresource"></a>2.3.3. FileSystemResource</h4>
<div class="paragraph">
<p>这是 <code>java.io.File</code> 句柄的 <code>Resource</code> 实现。它显然支持将资源解析为 <code>File</code> 和 <code>URL</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-servletcontextresource"><a class="anchor" href="#resources-implementations-servletcontextresource"></a>2.3.4. ServletContextResource</h4>
<div class="paragraph">
<p>这是 <code>ServletContext</code> 资源的 <code>Resource</code> 实现，解释相关 Web 应用程序根目录中的相对路径。</p>
</div>
<div class="paragraph">
<p>它总是支持流访问和 URL 访问，但只有在 Web 应用程序归档文件被扩展并且资源物理上位于文件系统上时才允许 <code>java.io.File</code> 访问。不管它是否被扩展，对于在这样在文件系统上，还是直接从 JAR 或其他地方类似  DB 中访问（可以想象），实际上都依赖于 Servlet 容器。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-inputstreamresource"><a class="anchor" href="#resources-implementations-inputstreamresource"></a>2.3.5. InputStreamResource</h4>
<div class="paragraph">
<p>给定的 <code>InputStream</code> 的 <code>Resource</code> 实现。只有在没有具体的 <code>Resource</code> 实现适用的情况下才会使用。特殊情况下，如果可能的话，首选 <code>ByteArrayResource</code> 或任何基于文件的 <code>Resource</code> 实现。</p>
</div>
<div class="paragraph">
<p>与其他 <code>Resource</code> 实现相比，这表示的是已打开资源的描述符，因此调用 <code>isOpen()</code> 会返回 <code>true</code>。如果您需要将资源描述符保存在某处，或者需要多次读取流，请不要使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-bytearrayresource"><a class="anchor" href="#resources-implementations-bytearrayresource"></a>2.3.6. ByteArrayResource</h4>
<div class="paragraph">
<p>这是给定字节数组的 <code>Resource</code> 实现。它为给定的字节数组创建一个 <code>ByteArrayInputStream</code>。</p>
</div>
<div class="paragraph">
<p>它对于从任何给定的字节数组中加载内容是很有用的，可避免求助于一次性的 <code>InputStreamResource</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-resourceloader"><a class="anchor" href="#resources-resourceloader"></a>2.4. The ResourceLoader</h3>
<div class="paragraph">
<p>实现 <code>ResourceLoader</code> 接口的对象会返回 <code>Resource</code> 实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ResourceLoader</span> {

        Resource getResource(<span class="predefined-type">String</span> location);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有应用程序上下文都实现了 <code>ResourceLoader</code> 接口，因此所有的应用程序上下文都可以用来获取<code>Resource</code> 实例。</p>
</div>
<div class="paragraph">
<p>当你在特定的应用程序上下文中调用 <code>getResource()</code>，并且指定的位置路径没有特定的前缀时，将返回适合该特定应用程序上下文的 <code>Resource</code> 类型。例如，假设下面的代码片段是针对 <code>ClassPathXmlApplicationContext</code> 实例执行的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的结果将会是 <code>ClassPathResource</code>; 如果对 <code>FileSystemXmlApplicationContext</code> 实例执行相同的方法，则会返回 <code>FileSystemResource</code>。 对于一个 <code>WebApplicationContext</code>，你会得到一个<code>ServletContextResource</code>，依此类推。</p>
</div>
<div class="paragraph">
<p>因此，你可以以适合特定应用程序上下文的方式加载资源。</p>
</div>
<div class="paragraph">
<p>另一方面，也可以通过指定特殊的<code>classpath:</code> 前缀来强制使用 <code>ClassPathResource</code>，而不管应用程序的上下文类型如何：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，可以通过指定任何标准的 <code>java.net.URL</code> 前缀来强制使用 <code>UrlResource</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://myhost.com/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表总结了将 <code>String</code>转换为 <code>Resource</code>的策略：</p>
</div>
<table id="resources-resource-strings" class="tableblock frame-all grid-all spread">
<caption class="title">Table 10. 资源字符串</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">前缀</th>
<th class="tableblock halign-left valign-top">例子</th>
<th class="tableblock halign-left valign-top">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classpath:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classpath:com/myapp/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从类路径加载。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">file:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="file:///data/config.xml" class="bare">file:///data/config.xml</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从文件系统将资源加载为一个 <code>URL</code>。<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://myserver/logo.png" class="bare">http://myserver/logo.png</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加载为 <code>URL</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">无</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/data/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">取决于相关 <code>ApplicationContext</code>。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="resources-resourceloaderaware"><a class="anchor" href="#resources-resourceloaderaware"></a>2.5. ResourceLoaderAware 接口</h3>
<div class="paragraph">
<p><code>ResourceLoaderAware</code> 接口是一个特殊的标记接口，用于标识期望通过 <code>ResourceLoader</code> 引用提供的对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ResourceLoaderAware</span> {

        <span class="type">void</span> setResourceLoader(ResourceLoader resourceLoader);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当一个类实现了 <code>ResourceLoaderAware</code> 并被部署到一个应用上下文（作为一个被Spring 管理的bean）时，它会被应用上下文识别为 <code>ResourceLoaderAware</code>。然后，应用程序上下文将调用 <code>setResourceLoader(ResourceLoader)</code>，并将自身作为参数（请记住，Spring中的所有应用程序上下文实现 <code>ResourceLoader</code> 接口）。</p>
</div>
<div class="paragraph">
<p>当然，由于 <code>ApplicationContext</code> 是一个 <code>ResourceLoader</code>，bean 也可以实现 <code>ApplicationContextAware</code> 接口并直接使用提供的应用程序上下文来加载资源，但通常情况下，最好使用专用的 <code>ResourceLoader</code> 接口（如果这么做已经可以满足全部需求）。代码仅仅只是与资源加载接口耦合了，它可以被认为是一个工具接口，而不是整个 Spring <code>ApplicationContext</code> 接口。</p>
</div>
<div class="paragraph">
<p>从 Spring 2.5 开始，您可以依靠 <code>ResourceLoader</code> 的自动装配来替代实现 <code>ResourceLoaderAware</code> 接口。“传统” <code>constructor</code>和 <code>byType</code> 自动装配模式（如<a href="#beans-factory-autowire">自动装配协作者</a> 中所述）现在可以分别为构造器参数或setter 方法参数提供 <code>ResourceLoader</code> 类型的依赖关系。为了获得更大的灵活性（包括自动装配字段和多个参数方法的能力），可以考虑使用新的基于注解的自动装配特性。在这种情况下，只要正在考虑的的字段，构造器或方法携带 <code>@Autowired</code> 注解，<code>ResourceLoader</code> 就会被自动装载到期望得到 <code>ResourceLoader</code> 类型的字段，构造器参数或方法参数中。有关更多信息，请参阅 <a href="#beans-autowired-annotation">@Autowired</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-as-dependencies"><a class="anchor" href="#resources-as-dependencies"></a>2.6. 作为依赖的资源</h3>
<div class="paragraph">
<p>如果 bean 本身要通过某种动态的过程来确定和提供资源路径，那么 bean 可能会使用 <code>ResourceLoader</code> 接口来加载资源。考虑加载某种类型的模板，其中需要的特定资源取决于用户的角色。 如果资源是静态的，那么完全消除 <code>ResourceLoader</code> 接口的使用是有意义的，只要让 bean 公开它需要的 <code>Resource</code>属性，并期望它们被注入到 bean 中。</p>
</div>
<div class="paragraph">
<p>使注入这些属性变得微不足道的是所有的应用程序上下文都注册并使用一个特殊的 JavaBeans <code>PropertyEditor</code>，它可以将 <code>String</code>路径转换为 <code>Resource</code> 对象。 因此，如果 <code>myBean</code> 具有 <code>Resource</code> 类型的模板属性，则可以使用该资源的简单字符串进行配置，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">template</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意资源路径没有前缀，于是因为应用程序上下文本身将被作为 <code>ResourceLoader</code>，所以根据上下文的确切类型，资源本身将通过 <code>ClassPathResource</code>，<code>FileSystemResource</code> 或 <code>ServletContextResource</code>（根据需要）来加载。</p>
</div>
<div class="paragraph">
<p>如果需要强制使用特定的 <code>Resource</code> 类型，则可以使用前缀。以下两个示例显示如何强制 <code>ClassPathResource</code> 和 <code>UrlResource</code>（后者用于访问文件系统文件）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">template</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">template</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-app-ctx"><a class="anchor" href="#resources-app-ctx"></a>2.7. 应用上下文和资源路径</h3>
<div class="sect3">
<h4 id="resources-app-ctx-construction"><a class="anchor" href="#resources-app-ctx-construction"></a>2.7.1. 构建应用上下文</h4>
<div class="paragraph">
<p>应用程序上下文构造器（对于特定的应用程序上下文类型）通常将字符串或字符串数组作为资源（如构成上下文定义的 XML 文件）的位置路径。</p>
</div>
<div class="paragraph">
<p>当这样的位置路径没有前缀时，从该路径构建并用于加载 bean 定义的特定 <code>Resource</code> 类型取决于并适合于特定的应用程序上下文。 例如，如果您创建一个 <code>ClassPathXmlApplicationContext</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bean 定义将从类路径中加载，因为将使用 <code>ClassPathResource</code>。但是，如果您创建一个 <code>FileSystemXmlApplicationContext</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bean 定义将从文件系统位置加载，在这种情况下路径相对于当前工作目录。</p>
</div>
<div class="paragraph">
<p>注意在位置路径中使用特殊的类路径前缀或标准的 URL 前缀将覆盖为加载定义而创建的默认资源的类型。 所以这个 <code>FileSystemXmlApplicationContext</code> ...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>实际上会从类路径中加载它的 bean 定义。但是，它仍然是一个 <code>FileSystemXmlApplicationContext</code>。如果随后将其用作 <code>ResourceLoader</code>，则任何前缀不足的路径仍将被视为文件系统路径。</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-classpathxml"><a class="anchor" href="#resources-app-ctx-classpathxml"></a>构建 ClassPathXmlApplicationContext 实例 - 快捷方式</h5>
<div class="paragraph">
<p><code>ClassPathXmlApplicationContext</code> 公开了许多构造器来实现方便的实例化。其基本思想是只提供一个字符串数组，它只包含 XML 文件本身的文件名（没有前导路径信息），和一个 <code>Class</code>; <code>ClassPathXmlApplicationContext</code> 将从所提供的类中派生路径信息。</p>
</div>
<div class="paragraph">
<p>下面的例子希望能清楚阐释这点。考虑一下这样的目录布局：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/
  foo/
	services.xml
	daos.xml
    MessengerService.class</pre>
</div>
</div>
<div class="paragraph">
<p>由 <code>'services.xml'</code> 和 <code>'daos.xml'</code> 中定义的 bean 组成的 <code>ClassPathXmlApplicationContext</code> 实例可以像这样被实例化...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(
        <span class="keyword">new</span> <span class="predefined-type">String</span><span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>}, MessengerService.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关各种构造函数的详细信息，请参考 <code>ClassPathXmlApplicationContext</code> javadoc。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-wildcards-in-resource-paths"><a class="anchor" href="#resources-app-ctx-wildcards-in-resource-paths"></a>2.7.2. 应用上下文构造器资源路径中的通配符</h4>
<div class="paragraph">
<p>应用程序上下文构造器参数值中的资源路径可以是一个简单的路径（如上所示），它具有到目标资源的一对一映射，或者可以包含特殊的“classpath *：”前缀和/或内部的 Ant 风格的正则表达式（使用 Spring 的 PathMatcher 工具进行匹配）。后者都是有效的通配符。</p>
</div>
<div class="paragraph">
<p>此机制的一个用途是在执行组件式应用程序组装时。所有组件都可以将上下文定义片段“发布”到众所周知的位置路径，并且当最终的应用程序上下文使用通过 <code>classpath*:</code> 前缀的相同路径创建时，所有组件片段将被自动获取。</p>
</div>
<div class="paragraph">
<p>注意此通配符是特定于应用程序上下文构造器参数中的资源路径的使用（或直接使用 <code>PathMatcher</code> 工具类分层结构时），并在构建时解析。它与 <code>Resource</code> 类型本身无关。无法使用 <code>classpath*:</code> 前缀来构造实际的 <code>Resource</code>，因为资源一次只能指向一个资源。</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-ant-patterns-in-paths"><a class="anchor" href="#resources-app-ctx-ant-patterns-in-paths"></a>Ant 风格的 Patterns</h5>
<div class="paragraph">
<p>当路径位置包含 Ant 风格 pattern 时，例如：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/WEB-INF/*-context.xml
  com/mycompany/**/applicationContext.xml
  file:C:/some/path/*-context.xml
  classpath:com/mycompany/**/applicationContext.xml</pre>
</div>
</div>
<div class="paragraph">
<p>解析器遵循更复杂但已定义的过程来尝试解析通配符。它为直到最后一个非通配符段的路径生成一个资源，并从中获得一个 URL。如果此 URL 不是 <code>jar:</code> URL 或容器特定的变体（例如，WebLogic中的 <code>zip:</code>，WebSphere 中的 <code>wsjar</code> 等），则从中获取 <code>java.io.File</code>，并通过遍历文件系统来解析通配符。对于jar URL，解析器要么从中获取 <code>java.io.File</code>，要么手动解析jar 的U RL，然后遍历 jar 文件的内容来解析通配符。</p>
</div>
<div class="sect5">
<h6 id="resources-app-ctx-portability"><a class="anchor" href="#resources-app-ctx-portability"></a>对于便携性的影响</h6>
<div class="paragraph">
<p>如果指定的路径已经是文件 URL（无论是显式地还是隐式的，因为基本的 <code>ResourceLoader</code> 是一个文件 <code>ResourceLoader</code>，那么通配符就可以保证以完全便携的方式工作。</p>
</div>
<div class="paragraph">
<p>如果指定的路径是类路径地址，则解析器必须通过 <code>Classloader.getResource()</code> 调用获取最后一个非通配符路径段 URL。由于这只是路径的一个节点（不是最后的文件），所以在这种情况下，究竟返回的是什么样的 URL 实际还未定义（在 <code>ClassLoader</code> 的javadocs中）。在实践中，它始终是代表目录的用于将类路径资源解析为文件系统地址的 <code>java.io.File</code>，或者将类路径资源解析为 jar 地址的某种类型的 jar URL。但是，这个操作仍然存在可移植性问题。</p>
</div>
<div class="paragraph">
<p>如果从最后一个非通配符路径段获取了 jar URL，解析器肯定能够从中获得一个 <code>java.net.JarURLConnection</code> ，或者手动解析 jar 的 URL，以便能够遍历 jar 的内容，并解析通配符。这在大多数环境下都能正常工作，但是在其他某些环境下却不能正常工作，强烈建议你在依赖于特定环境的情况下在依赖它之前对来自 jar 的资源进行通配解析并测试通过。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="resources-classpath-wildcards"><a class="anchor" href="#resources-classpath-wildcards"></a>Classpath*: 可移植 classpath*: 前缀</h5>
<div class="paragraph">
<p>当构建基于 XML 的应用上下文时，地址字符串可以使用特殊的 <code>classpath*:</code> 前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath*:conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个特殊的前缀指定所有与给定名称相匹配的类路径资源都必须被获取（在内部，这本质上是通过 <code>ClassLoader.getResources(&#8230;&#8203;)</code> 调用实现的），然后合并以形成最终的应用上下文定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通配符类路径依赖于潜在类加载器的 <code>getResources()</code> 方法。由于现在大多数应用程序服务器都提供了自己的类加载器实现，所以在处理 jar 文件时行为可能会有所不同。 检查 <code>classpath*</code> 是否有用的简单测试是使用类加载器从类路径中的 jar 加载文件：<code>getClass().getClassLoader().getResources("&lt;someFileInsideTheJar&gt;")</code>。尝试使用具有相同名称但位于两个不同位置的文件进行此测试。如果返回的结果不正确，请检查应用程序服务器文档以了解可能影响类加载器行为的设置。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>classpath*:</code> 前缀也可以与其他位置路径中的 <code>PathMatcher</code> 模式结合使用，例如  <code>classpath*:META-INF/*-beans.xml</code>。在这种情况下，解析策略相当简单：在最后一个非通配符路径段上使用 <code>ClassLoader.getResources()</code> 调用来获取类加载器层次结构中的所有匹配资源，然后关闭每个资源相同的 PathMatcher 分解策略如上所述用于通配符子路径。</p>
</div>
</div>
<div class="sect4">
<h5 id="resources-wildcards-in-path-other-stuff"><a class="anchor" href="#resources-wildcards-in-path-other-stuff"></a>其他有关通配符的说明</h5>
<div class="paragraph">
<p>注意除非实际的目标文件驻留在文件系统中，否则 <code>classpath*:</code> 与 Ant 风格 pattern 结合使用时，在模式启动之前必须保证至少有一个根目录。这意味着像 <code>classpath*:*.xml</code> 这样的模式不会从 jar 文件的根文件中检索文件，而只能从扩展目录的根文件中检索文件。这起源于 JDK 的 <code>ClassLoader.getResources()</code> 方法的限制，该方法只返回传入的空字符串的文件系统位置（指示要搜索的潜在根）。</p>
</div>
<div class="paragraph">
<p>带有 <code>classpath:</code> 的 Ant 风格 pattern：如果要在多个类路径位置中使用要搜索的根包，则不保证资源能够找到匹配的资源。 这是因为一个资源如：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/mycompany/package1/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>可能只存在一个地址中，但是当一个路径如：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>classpath:com/mycompany/**/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>被用来解析，解析器将处理由<code>getResource("com/mycompany")</code>返回的（第一个）URL。 如果此基础包节点存在于多个类加载器位置中，则实际的最终资源可能不在其下。 因此，最好在这种情况下使用具有相同Ant 风格的“classpath*:”，它将搜索包含根包的所有类路径位置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-filesystemresource-caveats"><a class="anchor" href="#resources-filesystemresource-caveats"></a>2.7.3. FileSystemResource 警告</h4>
<div class="paragraph">
<p><code>FileSystemResource</code> 并不依附于 <code>FileSystemApplicationContext</code> （即，
<code>FileSystemApplicationContext</code> 不是实际的 <code>ResourceLoader</code>），将按你的期望处理绝对路径与相对路径。相对路径相对于当前工作目录，而绝对路径相对于文件系统根目录。</p>
</div>
<div class="paragraph">
<p>但是为了向后兼容（历史）原因，当 <code>FileSystemApplicationContext</code> 是 <code>ResourceLoader</code> 时会发生变化。 <code>FileSystemApplicationContext</code> 只是强制所有的 <code>FileSystemResource</code> 实例将所有位置路径视为相对依附得得，无论它们是否以一个前导斜杠开始。在实践中，这意味着以下是等价的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">conf/context.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">/conf/context.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如下也一样：（尽管他们有所不同，一个是相对路径，一个是绝对路径。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">/some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，如果需要真正的绝对文件系统路径，最好放弃使用<code>FileSystemResource</code> / <code>FileSystemXmlApplicationContext</code> 的绝对路径，并使用 <code>file:</code> URL 前缀强制使用 <code>UrlResource</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// actual context type doesn't matter, the Resource will always be UrlResource</span>
ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource</span>
ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///conf/context.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validation"><a class="anchor" href="#validation"></a>3. 验证，数据绑定和类型转换</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="validation-introduction"><a class="anchor" href="#validation-introduction"></a>3.1. 简介</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">JSR-303/JSR-349 Bean 验证</div>
<div class="paragraph">
<p>Spring Framework 4.0 在设置支持方面支持 Bean Validation 1.0（JSR-303）和Bean Validation 1.1（JSR-349），同时也支持Spring <code>Validator</code> 接口。</p>
</div>
<div class="paragraph">
<p>如<a href="#validation-beanvalidation">Spring 验证</a>中所述，应用程序可以选择全局启用Bean 验证，并专门用于所有验证需求。</p>
</div>
<div class="paragraph">
<p>应用程序还可以为每个 <code>DataBinder</code> 实例注册额外的Spring <code>Validator</code> 实例，如 <a href="#validation-binder">配置DataBinder</a> 中所述。这对于不使用注解而插入验证逻辑而可能是有用的。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>作为业务逻辑，验证有一些优点和缺点 Spring 提供了一个包含所有优缺点的验证（和数据绑定）设计。具体的验证不应该绑定到 Web 层，应该易于本地化，应该可以插入任何可用的验证器。考虑到上述情况，Spring 已经提出了一个<code>Validator</code> 接口，这个接口在应用程序的每一层都是基本的和显着的可用的。</p>
</div>
<div class="paragraph">
<p>数据绑定对于允许用户输入动态地绑定到应用程序的域模型（或用于处理用户输入的任何对象）是有用的。Spring 提供了所谓的 <code>DataBinder</code> 来做到这一点。 <code>Validator</code> 和 <code>DataBinder</code> 组成了验证包，主要用于但不限于 MVC 框架。</p>
</div>
<div class="paragraph">
<p><code>BeanWrapper</code> 是 Spring 框架中的一个基本概念，在很多地方都有使用。但是，您可能没有直接使用 <code>BeanWrapper</code> 的需求。因为这是参考文件，所以我们会提供一些解释。我们将在本章中解释 <code>BeanWrapper</code> ，因为如果您打算使用它，那么你很可能将在尝试将数据绑定到对象时使用它。</p>
</div>
<div class="paragraph">
<p>Spring 的 DataBinder 和低级别的 BeanWrapper 都使用 PropertyEditors 来解析和格式化属性值。<code>PropertyEditor</code> 是 JavaBeans 规范的一部分，本章也会对此说明。Spring 3 引入了一个“core.convert”包，它提供了一个通用的类型转换工具，以及一个用于格式化 UI 字段值的高级“格式”包。这些新的包可以作为 PropertyEditor 的简单替代品，本章也将对其进行讨论。</p>
</div>
</div>
<div class="sect2">
<h3 id="validator"><a class="anchor" href="#validator"></a>3.2. 使用 Spring 的 Validator 接口</h3>
<div class="paragraph">
<p>Spring 提供了一个可以用来验证对象的 <code>Validator</code> 接口。<code>Validator</code> 接口使用 <code>Errors</code> 对象，以便在验证时验证器可以将验证失败报告给 <code>Errors</code> 对象。</p>
</div>
<div class="paragraph">
<p>考虑一个微小的数据对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> <span class="type">int</span> age;

        <span class="comment">// the usual getters and setters...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将通过实现 <code>org.springframework.validation.Validator</code> 接口的以下两个方法来为 <code>Person</code> 类提供验证行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supports(Class)</code> - 这个 <code>Validator</code> 验证器可以验证提供的 <code>Class</code> 类的实例吗？</p>
</li>
<li>
<p><code>validate(Object, org.springframework.validation.Errors)</code> - 验证给定的对象，并在验证错误的情况下，注册给定的 <code>Errors</code>对象。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>实现 <code>Validator</code> 非常简单，特别是当你知道 Spring Framewor k也提供的 <code>ValidationUtils</code> 帮助类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonValidator</span> <span class="directive">implements</span> <span class="predefined-type">Validator</span> {

        <span class="comment">/**
         * This Validator validates *just* Person instances
         */</span>
        <span class="directive">public</span> <span class="type">boolean</span> supports(<span class="predefined-type">Class</span> clazz) {
                <span class="keyword">return</span> Person.class.equals(clazz);
        }

        <span class="directive">public</span> <span class="type">void</span> validate(<span class="predefined-type">Object</span> obj, Errors e) {
                ValidationUtils.rejectIfEmpty(e, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name.empty</span><span class="delimiter">&quot;</span></span>);
                Person p = (Person) obj;
                <span class="keyword">if</span> (p.getAge() &lt; <span class="integer">0</span>) {
                        e.rejectValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">negativevalue</span><span class="delimiter">&quot;</span></span>);
                } <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="integer">110</span>) {
                        e.rejectValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">too.darn.old</span><span class="delimiter">&quot;</span></span>);
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，当 name 为 <code>null</code> 或空字符串时，<code>ValidationUtils</code> 类上的 <code>static</code> <code>rejectIfEmpty(..)</code> 方法就用于拒绝“name”属性。可以查看 <code>ValidationUtils</code> 的 javadocs 来查看它是如何工作的。</p>
</div>
<div class="paragraph">
<p>尽管可以实现一个 <code>Validator</code> 类来验证富对象中的每个嵌套对象，但最好是将每个嵌套类对象的验证逻辑封装在自己的 <code>Validator</code> 实现中。一个“富”对象的简单例子是由两个 <code>String</code> 属性（第一个和第二个名字）和一个复杂的 <code>Address</code> 对象组成的 <code>Customer</code>。<code>Address</code> 对象可以独立于  <code>Customer</code>  对象使用，所以一个独特的 <code>AddressValidator</code> 已经被实现。如果你希望你的 <code>CustomerValidator</code> 重复使用 <code>AddressValidator</code> 类中包含的逻辑而无需复制粘贴，则可以在你的 <code>CustomerValidator</code> 中依赖注入或实例化 <code>AddressValidator</code> ，并像下面这样使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CustomerValidator</span> <span class="directive">implements</span> <span class="predefined-type">Validator</span> {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Validator</span> addressValidator;

        <span class="directive">public</span> CustomerValidator(<span class="predefined-type">Validator</span> addressValidator) {
                <span class="keyword">if</span> (addressValidator == <span class="predefined-constant">null</span>) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">The supplied [Validator] is </span><span class="delimiter">&quot;</span></span> +
                                <span class="string"><span class="delimiter">&quot;</span><span class="content">required and must not be null.</span><span class="delimiter">&quot;</span></span>);
                }
                <span class="keyword">if</span> (!addressValidator.supports(Address.class)) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">The supplied [Validator] must </span><span class="delimiter">&quot;</span></span> +
                                <span class="string"><span class="delimiter">&quot;</span><span class="content">support the validation of [Address] instances.</span><span class="delimiter">&quot;</span></span>);
                }
                <span class="local-variable">this</span>.addressValidator = addressValidator;
        }

        <span class="comment">/**
         * This Validator validates Customer instances, and any subclasses of Customer too
         */</span>
        <span class="directive">public</span> <span class="type">boolean</span> supports(<span class="predefined-type">Class</span> clazz) {
                <span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);
        }

        <span class="directive">public</span> <span class="type">void</span> validate(<span class="predefined-type">Object</span> target, Errors errors) {
                ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string"><span class="delimiter">&quot;</span><span class="content">firstName</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">field.required</span><span class="delimiter">&quot;</span></span>);
                ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string"><span class="delimiter">&quot;</span><span class="content">surname</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">field.required</span><span class="delimiter">&quot;</span></span>);
                Customer customer = (Customer) target;
                <span class="keyword">try</span> {
                        errors.pushNestedPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">address</span><span class="delimiter">&quot;</span></span>);
                        ValidationUtils.invokeValidator(<span class="local-variable">this</span>.addressValidator, customer.getAddress(), errors);
                } <span class="keyword">finally</span> {
                        errors.popNestedPath();
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将验证错误报告给传递给验证器的 <code>Errors</code> 对象。 在 Spring Web MVC 的情况下，你可以使用<code>&lt;spring:bind/&gt;</code> 标签检查错误信息，当然你也可以自己检查错误对象。有关它提供的方法的更多信息可以在javadocs中找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-conversion"><a class="anchor" href="#validation-conversion"></a>3.3. 解析代码到对应错误信息</h3>
<div class="paragraph">
<p>我们已经讨论过数据绑定和验证。输出对应于验证错误的消息是我们需要讨论的最后一件事。在上面的例子中，我们拒绝了 <code>name</code> 和 <code>age</code> 字段。如果我们要通过使用 <code>MessageSource</code> 输出错误消息，我们将使用我们在拒绝字段（在这种情况下为“name”和“age”）时给出的错误代码。当你从 <code>Errors</code> 接口调用（直接或者间接使用 <code>ValidationUtils</code> 类）<code>rejectValue</code> 或者其他的 <code>reject</code> 方法时，底层的实现不仅会注册你传入的代码，还会传入一些附加的错误代码。它注册的错误代码由所使用的 <code>MessageCodesResolver</code> 决定。默认情况下，使用 <code>DefaultMessageCodesResolver</code> ，例如，它不仅会使用您提供的代码注册信息，还会使用包含您传递给拒绝方法的字段名的信息。因此，如果您使用<code>rejectValue("age", "too.darn.old")</code> 拒绝了一个字段，除了 <code>too.darn.old</code> 代码，Spring还将注册 <code>too.darn.old.age</code> 和 <code>too.darn.old.age.int</code>（这样第一个将包括字段名称，第二个将包括字段的类型）;这是为了方便开发人员定位错误消息等。</p>
</div>
<div class="paragraph">
<p>有关 <code>MessageCodesResolver</code> 和默认策略的更多信息可分别在 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/validation/MessageCodesResolver.html"><code>MessageCodesResolver</code></a> 和 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html"><code>DefaultMessageCodesResolver</code></a> 的 javadoc 中找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-beans"><a class="anchor" href="#beans-beans"></a>3.4. Bean 操作和 BeanWrapper</h3>
<div class="paragraph">
<p><code>org.springframework.beans</code> 包遵循 Oracle 提供的 JavaBeans 标准。JavaBean只是一个具有默认无参构造器的类，它遵循一个命名约定（举例来说），名为 <code>bingoMadness</code> 的属性将具有 setter 方法 <code>setBingoMadness(..)</code> 和 getter 方法 <code>getBingoMadness()</code>。有关 JavaBeans 和规范的更多信息，请参阅 Oracle 网站（<a href="http://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html">javabeans</a>）。</p>
</div>
<div class="paragraph">
<p>Bean 包中一个相当重要的类是 <code>BeanWrapper</code> 接口及其相应的实现（<code>BeanWrapperImpl</code>）。javadocs 引言，<code>BeanWrapper</code> 提供了设置和获取属性值（单独或批量），获取属性描述符，并查询属性以确定它们是否可读或可写的功能。此外，<code>BeanWrapper</code> 提供对嵌套属性的支持，可以无限深度的子属性设置。然后，<code>BeanWrapper</code> 支持添加标准的 JavaBeans <code>PropertyChangeListeners</code> 和 <code>VetoableChangeListeners</code>，而不需要目标类的代码支持。最后，<code>BeanWrapper</code> 提供了对索引属性设置的支持。 <code>BeanWrapper</code> 通常不被应用程序代码直接使用，而是被 <code>DataBinder</code> 和 <code>BeanFactory</code> 使用。</p>
</div>
<div class="paragraph">
<p><code>BeanWrapper</code> 的工作方式部分由它的名字来表示：<em>它包装一个 bean</em>来对这个它执行操作，比如设置和检索属性。</p>
</div>
<div class="sect3">
<h4 id="beans-beans-conventions"><a class="anchor" href="#beans-beans-conventions"></a>3.4.1. 设置或获得基本和嵌套属性</h4>
<div class="paragraph">
<p>设置和获取属性是使用 <code>setPropertyValue(s)</code> 和 <code>getPropertyValue(s)</code> 方法完成的，这两个方法都带有一些重载的变体。他们都在 javadocs 中有更详细的描述。重要的是知道有几个用于指示对象的属性约定。几个例子：</p>
</div>
<table id="beans-beans-conventions-properties-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 11. 属性的例子</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">表达式</th>
<th class="tableblock halign-left valign-top">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示与方法 <code>getName()</code> 或 <code>isName()</code> 和 <code>setName(..)</code> 相对应的属性名称。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示 <code>account</code> 属性的嵌套属性属性 <code>name</code> 对应的方法 <code>getAccount().setName()</code> 或者 <code>getAccount().getName()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[2]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示可索引的 <code>account</code> 属性的第三个元素。 索引属性可以是数组 <code>array</code>，列表 <code>list</code> 或其他自然排序的集合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[COMPANYNAME]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示由 Map 属性 <code>account</code> 的键 <em>COMPANYNAME</em> 索引的 map 条目的值</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下面你会发现一些使用 <code>BeanWrapper</code> 来获取和设置属性的例子。=</p>
</div>
<div class="paragraph">
<p><em>（如果你不打算直接使用 <code>BeanWrapper</code> ，那么下一节对你来说并不是非常重要，如果你只是使用<code>DataBinder</code> 和 <code>BeanFactory</code> 以及它们的开箱即用的实现，你应该跳到有关<code>PropertyEditors</code> 的部分。）</em></p>
</div>
<div class="paragraph">
<p>考虑以下两个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Company</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> Employee managingDirector;

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> Employee getManagingDirector() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.managingDirector;
        }

        <span class="directive">public</span> <span class="type">void</span> setManagingDirector(Employee managingDirector) {
                <span class="local-variable">this</span>.managingDirector = managingDirector;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Employee</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="directive">private</span> <span class="type">float</span> salary;

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> <span class="type">float</span> getSalary() {
                <span class="keyword">return</span> salary;
        }

        <span class="directive">public</span> <span class="type">void</span> setSalary(<span class="type">float</span> salary) {
                <span class="local-variable">this</span>.salary = salary;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下代码片段显示了如何检索和操作实例化 <code>Companies</code> 和 <code>Employees</code> 的一些属性的一些示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">BeanWrapper company = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Company());
<span class="comment">// setting the company name..</span>
company.setPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Some Company Inc.</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// ... can also be done like this:</span>
PropertyValue value = <span class="keyword">new</span> PropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Some Company Inc.</span><span class="delimiter">&quot;</span></span>);
company.setPropertyValue(value);

<span class="comment">// ok, let's create the director and tie it to the company:</span>
BeanWrapper jim = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Employee());
jim.setPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jim Stravinsky</span><span class="delimiter">&quot;</span></span>);
company.setPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">managingDirector</span><span class="delimiter">&quot;</span></span>, jim.getWrappedInstance());

<span class="comment">// retrieving the salary of the managingDirector through the company</span>
<span class="predefined-type">Float</span> salary = (<span class="predefined-type">Float</span>) company.getPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">managingDirector.salary</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-beans-conversion"><a class="anchor" href="#beans-beans-conversion"></a>3.4.2. 内置的 PropertyEditor 实现</h4>
<div class="paragraph">
<p>Spring 使用 <code>PropertyEditors</code> 的概念来实现 <code>Object</code> 和 <code>String</code> 之间的转换。如果你仔细想想，有时候使用不同于对象本身的方式表示属性可能会比比对象本身更方便。 例如，<code>Date</code> 可以用人类可读的方式表示（如<code>String</code> <code>'2007-14-09'</code>），而我们仍然能够将人类可读的形式转换回原始日期（或者甚至更好：将任何日期以人类可读形式输入，返回 <code>Date</code> 对象）。这种行为可以通过注册 <code>java.beans.PropertyEditor</code> 类型的自定义编辑器来实现。在上一章中提到的在 <code>BeanWrapper</code> 上注册自定义编辑器，或者在特定的 IoC 容器中注册自定义编辑器，可以使其知道如何将属性转换为所需的类型。 你可以在 Oracle 提供的 <code>java.beans</code> 包的 javadoc 中阅读更多关于 <code>PropertyEditors</code> 的内容。</p>
</div>
<div class="paragraph">
<p>在 Spring 中使用属性编辑的几个例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>PropertyEditors</code> 来 <em>设置 bean 的属性</em>。当作为你在 XML 文件中声明的某个 bean 属性的值的 <code>java.lang.String</code> 时，Spring 将（如果相应属性的 setter 具有一个 <code>Class</code> 参数）使用 <code>ClassEditor</code> 来尝试将参数解析为 <code>Class</code> 对象。</p>
</li>
<li>
<p>在 Spring 的 MVC 框架中 <em>解析HTTP请求参数 </em> 是使用各种 <code>PropertyEditors</code> 完成的，你可以在 <code>CommandController</code> 的所有子类中手动绑定。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring 有一些内置的 <code>PropertyEditors</code> 来简化你代码。所有项目都在下表中列出了，它们都位于<code>org.springframework.beans.propertyeditors</code> 包中。大部分但不是全部（如下所示）由 <code>BeanWrapperImpl</code> 默认注册。在以某种方式配置属性编辑器的情况下，你当然可以注册自己的自定义编辑器来覆盖默认的行为：</p>
</div>
<table id="beans-beans-property-editors-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 12. 内置 PropertyEditors</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类</th>
<th class="tableblock halign-left valign-top">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayPropertyEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字节数组编辑器。字符串将被简单地转换为相应的字节表示。由 <code>BeanWrapperImpl</code> 默认注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClassEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将表示类的字符串解析为实际类，反之亦然。当找不到类时，会抛出 <code>IllegalArgumentException</code> 。由 <code>BeanWrapperImpl</code> 默认注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomBooleanEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为 <code>Boolean</code> 属性自定义属性编辑器。由 <code>BeanWrapperImpl</code> 默认注册，但可以通过将自定义实例注册为自定义编辑器来覆盖之前的配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomCollectionEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合属性编辑器，将任何源 <code>Collection</code> 转换成给定的目标 <code>Collection</code> 类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomDateEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">java.util.Date 自定义属性编辑器，支持自定义日期格式。默认并未注册。必须由用户根据需求以适当的格式注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomNumberEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自定义属性编辑器，用于任何Number 子类，如 <code>Integer</code>， <code>Long</code>，<code>Float</code>，<code>Double</code>。由 <code>BeanWrapperImpl</code> 默认注册，但可以通过将自定义实例注册为自定义编辑器来覆盖之前的配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FileEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">能够将字符串解析为 <code>java.io.File</code> 对象。 由 <code>BeanWrapperImpl</code> 默认注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InputStreamEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单向属性编辑器，能够接受一个文本字符串并生成（通过中间媒介 <code>ResourceEditor</code>和 <code>Resource</code>）一个 <code>InputStream</code> ，所以 <code>InputStream</code> 属性可以直接设置为 Strings。注意默认的用法不会为你关闭 <code>InputStream</code>！ 由 <code>BeanWrapperImpl</code> 默认注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">能够将字符串解析为 <code>Locale</code> 对象，反之亦然（字符串格式是<em class="language">[country]</em>[variant]，与Locale 提供的 toString() 方法是一样的）。由 <code>BeanWrapperImpl</code> 默认注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> 能够将字符串解析为 <code>java.util.regex.Pattern</code> 对象，反之亦然。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PropertiesEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">能够将字符串（使用<code>java.util.Properties</code> 类的 javadoc 中定义的格式进行格式化）转换为 <code>Properties</code> 对象。由 <code>BeanWrapperImpl</code> 默认注册。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringTrimmerEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">修剪字符串的属性编辑器。 可以允许将空字符串转换为 <code>null</code> 值。默认并未注册;必须由用户根据需求注册。</td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>URLEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">能够将 <code>URL</code> 的字符串表示解析为实际的 <code>URL</code> 对象。 由 <code>BeanWrapperImpl</code> 默认注册。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring使用 <code>java.beans.PropertyEditorManager</code> 来设置可能需要的属性编辑器的搜索路径。 搜索路径还包括 <code>sun.bean.editors</code> ，其中包括用于 <code>Font</code>，<code>Color</code> 和大多数基本类型的 <code>PropertyEditor</code> 实现。还要注意，如果 <code>PropertyEditor</code> 类与它们处理的类位于同一个包中，并且与该类具有相同的名称，并以 <code>'Editor'</code> ，即使他们没有被显式注册，标准 JavaBeans 基础结构约会自动发现 <code>PropertyEditor</code> 类; 例如，对于以下类和包结构，这足以使 <code>FooEditor</code> 类被识别并用作 <code>Foo</code> 类型属性的 <code>PropertyEditor</code>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Foo
      FooEditor // the PropertyEditor for the Foo class</pre>
</div>
</div>
<div class="paragraph">
<p>注意你也可以在这里使用标准的 <code>BeanInfo</code> JavaBeans 机制（在
  <a href="http://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">这里</a>描述）。下面是一个使用 <code>BeanInfo</code> 机制来显式注册一个或多个 <code>PropertyEditor</code> 实例和关联类的属性的例子。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Foo
      FooBeanInfo // the BeanInfo for the Foo class</pre>
</div>
</div>
<div class="paragraph">
<p>这里是引用的 <code>FooBeanInfo</code> 类的 Java 源代码。这会将 <code>CustomNumberEditor</code> 与 <code>Foo</code> 类的 <code>age</code> 属性相关联。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">FooBeanInfo</span> <span class="directive">extends</span> <span class="predefined-type">SimpleBeanInfo</span> {

        <span class="directive">public</span> <span class="predefined-type">PropertyDescriptor</span><span class="type">[]</span> getPropertyDescriptors() {
                <span class="keyword">try</span> {
                        <span class="directive">final</span> <span class="predefined-type">PropertyEditor</span> numberPE = <span class="keyword">new</span> CustomNumberEditor(<span class="predefined-type">Integer</span>.class, <span class="predefined-constant">true</span>);
                        <span class="predefined-type">PropertyDescriptor</span> ageDescriptor = <span class="keyword">new</span> <span class="predefined-type">PropertyDescriptor</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, Foo.class) {
                                <span class="directive">public</span> <span class="predefined-type">PropertyEditor</span> createPropertyEditor(<span class="predefined-type">Object</span> bean) {
                                        <span class="keyword">return</span> numberPE;
                                };
                        };
                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">PropertyDescriptor</span><span class="type">[]</span> { ageDescriptor };
                }
                <span class="keyword">catch</span> (<span class="exception">IntrospectionException</span> ex) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">Error</span>(ex.toString());
                }
        }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="beans-beans-conversion-customeditor-registration"><a class="anchor" href="#beans-beans-conversion-customeditor-registration"></a>注册额外的自定义属性编辑器</h5>
<div class="paragraph">
<p>将 bean 属性设置为字符串值时，Spring IoC 容器最终将使用标准 JavaBean <code>PropertyEditors</code> 将这些字符串转换为该属性的复杂类型。 Spring 预注册了一些定制的 <code>PropertyEditors</code>（例如，将一个以字符串表示的类名转换为一个真实的 <code>Class</code> 对象）。另外，Java 的标准 JavaBean <code>PropertyEditor</code> 查找机制允许只要一个 <code>PropertyEditor</code> 类被恰当地命名，并且被放在与它提供支持的类相同的包中，便能被自动找到。</p>
</div>
<div class="paragraph">
<p>如果需要注册其他的自定义 <code>PropertyEditors</code>，有几种机制可用。通常不方便或不推荐的最手动的方法是假设你有一个 <code>BeanFactory</code> 引用，使用 <code>ConfigurableBeanFactory</code> 接口的 <code>registerCustomEditor()</code>方法。另一种稍微方便一点的机制是使用一个名为 <code>CustomEditorConfigurer</code> 的特殊的 bean 工厂 post-processor。尽管 bean 工厂 post-processor 可以与 <code>BeanFactory</code> 实现结合使用，但是 <code>CustomEditorConfigurer</code> 具有嵌套的属性设置，因此强烈建议将其与 <code>ApplicationContext</code> 一起使用，它可以以类似于任何其他 bean 的方式进行部署，并自动检测和应用。</p>
</div>
<div class="paragraph">
<p>请注意，所有的 bean 工厂和应用程序上下文会自动使用一些内置的属性编辑器，通过使用称为 <code>BeanWrapper</code> 的东西来处理属性转换。<a href="#beans-beans-conversion">上一节</a> 中列出了 <code>BeanWrapper</code> 注册的标准属性编辑器。此外，<code>ApplicationContexts</code> 还会覆盖或添加额外数量的编辑器，以适合特定应用程序上下文类型的方式处理资源查找。</p>
</div>
<div class="paragraph">
<p>标准 JavaBeans <code>PropertyEditor</code> 实例用于将以字符串表示的属性值转换为属性的实际复杂类型。 CustomEditorConfigurer（一个 bean 工厂 post-processor ）可以方便地将对额外 <code>PropertyEditor</code> 实例的支持添加到一个ApplicationContext中。</p>
</div>
<div class="paragraph">
<p>考虑一个用户类 <code>ExoticType</code> ，以及需要将 <code>ExoticType</code> 设置为属性的另一个类<code>DependsOnExoticType</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">example</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExoticType</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="directive">public</span> ExoticType(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">DependsOnExoticType</span> {

        <span class="directive">private</span> ExoticType type;

        <span class="directive">public</span> <span class="type">void</span> setType(ExoticType type) {
                <span class="local-variable">this</span>.type = type;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当设置正确的时候，我们希望能够将类型属性赋值为一个字符串，<code>PropertyEditor</code> 会在幕后将这个字符串转换成一个实际的 <code>ExoticType</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.DependsOnExoticType</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aNameForExoticType</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PropertyEditor</code> 的实现可能看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// converts string representation to ExoticType object</span>
<span class="keyword">package</span> <span class="namespace">example</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExoticTypeEditor</span> <span class="directive">extends</span> <span class="predefined-type">PropertyEditorSupport</span> {

        <span class="directive">public</span> <span class="type">void</span> setAsText(<span class="predefined-type">String</span> text) {
                setValue(<span class="keyword">new</span> ExoticType(text.toUpperCase()));
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们使用 <code>CustomEditorConfigurer</code> 向 <code>ApplicationContext</code> 注册新的 <code>PropertyEditor</code> ，然后根据需要使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.CustomEditorConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customEditors</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;map&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ExoticType</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ExoticTypeEditor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/map&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-beans-conversion-customeditor-registration-per"><a class="anchor" href="#beans-beans-conversion-customeditor-registration-per"></a>使用 PropertyEditorRegistrars</h6>
<div class="paragraph">
<p>向 Spring 容器注册属性编辑器的另一种机制是创建和使用 <code>PropertyEditorRegistrar</code>。当你需要在几种不同的情况下使用同一组属性编辑器时，此接口特别有用：编写相应的注册器，并在每种情况下重用。<code>PropertyEditorRegistrars</code> 与一个名为 <code>PropertyEditorRegistry</code> 的接口同时使用，这是一个被 Spring <code>BeanWrapper</code>（和 <code>DataBinder</code> ）实现的接口。 <code>PropertyEditorRegistrars</code> 与 <code>CustomEditorConfigurer</code>（在 <a href="#beans-beans-conversion-customeditor-registration">这里</a> 介绍）结合使用时特别方便，它暴露了一个名为<code>setPropertyEditorRegistrars(..)</code> 的属性：以这种方式添加到 <code>CustomEditorConfigurer</code> 的 <code>PropertyEditorRegistrars</code> 可以很容易地与<code>DataBinder</code> 和 Spring MVC <code>Controllers</code> 共享。此外，它避免了在自定义编辑器上需要同步的缺点：<code>PropertyEditorRegistrar</code> 应该为每次创建 bean 的尝试对应创建新的 <code>PropertyEditor</code> 实例。</p>
</div>
<div class="paragraph">
<p>使用 <code>PropertyEditorRegistrar</code> 最好的方法在例子中。首先，您需要创建自己的 <code>PropertyEditorRegistrar</code> 实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.foo.editors.spring</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">CustomPropertyEditorRegistrar</span> <span class="directive">implements</span> PropertyEditorRegistrar {

        <span class="directive">public</span> <span class="type">void</span> registerCustomEditors(PropertyEditorRegistry registry) {

                <span class="comment">// it is expected that new PropertyEditor instances are created</span>
                registry.registerCustomEditor(ExoticType.class, <span class="keyword">new</span> ExoticTypeEditor());

                <span class="comment">// you could register as many custom property editors as are required here...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关 <code>PropertyEditorRegistrar</code> 实现的示例，另请参阅 <code>org.springframework.beans.support.ResourceEditorRegistrar</code> 。 注意在它的 <code>registerCustomEditors(..)</code> 方法的实现中，它为每个属性编辑器创建新的实例。</p>
</div>
<div class="paragraph">
<p>接下来，我们配置一个 <code>CustomEditorConfigurer</code> 并将其 <code>CustomPropertyEditorRegistrar</code> 的一个实例注入到其中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.CustomEditorConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">propertyEditorRegistrars</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customPropertyEditorRegistrar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customPropertyEditorRegistrar</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.editors.spring.CustomPropertyEditorRegistrar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，在本章的重点之外，对于那些使用 <a href="web.html#mvc">Spring 的 MVC Web 框架</a> 的使用者来说，使用 <code>PropertyEditorRegistrars</code> 和数据绑定 <code>Controllers</code>（如<code>SimpleFormController</code>）非常方便。下面的例子使用 <code>PropertyEditorRegistrar</code> 实现一个 <code>initBinder(..)</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">RegisterUserController</span> <span class="directive">extends</span> SimpleFormController {

        <span class="directive">private</span> <span class="directive">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;

        <span class="directive">public</span> RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
                <span class="local-variable">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;
        }

        <span class="directive">protected</span> <span class="type">void</span> initBinder(HttpServletRequest request,
                        ServletRequestDataBinder binder) <span class="directive">throws</span> <span class="exception">Exception</span> {
                <strong><span class="local-variable">this</span>.customPropertyEditorRegistrar.registerCustomEditors(binder);</strong>
        }

        <span class="comment">// other methods to do with registering a User</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种 <code>PropertyEditor</code> 注册的风格可以简化代码（<code>initBinder(..)</code> 的实现只是一行！），并允许将通用的 <code>PropertyEditor</code> 注册代码封装在一个类中，然后根据需要在众多 <code>Controllers</code> 之间共享。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert"><a class="anchor" href="#core-convert"></a>3.5. Spring 类型转换</h3>
<div class="paragraph">
<p>Spring 3 引入了一个 <code>core.convert</code> 包，提供了一个通用的类型转换系统。系统定义了一个 SPI 来实现类型转换逻辑，以及一个在运行时执行类型转换的 API。在一个Spring容器中，这个系统可以用来替代属性编辑器来将外部化的 bean 属性值字符串转换为所需的属性类型。公共 API 也可以在需要进行类型转换的应用程序中使用。</p>
</div>
<div class="sect3">
<h4 id="core-convert-Converter-API"><a class="anchor" href="#core-convert-Converter-API"></a>3.5.1. Converter SPI</h4>
<div class="paragraph">
<p>实现类型转换逻辑的 SPI 是简单的而且是强类型的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">Converter</span>&lt;S, T&gt; {

        T convert(S source);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建自己的转换器，只需实现上面的接口。 将 <code>S</code> 指定为要转换的类型，将 <code>T</code> 指定为转换后的类型。 如果 <code>S</code> 的集合或者数组需要被转换为 <code>T</code> 的数组或者集合的话，这样的转换器也可以被透明地应用，只要委托的数组/收集转换器也被注册（默认是 <code>DefaultConversionService</code>）。</p>
</div>
<div class="paragraph">
<p>对于每个<code>convert(S)</code> 调用，源参数保证不为 null。如果转换失败，您的转换器可能会抛出任何未检查的异常; 具体而言，应抛出 <code>IllegalArgumentException</code> 异常来报告无效的源值。 注意确保您的 <code>Converter</code> 实现是线程安全的。</p>
</div>
<div class="paragraph">
<p>为方便起见，<code>core.convert.support</code> 包提供了几个转换器实现。这些包括从字符串到数字和其他常见类型的转换器。 以 <code>StringToInteger</code>  作为典型的 <code>Converter</code> 实现的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.support</span>;

<span class="directive">final</span> <span class="type">class</span> <span class="class">StringToInteger</span> <span class="directive">implements</span> Converter&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Integer</span>&gt; {

        <span class="directive">public</span> <span class="predefined-type">Integer</span> convert(<span class="predefined-type">String</span> source) {
                <span class="keyword">return</span> <span class="predefined-type">Integer</span>.valueOf(source);
        }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConverterFactory-SPI"><a class="anchor" href="#core-convert-ConverterFactory-SPI"></a>3.5.2. ConverterFactory 转换工厂</h4>
<div class="paragraph">
<p>当您需要集中整个类层次结构的转换逻辑时，例如，从 String 转换为 java.lang.Enum 对象时，实现 <code>ConverterFactory</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ConverterFactory</span>&lt;S, R&gt; {

        &lt;T <span class="directive">extends</span> R&gt; Converter&lt;S, T&gt; getConverter(<span class="predefined-type">Class</span>&lt;T&gt; targetType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 S 指定为要转换的类型，将 R 指定为转换之后允许的类范围的基本类型。然后实现 getConverter(Class&lt;T&gt;)，其中 T 是 R 的子类。</p>
</div>
<div class="paragraph">
<p>以 <code>StringToEnum</code> ConverterFactory 为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.support</span>;

<span class="directive">final</span> <span class="type">class</span> <span class="class">StringToEnumConverterFactory</span> <span class="directive">implements</span> ConverterFactory&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Enum</span>&gt; {

        <span class="directive">public</span> &lt;T <span class="directive">extends</span> <span class="predefined-type">Enum</span>&gt; Converter&lt;<span class="predefined-type">String</span>, T&gt; getConverter(<span class="predefined-type">Class</span>&lt;T&gt; targetType) {
                <span class="keyword">return</span> <span class="keyword">new</span> StringToEnumConverter(targetType);
        }

        <span class="directive">private</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">StringToEnumConverter</span>&lt;T <span class="directive">extends</span> <span class="predefined-type">Enum</span>&gt; <span class="directive">implements</span> Converter&lt;<span class="predefined-type">String</span>, T&gt; {

                <span class="directive">private</span> <span class="predefined-type">Class</span>&lt;T&gt; enumType;

                <span class="directive">public</span> StringToEnumConverter(<span class="predefined-type">Class</span>&lt;T&gt; enumType) {
                        <span class="local-variable">this</span>.enumType = enumType;
                }

                <span class="directive">public</span> T convert(<span class="predefined-type">String</span> source) {
                        <span class="keyword">return</span> (T) <span class="predefined-type">Enum</span>.valueOf(<span class="local-variable">this</span>.enumType, source.trim());
                }
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-GenericConverter-SPI"><a class="anchor" href="#core-convert-GenericConverter-SPI"></a>3.5.3. GenericConverter 通用转换器</h4>
<div class="paragraph">
<p>当您需要某个复杂的 Converter 实现时，请考虑 GenericConverter 接口。使用更灵活但更少的强类型签名，GenericConverter 支持在多个源类型和目标类型之间进行转换。此外，GenericConverter 还提供了在实现转换逻辑时可以使用的源和目标字段上下文。 这样的上下文允许类型转换由字段注解或在字段签名上声明的通用信息来驱动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">GenericConverter</span> {

        <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;ConvertiblePair&gt; getConvertibleTypes();

        <span class="predefined-type">Object</span> convert(<span class="predefined-type">Object</span> source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要实现 GenericConverter，getConvertibleTypes() 返回支持的源→目标类型对。然后实现 convert(Object, TypeDescriptor, TypeDescriptor) 来实现你的转换逻辑。源 TypeDescriptor 提供对持有正在转换的值的源字段的访问。 目标 TypeDescriptor 提供对设置转换值的目标字段的访问。</p>
</div>
<div class="paragraph">
<p>GenericConverter的一个很好的例子是在 Java Array 和 Collection 之间转换的转换器。这样的 ArrayToCollectionConverter 内省了声明目标 Collection 类型的字段来解析 Collection 的元素类型。 这允许源数组中的每个元素在目标字段被设置为目标 Collection 类型之前转换为 Collection 元素类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于 GenericConverter 是一个更复杂的 SPI 接口，只有在需要时才使用它。Converter 或 ConverterFactory 用于基本类型转换需求。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="core-convert-ConditionalGenericConverter-SPI"><a class="anchor" href="#core-convert-ConditionalGenericConverter-SPI"></a>ConditionalGenericConverter</h5>
<div class="paragraph">
<p>有时你只想要 <code>Converter</code> 在特定的条件成立的情况下执行。例如，如果目标字段上存在特定的注解，则你可能只想执行某个 <code>Converter</code> 。或者，如果在目标类上定义了特定的方法（如 <code>static valueOf</code> 方法），就执行某个 <code>Converter</code>。<code>ConditionalGenericConverter</code> 是 <code>GenericConverter</code> 和 <code>ConditionalConverter</code> 接口的联合，允许你定义这样的自定义匹配条件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ConditionalConverter</span> {

        <span class="type">boolean</span> matches(TypeDescriptor sourceType, TypeDescriptor targetType);

}

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ConditionalGenericConverter</span>
        <span class="directive">extends</span> GenericConverter, ConditionalConverter {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ConditionalGenericConverter</code> 的一个很好的例子是一个 EntityConverter，它在持久化实体标识符和实体引用之间进行转换。 这种 EntityConverter 可能只有在目标实体类型声明静态查找方法（例如，<code>findAccount(Long)</code>）的时候才会匹配成功。 你可以在 <code>matches(TypeDescriptor, TypeDescriptor)</code> 的实现中执行这样的 finder 方法检查。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConversionService-API"><a class="anchor" href="#core-convert-ConversionService-API"></a>3.5.4. ConversionService API 转换服务接口</h4>
<div class="paragraph">
<p>ConversionService 定义了用于在运行时执行类型转换逻辑的统一 API。转换器通常在这个外观接口后执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ConversionService</span> {

        <span class="type">boolean</span> canConvert(<span class="predefined-type">Class</span>&lt;?&gt; sourceType, <span class="predefined-type">Class</span>&lt;?&gt; targetType);

        &lt;T&gt; T convert(<span class="predefined-type">Object</span> source, <span class="predefined-type">Class</span>&lt;T&gt; targetType);

        <span class="type">boolean</span> canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

        <span class="predefined-type">Object</span> convert(<span class="predefined-type">Object</span> source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>大多数 ConversionService 实现也实现了 <code>ConverterRegistry</code>，它提供了一个用于注册转换器的 SPI。 在内部，ConversionService 实现委托其已注册的转换器来执行类型转换逻辑。</p>
</div>
<div class="paragraph">
<p>在 <code>core.convert.support</code> 包中提供了强健的 ConversionService 实现。 <code>GenericConversionService</code> 是适用于大多数环境的通用实现。<code>ConversionServiceFactory</code> 为创建常见的 ConversionService 配置提供了一个便利的工厂。</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-Spring-config"><a class="anchor" href="#core-convert-Spring-config"></a>3.5.5. 配置 ConversionService</h4>
<div class="paragraph">
<p>ConversionService 是一个无状态对象，被设计用于在应用程序启动时实例化，然后在多个线程之间共享。 在 Spring 应用程序中，通常为每个 Spring 容器（或 ApplicationContext）配置一个 ConversionService 实例。 该 ConversionService 将被 Spring 获取，然后在框架需要执行类型转换时使用。 您也可以将这个 ConversionService 注入到任何一个bean中，并直接调用它。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果 Spring 中没有注册 ConversionService，则使用原始的基于 PropertyEditor 的系统。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要用 Spring 注册一个默认的 ConversionService，需要添加下面的id 为 <code>conversionService</code> 的 bean 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">conversionService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ConversionServiceFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>默认的 ConversionService 可以在字符串，数字，枚举，集合，map 和其他常用类型之间进行转换。 要用自定义转换器补充或覆盖默认转换器，需要设置 <code>converters</code> 属性。属性值可以是 Converter，ConverterFactory 或 GenericConverter 接口的实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">conversionService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ConversionServiceFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">converters</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MyCustomConverter</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Spring MVC 应用程序中使用 ConversionService 也很常见。 请参阅 Spring MVC 章节中的 <a href="web.html#mvc-config-conversion">转换和格式化</a>。</p>
</div>
<div class="paragraph">
<p>在某些情况下，您可能希望在转换过程中对其进行格式化。有关使用 <code>FormattingConversionServiceFactoryBean</code> 的详细信息，请参阅 <a href="#format-FormatterRegistry-SPI">FormatterRegistry SPI</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-programmatic-usage"><a class="anchor" href="#core-convert-programmatic-usage"></a>3.5.6. 编程使用 ConversionService</h4>
<div class="paragraph">
<p>要以编程方式使用 ConversionServic e实例，只需像为其他任何 bean 注入引用即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MyService(ConversionService conversionService) {
                <span class="local-variable">this</span>.conversionService = conversionService;
        }

        <span class="directive">public</span> <span class="type">void</span> doIt() {
                <span class="local-variable">this</span>.conversionService.convert(...)
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于大多数使用用例，可以使用指定 <em>targetType</em> 的 <code>convert</code> 方法，但这不适用于更复杂的类型，如参数化元素的集合。例如，如果要以编程方式将 <code>Integer</code> <code>List</code> 转换为<code>String</code> <code>List</code>，则需要提供源和目标类型的格式化定义。</p>
</div>
<div class="paragraph">
<p>幸运的是，<code>TypeDescriptor</code>  提供了多种选项来简化实现这样的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultConversionService cs = <span class="keyword">new</span> DefaultConversionService();

<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; input = ....
cs.convert(input,
        TypeDescriptor.forObject(input), <span class="comment">// List&lt;Integer&gt; type descriptor</span>
        TypeDescriptor.collection(<span class="predefined-type">List</span>.class, TypeDescriptor.valueOf(<span class="predefined-type">String</span>.class)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>DefaultConversionService</code>  会自动注册适用于大多数环境的转换器。 这包括集合转换器，标量转换器，以及基本的 <code>Object</code> 到 <code>String</code> 的转换器。可以使用 <code>DefaultConversionService</code> 类上的 <em>static</em> <code>addDefaultConverters</code> 方法将相同的转换器注册到任何 <code>ConverterRegistry</code>。</p>
</div>
<div class="paragraph">
<p>值类型转换器将被重用于数组和集合，因此，假设标准的集合处理是合适的，就不需要创建一个特定的转换器来从 <code>S</code> 集合转换为 <code>T</code> 集合。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format"><a class="anchor" href="#format"></a>3.6. Spring 字段格式化</h3>
<div class="paragraph">
<p>如上一小节所述，<a href="#core-convert"><code>core.convert</code></a> 是一个通用的类型转换系统。它提供了一个统一的 ConversionService API 以及一个强类型的 Converter SPI，用于实现从一种类型到另一种类型的转换逻辑。 Spring 容器使用这个系统来绑定 bean 的属性值。另外，Spring 表达式语言（SpEL）和 DataBinder 都使用这个系统绑定字段值。例如，当 SpEL 需要强制将 <code>Short</code> 转换为 <code>Long</code> 来完成一个 <code>expression.setValue(Object bean, Object value)</code> 尝试时，core.convert 系统会强制执行这个操作。</p>
</div>
<div class="paragraph">
<p>现在考虑典型客户端环境（如 Web 或桌面应用程序）的类型转换要求。在这样的环境中，您通常将 String 作为转换的源类型来支持客户端回发过程，并将 String 作为转换的目的类型返回以支持视图呈现过程。另外，您经常需要本地化字符串值。更一般的 <em>core.convert</em> Converter SPI 不能直接解决这种格式化要求。为了直接解决这些问题，Spring 3 引入了一个方便的 Formatter SPI，为客户端环境提供了 PropertyEditor 的一个简单而健壮的替代方案。</p>
</div>
<div class="paragraph">
<p>通常，在需要实现通用类型转换逻辑时使用 Converter SPI；例如，在 java.util.Date 和 java.lang.Long 之间进行类型转换。在客户端环境（如Web应用程序）中使用 Formatter SPI 时，需要解析和打印本地化的字段值。 ConversionService 为两个 SPI 提供了一个统一的类型转换API。</p>
</div>
<div class="sect3">
<h4 id="format-Formatter-SPI"><a class="anchor" href="#format-Formatter-SPI"></a>3.6.1. Formatter SPI</h4>
<div class="paragraph">
<p>用于实现字段格式化逻辑的 Formatter SPI 是简单且强类型的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">Formatter</span>&lt;T&gt; <span class="directive">extends</span> Printer&lt;T&gt;, <span class="predefined-type">Parser</span>&lt;T&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Formatter 继承了 Printer 和 Parser 内置接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Printer</span>&lt;T&gt; {
        <span class="predefined-type">String</span> print(T fieldValue, <span class="predefined-type">Locale</span> locale);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.text.ParseException</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">Parser</span>&lt;T&gt; {
        T parse(<span class="predefined-type">String</span> clientValue, <span class="predefined-type">Locale</span> locale) <span class="directive">throws</span> <span class="exception">ParseException</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建自己的格式化程序，只需实现上面的格式化接口。将 T 参数化为要格式化的对象的类型，例如 <code>java.util.Date</code>。实现 <code>print()</code> 操作来打印 T 的实例以在客户端语言环境中显示。实现 <code>parse()</code>操作，从客户端语言环境返回的格式化表示中解析 T 的一个实例。如果解析尝试失败，则格式化程序应该抛出 ParseException 或 IllegalArgumentException。注意确保您的 Formatter 实现是线程安全的。
</p>
</div>
<div class="paragraph">
<p>方便起见，<code>format</code> 子程序包中提供了几个格式化程序实现。<code>number</code> 包提供了 <code>NumberFormatter</code>，<code>CurrencyFormatter</code> 和 <code>PercentFormatter</code> 来格式化使用 <code>java.text.NumberFormat</code> 的 <code>java.lang.Number</code> 对象。<code>datetime</code> 包提供了一个 <code>DateFormatter</code> 用 <code>java.text.DateFormat</code> 来格式化 <code>java.util.Date</code> 对象。<code>datetime.joda</code> 包提供基于 <a href="http://joda-time.sourceforge.net">Joda Time library</a> 的综合日期时间格式化支持。</p>
</div>
<div class="paragraph">
<p>以 <code>DateFormatter</code> 为 <code>Formatter</code> 实现的一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format.datetime</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">DateFormatter</span> <span class="directive">implements</span> <span class="predefined-type">Formatter</span>&lt;<span class="predefined-type">Date</span>&gt; {

        <span class="directive">private</span> <span class="predefined-type">String</span> pattern;

        <span class="directive">public</span> <span class="predefined-type">DateFormatter</span>(<span class="predefined-type">String</span> pattern) {
                <span class="local-variable">this</span>.pattern = pattern;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> print(<span class="predefined-type">Date</span> date, <span class="predefined-type">Locale</span> locale) {
                <span class="keyword">if</span> (date == <span class="predefined-constant">null</span>) {
                        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
                }
                <span class="keyword">return</span> getDateFormat(locale).format(date);
        }

        <span class="directive">public</span> <span class="predefined-type">Date</span> parse(<span class="predefined-type">String</span> formatted, <span class="predefined-type">Locale</span> locale) <span class="directive">throws</span> <span class="exception">ParseException</span> {
                <span class="keyword">if</span> (formatted.length() == <span class="integer">0</span>) {
                        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
                }
                <span class="keyword">return</span> getDateFormat(locale).parse(formatted);
        }

        <span class="directive">protected</span> <span class="predefined-type">DateFormat</span> getDateFormat(<span class="predefined-type">Locale</span> locale) {
                <span class="predefined-type">DateFormat</span> dateFormat = <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>(<span class="local-variable">this</span>.pattern, locale);
                dateFormat.setLenient(<span class="predefined-constant">false</span>);
                <span class="keyword">return</span> dateFormat;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 团队欢迎社区驱动的 <code>Formatter</code> 贡献; 见向 <a href="https://jira.spring.io/browse/SPR">jira.spring.io</a> 贡献。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-CustomFormatAnnotations"><a class="anchor" href="#format-CustomFormatAnnotations"></a>3.6.2. 注解驱动的格式化</h4>
<div class="paragraph">
<p>你将会看到，字段格式化可以通过字段类型或注解进行配置。要将注解绑定到 formatter，需要实现 AnnotationFormatterFactory：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotationFormatterFactory</span>&lt;A <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; {

        <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getFieldTypes();

        Printer&lt;?&gt; getPrinter(A annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType);

        <span class="predefined-type">Parser</span>&lt;?&gt; getParser(A annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>参数化的 A 是你想要与格式化逻辑关联的字段注解类型，例如 <code>org.springframework.format.annotation.DateTimeFormat</code>。<code>getFieldTypes()</code> 返回可以使用该注解的字段类型。<code>getPrinter()</code> 返回一个用于打印注解字段的值的 Printer。<code>getParser()</code> 返回用来解析注解字段 clientValue 的 Parser。</p>
</div>
<div class="paragraph">
<p>下面的示例 AnnotationFormatterFactory 实现将 @NumberFormat 注解绑定到一个 formatter。 此注解允许指定 number 样式或特定格式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">NumberFormatAnnotationFormatterFactory</span>
                <span class="directive">implements</span> AnnotationFormatterFactory&lt;<span class="predefined-type">NumberFormat</span>&gt; {

        <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getFieldTypes() {
                <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt;(asList(<span class="keyword">new</span> <span class="predefined-type">Class</span>&lt;?&gt;<span class="type">[]</span> {
                        <span class="predefined-type">Short</span>.class, <span class="predefined-type">Integer</span>.class, <span class="predefined-type">Long</span>.class, <span class="predefined-type">Float</span>.class,
                        <span class="predefined-type">Double</span>.class, <span class="predefined-type">BigDecimal</span>.class, <span class="predefined-type">BigInteger</span>.class }));
        }

        <span class="directive">public</span> Printer&lt;<span class="predefined-type">Number</span>&gt; getPrinter(<span class="predefined-type">NumberFormat</span> annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType) {
                <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);
        }

        <span class="directive">public</span> <span class="predefined-type">Parser</span>&lt;<span class="predefined-type">Number</span>&gt; getParser(<span class="predefined-type">NumberFormat</span> annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType) {
                <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);
        }

        <span class="directive">private</span> <span class="predefined-type">Formatter</span>&lt;<span class="predefined-type">Number</span>&gt; configureFormatterFrom(<span class="predefined-type">NumberFormat</span> annotation,
                        <span class="predefined-type">Class</span>&lt;?&gt; fieldType) {
                <span class="keyword">if</span> (!annotation.pattern().isEmpty()) {
                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">NumberFormatter</span>(annotation.pattern());
                } <span class="keyword">else</span> {
                        <span class="predefined-type">Style</span> style = annotation.style();
                        <span class="keyword">if</span> (style == <span class="predefined-type">Style</span>.PERCENT) {
                                <span class="keyword">return</span> <span class="keyword">new</span> PercentFormatter();
                        } <span class="keyword">else</span> <span class="keyword">if</span> (style == <span class="predefined-type">Style</span>.CURRENCY) {
                                <span class="keyword">return</span> <span class="keyword">new</span> CurrencyFormatter();
                        } <span class="keyword">else</span> {
                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">NumberFormatter</span>();
                        }
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要触发格式化，只需使用 @NumberFormat 注解字段即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> {

        <span class="annotation">@NumberFormat</span>(style=<span class="predefined-type">Style</span>.CURRENCY)
        <span class="directive">private</span> <span class="predefined-type">BigDecimal</span> decimal;

}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="format-annotations-api"><a class="anchor" href="#format-annotations-api"></a>格式化注解 API</h5>
<div class="paragraph">
<p><code>org.springframework.format.annotation</code> 包中存在可移植的格式化 API。使用 @NumberFormat 格式化 java.lang.Number 字段。使用 @DateTimeFormat 格式化 java.util.Date，java.util.Calendar，java.util.Long 或 Joda </p>
</div>
<div class="paragraph">
<p>下面的示例使用 @DateTimeFormat 将 java.util.Date 格式化为 ISO 日期（yyyy-MM-dd）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> {

        <span class="annotation">@DateTimeFormat</span>(iso=ISO.DATE)
        <span class="directive">private</span> <span class="predefined-type">Date</span> date;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistry-SPI"><a class="anchor" href="#format-FormatterRegistry-SPI"></a>3.6.3. FormatterRegistry SPI</h4>
<div class="paragraph">
<p>FormatterRegistry 是用于注册 formatter 和 converter 的 SPI。<code>FormattingConversionService</code> 是适用于大多数环境的 FormatterRegistry 的一个实现。 这个实现可以使用 <code>FormattingConversionServiceFactoryBean</code> 以编程方式或声明方式配置为Spring bean。 因为这个实现也实现了 <code>ConversionService</code>，所以它可以直接配置用于 Spring 的 DataBinder 和 Spring 表达式语言（SpEL）。</p>
</div>
<div class="paragraph">
<p>请看下面的 FormatterRegistry SPI：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">FormatterRegistry</span> <span class="directive">extends</span> ConverterRegistry {

        <span class="type">void</span> addFormatterForFieldType(<span class="predefined-type">Class</span>&lt;?&gt; fieldType, Printer&lt;?&gt; printer, <span class="predefined-type">Parser</span>&lt;?&gt; parser);

        <span class="type">void</span> addFormatterForFieldType(<span class="predefined-type">Class</span>&lt;?&gt; fieldType, <span class="predefined-type">Formatter</span>&lt;?&gt; formatter);

        <span class="type">void</span> addFormatterForFieldType(<span class="predefined-type">Formatter</span>&lt;?&gt; formatter);

        <span class="type">void</span> addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所示，Formatter 可以通过 fieldType 或注解进行注册。</p>
</div>
<div class="paragraph">
<p>FormatterRegistry SPI 允许您集中配置格式化规则，而不是在控制器中复制这样的配置。例如，你可能希望强制所有日期字段以特定方式格式化，或者使用特定注解的字段以特定方式格式化。使用共享的 FormatterRegistry，你只要一次性定义这些规则，然后需要格式化时应用这些规则。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistrar-SPI"><a class="anchor" href="#format-FormatterRegistrar-SPI"></a>3.6.4. FormatterRegistrar SPI</h4>
<div class="paragraph">
<p>FormatterRegistrar 是通过 FormatterRegistry 注册 formatter 和 converter 的 SPI：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">FormatterRegistrar</span> {

        <span class="type">void</span> registerFormatters(FormatterRegistry registry);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>FormatterRegistrar 在对于给定的格式类别（如日期格式）注册多个相关的 converter 和 formatter 时很有用。在声明式注册不满足需求的情况下也是有用的。例如，对于 <T> 泛型取得的不同的特定字段类型，某个 formatter 需要进行索引，或者在注册 Printer/Parser 对时。下一节提供有关 converter 和 formatter 注册的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="format-configuring-formatting-mvc"><a class="anchor" href="#format-configuring-formatting-mvc"></a>3.6.5. 在 Spring MVC 中配置格式化</h4>
<div class="paragraph">
<p>参见 Spring MVC 章节的 <a href="web.html#mvc-config-conversion">类型转换和格式化</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format-configuring-formatting-globaldatetimeformat"><a class="anchor" href="#format-configuring-formatting-globaldatetimeformat"></a>3.7. 配置全局的日期和时间格式</h3>
<div class="paragraph">
<p>默认情况下，未使用 <code>@DateTimeFormat</code> 注解的日期和时间字段使用 <code>DateFormat.SHORT</code> 风格从字符串转换而来。如果你需要，你可以通过定义你自己的全局格式来改变现有行为。</p>
</div>
<div class="paragraph">
<p>你需要确保 Spring 不会注册默认 formatter，而应该手动注册所有 formatter。使用 <code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code> 还是 <code>org.springframework.format.datetime.DateFormatterRegistrar</code> 类取决于你是否使用Joda时间库。</p>
</div>
<div class="paragraph">
<p>例如，下面的 Java 配置将会注册一个全局的 “yyyyMMdd” 格式。这个例子不依赖于 Joda 时间库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> FormattingConversionService conversionService() {

                <span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span>
                DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="predefined-constant">false</span>);

                <span class="comment">// Ensure @NumberFormat is still supported</span>
                conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());

                <span class="comment">// Register date conversion with a specific global format</span>
                DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();
                registrar.setFormatter(<span class="keyword">new</span> <span class="predefined-type">DateFormatter</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">yyyyMMdd</span><span class="delimiter">&quot;</span></span>));
                registrar.registerFormatters(conversionService);

                <span class="keyword">return</span> conversionService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你更喜欢基于 XML 的配置，则可以使用 <code>FormattingConversionServiceFactoryBean</code>。同样的例子，这次使用 Joda Time：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="error">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">conversionService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.support.FormattingConversionServiceFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">registerDefaultFormatters</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">formatters</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;set&gt;</span>
                                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.number.NumberFormatAnnotationFormatterFactory</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                        <span class="tag">&lt;/set&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">formatterRegistrars</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;set&gt;</span>
                                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dateFormatter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pattern</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yyyyMMdd</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                                <span class="tag">&lt;/bean&gt;</span>
                                        <span class="tag">&lt;/property&gt;</span>
                                <span class="tag">&lt;/bean&gt;</span>
                        <span class="tag">&lt;/set&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Joda Time 提供单独的不同类型来表示日期 <code>date</code>，时间 <code>time</code> 和日期时间 <code>date-time</code> 值。 应该使用 <code>JodaTimeFormatterRegistrar</code> 的 <code>dateFormatter</code>，<code>timeFormatter</code> 和 <code>dateTimeFormatter</code> 属性为每种类型配置不同的格式。 <code>DateTimeFormatterFactoryBean</code> 提供了创建 formatter 的简便方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你使用的是Spring MVC，请记住要显式地配置使用的转换服务。对于基于 Java 的 <code>@Configuration</code>，这意味着扩展 <code>WebMvcConfigurationSupport</code> 类并覆盖 <code>mvcConversionService()</code> 方法。对于 XML，你应该使用 <code>mvc:annotation-driven</code> 元素的 <code>'conversion-service'</code> 属性。有关详细信息，请参阅<a href="web.html#mvc-config-conversion">转换和格式</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-beanvalidation"><a class="anchor" href="#validation-beanvalidation"></a>3.8. Spring 验证</h3>
<div class="paragraph">
<p>Spring 3 引入了一些对其验证支持功能的增强。 首先，现在完全支持 JSR-303 Bean 验证 API。其次，当以编程方式使用时，Spring 的 DataBinder 现在可以验证对象并绑定到它们。第三，Spring MVC 现在支持声明性验证 <code>@Controller</code> 输入。</p>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-overview"><a class="anchor" href="#validation-beanvalidation-overview"></a>3.8.1. JSR-303 Bean 验证 API 概述</h4>
<div class="paragraph">
<p>JSR-303 标准化了 Java 平台的验证约束声明和元数据。 使用此 API，你可以使用声明式验证约束来注解域模型属性，并且运行时会强制执行它们。 有许多内置的约束可以利用。 你也可以定义你自己的自定义约束。</p>
</div>
<div class="paragraph">
<p>考虑一个简单的具有两个属性的 PersonForm 模型来进行说明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonForm</span> {
        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> <span class="type">int</span> age;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSR-303 允许你定义对这些属性的声明式验证约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonForm</span> {

        <span class="annotation">@NotNull</span>
        <span class="annotation">@Size</span>(max=<span class="integer">64</span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="annotation">@Min</span>(<span class="integer">0</span>)
        <span class="directive">private</span> <span class="type">int</span> age;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当这个类的一个实例被 JSR-303 验证器验证时，这些约束将被执行。</p>
</div>
<div class="paragraph">
<p>有关 JSR-303/JSR-349 的总览信息，请参阅 <a href="http://beanvalidation.org/">Bean验证网站</a>。 有关默认引用实现的特定功能的信息，请参阅 <a href="https://www.hibernate.org/412.html">Hibernate Validator</a> 文档。要学习如何将 Bean Validation 提供者设置为 Spring bean，请继续阅读。</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring"><a class="anchor" href="#validation-beanvalidation-spring"></a>3.8.2. 配置 Bean Validation Provider</h4>
<div class="paragraph">
<p>Spring 提供对 Bean Validation API 的全面支持。这包括对以 JSR-303/JSR-349 Bean Validation provider 作为 Spring bean 进行引导的方便支持。 这允许在你的应用程序在需要验证的任何地方注入 <code>javax.validation.ValidatorFactory</code> 或 <code>javax.validation.Validator</code>。</p>
</div>
<div class="paragraph">
<p>使用 <code>LocalValidatorFactoryBean</code> 将默认的 Validator 配置为一个 Spring bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">validator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的基本配置将触发 Bean Validation 使用其默认引导机制进行初始化。 JSR-303/JSR-349 provider（如Hibernate Validator）如期会出现在类路径中，并会自动检测到。</p>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-inject"><a class="anchor" href="#validation-beanvalidation-spring-inject"></a>注入 Validator</h5>
<div class="paragraph">
<p><code>LocalValidatorFactoryBean</code> 实现了 <code>javax.validation.ValidatorFactory</code> 和 <code>javax.validation.Validator</code>，以及 Spring 的 <code>org.springframework.validation.Validator</code>。你可以将这些接口的引用注入到需要调用验证逻辑的 bean 中。</p>
</div>
<div class="paragraph">
<p>如果你跟愿意直接使用 Bean Validation API，则注入对 <code>javax.validation.Validator</code> 的引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.validation.Validator</span>;

<span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> <span class="predefined-type">Validator</span> validator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您的 bean 需要Spring Validation API，则注入对 <code>org.springframework.validation.Validator</code> 的引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.validation.Validator</span>;

<span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> <span class="predefined-type">Validator</span> validator;

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-constraints"><a class="anchor" href="#validation-beanvalidation-spring-constraints"></a>配置自定义约束</h5>
<div class="paragraph">
<p>每个Bean Validation 约束由两部分组成。 首先，一个声明约束及其可配置的属性的 <code>@Constraint</code> 注解。其次，实现约束行为的 <code>javax.validation.ConstraintValidator</code> 接口的实现。为了将一个声明和一个实现关联起来，每个 <code>@Constraint</code> 注解引用一个对应的 ValidationConstraint 实现类。在运行时，<code>ConstraintValidatorFactory</code> 在你的域模型中遇到约束注解时实例化所引用的实现。</p>
</div>
<div class="paragraph">
<p>默认情况下，<code>LocalValidatorFactoryBean</code> 配置一个使用 Spring 创建 ConstraintValidator 实例的 <code>SpringConstraintValidatorFactory</code>。这允许你的自定义 ConstraintValidators 像任何其他 Spring bean 一样受益于依赖注入。</p>
</div>
<div class="paragraph">
<p>下面是一个自定义 <code>@Constraint</code> 声明的示例，之后是一个使用 Spring 进行依赖注入的相关 <code>ConstraintValidator</code>  实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.METHOD, <span class="predefined-type">ElementType</span>.FIELD})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Constraint</span>(validatedBy=MyConstraintValidator.class)
<span class="directive">public</span> <span class="annotation">@interface</span> MyConstraint {
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.validation.ConstraintValidator</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConstraintValidator</span> <span class="directive">implements</span> ConstraintValidator {

        <span class="annotation">@Autowired</span>;
        <span class="directive">private</span> Foo aDependency;

        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，一个 ConstraintValidator 实现可能像其他任何 Spring bean 一样拥有 @Autowired 依赖。</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-method"><a class="anchor" href="#validation-beanvalidation-spring-method"></a>Spring 驱动的方法验证</h5>
<div class="paragraph">
<p>Bean Validation 1.1 支持的方法验证功能以及 Hibernate Validator 4.3 的自定义扩展可以通过一个 <code>MethodValidationPostProcessor</code> bean 定义集成到 Spring 上下文中：:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.validation.beanvalidation.MethodValidationPostProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了符合 Spring 驱动的方法验证的条件，所有的目标类都需要使用 Spring 的 <code>@Validated</code> 注解，可以选择声明验证组来使用。使用 Hibernate Validator 和 Bean Validation 1.1 provider 查看 <code>MethodValidationPostProcessor</code> javadoc 以了解设置细节。</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-other"><a class="anchor" href="#validation-beanvalidation-spring-other"></a>其他配置选项</h5>
<div class="paragraph">
<p>在大多数情况下，默认的 <code>LocalValidatorFactoryBean</code>  配置应该足够了。对于各种 Bean Validation 结构，有许多配置选项，从消息插值到遍历解析。有关这些选项的更多信息，请参阅 <code>LocalValidatorFactoryBean</code> javadoc。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validation-binder"><a class="anchor" href="#validation-binder"></a>3.8.3. 配置 DataBinder</h4>
<div class="paragraph">
<p>从 Spring 3 开始，可以在 DataBinder 实例上使用 Validator 配置。配置完成后，可以通过调用 <code>binder.validate()</code>来调用 Validator。任何验证错误都会自动添加到 binder 的 BindingResult 中。</p>
</div>
<div class="paragraph">
<p>以编程方式使用 DataBinder 时，可以在绑定到目标对象后调用验证逻辑：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Foo target = <span class="keyword">new</span> Foo();
DataBinder binder = <span class="keyword">new</span> DataBinder(target);
binder.setValidator(<span class="keyword">new</span> FooValidator());

<span class="comment">// bind to the target object</span>
binder.bind(propertyValues);

<span class="comment">// validate the target object</span>
binder.validate();

<span class="comment">// get BindingResult that includes any validation errors</span>
BindingResult results = binder.getBindingResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>DataBinder 也可以通过 <code>dataBinder.addValidators</code> 和 <code>dataBinder.replaceValidators</code> 配置多个 <code>Validator</code> 实例。将全局配置的 Bean Validation 与本地在 DataBinder 实例上配置的 Spring <code>Validator</code> 相结合时，这非常有用。参见 <a href="#validation-mvc-configuring">[validation-mvc-configuring]</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-mvc"><a class="anchor" href="#validation-mvc"></a>3.8.4. Spring MVC 3 Validation</h4>
<div class="paragraph">
<p>参见 Spring MVC 章节的 <a href="web.html#mvc-config-validation">Validation</a>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expressions"><a class="anchor" href="#expressions"></a>4. Spring 表达式语言 (SpEL)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="expressions-intro"><a class="anchor" href="#expressions-intro"></a>4.1. 简介</h3>
<div class="paragraph">
<p>Spring 表达式语言（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象拓扑图。语言语法与Unified EL相似，但是提供了额外的功能，特别是方法调用和基本字符串模板功能。.</p>
</div>
<div class="paragraph">
<p>虽然还有其他几种可用的Java表达式语言，如 OGNL，MVEL和 JBoss EL（仅举几个例子），Spring 表达式语言的创建是为了向 Spring 社区提供单一支持的表达式语言，可以在所有产品中使用 Spring 的项目组合。它的语言特性是由 Spring 项目中的项目需求驱动的，包括基于 Eclipse 的 Spring Tool Suite 中 code completion support 的工具需求。也就是说，SpEL 基于一种技术无关的 API，允许在需要时集成其他表达式语言实现。</p>
</div>
<div class="paragraph">
<p>虽然 SpEL 是 Spring 项目组合中表达式评估的基础，但它并不与 Spring 直接相关，可以独立使用。为了自包含，本章中的许多例子都使用 SpEL，就好像它是独立的表达式语言一样。这需要创建一些引导基础结构类，比如解析器。大多数 Spring 用户不需要处理这个基础结构，而只需要编写用于评估的表达式字符串。这种典型用法的一个例子是将 SpEL 集成到创建 XML 或基于注解的 bean 定义中，如 <a href="#expressions-beandef"> 定义 bean 定义的表达式支持</a> 部分所示。</p>
</div>
<div class="paragraph">
<p>本节介绍了表达式语言，API 及其语言语法的特性。在一些地方，Inventor 和 Inventor 的 Society 类被用作表达评估的目标对象。这些类声明和用来填充它们的数据在本章最后列出。</p>
</div>
</div>
<div class="sect2">
<h3 id="expressions-features"><a class="anchor" href="#expressions-features"></a>4.2. 特性概览</h3>
<div class="paragraph">
<p> 表达式语言支持以下的功能 </p>
</div>
<div class="ulist">
<ul>
<li>
<p>Literal expressions 字面表达式</p>
</li>
<li>
<p>Boolean and relational operators 布尔和关系操作符</p>
</li>
<li>
<p>Regular expressions 正则表达式</p>
</li>
<li>
<p>Class expressions 类表达式</p>
</li>
<li>
<p>Accessing properties, arrays, lists, maps 访问 properties，数组，列表，map</p>
</li>
<li>
<p>Method invocation 方法调用</p>
</li>
<li>
<p>Relational operators 关系操作符</p>
</li>
<li>
<p>Assignment 赋值</p>
</li>
<li>
<p>Calling constructors 调用构造器</p>
</li>
<li>
<p>Bean references Bean 引用</p>
</li>
<li>
<p>Array construction 数组构建</p>
</li>
<li>
<p>Inline lists 内联list</p>
</li>
<li>
<p>Inline maps 内联 map</p>
</li>
<li>
<p>Ternary operator 三目运算符</p>
</li>
<li>
<p>Variables 变量</p>
</li>
<li>
<p>User defined functions 用于自定义功能</p>
</li>
<li>
<p>Collection projection 集合映射</p>
</li>
<li>
<p>Collection selection 集合选择</p>
</li>
<li>
<p>Templated expressions 模板表达式</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="expressions-evaluation"><a class="anchor" href="#expressions-evaluation"></a>4.3. 使用 Spring 表达式接口来评估表达式</h3>
<div class="paragraph">
<p>本节介绍 SpEL 接口的简单使用及其表达式语言。完整的语言参考可在<a href="#expressions-language-ref">语言参考</a>一节中找到。</p>
</div>
<div class="paragraph">
<p>以下代码引入了 SpEL API 来评估文字字符串表达式 'Hello World' 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> message = (<span class="predefined-type">String</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>message 的值就是简单的 'Hello World' 字符串</p>
</div>
<div class="paragraph">
<p>你最可能使用的 SpEL 类和接口位于 <code>org.springframework.expression</code> 包及其子包 <code>spel.support</code> 中。</p>
</div>
<div class="paragraph">
<p><code>ExpressionParser</code> 接口负责解析表达式字符串。在这个例子中，表达式字符串是由单引号包含的字符串文字。 接口 <code>Expression</code> 负责评估之前定义的表达式字符串。 当分别调用 <code>parser.parseExpression</code>和 <code>exp.getValue</code> 时，可能会抛出两个异常，<code>ParseException</code> 和 <code>EvaluationException</code> 。</p>
</div>
<div class="paragraph">
<p>SpEL 支持许多的功能，例如方法调用，属性访问和构造器调用。</p>
</div>
<div class="paragraph">
<p>举一个方法调用的例子，我们在字符串上调用 <code>concat</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'.concat('!')</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> message = (<span class="predefined-type">String</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 message 的值变成了 'Hello World!'.</p>
</div>
<div class="paragraph">
<p>举一个 JavaBean 属性调用的例子， 字符串属性 <code>Bytes</code> 可以按如下方式调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// invokes 'getBytes()'</span>
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'.bytes</strong></span><span class="delimiter">&quot;</span></span>);
<span class="type">byte</span><span class="type">[]</span> bytes = (<span class="type">byte</span><span class="type">[]</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>SpEL 还支持通过标准的点号访问嵌套属性，如 prop1.prop2.prop3 和属性值的设置。</p>
</div>
<div class="paragraph">
<p>Public 字段也可以被访问。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// invokes 'getBytes().length'</span>
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'.bytes.length</strong></span><span class="delimiter">&quot;</span></span>);
<span class="type">int</span> length = (<span class="predefined-type">Integer</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以调用 String 的构造器，而不使用字符串字面量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>new String('hello world').toUpperCase()</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> message = exp.getValue(<span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意使用通用方法public <T> T getValue(Class <T> desiredResultType)。使用此方法就不需要将表达式的值强制转换为所需的结果类型。如果值不能转换为类型 <code>T</code> 或者使用注册类型转换器转换失败，则抛出 <code>EvaluationException</code> 异常。</p>
</div>
<div class="paragraph">
<p>SpEL 更常见的用法是提供一个处理特定对象实例（称为根对象）的表达式字符串。这里有两个选项，选择哪一个取决于表达式被评估的对象是否随每次对表达式评估的调用而改变。在以下示例中，我们从 Inventor 类的实例中检索 <code>name</code> 属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create and set a calendar</span>
<span class="predefined-type">GregorianCalendar</span> c = <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span>();
c.set(<span class="integer">1856</span>, <span class="integer">7</span>, <span class="integer">9</span>);

<span class="comment">// The constructor arguments are name, birthday, and nationality.</span>
Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, c.getTime(), <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);

ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>name</strong></span><span class="delimiter">&quot;</span></span>);

EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);
<span class="predefined-type">String</span> name = (<span class="predefined-type">String</span>) exp.getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在最后一行中，字符串变量 <code>name</code> 的值将被设置为“Nikola Tesla”。StandardEvaluationContext 类可以指定哪个对象的 “name” 属性将被评估。如果根对象不太可能改变就使用这个机制，它只要在评估上下文中设置一次即可。如果根对象可能会重复更改，则可以在每次调用 <code>getValue</code> 时提供该对象，如下面的示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">/ Create and set a calendar
<span class="predefined-type">GregorianCalendar</span> c = <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span>();
c.set(<span class="integer">1856</span>, <span class="integer">7</span>, <span class="integer">9</span>);

<span class="comment">// The constructor arguments are name, birthday, and nationality.</span>
Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, c.getTime(), <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);

ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>name</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> name = (<span class="predefined-type">String</span>) exp.getValue(tesla);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，inventor <code>tesla</code> 被直接传递给 <code>getValue</code>，表达式评估基础结构在内部创建和管理默认的评估上下文 - 它不需要被显式创建并传递。</p>
</div>
<div class="paragraph">
<p>StandardEvaluationContext 的构造代价相对来说比较大，在重复使用时，它建立了缓存状态，使后续的表达式评估能够更快地执行。因此最好在可能的地方缓存和重用它们，而不是为每个表达式评估构建一个新的上下文。</p>
</div>
<div class="paragraph">
<p>在某些情况下，可能需要使用一个配置好的评估上下文，但仍然希望在每次调用 <code>getValue</code> 时提供不同的根对象。<code>getValue</code>  允许你在同一个调用中保留这两个特性。在这些情况下，在调用中传递的根对象将被视为会覆盖评估上下文中指定的任何（可能为null）根对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在独立使用 SpEL 的环境中，需要创建解析器，解析表达式，并可能需要提供评估上下文和根上下文对象。但是，更常见的用法是只提供 SpEL 表达式字符串作为配置文件的一部分，例如 Spring bean 或 Spring Web Flow 定义。在这种情况下，解析器，评估上下文，根对象和任何预定义的变量都是隐式设置的，要求用户除了表达式之外什么也不指定。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>作为最后的介绍性例子，使用前面的例子中的 Inventor 对象展示了布尔运算符的使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">name == 'Nikola Tesla'</span><span class="delimiter">&quot;</span></span>);
<span class="type">boolean</span> result = exp.getValue(context, <span class="predefined-type">Boolean</span>.class); <span class="comment">// evaluates to true</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="expressions-evaluation-context"><a class="anchor" href="#expressions-evaluation-context"></a>4.3.1. EvaluationContext 接口</h4>
<div class="paragraph">
<p>The interface <code>EvaluationContext</code> is used when evaluating an expression to resolve
properties, methods, fields, and to help perform type conversion. The out-of-the-box
implementation, <code>StandardEvaluationContext</code>, uses reflection to manipulate the object,
caching <code>java.lang.reflect.Method</code>, <code>java.lang.reflect.Field</code>, and
<code>java.lang.reflect.Constructor</code> instances for increased performance.</p>
</div>
<div class="paragraph">
<p>The <code>StandardEvaluationContext</code> is where you may specify the root object to evaluate
against via the method <code>setRootObject()</code> or passing the root object into the
constructor. You can also specify variables and functions that will be used in the
expression using the methods <code>setVariable()</code> and <code>registerFunction()</code>. The use of
variables and functions are described in the language reference sections
<a href="#expressions-ref-variables">Variables</a> and <a href="#expressions-ref-functions">Functions</a>. The
<code>StandardEvaluationContext</code> is also where you can register custom
<code>ConstructorResolver</code>s, <code>MethodResolver</code>s, and <code>PropertyAccessor</code>s to extend how SpEL
evaluates expressions. Please refer to the javadoc of these classes for more details.</p>
</div>
<div class="sect4">
<h5 id="expressions-type-conversion"><a class="anchor" href="#expressions-type-conversion"></a>Type Conversion</h5>
<div class="paragraph">
<p>By default SpEL uses the conversion service available in Spring core (
<code>org.springframework.core.convert.ConversionService</code>). This conversion service comes
with many converters built in for common conversions but is also fully extensible so
custom conversions between types can be added. Additionally it has the key capability
that it is generics aware. This means that when working with generic types in
expressions, SpEL will attempt conversions to maintain type correctness for any objects
it encounters.</p>
</div>
<div class="paragraph">
<p>What does this mean in practice? Suppose assignment, using <code>setValue()</code>, is being used
to set a <code>List</code> property. The type of the property is actually <code>List&lt;Boolean&gt;</code>. SpEL
will recognize that the elements of the list need to be converted to <code>Boolean</code> before
being placed in it. A simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Simple</span> {
        <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Boolean</span>&gt; booleanList = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Boolean</span>&gt;();
}

Simple simple = <span class="keyword">new</span> Simple();

simple.booleanList.add(<span class="predefined-constant">true</span>);

StandardEvaluationContext simpleContext = <span class="keyword">new</span> StandardEvaluationContext(simple);

<span class="comment">// false is passed in here as a string. SpEL and the conversion service will</span>
<span class="comment">// correctly recognize that it needs to be a Boolean and convert it</span>
parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">booleanList[0]</span><span class="delimiter">&quot;</span></span>).setValue(simpleContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// b will be false</span>
<span class="predefined-type">Boolean</span> b = simple.booleanList.get(<span class="integer">0</span>);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-parser-configuration"><a class="anchor" href="#expressions-parser-configuration"></a>4.3.2. Parser configuration</h4>
<div class="paragraph">
<p>It is possible to configure the SpEL expression parser using a parser configuration object
(<code>org.springframework.expression.spel.SpelParserConfiguration</code>). The configuration
object controls the behavior of some of the expression components. For example, if
indexing into an array or collection and the element at the specified index is <code>null</code>
it is possible to automatically create the element. This is useful when using expressions made up of a
chain of property references. If indexing into an array or list
and specifying an index that is beyond the end of the current size of the array or
list it is possible to automatically grow the array or list to accommodate that index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Demo</span> {
        <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list;
}

<span class="comment">// Turn on:</span>
<span class="comment">// - auto null reference initialization</span>
<span class="comment">// - auto collection growing</span>
SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="predefined-constant">true</span>,<span class="predefined-constant">true</span>);

ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);

<span class="predefined-type">Expression</span> expression = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">list[3]</span><span class="delimiter">&quot;</span></span>);

Demo demo = <span class="keyword">new</span> Demo();

<span class="predefined-type">Object</span> o = expression.getValue(demo);

<span class="comment">// demo.list will now be a real collection of 4 entries</span>
<span class="comment">// Each entry is a new empty String</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to configure the behaviour of the SpEL expression compiler.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-spel-compilation"><a class="anchor" href="#expressions-spel-compilation"></a>4.3.3. SpEL compilation</h4>
<div class="paragraph">
<p>Spring Framework 4.1 includes a basic expression compiler. Expressions are usually
interpreted which provides a lot of dynamic flexibility during evaluation but
does not provide the optimum performance. For occasional expression usage
this is fine, but when used by other components like Spring Integration,
performance can be very important and there is no real need for the dynamism.</p>
</div>
<div class="paragraph">
<p>The new SpEL compiler is intended to address this need. The
compiler will generate a real Java class on the fly during evaluation that embodies the
expression behavior and use that to achieve much faster expression
evaluation. Due to the lack of typing around expressions the compiler
uses information gathered during the interpreted evaluations of an
expression when performing compilation. For example, it does not know the type
of a property reference purely from the expression but during the first
interpreted evaluation it will find out what it is. Of course, basing the
compilation on this information could cause trouble later if the types of
the various expression elements change over time. For this reason compilation
is best suited to expressions whose type information is not going to change
on repeated evaluations.</p>
</div>
<div class="paragraph">
<p>For a basic expression like this:</p>
</div>
<div class="paragraph">
<p><code>someArray[0].someProperty.someOtherProperty &lt; 0.1</code></p>
</div>
<div class="paragraph">
<p>which involves array access, some property derefencing and numeric operations, the performance
gain can be very noticeable. In an example micro benchmark run of 50000 iterations, it was
taking 75ms to evaluate using only the interpreter and just 3ms using the compiled version
of the expression.</p>
</div>
<div class="sect4">
<h5 id="expressions-compiler-configuration"><a class="anchor" href="#expressions-compiler-configuration"></a>Compiler configuration</h5>
<div class="paragraph">
<p>The compiler is not turned on by default, but there are two ways to turn
it on. It can be turned on using the parser configuration process discussed earlier or
via a system property when SpEL usage is embedded inside another component. This section
discusses both of these options.</p>
</div>
<div class="paragraph">
<p>It is important to understand that there are a few modes the compiler can operate in, captured
in an enum (<code>org.springframework.expression.spel.SpelCompilerMode</code>). The modes are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OFF</code> - The compiler is switched off; this is the default.</p>
</li>
<li>
<p><code>IMMEDIATE</code> - In immediate mode the expressions are compiled as soon as possible. This
is typically after the first interpreted evaluation. If the compiled expression fails
(typically due to a type changing, as described above) then the caller of the expression
evaluation will receive an exception.</p>
</li>
<li>
<p><code>MIXED</code> - In mixed mode the expressions silently switch between interpreted and compiled
mode over time. After some number of interpreted runs they will switch to compiled
form and if something goes wrong with the compiled form (like a type changing, as
described above) then the expression will automatically switch back to interpreted form
again. Sometime later it may generate another compiled form and switch to it. Basically
the exception that the user gets in <code>IMMEDIATE</code> mode is instead handled internally.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>IMMEDIATE</code> mode exists because <code>MIXED</code> mode could cause issues for expressions that
have side effects. If a compiled expression blows up after partially succeeding it
may have already done something that has affected the state of the system. If this
has happened the caller may not want it to silently re-run in interpreted mode
since part of the expression may be running twice.</p>
</div>
<div class="paragraph">
<p>After selecting a mode, use the <code>SpelParserConfiguration</code> to configure the parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
        <span class="local-variable">this</span>.getClass().getClassLoader());

SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);

<span class="predefined-type">Expression</span> expr = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">payload</span><span class="delimiter">&quot;</span></span>);

MyMessage message = <span class="keyword">new</span> MyMessage();

<span class="predefined-type">Object</span> payload = expr.getValue(message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When specifying the compiler mode it is also possible to specify a classloader (passing null is allowed).
Compiled expressions will be defined in a child classloader created under any that is supplied.
It is important to ensure if a classloader is specified it can see all the types involved in
the expression evaluation process.
If none is specified then a default classloader will be used (typically the context classloader for
the thread that is running during expression evaluation).</p>
</div>
<div class="paragraph">
<p>The second way to configure the compiler is for use when SpEL is embedded inside some other
component and it may not be possible to configure via a configuration object.
In these cases it is possible to use a system property. The property
<code>spring.expression.compiler.mode</code> can be set to one of the <code>SpelCompilerMode</code>
enum values (<code>off</code>, <code>immediate</code>, or <code>mixed</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-compiler-limitations"><a class="anchor" href="#expressions-compiler-limitations"></a>Compiler limitations</h5>
<div class="paragraph">
<p>With Spring Framework 4.1 the basic compilation framework is in place. However, the framework does not
yet support compiling every kind of expression. The initial focus has been on the common expressions that are
likely to be used in performance critical contexts. These kinds of expression cannot be compiled
at the moment:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>expressions involving assignment</p>
</li>
<li>
<p>expressions relying on the conversion service</p>
</li>
<li>
<p>expressions using custom resolvers or accessors</p>
</li>
<li>
<p>expressions using selection or projection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>More and more types of expression will be compilable in the future.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-beandef"><a class="anchor" href="#expressions-beandef"></a>4.4. Expression support for defining bean definitions</h3>
<div class="paragraph">
<p>SpEL expressions can be used with XML or annotation-based configuration metadata for
defining <code>BeanDefinition</code>s. In both cases the syntax to define the expression is of the
form <code>#{ &lt;expression string&gt; }</code>.</p>
</div>
<div class="sect3">
<h4 id="expressions-beandef-xml-based"><a class="anchor" href="#expressions-beandef-xml-based"></a>4.4.1. XML based configuration</h4>
<div class="paragraph">
<p>A property or constructor-arg value can be set using expressions as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">numberGuess</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.NumberGuess</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">randomNumber</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ T(java.lang.Math).random() * 100.0 }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable <code>systemProperties</code> is predefined, so you can use it in your expressions as
shown below. Note that you do not have to prefix the predefined variable with the <code>#</code>
symbol in this context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">taxCalculator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.TaxCalculator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">defaultLocale</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also refer to other bean properties by name, for example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">numberGuess</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.NumberGuess</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">randomNumber</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ T(java.lang.Math).random() * 100.0 }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">shapeGuess</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.ShapeGuess</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialShapeSeed</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ numberGuess.randomNumber }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-beandef-annotation-based"><a class="anchor" href="#expressions-beandef-annotation-based"></a>4.4.2. Annotation-based configuration</h4>
<div class="paragraph">
<p>The <code>@Value</code> annotation can be placed on fields, methods and method/constructor
parameters to specify a default value.</p>
</div>
<div class="paragraph">
<p>Here is an example to set the default value of a field variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">FieldValueTestBean</span>

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="directive">public</span> <span class="type">void</span> setDefaultLocale(<span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getDefaultLocale() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.defaultLocale;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent but on a property setter method is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">PropertyValueTestBean</span>

        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> setDefaultLocale(<span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getDefaultLocale() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.defaultLocale;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Autowired methods and constructors can also use the <code>@Value</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;
        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> configure(MovieFinder movieFinder,
                        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao,
                        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{systemProperties['user.country']}</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-language-ref"><a class="anchor" href="#expressions-language-ref"></a>4.5. Language Reference</h3>
<div class="sect3">
<h4 id="expressions-ref-literal"><a class="anchor" href="#expressions-ref-literal"></a>4.5.1. Literal expressions</h4>
<div class="paragraph">
<p>The types of literal expressions supported are strings, numeric values (int, real, hex),
boolean and null. Strings are delimited by single quotes. To put a single quote itself
in a string, use two single quote characters.</p>
</div>
<div class="paragraph">
<p>The following listing shows simple usage of literals. Typically they would not be used
in isolation like this but rather as part of a more complex expression, for example
using a literal on one side of a logical comparison operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// evals to &quot;Hello World&quot;</span>
<span class="predefined-type">String</span> helloWorld = (<span class="predefined-type">String</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">'Hello World'</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="type">double</span> avogadrosNumber = (<span class="predefined-type">Double</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">6.0221415E+23</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="comment">// evals to 2147483647</span>
<span class="type">int</span> maxValue = (<span class="predefined-type">Integer</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">0x7FFFFFFF</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="type">boolean</span> trueValue = (<span class="predefined-type">Boolean</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="predefined-type">Object</span> nullValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">null</span><span class="delimiter">&quot;</span></span>).getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numbers support the use of the negative sign, exponential notation, and decimal points.
By default real numbers are parsed using Double.parseDouble().</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-properties-arrays"><a class="anchor" href="#expressions-properties-arrays"></a>4.5.2. Properties, Arrays, Lists, Maps, Indexers</h4>
<div class="paragraph">
<p>Navigating with property references is easy: just use a period to indicate a nested
property value. The instances of the <code>Inventor</code> class, pupin, and tesla, were populated with
data listed in the section <a href="#expressions-example-classes">Classes used in the examples</a>.
To navigate "down" and get Tesla&#8217;s year of birth and Pupin&#8217;s city of birth the following
expressions are used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evals to 1856</span>
<span class="type">int</span> year = (<span class="predefined-type">Integer</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Birthdate.Year + 1900</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">String</span> city = (<span class="predefined-type">String</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">placeOfBirth.City</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Case insensitivity is allowed for the first letter of property names. The contents of
arrays and lists are obtained using square bracket notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// Inventions Array</span>
StandardEvaluationContext teslaContext = <span class="keyword">new</span> StandardEvaluationContext(tesla);

<span class="comment">// evaluates to &quot;Induction motor&quot;</span>
<span class="predefined-type">String</span> invention = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">inventions[3]</span><span class="delimiter">&quot;</span></span>).getValue(
                teslaContext, <span class="predefined-type">String</span>.class);

<span class="comment">// Members List</span>
StandardEvaluationContext societyContext = <span class="keyword">new</span> StandardEvaluationContext(ieee);

<span class="comment">// evaluates to &quot;Nikola Tesla&quot;</span>
<span class="predefined-type">String</span> name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Members[0].Name</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">String</span>.class);

<span class="comment">// List and Array navigation</span>
<span class="comment">// evaluates to &quot;Wireless communication&quot;</span>
<span class="predefined-type">String</span> invention = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Members[0].Inventions[6]</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The contents of maps are obtained by specifying the literal key value within the
brackets. In this case, because keys for the Officers map are strings, we can specify
string literals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Officer's Dictionary</span>

Inventor pupin = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Officers['president']</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, Inventor.class);

<span class="comment">// evaluates to &quot;Idvor&quot;</span>
<span class="predefined-type">String</span> city = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Officers['president'].PlaceOfBirth.City</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">String</span>.class);

<span class="comment">// setting values</span>
parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Officers['advisors'][0].PlaceOfBirth.Country</span><span class="delimiter">&quot;</span></span>).setValue(
                societyContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">Croatia</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-lists"><a class="anchor" href="#expressions-inline-lists"></a>4.5.3. Inline lists</h4>
<div class="paragraph">
<p>Lists can be expressed directly in an expression using <code>{}</code> notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to a Java list containing the four numbers</span>
<span class="predefined-type">List</span> numbers = (<span class="predefined-type">List</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{1,2,3,4}</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">List</span> listOfLists = (<span class="predefined-type">List</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{{'a','b'},{'x','y'}}</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{}</code> by itself means an empty list. For performance reasons, if the list is itself
entirely composed of fixed literals then a constant list is created to represent the
expression, rather than building a new list on each evaluation.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-maps"><a class="anchor" href="#expressions-inline-maps"></a>4.5.4. Inline Maps</h4>
<div class="paragraph">
<p>Maps can also be expressed directly in an expression using <code>{key:value}</code> notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to a Java map containing the two entries</span>
<span class="predefined-type">Map</span> inventorInfo = (<span class="predefined-type">Map</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{name:'Nikola',dob:'10-July-1856'}</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">Map</span> mapOfMaps = (<span class="predefined-type">Map</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{:}</code> by itself means an empty map. For performance reasons, if the map is itself composed
of fixed literals or other nested constant structures (lists or maps) then a constant map is created
to represent the expression, rather than building a new map on each evaluation. Quoting of the map keys
is optional, the examples above are not using quoted keys.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-array-construction"><a class="anchor" href="#expressions-array-construction"></a>4.5.5. Array construction</h4>
<div class="paragraph">
<p>Arrays can be built using the familiar Java syntax, optionally supplying an initializer
to have the array populated at construction time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span><span class="type">[]</span> numbers1 = (<span class="type">int</span><span class="type">[]</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">new int[4]</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="comment">// Array with initializer</span>
<span class="type">int</span><span class="type">[]</span> numbers2 = (<span class="type">int</span><span class="type">[]</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">new int[]{1,2,3}</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="comment">// Multi dimensional array</span>
<span class="type">int</span><span class="type">[]</span><span class="type">[]</span> numbers3 = (<span class="type">int</span><span class="type">[]</span><span class="type">[]</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">new int[4][5]</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is not currently allowed to supply an initializer when constructing a
multi-dimensional array.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-methods"><a class="anchor" href="#expressions-methods"></a>4.5.6. Methods</h4>
<div class="paragraph">
<p>Methods are invoked using typical Java programming syntax. You may also invoke methods
on literals. Varargs are also supported.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// string literal, evaluates to &quot;bc&quot;</span>
<span class="predefined-type">String</span> c = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">'abc'.substring(2, 3)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class);

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> isMember = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Mihajlo Pupin')</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operators"><a class="anchor" href="#expressions-operators"></a>4.5.7. Operators</h4>
<div class="sect4">
<h5 id="expressions-operators-relational"><a class="anchor" href="#expressions-operators-relational"></a>Relational operators</h5>
<div class="paragraph">
<p>The relational operators; equal, not equal, less than, less than or equal, greater than,
and greater than or equal are supported using standard operator notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">2 == 2</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">2 &lt; -5.0</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">'black' &lt; 'block'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Greater/less-than comparisons against <code>null</code> follow a simple rule: <code>null</code> is treated as
nothing here (i.e. NOT as zero). As a consequence, any other value is always greater
than <code>null</code> (<code>X &gt; null</code> is always <code>true</code>) and no other value is ever less than nothing
(<code>X &lt; null</code> is always <code>false</code>).</p>
</div>
<div class="paragraph">
<p>If you prefer numeric comparisons instead, please avoid number-based <code>null</code> comparisons
in favor of comparisons against zero (e.g. <code>X &gt; 0</code> or <code>X &lt; 0</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to standard relational operators SpEL supports the <code>instanceof</code> and regular
expression based <code>matches</code> operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'xyz' instanceof T(Integer)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'5.00' matches '</span><span class="content">\^</span><span class="content">-?</span><span class="char">\\</span><span class="content">d+(</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d{2})?$'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">//evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'5.0067' matches '</span><span class="content">\^</span><span class="content">-?</span><span class="char">\\</span><span class="content">d+(</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d{2})?$'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Be careful with primitive types as they are immediately boxed up to the wrapper type,
so <code>1 instanceof T(int)</code> evaluates to <code>false</code> while <code>1 instanceof T(Integer)</code>
evaluates to <code>true</code>, as expected.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each symbolic operator can also be specified as a purely alphabetic equivalent. This
avoids problems where the symbols used have special meaning for the document type in
which the expression is embedded (eg. an XML document). The textual equivalents are
shown here: <code>lt</code> (<code>&lt;</code>), <code>gt</code> (<code>&gt;</code>), <code>le</code> (<code>&#8656;</code>), <code>ge</code> (<code>&gt;=</code>), <code>eq</code> (<code>==</code>),
<code>ne</code> (<code>!=</code>), <code>div</code> (<code>/</code>), <code>mod</code> (<code>%</code>), <code>not</code> (<code>!</code>). These are case insensitive.</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-logical"><a class="anchor" href="#expressions-operators-logical"></a>Logical operators</h5>
<div class="paragraph">
<p>The logical operators that are supported are and, or, and not. Their use is demonstrated
below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// -- AND --</span>

<span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">true and false</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Nikola Tesla') and isMember('Mihajlo Pupin')</span><span class="delimiter">&quot;</span></span>;
<span class="type">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, <span class="predefined-type">Boolean</span>.class);

<span class="comment">// -- OR --</span>

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">true or false</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Nikola Tesla') or isMember('Albert Einstein')</span><span class="delimiter">&quot;</span></span>;
<span class="type">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, <span class="predefined-type">Boolean</span>.class);

<span class="comment">// -- NOT --</span>

<span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">!true</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// -- AND and NOT --</span>
<span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')</span><span class="delimiter">&quot;</span></span>;
<span class="type">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, <span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-mathematical"><a class="anchor" href="#expressions-operators-mathematical"></a>Mathematical operators</h5>
<div class="paragraph">
<p>The addition operator can be used on both numbers and strings. Subtraction, multiplication
and division can be used only on numbers. Other mathematical operators supported are
modulus (%) and exponential power (^). Standard operator precedence is enforced. These
operators are demonstrated below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Addition</span>
<span class="type">int</span> two = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 1</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 2</span>

<span class="predefined-type">String</span> testString = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'test' + ' ' + 'string'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class); <span class="comment">// 'test string'</span>

<span class="comment">// Subtraction</span>
<span class="type">int</span> four = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1 - -3</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 4</span>

<span class="type">double</span> d = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1000.00 - 1e4</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Double</span>.class); <span class="comment">// -9000</span>

<span class="comment">// Multiplication</span>
<span class="type">int</span> six = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">-2 * -3</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 6</span>

<span class="type">double</span> twentyFour = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">2.0 * 3e0 * 4</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Double</span>.class); <span class="comment">// 24.0</span>

<span class="comment">// Division</span>
<span class="type">int</span> minusTwo = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">6 / -3</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// -2</span>

<span class="type">double</span> one = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">8.0 / 4e0 / 2</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Double</span>.class); <span class="comment">// 1.0</span>

<span class="comment">// Modulus</span>
<span class="type">int</span> three = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">7 % 4</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 3</span>

<span class="type">int</span> one = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">8 / 5 % 2</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 1</span>

<span class="comment">// Operator precedence</span>
<span class="type">int</span> minusTwentyOne = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1+2-3*8</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// -21</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-assignment"><a class="anchor" href="#expressions-assignment"></a>4.5.8. Assignment</h4>
<div class="paragraph">
<p>Setting of a property is done by using the assignment operator. This would typically be
done within a call to <code>setValue</code> but can also be done inside a call to <code>getValue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor inventor = <span class="keyword">new</span> Inventor();
StandardEvaluationContext inventorContext = <span class="keyword">new</span> StandardEvaluationContext(inventor);

parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name</span><span class="delimiter">&quot;</span></span>).setValue(inventorContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">Alexander Seovic2</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// alternatively</span>

<span class="predefined-type">String</span> aleks = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Name = 'Alexandar Seovic'</span><span class="delimiter">&quot;</span></span>).getValue(inventorContext, <span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-types"><a class="anchor" href="#expressions-types"></a>4.5.9. Types</h4>
<div class="paragraph">
<p>The special <code>T</code> operator can be used to specify an instance of java.lang.Class (the
<em>type</em>). Static methods are invoked using this operator as well. The
<code>StandardEvaluationContext</code> uses a <code>TypeLocator</code> to find types and the
<code>StandardTypeLocator</code> (which can be replaced) is built with an understanding of the
java.lang package. This means T() references to types within java.lang do not need to be
fully qualified, but all other type references must be.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Class</span> dateClass = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">T(java.util.Date)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Class</span>.class);

<span class="predefined-type">Class</span> stringClass = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">T(String)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Class</span>.class);

<span class="type">boolean</span> trueValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR</span><span class="delimiter">&quot;</span></span>)
                .getValue(<span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-constructors"><a class="anchor" href="#expressions-constructors"></a>4.5.10. Constructors</h4>
<div class="paragraph">
<p>Constructors can be invoked using the new operator. The fully qualified class name
should be used for all but the primitive type and String (where int, float, etc, can be
used).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor einstein = p.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')</span><span class="delimiter">&quot;</span></span>)
                .getValue(Inventor.class);

<span class="comment">//create new inventor instance within add method of List</span>
p.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Members.add(new org.spring.samples.spel.inventor.Inventor(
                        'Albert Einstein', 'German'))</span><span class="delimiter">&quot;</span></span>).getValue(societyContext);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-variables"><a class="anchor" href="#expressions-ref-variables"></a>4.5.11. Variables</h4>
<div class="paragraph">
<p>Variables can be referenced in the expression using the syntax <code>#variableName</code>. Variables
are set using the method setVariable on the <code>StandardEvaluationContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);
context.setVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">newName</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mike Tesla</span><span class="delimiter">&quot;</span></span>);

parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name = #newName</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">System</span>.out.println(tesla.getName()) <span class="comment">// &quot;Mike Tesla&quot;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="expressions-this-root"><a class="anchor" href="#expressions-this-root"></a>The #this and #root variables</h5>
<div class="paragraph">
<p>The variable #this is always defined and refers to the current evaluation object
(against which unqualified references are resolved). The variable #root is always
defined and refers to the root context object. Although #this may vary as components of
an expression are evaluated, #root always refers to the root.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// create an array of integers</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; primes = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;();
primes.addAll(<span class="predefined-type">Arrays</span>.asList(<span class="integer">2</span>,<span class="integer">3</span>,<span class="integer">5</span>,<span class="integer">7</span>,<span class="integer">11</span>,<span class="integer">13</span>,<span class="integer">17</span>));

<span class="comment">// create parser and set variable 'primes' as the array of integers</span>
ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();
context.setVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">primes</span><span class="delimiter">&quot;</span></span>,primes);

<span class="comment">// all prime numbers &gt; 10 from the list (using selection ?{...})</span>
<span class="comment">// evaluates to [11, 13, 17]</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; primesGreaterThanTen = (<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt;) parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">#primes.?[#this&gt;10]</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-functions"><a class="anchor" href="#expressions-ref-functions"></a>4.5.12. Functions</h4>
<div class="paragraph">
<p>You can extend SpEL by registering user defined functions that can be called within the
expression string. The function is registered with the <code>StandardEvaluationContext</code> using
the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> registerFunction(<span class="predefined-type">String</span> name, <span class="predefined-type">Method</span> m)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A reference to a Java Method provides the implementation of the function. For example, a
utility method to reverse a string is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">StringUtils</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> reverseString(<span class="predefined-type">String</span> input) {
                <span class="predefined-type">StringBuilder</span> backwards = <span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>();
                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; input.length(); i++)
                        backwards.append(input.charAt(input.length() - <span class="integer">1</span> - i));
                }
                <span class="keyword">return</span> backwards.toString();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method is then registered with the evaluation context and can be used within an
expression string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();

context.registerFunction(<span class="string"><span class="delimiter">&quot;</span><span class="content">reverseString</span><span class="delimiter">&quot;</span></span>,
        StringUtils.class.getDeclaredMethod(<span class="string"><span class="delimiter">&quot;</span><span class="content">reverseString</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">Class</span><span class="type">[]</span> { <span class="predefined-type">String</span>.class }));

<span class="predefined-type">String</span> helloWorldReversed = parser.parseExpression(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">#reverseString('hello')</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-bean-references"><a class="anchor" href="#expressions-bean-references"></a>4.5.13. Bean references</h4>
<div class="paragraph">
<p>If the evaluation context has been configured with a bean resolver it is possible to
lookup beans from an expression using the (@) symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();
context.setBeanResolver(<span class="keyword">new</span> MyBeanResolver());

<span class="comment">// This will end up calling resolve(context,&quot;foo&quot;) on MyBeanResolver during evaluation</span>
<span class="predefined-type">Object</span> bean = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">@foo</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To access a factory bean itself, the bean name should instead be prefixed with a (&amp;) symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();
context.setBeanResolver(<span class="keyword">new</span> MyBeanResolver());

<span class="comment">// This will end up calling resolve(context,&quot;&amp;foo&quot;) on MyBeanResolver during evaluation</span>
<span class="predefined-type">Object</span> bean = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">&amp;foo</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-ternary"><a class="anchor" href="#expressions-operator-ternary"></a>4.5.14. Ternary Operator (If-Then-Else)</h4>
<div class="paragraph">
<p>You can use the ternary operator for performing if-then-else conditional logic inside
the expression. A minimal example is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> falseString = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">false ? 'trueExp' : 'falseExp'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the boolean false results in returning the string value 'falseExp'. A more
realistic example is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name</span><span class="delimiter">&quot;</span></span>).setValue(societyContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">IEEE</span><span class="delimiter">&quot;</span></span>);
societyContext.setVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">queryName</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>);

expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember(#queryName)? #queryName + ' is a member of the ' </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'</span><span class="delimiter">&quot;</span></span>;

<span class="predefined-type">String</span> queryResultString = parser.parseExpression(expression)
                .getValue(societyContext, <span class="predefined-type">String</span>.class);
<span class="comment">// queryResultString = &quot;Nikola Tesla is a member of the IEEE Society&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also see the next section on the Elvis operator for an even shorter syntax for the
ternary operator.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-elvis"><a class="anchor" href="#expressions-operator-elvis"></a>4.5.15. The Elvis Operator</h4>
<div class="paragraph">
<p>The Elvis operator is a shortening of the ternary operator syntax and is used in the
<a href="http://www.groovy-lang.org/operators.html#_elvis_operator">Groovy</a> language.
With the ternary operator syntax you usually have to repeat a variable twice, for
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="predefined-type">String</span> name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Elvis Presley</span><span class="delimiter">&quot;</span></span>;
<span class="predefined-type">String</span> displayName = name != <span class="predefined-constant">null</span> ? name : <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead you can use the Elvis operator, named for the resemblance to Elvis' hair style.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="predefined-type">String</span> name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">name?:'Unknown'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(name); <span class="comment">// 'Unknown'</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a more complex example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);

<span class="predefined-type">String</span> name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name?:'Elvis Presley'</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(name); <span class="comment">// Nikola Tesla</span>

tesla.setName(<span class="predefined-constant">null</span>);

name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name?:'Elvis Presley'</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(name); <span class="comment">// Elvis Presley</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-safe-navigation"><a class="anchor" href="#expressions-operator-safe-navigation"></a>4.5.16. Safe Navigation operator</h4>
<div class="paragraph">
<p>The Safe Navigation operator is used to avoid a <code>NullPointerException</code> and comes from
the <a href="http://www.groovy-lang.org/operators.html#_safe_navigation_operator">Groovy</a>
language. Typically when you have a reference to an object you might need to verify that
it is not null before accessing methods or properties of the object. To avoid this, the
safe navigation operator will simply return null instead of throwing an exception.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);
tesla.setPlaceOfBirth(<span class="keyword">new</span> PlaceOfBirth(<span class="string"><span class="delimiter">&quot;</span><span class="content">Smiljan</span><span class="delimiter">&quot;</span></span>));

StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);

<span class="predefined-type">String</span> city = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">PlaceOfBirth?.City</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);
<span class="predefined-type">System</span>.out.println(city); <span class="comment">// Smiljan</span>

tesla.setPlaceOfBirth(<span class="predefined-constant">null</span>);

city = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">PlaceOfBirth?.City</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(city); <span class="comment">// null - does not throw NullPointerException!!!</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Elvis operator can be used to apply default values in expressions, e.g. in an
<code>@Value</code> expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{systemProperties['pop3.port'] ?: 25}</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will inject a system property <code>pop3.port</code> if it is defined or 25 if not.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-selection"><a class="anchor" href="#expressions-collection-selection"></a>4.5.17. Collection Selection</h4>
<div class="paragraph">
<p>Selection is a powerful expression language feature that allows you to transform some
source collection into another by selecting from its entries.</p>
</div>
<div class="paragraph">
<p>Selection uses the syntax <code>.?[selectionExpression]</code>. This will filter the collection and
return a new collection containing a subset of the original elements. For example,
selection would allow us to easily get a list of Serbian inventors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Inventor&gt; list = (<span class="predefined-type">List</span>&lt;Inventor&gt;) parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Members.?[Nationality == 'Serbian']</span><span class="delimiter">&quot;</span></span>).getValue(societyContext);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Selection is possible upon both lists and maps. In the former case the selection
criteria is evaluated against each individual list element whilst against a map the
selection criteria is evaluated against each map entry (objects of the Java type
<code>Map.Entry</code>). Map entries have their key and value accessible as properties for use in
the selection.</p>
</div>
<div class="paragraph">
<p>This expression will return a new map consisting of those elements of the original map
where the entry value is less than 27.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Map</span> newMap = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">map.?[value&lt;27]</span><span class="delimiter">&quot;</span></span>).getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to returning all the selected elements, it is possible to retrieve just the
first or the last value. To obtain the first entry matching the selection the syntax is
<code>^[&#8230;&#8203;]</code> whilst to obtain the last matching selection the syntax is <code>$[&#8230;&#8203;]</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-projection"><a class="anchor" href="#expressions-collection-projection"></a>4.5.18. Collection Projection</h4>
<div class="paragraph">
<p>Projection allows a collection to drive the evaluation of a sub-expression and the
result is a new collection. The syntax for projection is <code>![projectionExpression]</code>. Most
easily understood by example, suppose we have a list of inventors but want the list of
cities where they were born. Effectively we want to evaluate 'placeOfBirth.city' for
every entry in the inventor list. Using projection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// returns ['Smiljan', 'Idvor' ]</span>
<span class="predefined-type">List</span> placesOfBirth = (<span class="predefined-type">List</span>)parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Members.![placeOfBirth.city]</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A map can also be used to drive projection and in this case the projection expression is
evaluated against each entry in the map (represented as a Java <code>Map.Entry</code>). The result
of a projection across a map is a list consisting of the evaluation of the projection
expression against each map entry.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-templating"><a class="anchor" href="#expressions-templating"></a>4.5.19. Expression templating</h4>
<div class="paragraph">
<p>Expression templates allow a mixing of literal text with one or more evaluation blocks.
Each evaluation block is delimited with prefix and suffix characters that you can
define, a common choice is to use <code>#{ }</code> as the delimiters. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> randomPhrase = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">random number is #{T(java.lang.Math).random()}</span><span class="delimiter">&quot;</span></span>,
                <span class="keyword">new</span> TemplateParserContext()).getValue(<span class="predefined-type">String</span>.class);

<span class="comment">// evaluates to &quot;random number is 0.7038186818312008&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The string is evaluated by concatenating the literal text 'random number is ' with the
result of evaluating the expression inside the #{ } delimiter, in this case the result
of calling that random() method. The second argument to the method <code>parseExpression()</code>
is of the type <code>ParserContext</code>. The <code>ParserContext</code> interface is used to influence how
the expression is parsed in order to support the expression templating functionality.
The definition of <code>TemplateParserContext</code> is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TemplateParserContext</span> <span class="directive">implements</span> ParserContext {

        <span class="directive">public</span> <span class="predefined-type">String</span> getExpressionPrefix() {
                <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">#{</span><span class="delimiter">&quot;</span></span>;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getExpressionSuffix() {
                <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;
        }

        <span class="directive">public</span> <span class="type">boolean</span> isTemplate() {
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-example-classes"><a class="anchor" href="#expressions-example-classes"></a>4.6. Classes used in the examples</h3>
<div class="paragraph">
<p>Inventor.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span>;

<span class="keyword">import</span> <span class="include">java.util.Date</span>;
<span class="keyword">import</span> <span class="include">java.util.GregorianCalendar</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Inventor</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> <span class="predefined-type">String</span> nationality;
        <span class="directive">private</span> <span class="predefined-type">String</span><span class="type">[]</span> inventions;
        <span class="directive">private</span> <span class="predefined-type">Date</span> birthdate;
        <span class="directive">private</span> PlaceOfBirth placeOfBirth;

        <span class="directive">public</span> Inventor(<span class="predefined-type">String</span> name, <span class="predefined-type">String</span> nationality) {
                <span class="predefined-type">GregorianCalendar</span> c= <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span>();
                <span class="local-variable">this</span>.name = name;
                <span class="local-variable">this</span>.nationality = nationality;
                <span class="local-variable">this</span>.birthdate = c.getTime();
        }

        <span class="directive">public</span> Inventor(<span class="predefined-type">String</span> name, <span class="predefined-type">Date</span> birthdate, <span class="predefined-type">String</span> nationality) {
                <span class="local-variable">this</span>.name = name;
                <span class="local-variable">this</span>.nationality = nationality;
                <span class="local-variable">this</span>.birthdate = birthdate;
        }

        <span class="directive">public</span> Inventor() {
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getNationality() {
                <span class="keyword">return</span> nationality;
        }

        <span class="directive">public</span> <span class="type">void</span> setNationality(<span class="predefined-type">String</span> nationality) {
                <span class="local-variable">this</span>.nationality = nationality;
        }

        <span class="directive">public</span> <span class="predefined-type">Date</span> getBirthdate() {
                <span class="keyword">return</span> birthdate;
        }

        <span class="directive">public</span> <span class="type">void</span> setBirthdate(<span class="predefined-type">Date</span> birthdate) {
                <span class="local-variable">this</span>.birthdate = birthdate;
        }

        <span class="directive">public</span> PlaceOfBirth getPlaceOfBirth() {
                <span class="keyword">return</span> placeOfBirth;
        }

        <span class="directive">public</span> <span class="type">void</span> setPlaceOfBirth(PlaceOfBirth placeOfBirth) {
                <span class="local-variable">this</span>.placeOfBirth = placeOfBirth;
        }

        <span class="directive">public</span> <span class="type">void</span> setInventions(<span class="predefined-type">String</span><span class="type">[]</span> inventions) {
                <span class="local-variable">this</span>.inventions = inventions;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span><span class="type">[]</span> getInventions() {
                <span class="keyword">return</span> inventions;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>PlaceOfBirth.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">PlaceOfBirth</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> city;
        <span class="directive">private</span> <span class="predefined-type">String</span> country;

        <span class="directive">public</span> PlaceOfBirth(<span class="predefined-type">String</span> city) {
                <span class="local-variable">this</span>.city=city;
        }

        <span class="directive">public</span> PlaceOfBirth(<span class="predefined-type">String</span> city, <span class="predefined-type">String</span> country) {
                <span class="local-variable">this</span>(city);
                <span class="local-variable">this</span>.country = country;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getCity() {
                <span class="keyword">return</span> city;
        }

        <span class="directive">public</span> <span class="type">void</span> setCity(<span class="predefined-type">String</span> s) {
                <span class="local-variable">this</span>.city = s;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getCountry() {
                <span class="keyword">return</span> country;
        }

        <span class="directive">public</span> <span class="type">void</span> setCountry(<span class="predefined-type">String</span> country) {
                <span class="local-variable">this</span>.country = country;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Society.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span>;

<span class="keyword">import</span> <span class="include">java.util</span>.*;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Society</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> Advisors = <span class="string"><span class="delimiter">&quot;</span><span class="content">advisors</span><span class="delimiter">&quot;</span></span>;
        <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> President = <span class="string"><span class="delimiter">&quot;</span><span class="content">president</span><span class="delimiter">&quot;</span></span>;

        <span class="directive">private</span> <span class="predefined-type">List</span>&lt;Inventor&gt; members = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;Inventor&gt;();
        <span class="directive">private</span> <span class="predefined-type">Map</span> officers = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>();

        <span class="directive">public</span> <span class="predefined-type">List</span> getMembers() {
                <span class="keyword">return</span> members;
        }

        <span class="directive">public</span> <span class="predefined-type">Map</span> getOfficers() {
                <span class="keyword">return</span> officers;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> <span class="type">boolean</span> isMember(<span class="predefined-type">String</span> name) {
                <span class="keyword">for</span> (Inventor inventor : members) {
                        <span class="keyword">if</span> (inventor.getName().equals(name)) {
                                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
                        }
                }
                <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop"><a class="anchor" href="#aop"></a>5. 使用 Spring 进行面向切面编程 </h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="aop-introduction"><a class="anchor" href="#aop-introduction"></a>5.1. 简介</h3>
<div class="paragraph">
<p><em>面向切面编程</em>（AOP）通过提供另一种思考程序结构的方式来补充面向对象编程（OOP）。OOP 中模块化的关键单元是类，而 AOP 中模块化的单元是切面。Aspect 可以使关注点模块化，例如跨越多种类型和对象的事务管理。（这种关注在 AOP 文献中常常被称为横切关注点。）</p>
</div>
<div class="paragraph">
<p><em>AOP 框架</em> 是 Spring 的关键组件之一。不过 Spring IoC 容器不依赖于 AOP，也就是说，如果你不想使用 AOP，就可以不用， AOP 是 Spring IoC 的补充，可以提供非常强大的中间件解决方案。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Spring 2.0 AOP</div>
<div class="paragraph">
<p>Spring 2.0 引入了使用 <a href="#aop-schema">基于 schema 的方法</a> 或 <a href="#aop-ataspectj">@AspectJ 注解风格</a> 来编写自定义切面的更简单和更强大的方法。这两种风格都提供完AspectJ pointcut 语言的所有类型的 advice 和使用，同时仍然使用Spring AOP 进行织入。</p>
</div>
<div class="paragraph">
<p>本章将讨论基于Spring 2.0 schema 和基于 @AspectJ 的 AOP 支持。Spring 2.0 AOP 对 Spring 1.2 AOP 保持完全向后兼容，Spring 1.2 API 提供的底层AOP支持将在 <a href="#aop-api">下一章</a> 讨论。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>AOP 被用来在 Spring 框架中...</p>
</div>
<div class="ulist">
<ul>
<li>
<p>...提供声明式企业服务，特别是作为 EJB 声明式服务的替代品。这种服务最重要的是 <a href="#transaction-declarative"><em>声明式事务管理</em></a>。</p>
</li>
<li>
<p>...允许用户实现自定义的切面，用 AOP 补充面向对象 OOP 的使用。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你只对通用声明式服务或其他预先打包的声明式中间件服务（例如池）感兴趣，则不需要直接使用 Spring AOP，且可以跳过本章的大部分内容。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-introduction-defn"><a class="anchor" href="#aop-introduction-defn"></a>5.1.1. AOP 概念</h4>
<div class="paragraph">
<p>让我们从定义一些 AOP 核心概念和术语开始。这些术语不是特定于 Spring 的...不幸的是，AOP 术语并不是特别直观；然而，如果 Spring 使用自己的术语，那将更加令人困惑。</p>
</div>
<div class="ulist">
<ul>
<li>
  <p><em>Aspect（切面）</em>：跨越多个类的关注点的模块化。事务管理是企业级 Java 应用程序中横切关注的一个很好的例子。在 Spring AOP 中，切面是使用常规类（<a href="#aop-schema">基于 schema 的方法</a>）或使用 <code>@Aspect</code> 注解（<a href="#aop-ataspectj"><code>@AspectJ</code> 风格</a>）的常规类来实现的。</p>
</li>
<li>
<p><em>Join point（连接点）</em>：程序执行期间的一个点，例如方法的执行或异常的处理。在 Spring AOP中，连接点总是代表一个方法的执行。</p>
</li>
<li>
<p><em>Advice（通知）</em>：切面在特定连接点执行的操作。通知有个不同类型，包括“around”环绕，“before”前置“after”后置。（通知的类型在后面会讨论到）。包括 Spring 在内的很多 AOP 框架将通知建模成拦截器，围绕连接点维护了一个拦截器链。</p>
</li>
<li>
<p><em>Pointcut（切点）</em>：匹配连接点的谓词断言。通知与切点表达式相关联，且在与切点匹配的连接点上执行（例如，执行具有特定方法名的方法）。与切点匹配的连接点概念是 AOP 的核心，Spring 默认使用 AspectJ 切点表达式语言。</p>
</li>
<li>
<p><em>Introduction（引入）</em>：代表类型声明额外的方法或者字段。Spring AOP 允许你对通知对象引入新的接口（和一个相应的实现）。例如，你可以使用 introduction 使得某个 bean 实现 <code>IsModified</code> 接口以便简化缓存。（在 AspectJ 社区中，introduction 被称为“类型间声明”。）</p>
</li>
<li>
<p><em>Target object（目标对象）</em>：被一个或多个切面通知的对象。也被称为通知对象。由于 Spring AOP 是使用运行时代理实现的，因此该对象将始终是代理对象。</p>
</li>
<li>
<p><em>AOP proxy（AOP 代理）</em>：一个由 AOP 框架创建的用于实现切面约定（通知方法执行等等）的对象。在 Spring 框架中，AOP 代理是由 JDK 动态代理或 CGLIB 代理实现的。</p>
</li>
<li>
<p><em>Weaving（织入）</em>：将切面与其他应用程序类型或对象链接以创建通知对象。这可以在编译时（例如使用 AspectJ 编译器），加载时或运行时完成。像其他纯 Java AOP 框架一样，Spring AOP 在运行时执行织入。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通知类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Before advice（前置通知）</em>：在连接点目标之前执行的通知，它不能阻止程序执行流执行到连接点（除非通知抛出异常）。</p>
</li>
<li>
<p><em>After returning advice（返回通知）</em>：在连接点目标正常完成之后执行的通知：例如，如果一个方法在没有异常抛出的情况下返回。</p>
</li>
<li>
<p><em>After throwing advice（异常通知）</em>：如果某个方法因抛出异常而退出才执行的通知。 </p>
</li>
<li>
<p><em>After (finally) advice（后置通知）</em>：不管连接点以什么方式退出（正常的或者异常的返回）都会在之后执行的通知。</p>
</li>
<li>
<p><em>Around advice（环绕通知）</em>：在连接点如方法调用前后（环绕）执行的通知。这是最强大的通知类型。环绕通知可以在方法调用前调用后执行自定义行为。它还负责选择是否处理连接点或者是否通过返回通知方法本身的返回值或抛出异常来切断通知方法的执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>环绕通知是最常用的通知。Spring AOP 像 AspectJ 一样提供了一整套的通知类型，我们建议你使用能够满足实现所需行为的能力相对对小的通知类型。例如，如果只需要用方法的返回值来更新缓存，则最好是实现一个返回通知而不是环绕通知，尽管环绕通知可以完成同样的事情。使用的通知类型越具体，编程模型就越简单，潜在错误的可能性也就越小。例如，如果你不需要调用 <code>JoinPoint</code> 中用于环绕通知的 <code>proceed()</code> 方法，也就不可能出现调用失败。</p>
</div>
<div class="paragraph">
<p>在 Spring 2.0 中，所有的通知参数都是静态类型的，所以你应该使用适当类型的通知参数（例如来自方法执行的返回值的类型）而不是 <code>Object</code> 数组。</p>
</div>
<div class="paragraph">
<p>被切点匹配的连接点的概念是 AOP 的关键，区别于仅提供拦截的旧技术。切点使通知可以独立于面向对象的层次结构进行设定。例如，提供声明式事务管理的环绕通知可以应用于跨越多个对象（例如服务层中的所有业务操作）的一组方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-introduction-spring-defn"><a class="anchor" href="#aop-introduction-spring-defn"></a>5.1.2. Spring AOP 能力和目标</h4>
<div class="paragraph">
<p>Spring AOP 是用纯 Java 实现的。不需要特殊的编译过程。Spring AOP 不需要控制类加载器层次结构，因此适用于Servlet 容器或应用程序服务器。</p>
</div>
<div class="paragraph">
<p>Spring AOP 目前仅支持方法执行连接点（通知 Spring bean 上的方法执行）。字段拦截并没有实现，虽然可以在不破坏核心 Spring AOP API 的情况下添加对字段拦截的支持。如果你需要通知字段访问和更新连接点，请考虑使用诸如AspectJ 之类的语言。</p>
</div>
<div class="paragraph">
<p>Spring AOP 的 AOP 方法与其他大多数 AOP 框架不同。目标不是提供最完整的 AOP 实现（尽管 Spring AOP 是可以做到的）;而是提供 AOP 实现和 Spring IoC 之间的紧密集成，以帮助解决企业应用程序中的常见问题。</p>
</div>
<div class="paragraph">
<p>因此，举个例子，Spring 框架的 AOP 功能通常与 Spring IoC 容器一起使用。切面使用正常的 bean 定义语法进行配置（尽管这允许强大的“自动代理”功能来实现）：这是与其他 AOP 实现的关键区别。有些事情你无法用Spring AOP 轻松或有效地完成，比如通知非常细粒度的对象（比如典型的域对象）：在这种情况下，AspectJ是最好的选择。但是，我们的经验是，Spring AOP 为适用于 AOP 的企业级 Java 应用程序中的大多数问题提供了极好的解决方案。</p>
</div>
<div class="paragraph">
<p>Spring AOP 将永远不会与 AspectJ 竞争提供全面的 AOP 解决方案。我们认为像 Spring AOP 这样的基于代理的框架和像 AspectJ 这样的全面的框架都是有价值的，而且它们是互补的关系，而不是竞争的关系。 Spring 将 Spring AOP 和 IoC 与 AspectJ 无缝集成，以便在一致的基于 Spring 的应用程序体系结构中满足 AOP 的所有用途。此集成不影响 Spring AOP API 或 AOP Alliance API：Spring AOP 保持向后兼容。有关Spring AOP API 的讨论，请参阅<a href="#aop-api">以下章节</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 框架的核心原则之一是 <em>非侵入式</em>；意思就是你不应该被迫在你的业务/领域模型中引入框架特定的类和接口。然而，在一些地方，Spring 框架的确给了你在你的代码库中引入特定的 Spring 框架的依赖关系的选择：给你这样的选择的理由是因为在某些情况下，阅读或者编写一些特定的功能可能会变得更加简单。Spring 框架（几乎）总会为你提供这样选择：你可以自由决定哪个选项最适合你的特定用例或场景。</p>
</div>
<div class="paragraph">
<p>与本章相关的此类选择是对于 AOP 框架（以及 AOP 风格）的选择。您可以选择 AspectJ 和/或 Spring AOP，也可以选择 @AspectJ 注解风格的方式或 Spring XML 配置风格的方式。本章首先选择引入的是 @AspectJ 风格的方式，这个事实不应该被认为是：相比Spring XML 配置风格， Spring 团队更喜欢使用 @AspectJ 注解风格的方式。</p>
</div>
<div class="paragraph">
<p>请参阅 <a href="#aop-choosing">选择使用哪种 AOP 声明风格</a> 来更全面地讨论每种风格的原因和动机。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-introduction-proxies"><a class="anchor" href="#aop-introduction-proxies"></a>5.1.3. AOP Proxies（AOP 代理）</h4>
<div class="paragraph">
<p>Spring AOP 默认使用标准 JDK <em>动态代理</em> 来实现 AOP 代理。这使得任何接口（或一组接口）都可以被代理。</p>
</div>
<div class="paragraph">
<p>Spring AOP 也可以使用 CGLIB 代理。这是代理类而不是接口的必要条件。如果业务对象没有实现接口，则默认使用CGLIB。 对接口进行编程而不是对类进行编程是个好习惯; 业务类通常会实现一个或多个业务接口。在那些需要通知未在接口中声明的方法的情况下（希望很少），或者需要将代理对象作为具体类型传递给方法的情况下，可以<a href="#aop-proxying">强制使用CGLIB</a>，</p>
</div>
<div class="paragraph">
<p>记住 Spring AOP 是 <em>基于代理的</em> 这个事实非常重要。请参阅 <a href="#aop-understanding-aop-proxies">理解 AOP 代理</a>，以彻底查看此实现细节的实际含义。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-ataspectj"><a class="anchor" href="#aop-ataspectj"></a>5.2. @AspectJ 支持</h3>
<div class="paragraph">
<p>@AspectJ 是指将切面声明为常规 Java 类的注解的风格。<a href="https://www.eclipse.org/aspectj">AspectJ</a> 项目作为 AspectJ 5 版本的一部分引入了 @AspectJ 风格。Spring 使用 AspectJ 提供的用于切点解析和匹配的库来翻译与 AspectJ 5 相同的注解。AOP 运行时仍然是纯粹的 Spring AOP，并且不依赖于 AspectJ 编译器或织入器。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对 AspectJ 编译器和织入器的使用启用了完整的 AspectJ 语言，在<a href="#aop-using-aspectj">在 Spring 应用程序中使用 AspectJ</a> 中进行了讨论。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-aspectj-support"><a class="anchor" href="#aop-aspectj-support"></a>5.2.1. 启用 @AspectJ 支持</h4>
<div class="paragraph">
<p>要在 Spring 配置中使用 @AspectJ 切面，你需要启用 Spring 对于基于 @AspectJ 切面配置 Spring AOP 的支持，并根据 bean 是否被这些切面通知决定是否对 bean 进行自动代理配置。自动代理的意思是，如果 Spring 确定 bean 被一个或多个切面通知，它会自动生成一个代理来拦截方法调用，并确保在需要时执行通知。</p>
</div>
<div class="paragraph">
<p>对 @AspectJ 支持可以使用 XML 或 Java 风格的配置来启用。无论哪种情况，你还需要确保 AspectJ 的<code>aspectjweaver.jar</code> 库位于应用程序的类路径（1.6.8 或更高版本）上。 这个库可以在 AspectJ 发行版的 <code>'lib'</code> 目录下或者通过 Maven Central 版本库获得。</p>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-java"><a class="anchor" href="#aop-enable-aspectj-java"></a>通过 Java 配置启用对 @AspectJ 的支持</h5>
<div class="paragraph">
<p>要通过 Java 配置启用对 @AspectJ 的支持需要添加 <code>@EnableAspectJAutoProxy</code> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableAspectJAutoProxy</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-xml"><a class="anchor" href="#aop-enable-aspectj-xml"></a>通过 XML 配置启用对 @AspectJ 的支持</h5>
<div class="paragraph">
<p>要通过基于 XML DE 配置启用对 @AspectJ 的支持需要使用 <code>aop:aspectj-autoproxy</code> 元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy</span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>前提是假设你正在使用如 <a href="appendix.html#xsd-configuration">基于 XML Schema 的配置</a> 中所述的对 schema 支持。请参阅<a href="appendix.html#xsd-config-body-schemas-aop"> AOP schema</a> 以了解如何在 <code>aop</code> 命名空间中导入标签。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-at-aspectj"><a class="anchor" href="#aop-at-aspectj"></a>5.2.2. 声明切面</h4>
<div class="paragraph">
<p>在启用 @AspectJ 支持的情况下，在你的应用程序上下文中定义的任何一个具有 @AspectJ 切面的类（具有@Aspect 注解）的 bean 将被 Spring 自动检测，并用于配置 Spring AOP。以下示例显示了一个不太有用的切面所需的最小定义：</p>
</div>
<div class="paragraph">
<p>应用程序上下文中的常规 bean 定义，指向具有<code>@Aspect</code> 注解的 bean 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xyz.NotVeryUsefulAspect</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- configure properties of aspect here as normal --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>以及由 <code>org.aspectj.lang.annotation.Aspect</code> 注解的 <code>NotVeryUsefulAspect</code> 类定义；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.xyz</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">NotVeryUsefulAspect</span> {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>切面（用 <code>@Aspect</code> 注解的类）可能与其他类一样有其他方法和字段。它们也可能包含切点，通知和引入（类型间）声明。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">通过组件扫描自动检测切面</div>
<div class="paragraph">
<p>你可以在 Spring XML 配置中将切面类注册为常规 bean，或者像通过其他 Spring 管理的 bean 一样通过类路径扫描来自动检测它们。但是，注意，<em>@Aspect</em> 注解对于类路径中的自动检测是不够的：为此，您需要添加一个单独的 <em>@Component</em> 注解（或者按照 Spring 组件扫描器的规则，添加一个自定义 stereotype 注解）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">用其他切面通知切面？</div>
<div class="paragraph">
<p>在 Spring AOP 中，不可能将切面本身作为其他切面的通知目标。类上的 <em>@Aspect</em> 注解将其标记为一个切面，因此它会被自动代理排除。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-pointcuts"><a class="anchor" href="#aop-pointcuts"></a>5.2.3. 声明切点</h4>
<div class="paragraph">
<p>回想一下，切点决定了感兴趣的连接点，从而使我们能够控制何时执行通知。<em>Spring AOP 只支持 Spring bean 的方法执行连接点</em>，所以你可以把切点视为对 Spring bean 上方法执行的匹配。切点声明包含两部分：包含名称和任何参数的签名，以及确定我们感兴趣的方法执行的切点表达式。在 AOP 的 @AspectJ 注解风格中，切点签名由常规方法定义提供，并且使用 <code>@Pointcut</code> 注解来表示切点表达式（用作切点签名的方法 <em>必须</em> 具有 <code>void</code> 返回类型）。</p>
</div>
<div class="paragraph">
<p>举个例子将有助于区分切点签名和切点表达式之间的区别。以下示例定义了一个名为 <code>'anyOldTransfer'</code> 的切点，该切点将匹配任何名为 <code>'transfer'</code> 的方法的执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* transfer(..))</span><span class="delimiter">&quot;</span></span>)<span class="comment">// the pointcut expression</span>
<span class="directive">private</span> <span class="type">void</span> anyOldTransfer() {}<span class="comment">// the pointcut signature</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>构成 <code>@Pointcut</code> 注解值的切点表达式是一个常规的 AspectJ 5 切点表达式。有关 AspectJ 的切点语言的完整讨论，请参见 <a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ编程指南</a>（以及用于扩展的 <a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5 开发人员笔记</a>）或 AspectJ 主题的书籍，如Colyer 等人的“Eclipse AspectJ” 或 Ramnivas Laddad 的“AspectJ in Action”。</p>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-designators"><a class="anchor" href="#aop-pointcuts-designators"></a>支持的切点指示符</h5>
<div class="paragraph">
<p>Spring AOP 支持在切点表达式中使用以下 AspectJ 切点指示符（PCD）：</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">其它切点类型</div>
<div class="paragraph">
<p>完整的 AspectJ 切点语言支持 Spring 中不支持的附加切入点指示符。它们是：<code>call，get，set，preinitialization，staticinitialization，initialization，handler，adviceexecution，withincode，cflow，cflowbelow，if，@this</code> 和<code> @withincode</code>。在由 Spring AOP 翻译的切点表达式中使用这些切点指示符将导致抛出 <code>IllegalArgumentException</code> 异常。</p>
</div>
<div class="paragraph">
<p>Spring AOP 支持的一系列切点指示符可能在将来的版本中扩展，以支持更多的 AspectJ 切点指示符。</p>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>execution</em> - 用于匹配方法执行连接点，是使用 Spring AOP 时要使用的主要切点指示符</p>
</li>
<li>
<p><em>within</em> - 限制匹配的连接点类型范围（使用 Spring AOP 时，匹配类型中声明的方法的执行）</p>
</li>
<li>
<p><em>this</em> - 限制匹配连接点（使用 Spring AOP 时，方法的执行），其中 bean 引用（Spring AOP 代理）是给定类型的一个实例</p>
</li>
<li>
<p><em>target</em> - 限制匹配连接点（使用Spring AOP时，方法的执行），其中目标对象（被代理的应用程序对象）是给定类型的实例</p>
</li>
<li>
<p><em>args</em> -  限制匹配连接点（使用Spring AOP时，方法的执行），其中参数是给定类型的实例</p>
</li>
<li>
<p><em>@target</em> - 限制匹配连接点（使用Spring AOP时，方法的执行），执行对象的类有一个给定类型的注解</p>
</li>
<li>
<p><em>@args</em> - 限制匹配连接点（使用Spring AOP时，方法的执行），实参的运行时类型有给定类型的注解</p>
</li>
<li>
<p><em>@within</em> - 限制匹配具有给定注解类型的连接点（使用Spring AOP时，带有给定注解的类型声明的方法的执行</p>
</li>
<li>
<p><em>@annotation</em> -  限制匹配具有给定的注解类型的连接点（在Spring AOP中执行的方法）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于 Spring AOP 将匹配仅限于方法执行连接点，所以上面的切点指示符的讨论给出了比在 AspectJ 编程指南中找到的更窄的定义。另外，AspectJ 本身具有基于类型的语义且在执行连接点上，<code>this</code> 和 <code>target</code> 都指向同一个对象 - 执行方法的对象。 Spring AOP 是一个基于代理的系统，区分代理对象本身（绑定到 <code>this</code>）和代理（绑定到 <code>target</code> ）后面的目标对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于 Spring AOP 框架基于代理的性质，目标对象内的调用根本没有被截取。对于 JDK 代理，只有代理上的 public 接口方法调用才能被拦截。使用 CGLIB，代理上的 public 和 protected 方法调用将被拦截，如果需要的话，甚至包package-visible 方法。但是，通过代理的常见交互应始终通过public 签名来设计。</p>
</div>
<div class="paragraph">
<p>注意切点定义通常与任何拦截的方法相匹配。如果一个切点严格意味着它只能是 public 的，即使在通过代理进行潜在的非 public 交互的 CGLIB 代理场景中，也需要相应地定义切点。</p>
</div>
<div class="paragraph">
<p>如果拦截需求包含方法调用，甚至包含目标类中的构造器，请考虑使用给予 Spring 驱动的<a href="#aop-aj-ltw">本地 AspectJ 织入</a>，而不是 Spring 的基于代理的 AOP 框架。这构成了不同特征的 AOP 使用方式，所以在做出决定之前一定要先熟悉织入。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring AOP 还支持额外的 PCD 命名 <code>bean</code>。 这个 PCD 允许你将连接点限制为一个特定的 Spring bean 的匹配，或者一组命名的 Spring bean（当使用通配符时）。 <code>bean</code> PCD 有以下形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>idOrNameOfBean</code> 标记可以是任何 Spring bean 的 name：提供了使用 <code>*</code> 字符的有限通配符支持，所以如果你为 Spring bean 建立了一些命名约定，你可以很容易地写一个 <code>bean</code> PCD 表达式来挑选它们。与其他切入点指示符的情况一样，<code>bean</code> PCD 可以被 &&，||和!（否定）编辑。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，<code>bean</code> PCD 仅在 Spring AOP 中受支持，而不是在 AspectJ 本地织入中支持。 这是 AspectJ 定义的标准 PCD 的 Spring 扩展，因此不适用于 <code>@Aspect</code> 模型中声明的切面。</p>
</div>
<div class="paragraph">
<p><code>bean</code> PCD 在实例级别运行（基于Spring bean 命名概念构建），而不是仅在类型级别（这是基于织入的 AOP 所限制的）。基于实例的切点指示符是 Spring 基于代理的 AOP 框架的一个特殊功能，它与 Spring bean 工厂紧密集成，通过名称识别特定的 bean 是很自然和直接的。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-combining"><a class="anchor" href="#aop-pointcuts-combining"></a>合并切点表达式</h5>
<div class="paragraph">
<p>切入点表达式可以使用'&&'，'||' 和 “!” 合并，也可以通过名称来引用切点表达式。 以下示例显示三个切点表达式：<code>anyPublicOperation</code>（如果方法执行连接点表示任何 public 方法的执行，则匹配）; <code>inTrading</code>（如果方法执行连接点在 trading 模块下执行，则匹配）和 <code>tradingOperation</code>（如果方法执行连接点表示在 trading 模块下任何 public 方法的执行，则匹配）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(public * *(..))</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> anyPublicOperation() {}

<span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.trading..*)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> inTrading() {}

<span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">anyPublicOperation() &amp;&amp; inTrading()</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> tradingOperation() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所示，用更小的命名组件构建更复杂的切点表达式是一种最佳实践。当按名称引用切点时，将应用普通的 Java 可见性规则（你可以看到相同类型的 private 切点，层次结构中受 protected 切点，任何位置的 public 切点等）。可见性不影响切入点匹配。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-common-pointcuts"><a class="anchor" href="#aop-common-pointcuts"></a>共享通用的切点定义</h5>
<div class="paragraph">
<p>在处理企业级应用程序时，你经常要从几个切面引用应用程序的模块和特定的一组操作。我们建议定义一个 “SystemArchitecture” 切面来捕获常见的切点表达式。典型的这个切面看起来如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.xyz.someapp</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Pointcut</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemArchitecture</span> {

        <span class="comment">/**
         * A join point is in the web layer if the method is defined
         * in a type in the com.xyz.someapp.web package or any sub-package
         * under that.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.web..*)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> inWebLayer() {}

        <span class="comment">/**
         * A join point is in the service layer if the method is defined
         * in a type in the com.xyz.someapp.service package or any sub-package
         * under that.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.service..*)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> inServiceLayer() {}

        <span class="comment">/**
         * A join point is in the data access layer if the method is defined
         * in a type in the com.xyz.someapp.dao package or any sub-package
         * under that.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.dao..*)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> inDataAccessLayer() {}

        <span class="comment">/**
         * A business service is the execution of any method defined on a service
         * interface. This definition assumes that interfaces are placed in the
         * &quot;service&quot; package, and that implementation types are in sub-packages.
         *
         * If you group service interfaces by functional area (for example,
         * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
         * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;
         * could be used instead.
         *
         * Alternatively, you can write the expression using the 'bean'
         * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have
         * named your Spring service beans in a consistent fashion.)
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.someapp..service.*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> businessService() {}

        <span class="comment">/**
         * A data access operation is the execution of any method defined on a
         * dao interface. This definition assumes that interfaces are placed in the
         * &quot;dao&quot; package, and that implementation types are in sub-packages.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.someapp.dao.*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> dataAccessOperation() {}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个切面定义的切点可以在任何需要切点表达式的地方引用。例如，要使服务层事务化，您可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>
        <span class="tag">&lt;aop:advisor</span>
                <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.someapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">advice-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;tx:advice</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;tx:attributes&gt;</span>
                <span class="tag">&lt;tx:method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">propagation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">REQUIRED</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/tx:attributes&gt;</span>
<span class="tag">&lt;/tx:advice&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;aop:config&gt;</code> 和 <code>&lt;aop:advisor&gt;</code> 元素会在基于 schema 的 AOP 支持中讨论。<a href="data-access.html#transaction">事务管理</a> 中讨论了事务相关的元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-examples"><a class="anchor" href="#aop-pointcuts-examples"></a>示例</h5>
<div class="paragraph">
<p>Spring AOP 用户可能最常使用 <code>execution</code> 切点指示符。execution 表达式的格式是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
                        <span class="directive">throws</span>-pattern?)</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了返回类型模式（上面代码段中的ret-type-pattern），命名模式和参数模式以外的所有部分都是可选的。返回类型模式决定了该方法的返回类型必须是什么，才能匹配连接点。大多数情况下，您将使用 <code>*</code> 作为返回类型，它匹配任何返回类型。只有当方法返回给定类型时，完全限定类型名称才会匹配。命名模式匹配方法名。您可以使用 <code>*</code> 通配符作为命名模式的全部或部分。如果要指定一个声明类型模式，就在命名模式后面添加 <code>.</code>。参数模式稍微复杂一点：<code>()</code> 匹配一个不带参数的方法，而 <code>(..)</code> 匹配任意数量的参数（零个或多个）。<code>(*)</code> 模式匹配任何类型接受一个参数的方法，<code>(*,String)</code> 匹配接受两个参数的方法，第一个可以是任何类型，第二个必须是一个字符串。有关更多信息，请参阅 “AspectJ 编程指南” 的 <a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">语言语义</a> 部分。</p>
</div>
<div class="paragraph">
<p>常见切点表达式的一些例子如下所示。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何 public 方法的执行</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(<span class="directive">public</span> * *(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>以“set”开头的任何方法的执行：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* set*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>由 <code>AccountService</code> 接口定义的任何方法的执行：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* com.xyz.service.AccountService.*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在 service 包定义的任何方法的执行：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* com.xyz.service.*.*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在 service 包或者其子包内定义的任何方法的执行：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* com.xyz.service..*.*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>service 包中的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">within(com.xyz.service.*)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>service 包或者其子包中的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">within(com.xyz.service..*)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>其代理实现了 <code>AccountService</code>  接口的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">this</span>(com.xyz.service.AccountService)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“this”更常用于绑定形式：-请参阅下面一节关于如何使代理对象在通知主体中可用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>其目标对象实现了 <code>AccountService</code> 接口的任何连接点（只在 Spring AOP 中的方法执行）a：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">target(com.xyz.service.AccountService)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“target”更常用于绑定形式：-请参阅下面一节关于如何使目标对象在通知主体中可用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>接受单个参数且传入参数的运行时类型是 <code>Serializable</code> 的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">args(java.io.Serializable)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“args”更常用于绑定形式：-请参阅下面一节关于如何使方法参数在通知主体中可用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>注意，此示例中给出的切点与 <code>execution(*
  *(java.io.Serializable))</code> 不同：如果在运行时传递的参数是 Serializable，则 args 版本会匹配，如果方法签名声明的单个参数类型是 <code>Serializable</code>，则 execution 版本匹配。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>目标对象具有 <code>@Transactional</code> 注解的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@target</span>(org.springframework.transaction.annotation.Transactional)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“@target”更常用于绑定形式：-请参阅下面一节关于如何使注解对象在通知主体中可用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>声明的目标对象的类型具有 <code>@Transactional</code> 注解的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@within</span>(org.springframework.transaction.annotation.Transactional)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“@within”更常用于绑定形式：-请参阅下面一节关于如何使注解对象在通知主体中可用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>执行的方法具有 <code>@Transactional</code> 注解的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@annotation</span>(org.springframework.transaction.annotation.Transactional)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“@annotation”更常用于绑定形式：-请参阅下面一节关于如何使注解对象在通知主体中可用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>接受单个参数且传入参数的运行时类型是具有 <code>@Classified</code> 注解的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@args</span>(com.xyz.security.Classified)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>“@args”更常用于绑定形式：-请参阅下面一节关于如何使注解对象在通知主体中可用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring bean 上名字为 <code>tradeService</code> 的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">bean(tradeService)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring bean 上名字匹配 <code>*Service</code> 通配符表达式的任何连接点（只在 Spring AOP 中的方法执行）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">bean(*Service)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="writing-good-pointcuts"><a class="anchor" href="#writing-good-pointcuts"></a>编写好的切点</h5>
<div class="paragraph">
<p>在编译期间，AspectJ 会处理切点以试图优化匹配性能。检查代码并确定每个连接点是否匹配（静态或动态）给定的切点是一个代价高昂的过程。（动态匹配意味着无法从静态分析完全确定匹配，并且将在代码中放置测试以确定代码运行时是否存在实际匹配）。在第一次遇到切点声明时，AspectJ 会为匹配过程重写切点的最佳形式。什么意思呢？ 基本上，切点会被重写为DNF（析取范式），并且切点的组件会被排序，以便首先检查那些评估代价更小的组件。 这意味着你不必担心需要理解各种切点指示符的性能，并且可以在切点声明中以任何顺序提供它们。</p>
</div>
<div class="paragraph">
<p>然而，AspectJ 只能使用它被告知的内容，为了获得最佳的匹配性能，你应该考虑他们正在努力实现的目标，并尽可能地缩小匹配的搜索空间。现有的指示符自然地分为三类：kinded，scoping 和 context：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kinded 指示符是那些选择特定连接点类型的指示符，例如：execution，get，set，call，handler</p>
</li>
<li>
<p>Scoping 指示符是那些选择一组感兴趣的连接点（可能会有很类型）的指示符，例如：within，withincode</p>
</li>
<li>
<p>Contextual 指示符是那些匹配（和选择性绑定）基于 context 的指示符，例如：this，target，@annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个编写良好的切点应至少包括前两种类型（kinded 和 scoping），如果希望基于连接点上下文进行匹配，则可以包含上下文指示符，或者将该上下文绑定以用于通知。只提供一个 kinded 指示符或仅指定一个 contextual 指示符将会起作用，但是会由于所有额外的处理和分析而影响织入性能（时间和内存消耗）。Scoping 指示符的匹配速度非常快，而且它们的使用方式意味着 AspectJ 可以很快地解除不应该进一步处理的连接点组-这就是为什么一个编写良好的切点应该总是包含一个 Scoping 指示符。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice"><a class="anchor" href="#aop-advice"></a>5.2.4. 声明通知</h4>
<div class="paragraph">
<p>通知与切点表达式相关联，并在切点匹配的方法执行之前，之后或前后运行。切点表达式可以是对已经命名切点的简单引用，也可以是就地声明的切点表达式。</p>
</div>
<div class="sect4">
<h5 id="aop-advice-before"><a class="anchor" href="#aop-advice-before"></a>前置通知</h5>
<div class="paragraph">
<p>切面中使用 <code>@Before</code>  注解来声明前置通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Before</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">BeforeExample</span> {

        <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果就地使用切点表达式，我们可以将上面的例子重写为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Before</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">BeforeExample</span> {

        <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.dao.*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-returning"><a class="anchor" href="#aop-advice-after-returning"></a>返回通知</h5>
<div class="paragraph">
<p>返回通知在一个匹配方法执行正常返回时执行。它使用 <code>@AfterReturning</code> 注解声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterReturning</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterReturningExample</span> {

        <span class="annotation">@AfterReturning</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意：同一个切面当然也可以有多个通知声明和其他成员。我们只是在这些例子中展示一个通知声明，以关注当下正在讨论的问题。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有时您需要在通知主体中访问返回的实际值。你可以使用 <code>@AfterReturning</code> 的形式来绑定这个返回值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterReturning</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterReturningExample</span> {

        <span class="annotation">@AfterReturning</span>(
                pointcut=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>,
                returning=<span class="string"><span class="delimiter">&quot;</span><span class="content">retVal</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck(<span class="predefined-type">Object</span> retVal) {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>returning</code> 属性中使用的名字必须对应于通知方法中参数的名子。当方法执行返回时，返回值将作为相应的参数值传递给通知方法。<code>returning</code> 子句还将匹配限制为仅返回指定类型的值的方法执行（在这个例子中 <code>Object</code> 将匹配任何返回值）。</p>
</div>
<div class="paragraph">
<p>请注意，使用返回通知时，不能返回完全不同的引用。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-throwing"><a class="anchor" href="#aop-advice-after-throwing"></a>异常通知</h5>
<div class="paragraph">
<p>异常通知在匹配方法执行以异常方式退出的时候执行。它使用 <code>@AfterThrowing</code> 注解声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterThrowing</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterThrowingExample</span> {

        <span class="annotation">@AfterThrowing</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doRecoveryActions() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，只有在抛出给定类型的异常时，才需要执行这个通知，而且你还需要经常访问通知主体中的被抛出异常。 使用 <code>throwing</code> 属性来限制匹配（如果需要，则使用  <code>Throwable</code> 作为异常类型）并将抛出的异常绑定到通知的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterThrowing</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterThrowingExample</span> {

        <span class="annotation">@AfterThrowing</span>(
                pointcut=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>,
                throwing=<span class="string"><span class="delimiter">&quot;</span><span class="content">ex</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doRecoveryActions(DataAccessException ex) {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>throwing</code> 属性中使用的名字必须对应于通知方法中参数的名子。当方法执行以抛出异常的方式退出时，异常将作为相应的参数值传递给通知方法。<code>throwing</code> 子句还将严格匹配限制为仅抛出指定类型的异常的方法执行（在这个例子中是 <code>DataAccessException</code>）。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-finally"><a class="anchor" href="#aop-advice-after-finally"></a>后置（finally）通知</h5>
<div class="paragraph">
<p>后置（finally）通知在匹配的方法执行退出后执行。它使用 <code>@After</code> 注解声明。后置通知必须准备好处理正常和异常的返回条件。它通常用于释放资源等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.After</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterFinallyExample</span> {

        <span class="annotation">@After</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doReleaseLock() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-around-advice"><a class="anchor" href="#aop-ataspectj-around-advice"></a>环绕通知</h5>
<div class="paragraph">
<p>最后一种类型的通知是环绕通知。环绕通知“环绕”匹配的方法执行。它可以在方法执行之前和之后进行工作，并确定方法实际上何时，如何甚至是何时执行。如果您需要以线程安全的方式（例如启动和停止计时器）在方法执行之前和之后共享状态，则通常会使用“围绕”通知。总是使用符合你要求的功能最少的通知（即在如果简单的前置通知就能完成就不要使用环绕通知）。</p>
</div>
<div class="paragraph">
<p>环绕通知使用 <code>@Around</code> 注解来声明。通知方法的第一个参数必须是 <code>ProceedingJoinPoint</code> 类型。在通知的主体中，在 <code>ProceedingJoinPoint</code> 上调用 <code>proceed()</code> 会似的底层方法执行。 <code>proceed</code> 方法也可以通过传递 <code>Object[]</code> 调用-数组的值将会被当作参数在方法执行时继续使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用 Object[] 调用时的 proceed 的行为与 AspectJ 编译器编译的 around 处理的行为稍有不同。对于使用传统AspectJ 语言编写的环绕通知，传递给 proceed 的参数数量必须与传递给环绕通知的参数数量（而不是当下连接点接受的参数数量）匹配，并且以给定的参数位置传递给 proceed 的值取代了该值所绑定的实体的连接点的原始值（如果现在不能理解，不用担心！）。Spring 采用的方法更简单，与其基于代理的匹配更好， execution only
  semantic。如果你正在编译为 Spring 编写 @AspectJ 切面，并使用 AspectJ 编译器和织入器进行参数处理，只需要了解这种差异就行了。有一种方法可以编写 Spring AOP 和 AspectJ 100％ 兼容的切面，这在下面的通知参数部分讨论。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Around</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.ProceedingJoinPoint</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AroundExample</span> {

        <span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">Object</span> doBasicProfiling(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// start stopwatch</span>
                <span class="predefined-type">Object</span> retVal = pjp.proceed();
                <span class="comment">// stop stopwatch</span>
                <span class="keyword">return</span> retVal;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>环绕通知返回的值将是此方法调用者看到的返回值。例如，一个简单的缓存切面可以从一个缓存中返回一个值，如果它存在;如果不存在，则调用 proceed()。 注意，proceed 可能会一次，多次调用或根本没有在环绕通知中出现，所有这些都是合法的。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params"><a class="anchor" href="#aop-ataspectj-advice-params"></a>通知参数</h5>
<div class="paragraph">
<p>Spring 提供全类型通知—— 意思就是你只需在通知签名（正如我们在之前看到的 returning 和 throwing 的例子）中声明你需要的参数而不是一直与 <code>Object[]</code> 数组打交道。后面我们会看到如何是的参数和其他上下文值在通知中可用。首先我们来看看如何编写通用通知，通用通知可以找出目前哪些方法正在被通知。</p>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-the-joinpoint"><a class="anchor" href="#aop-ataspectj-advice-params-the-joinpoint"></a>访问当前连接点</h6>
<div class="paragraph">
<p>任何通知方法都可能将 <code>org.aspectj.lang.JoinPoint</code> 类型声明为第一个参数（请注意，环绕通知要求其第一个参数必须是 <code>ProceedingJoinPoint</code> 类型，<code>JoinPoint</code> 的子类。<code>JoinPoint</code> 接口提供了很多有用的方法如 <code>getArgs()</code>（返回方法参数），<code>getThis()</code>（返回代理对象），<code>getTarget()</code>（返回目标对象），<code>getSignature()</code>（返回被通知方法的描述）和 <code>toString()</code>（打印被通知方法的有用描述））全部细节请参见 javadoc。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-passing"><a class="anchor" href="#aop-ataspectj-advice-params-passing"></a>向通知传递参数</h6>
<div class="paragraph">
<p>我们已经知道如何绑定返回的值或异常值（在返回通知和异常通知）。要使参数值在通知主体内可用，可以使用 <code>args</code> 的绑定形式。如果在 args 表达式中使用参数名称代替类型名称，则在调用通知时，相应参数的值将作为参数值传递。 举个例子会更清楚。假设你想通知第一个参数为 Account 对象的 dao 操作，并且你需要访问通知主体中的 account。 你可以按如下方式编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> validateAccount(Account account) {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>切点表达式的 <code>args(account,..)</code> 部分有两个目的：首先，它将匹配限制为那些至少需要一个参数的方法执行，并且传递给该形参的实参是一个 <code>Account</code> 实例; 其次，它通过 <code>account</code> 形参使实际的 <code>Account</code> 对象可用于通知。</p>
</div>
<div class="paragraph">
<p>
  另一种编写方法是声明一个切点，当它匹配一个连接点时“提供”  <code>Account</code> 对象的值，然后在通知中引用指定的切点。看起来如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> accountDataAccessOperation(Account account) {}

<span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDataAccessOperation(account)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> validateAccount(Account account) {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次提醒有兴趣的读者参考“AspectJ 编程指南”了解更多细节。</p>
</div>
<div class="paragraph">
<p>代理对象（<code>this</code>），目标对象（<code>target</code>）和注解（<code>@within,
  @target, @annotation, @args</code>）都可以以类似的方式绑定。以下示例展示了如何匹配使用 <code>@Auditable</code> 注解的方法执行，并提取 audit 代码。</p>
</div>
<div class="paragraph">
<p>首先，<code>@Auditable</code> 注解的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.METHOD)
<span class="directive">public</span> <span class="annotation">@interface</span> Auditable {
        AuditCode value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后与 <code>@Auditable</code> 方法执行匹配的通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(Auditable auditable) {
        AuditCode code = auditable.value();
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-generics"><a class="anchor" href="#aop-ataspectj-advice-params-generics"></a>通知参数和泛型</h6>
<div class="paragraph">
<p>Spring AOP 可以处理在类声明和方法参数中使用的泛型。假设你有一个泛型如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Sample</span>&lt;T&gt; {
        <span class="type">void</span> sampleGenericMethod(T param);
        <span class="type">void</span> sampleGenericCollectionMethod(<span class="predefined-type">Collection</span>&lt;T&gt; param);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过将通知参数设置为你想要拦截的方法的参数类型，而将对方法类型的拦截限制为某些特定参数类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> beforeSampleMethod(MyType param) {
        <span class="comment">// Advice implementation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据我们上面的讨论这是很明显这是有效的。但是，值得指出的是，这对于通用集合来说不起作用。所以你不能像定义这样一个切点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> beforeSampleMethod(<span class="predefined-type">Collection</span>&lt;MyType&gt; param) {
        <span class="comment">// Advice implementation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使这个设置有效，我们将不得不检查集合中的每一个元素，这是不合理的，因为我们也不能决定如何处理 <code>null</code> 值。为了实现类似于此的操作，您必须将参数键入 <code>Collection&lt;?&gt;</code> 并手动检查元素的类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-names"><a class="anchor" href="#aop-ataspectj-advice-params-names"></a>确定参数名</h6>
<div class="paragraph">
<p>通知调用中的参数绑定依赖于在切点表达式中使用的匹配名称，匹配名称用于在（通知和切点）方法签名中的声明参数名称。参数名不能通过 Java 反射来使用，所以 Spring AOP 使用以下策略来确定参数名称：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果用户明确指定了参数名，则使用指定的参数名：通知和切点注解都具有可选的“argNames”属性，可用于指定注解方法的参数名 - 这些参数名称在运行时可用。例如：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)</span><span class="delimiter">&quot;</span></span>,
                argNames=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean,auditable</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(<span class="predefined-type">Object</span> bean, Auditable auditable) {
        AuditCode code = auditable.value();
        <span class="comment">// ... use code and bean</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果第一个参数是 <code>JoinPoint</code>，<code>ProceedingJoinPoint</code>，或者 <code>JoinPoint.StaticPart</code> 类型，则可以从“argNames”属性的值中省略之。例如，如果修改前面的通知以接收连接点对象，则“argNames”属性不需要包含它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)</span><span class="delimiter">&quot;</span></span>,
                argNames=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean,auditable</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(JoinPoint jp, <span class="predefined-type">Object</span> bean, Auditable auditable) {
        AuditCode code = auditable.value();
        <span class="comment">// ... use code, bean, and jp</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于那些不需要收集任何连接点上下文信息的通知来说，对给定的参数类型为 <code>JoinPoint</code>，<code>ProceedingJoinPoint</code>，或者 <code>JoinPoint.StaticPart</code> 的第一个参数的特殊处理很方便的。在这种情况下，您只需省略“argNames”属性即可。例如，以下通知不需要声明“argNames”属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod()</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(JoinPoint jp) {
        <span class="comment">// ... use jp</span>
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>'argNames'</code> 属性有点笨拙，所以如果没有指定 <code>'argNames'</code> 属性，那么Spring AOP 将查看类的调试信息，并尝试从局部变量表中确定参数名称。只要这些类编译的时候带有调试信息（至少需要 <code>'-g:vars'</code>），这些信息就会呈现。用这个标记编译的结果是：（1）你的代码会更容易理解一点（反向工程），（2）类文件会稍微大一些（通常这是无关紧要的），（3）对未使用的本地变量会被删除的优化将不会被编译器应用。换句话说，用这个标记构建不会有任何困难。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果 AspectJ 编译器在没有调试信息的情况下（ajc）编译了 @AspectJ 切面，也不需要添加argNames属性，因为编译器会保留所需的信息。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>如果代码已经被编译且没有携带必要的调试信息，那么 Spring AOP 会尝试推断绑定变量与参数的配对（例如，如果在切点表达式中只绑定了一个变量，并且通知方法只有一个参数， 默认配对是很明显的！）。如果给定可用的信息对于变量的绑定有歧义，那么就会抛出一个 <code>AmbiguousBindingException</code> 异常。</p>
</li>
<li>
<p>如果上述所有的策略都失败了，那么 <code>IllegalArgumentException</code> 将被抛出。</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-proceeding-with-the-call"><a class="anchor" href="#aop-ataspectj-advice-proceeding-with-the-call"></a>实参处理</h6>
<div class="paragraph">
<p>我们之前提过，我们将描述如何利用可以在 Spring AOP 和 AspectJ 一致使用的参数来编写 proceed 调用。解决方案是只要确保通知签名按顺序绑定每个方法参数即可。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(List&lt;Account&gt; find*(..)) &amp;&amp; </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">args(accountHolderNamePattern)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">Object</span> preProcessQueryPattern(ProceedingJoinPoint pjp,
                <span class="predefined-type">String</span> accountHolderNamePattern) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
        <span class="predefined-type">String</span> newPattern = preProcess(accountHolderNamePattern);
        <span class="keyword">return</span> pjp.proceed(<span class="keyword">new</span> <span class="predefined-type">Object</span><span class="type">[]</span> {newPattern});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在许多情况下，你都会做这个绑定（如上面的例子）。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-ordering"><a class="anchor" href="#aop-ataspectj-advice-ordering"></a>通知顺序</h5>
<div class="paragraph">
<p>
  当多个通知都想在同一个连接点上执行时会发生什么？ Spring AOP 遵循与 AspectJ 相同的优先规则来确定通知执行的顺序。在切面从连接点到通知的执行进入过程中，最高优先级的通知首先执行“on the way in”（因此对于给定的两个前置通知，优先级高的通知先执行）。在切面从通知到连接点执行退出的过程中，优先级最高的通知最后运行“on the way out”（因此对于给定的两个后置通知，优先级高的通知后执行）。</p>
</div>
<div class="paragraph">
<p>当在不同切面定义的两个通知都需要在同一个连接点上执行时，除非你指定了否则执行的顺序是未定义的。您可以通过指定优先级来控制执行顺序。这是通过在切面类中实现 <code>org.springframework.core.Ordered</code> 接口或使用 <code>Order</code> 注解对其进行注解以正常的 Spring 方式完成的。给定两个切面，从 <code>Ordered.getValue()</code> 或注解值）返回较低值的切面具有较高的优先级。</p>
</div>
<div class="paragraph">
<p>当在同一切面定义的两个通知都需要在同一个连接点上执行时，执行顺势是未定义的（因为没有办法通过反射为 javac 编译的类检索声明顺序）。考虑将这些通知方法分解成每个切面类中的每个连接点的一个通知方法，或者将多个通知重构成单独的切面类 - 可以在切面级别进行排序。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-introductions"><a class="anchor" href="#aop-introductions"></a>5.2.5. 引入</h4>
<div class="paragraph">
<p>引入（在 AspectJ 中称为类型间声明）使得一个切面能够声明被通知对象实现给定的接口，并且代表这些对象提供该接口的实现。</p>
</div>
<div class="paragraph">
<p>引入使用 <code>@DeclareParents</code> 注解实现。这个注解用来声明匹配的类型有一个新的父类（因此名字）。 例如，给定一个接口 <code>UsageTracked</code> 和这个接口的实现 <code>DefaultUsageTracked</code>，下面的切面声明了所有服务接口的实现者也实现了 <code>UsageTracked</code> 接口。（例如，为了通过 JMX 公开统计信息。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">UsageTracking</span> {

        <span class="annotation">@DeclareParents</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xzy.myapp.service.*+</span><span class="delimiter">&quot;</span></span>, defaultImpl=DefaultUsageTracked.class)
        <span class="directive">public</span> <span class="directive">static</span> UsageTracked mixin;

        <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> recordUsage(UsageTracked usageTracked) {
                usageTracked.incrementUseCount();
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要实现哪个接口由注解字段的类型决定。<code>@DeclareParents</code> 注解的 <code>value</code> 属性是一个AspectJ 类型模式：- 匹配类型的任何 bean 都将实现 UsageTracked 接口。注意，在上述示例的前置通知中，serivce bean 可以直接作为 <code>UsageTracked</code> 接口的实现使用。如果以编程方式访问这个 bean，你可以编写如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-instantiation-models"><a class="anchor" href="#aop-instantiation-models"></a>5.2.6. 切面实例化模型</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>（这是一个高级主题，所以如果你刚开始使用 AOP，你可以选择跳过以后再读。）</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，应用程序上下文中将存在每个切面的单例实例。AspectJ 把这个模型称为单例实例化模型。 可以使用不同的生命周期定义切面：Spring 支持 AspectJ 的 <code>perthis</code> 和 <code>pertarget</code> 实例化模型（<code>percflow, percflowbelow,</code> 和 <code>pertypewithin</code> 目前不支持）。</p>
</div>
<div class="paragraph">
<p>“perthis”切面通过在 <code>@Aspect</code> 注解中指定 <code>perthis</code> 子句来声明。我们来看一个例子，然后我们将解释它是如何运行的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">perthis(com.xyz.myapp.SystemArchitecture.businessService())</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyAspect</span> {

        <span class="directive">private</span> <span class="type">int</span> someState;

        <span class="annotation">@Before</span>(com.xyz.myapp.SystemArchitecture.businessService())
        <span class="directive">public</span> <span class="type">void</span> recordServiceUsage() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>'perthis'</code> 子句的效果是，每个唯一的 service 对象执行 businessService 时，这个切面对象就会被创建（每个唯一对象都会跟与切点表达式匹配的接入点‘this’ 绑定）。切面实例是在 service 对象首次调用方法时创建的。当 service 对象处在作用域之外时，切面也会在作用域之外（ The aspect goes
  out of scope when the service object goes out of scope？how to understand this）。在创建 切面实例被创建之前，其中的任何通知都不会执行。一旦切面实例被创建，其中声明的通知将在连接点被匹配的时候执行，但前提条件是 service 对象是与此切面实例相关联的那个对象。有关每个子句的更多信息，请参阅 “AspectJ编程指南”。</p>
</div>
<div class="paragraph">
<p><code>'pertarget'</code> 实例化模型的执行方式与 perthis 完全相同，只是为在匹配连接点处的每个唯一目标对象创建一个切面实例。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-example"><a class="anchor" href="#aop-ataspectj-example"></a>5.2.7. 示例</h4>
<div class="paragraph">
<p>现在你已经看到所有组成部分是如何工作的，让我们把它们放在一起做一些有用的事情！</p>
</div>
<div class="paragraph">
<p>business service 的执行有时会由于并发问题而失败（例如死锁失败）。如果操作重新执行，下一次很有可能成功。 对于适合在这种情况下重试的 business service（不需要返回给用户进行冲突解决的幂等操作），我们希望透明地重试操作以避免客户端看到 <code>PessimisticLockingFailureException</code>。很明显这是一个在服务层中跨越多个 service 的需求，因此非常适合通过某个切面实现。</p>
</div>
<div class="paragraph">
<p>因为我们想重试操作，所以我们需要使用环绕通知，以便我们可以多次调用。以下是基本切面实现的的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConcurrentOperationExecutor</span> <span class="directive">implements</span> Ordered {

        <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> DEFAULT_MAX_RETRIES = <span class="integer">2</span>;

        <span class="directive">private</span> <span class="type">int</span> maxRetries = DEFAULT_MAX_RETRIES;
        <span class="directive">private</span> <span class="type">int</span> order = <span class="integer">1</span>;

        <span class="directive">public</span> <span class="type">void</span> setMaxRetries(<span class="type">int</span> maxRetries) {
                <span class="local-variable">this</span>.maxRetries = maxRetries;
        }

        <span class="directive">public</span> <span class="type">int</span> getOrder() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.order;
        }

        <span class="directive">public</span> <span class="type">void</span> setOrder(<span class="type">int</span> order) {
                <span class="local-variable">this</span>.order = order;
        }

        <span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="type">int</span> numAttempts = <span class="integer">0</span>;
                PessimisticLockingFailureException lockFailureException;
                <span class="keyword">do</span> {
                        numAttempts++;
                        <span class="keyword">try</span> {
                                <span class="keyword">return</span> pjp.proceed();
                        }
                        <span class="keyword">catch</span>(PessimisticLockingFailureException ex) {
                                lockFailureException = ex;
                        }
                } <span class="keyword">while</span>(numAttempts &lt;= <span class="local-variable">this</span>.maxRetries);
                <span class="keyword">throw</span> lockFailureException;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，该切面实现了 <code>Ordered</code> 接口，因此我们可以将其优先级设置高于事务通知（每次我们重试时都希望有一个新事务）。 <code>maxRetries</code> 和<code>order</code> 属性都将由 Spring 配置。主要的操作发生在 <code>doConcurrentOperation</code> 环绕通知方法。注意，目前我们正在将重试逻辑应用于所有 <code>businessService()</code>。我们试着 proceed，如果因为 <code>PessimisticLockingFailureException</code> 异常而失败了，只需要再试一次，除非已经耗尽了所有的重试次数。</p>
</div>
<div class="paragraph">
<p>对应的 Spring 配置是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy</span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationExecutor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.impl.ConcurrentOperationExecutor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxRetries</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了改进切面使其只重试幂等运算，我们可以定义一个 <code>Idempotent</code> 幂等注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Idempotent {
        <span class="comment">// marker annotation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并将此注解用于 service 操作的实现。将切面修改为只重试幂等操作只涉及改进切点表达式，使得只有 <code>@Idempotent</code> 操作匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">@annotation(com.xyz.myapp.service.Idempotent)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
        ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema"><a class="anchor" href="#aop-schema"></a>5.3. 基于 Schema 的 AOP 支持</h3>
<div class="paragraph">
<p>如果您更喜欢基于 XML 格式配置，那么 Spring 还提供了使用新的 “aop” 命名空间标签来支持定义切面。 使用 @AspectJ 风格，支持完全相同的切入点表达式和通知类型，因此在本节中，我们将重点介绍新的语法，并请读者参考前一节（<a href="#aop-ataspectj">@AspectJ 支持</a>）中的讨论，以便理解编写切点表达式和通知参数的绑定。</p>
</div>
<div class="paragraph">
<p>要使用本节中描述的 aop 命名空间标签，你需要按照 <a href="appendix.html#xsd-configuration">基于 XML schema 的配置</a> 中所述导入 <code>spring-aop</code> 模式。 参阅<a href="appendix.html#xsd-config-body-schemas-aop">AOP schema</a> 以了解如何在 <code>aop</code> 命名空间中导入标签。</p>
</div>
<div class="paragraph">
<p>在你的 Spring 配置中，所有的切面和通知元素都必须放置在 <code>&lt;aop:config&gt;</code>元素中（应用程序上下文配置中可以有多个 <code>&lt;aop:config&gt;</code> 元素）。 一个 <code>&lt;aop:config&gt;</code> 元素可以包含 pointcut，advisor 和 aspect 元素（注意这些元素必须按照这个顺序声明）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 的 <a href="#aop-autoproxy">auto-proxying</a> 机制大量使用 <code>&lt;aop:config&gt;</code> 风格的配置。如果你已经通过使用 <code>BeanNameAutoProxyCreator</code> 或类似的方式使用显式的自动代理，这可能会导致某些问题（如通知没有被织入）。推荐的使用模式是要么只使用 <code>&lt;aop:config&gt;</code> 风格，要么只使用 <code>AutoProxyCreator</code> 样式。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-schema-declaring-an-aspect"><a class="anchor" href="#aop-schema-declaring-an-aspect"></a>5.3.1. 声明切面</h4>
<div class="paragraph">
<p>有了 schema 的支持，切面就只是在 Spring 应用程序上下文中定义的一个普通的 Java 对象。状态和行为会在对象的字段和方法中被捕获，切点和通知信息会在 XML 中被捕获。</p>
</div>
<div class="paragraph">
<p>切面用 &lt;aop:aspect&gt; 元素声明，辅助的 bean 用 <code>ref</code> 特性实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>
        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                ...
        <span class="tag">&lt;/aop:aspect&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        ...
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>辅助切面的 bean （本例中是“aBean”）当然也可以像其他 Spring bean 一样被配置和被依赖注入。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-pointcuts"><a class="anchor" href="#aop-schema-pointcuts"></a>5.3.2. 声明切点</h4>
<div class="paragraph">
<p>一个命名的切点可以在 &lt;aop:config&gt; 元素中声明，使切点定义可以被多个切面和通知共享。</p>
</div>
<div class="paragraph">
<p>代表 service 层中任何 business service 的执行的切点可以定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意切点表达式本身正在使用 <a href="#aop-ataspectj">@AspectJ 支持</a> 中描述的相同的 AspectJ 切点表达式语言。如果使用基于 schema 的声明风格，则可以引用在切点表达式中的类型（@Aspects）中定义的命名切点。 定义上述切点的另一种方法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>假设你有一个如 <a href="#aop-common-pointcuts">共享通用切点定义</a> 中描述的 <code>SystemArchitecture</code> 切面。</p>
</div>
<div class="paragraph">
<p>在切面中定义切点与定义顶级切点非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                ...

        <span class="tag">&lt;/aop:aspect&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与 @AspectJ 切面大致相同，使用基于 shema 定义风格声明的切点可以收集连接点上下文。例如，下面的切点将“this”对象作为连接点上下文并将其传递给通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..)) </span><span class="entity">&amp;amp;</span><span class="entity">&amp;amp;</span> <span class="content">this(service)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;aop:before</span> <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">monitor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                ...

        <span class="tag">&lt;/aop:aspect&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通知必须通过包含匹配名字的参数声明来接收收集到的连接点上下文： </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> monitor(<span class="predefined-type">Object</span> service) {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当合并切点的子表达式时，在 XML 文档中使用 ‘&&’ 是很笨拙的，所以关键字‘and’，‘or’，‘not’可以分别用来代替‘&&’，‘||’ 和‘!’。例如，前面这个切点写成如下形式可能更好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..)) **and** this(service)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;aop:before</span> <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">monitor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                ...
        <span class="tag">&lt;/aop:aspect&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，以这种方式定义的切点由其 XML id 引用，不能用作命名切点来组成复合切点。因此，基于 schema 的定义风格中的命名切点支持比 @AspectJ 风格提供的支持更有限。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice"><a class="anchor" href="#aop-schema-advice"></a>5.3.3. 声明通知</h4>
<div class="paragraph">
<p>五种相同类型的通知也像 @AspectJ 风格中一样被支持，且它们具有完全相同的语义。</p>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-before"><a class="anchor" href="#aop-schema-advice-before"></a>前置通知</h5>
<div class="paragraph">
<p>前置通知在方法执行之前运行。它在 <code>&lt;aop:aspect&gt;</code> 中使用 &lt;aop:before&gt; 元素声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beforeExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:before</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>dataAccessOperation</code> 是定义在顶层的切点 id（<code>&lt;aop:config&gt;</code>）。要定义内联切点，请用 <code>pointcut</code> 特性替换 <code>pointcut-ref</code> 特性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beforeExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:before</span>
                <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.dao.*.*(..))</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们在讨论 @AspectJ 风格时所指出的那样，使用命名切点可以显着提高代码的可读性。</p>
</div>
<div class="paragraph">
<p>method 特性标识了提供通知主体的方法（doAccessCheck）。必须为包含通知的 aspect 元素所引用的 bean 定义此方法。在执行数据访问操作（由切点表达式匹配的方法执行连接点）之前，切面 bean 上的 “doAccessCheck” 方法将被调用。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-returning"><a class="anchor" href="#aop-schema-advice-after-returning"></a>返回通知</h5>
<div class="paragraph">
<p>返回通知在一个匹配方法执行正常返回时执行。它在 <code>&lt;aop:aspect&gt;</code> 中定义，与前置通知的定义方式一致。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterReturningExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-returning</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>就像在 @AspectJ 风格里阐述的，你可以在通知主体内获得返回值。使用 returning 特性来指定应传递给的参数的返回值名字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterReturningExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-returning</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">returning</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">retVal</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>doAccessCheck 方法必须声明一个名为 <code>retVal</code> 参数。这个参数会和 @AfterReturning 一样对参数类型进行约束匹配，方法签名声明如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> doAccessCheck(<span class="predefined-type">Object</span> retVal) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-throwing"><a class="anchor" href="#aop-schema-advice-after-throwing"></a>异常通知</h5>
<div class="paragraph">
<p>异常通知在匹配方法执行以异常方式退出的时候执行。它在 <code>&lt;aop:aspect&gt;</code> 中使用 after-throwing 元素声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterThrowingExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-throwing</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doRecoveryActions</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>就像在 @AspectJ 风格中一样，可以在通知主体中获取抛出的异常。使用 throwing 特性指定参数名，异常会被传递到这个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterThrowingExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-throwing</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">throwing</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessEx</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doRecoveryActions</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>doRecoveryActions 方法必须声明一个名为 <code>dataAccessEx</code> 参数。这个参数会和 @AfterThrowing 一样对参数类型进行约束匹配，方法签名声明如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> doRecoveryActions(DataAccessException dataAccessEx) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-finally"><a class="anchor" href="#aop-schema-advice-after-finally"></a>后置 (finally) 声明</h5>
<div class="paragraph">
<p>后置（finally）通知在匹配的方法执行退出后执行。它使用 <code>after</code> 元素定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterFinallyExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doReleaseLock</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-around"><a class="anchor" href="#aop-schema-advice-around"></a>环绕通知</h5>
<div class="paragraph">
<p>最后一种类型的通知是环绕通知。环绕通知“环绕”匹配的方法执行。它可以在方法执行之前和之后进行工作，并确定方法实际上何时，如何甚至是何时执行。如果您需要以线程安全的方式（例如启动和停止计时器）在方法执行之前和之后共享状态，则通常会使用“围绕”通知。总是使用符合你要求的功能最少的通知（即在如果简单的前置通知就能完成就不要使用环绕通知）.</p>
</div>
<div class="paragraph">
<p>环绕通知使用 <code>aop:around</code> 元素来声明。通知方法的第一个参数必须是 <code>ProceedingJoinPoint</code> 类型。在通知的主体中，在 <code>ProceedingJoinPoint</code> 上调用 <code>proceed()</code> 会似的底层方法执行。 <code>proceed</code> 方法也可以通过传递 <code>Object[]</code> 调用-数组的值将会被当作参数在方法执行时继续使用。有关调用带有<code>Object[]</code> 的 proceed 的要点，参见 <a href="#aop-ataspectj-around-advice">环绕通知</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aroundExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:around</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doBasicProfiling</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>doBasicProfiling</code> 通知的实现与 @AspectJ 例子中的完全一致 （当然除去注解）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Object</span> doBasicProfiling(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
        <span class="comment">// start stopwatch</span>
        <span class="predefined-type">Object</span> retVal = pjp.proceed();
        <span class="comment">// stop stopwatch</span>
        <span class="keyword">return</span> retVal;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-params"><a class="anchor" href="#aop-schema-params"></a>通知参数</h5>
<div class="paragraph">
<p>基于 schema 的声明风格支持全类型的通知，与 @AspectJ 支持中的描述的方法一样 —— 通过匹配切点参数名和通知方法参数名实现。 细节参见 <a href="#aop-ataspectj-advice-params">通知参数</a>。如果你希望为通知方法显式指定实参名（而不是依赖之前描述的检测策略）那么这可以用 advice 元素的 <code>arg-names</code> 实现，这与在 <a href="#aop-ataspectj-advice-params-names">确定实参名</a> 中所描述的对通知注解中的“argNames” 处理方式一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:before</span>
        <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">audit</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">arg-names</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">auditable</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>arg-names</code> 特性接受一个由逗号分隔的形参名列表。</p>
</div>
<div class="paragraph">
<p>下面是一个基于 XSD 的方法的示例，该示例演示了与一些强类型参数结合使用的一些环绕通知。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">x.y.service</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">FooService</span> {

        Foo getFoo(<span class="predefined-type">String</span> fooName, <span class="type">int</span> age);
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultFooService</span> <span class="directive">implements</span> FooService {

        <span class="directive">public</span> Foo getFoo(<span class="predefined-type">String</span> name, <span class="type">int</span> age) {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo(name, age);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是切面。注意  <code>profile(..)</code> 方法接受一些强类型参数的事实，第一个参数是用来执行 proceed 方法调用的连接点：这个参数的出现暗示了 <code>profile(..)</code> 会被当做环绕通知使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">x.y</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang.ProceedingJoinPoint</span>;
<span class="keyword">import</span> <span class="include">org.springframework.util.StopWatch</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleProfiler</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> profile(ProceedingJoinPoint call, <span class="predefined-type">String</span> name, <span class="type">int</span> age) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                StopWatch clock = <span class="keyword">new</span> StopWatch(<span class="string"><span class="delimiter">&quot;</span><span class="content">Profiling for '</span><span class="delimiter">&quot;</span></span> + name + <span class="string"><span class="delimiter">&quot;</span><span class="content">' and '</span><span class="delimiter">&quot;</span></span> + age + <span class="string"><span class="delimiter">&quot;</span><span class="content">'</span><span class="delimiter">&quot;</span></span>);
                <span class="keyword">try</span> {
                        clock.start(call.toShortString());
                        <span class="keyword">return</span> call.proceed();
                } <span class="keyword">finally</span> {
                        clock.stop();
                        <span class="predefined-type">System</span>.out.println(clock.prettyPrint());
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，这里的 XML 配置为特定连接点配置了上述影响其执行的通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fooService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.service.DefaultFooService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- this is the actual advice itself --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profiler</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.SimpleProfiler</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;aop:config&gt;</span>
                <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profiler</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theExecutionOfSomeFooServiceMethod</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* x.y.service.FooService.getFoo(String,int))</span>
                                <span class="content">and args(name, age)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                        <span class="tag">&lt;aop:around</span> <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theExecutionOfSomeFooServiceMethod</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profile</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;/aop:aspect&gt;</span>
        <span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们有以下驱动脚本，我们可以在标准输出上得到一些信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.beans.factory.BeanFactory</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;
<span class="keyword">import</span> <span class="include">x.y.service.FooService</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                BeanFactory ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">x/y/plain.xml</span><span class="delimiter">&quot;</span></span>);
                FooService foo = (FooService) ctx.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">fooService</span><span class="delimiter">&quot;</span></span>);
                foo.getFoo(<span class="string"><span class="delimiter">&quot;</span><span class="content">Pengo</span><span class="delimiter">&quot;</span></span>, <span class="integer">12</span>);
        }
}</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ordering"><a class="anchor" href="#aop-ordering"></a>通知顺序</h5>
<div class="paragraph">
<p>当多个通知都想在同一个连接点上执行时（执行方法）执行顺序规则在 <a href="#aop-ataspectj-advice-ordering">通知顺序</a> 中已经给出。切面之间的优先级是由在切面的辅助 bean 中添加 <code>Order</code> 注解或者实现 <code>Ordered</code> 接口实现的。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-introductions"><a class="anchor" href="#aop-schema-introductions"></a>5.3.4. 引入</h4>
<div class="paragraph">
  <p>引入（在 AspectJ 中称为类型间声明）使得一个切面能够声明被通知对象实现给定的接口，并且代表这些对象提供该接口的实现。</p>
</div>
<div class="paragraph">
<p>引入由 <code>aop:aspect</code> 元素中的 <code>aop:declare-parents</code> 元素实现。这个注解用来声明匹配的类型有一个新的父类（因此名字）。例如，给定一个接口 <code>UsageTracked</code> 和这个接口的实现 <code>DefaultUsageTracked</code>，下面的切面声明了所有服务接口的实现者也实现了 <code>UsageTracked</code> 接口。（例如，为了通过 JMX 公开统计信息。）</p>
</div>

<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">usageTrackerAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">usageTracking</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:declare-parents</span>
                <span class="attribute-name">types-matching</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xzy.myapp.service.*+</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">implement-interface</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.tracking.UsageTracked</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">default-impl</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.tracking.DefaultUsageTracked</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;aop:before</span>
                <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span>
                        <span class="content">and this(usageTracked)</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">recordUsage</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p> <code>usageTracking</code> bean 的辅助 bean 会包含这个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> recordUsage(UsageTracked usageTracked) {
        usageTracked.incrementUseCount();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要实现哪个接口由 <code>implement-interface</code> 特性决定。<code>types-matching</code> 特性的值是一个 AspectJ 类型模式：- 匹配类型的任何 bean 都将实现 UsageTracked 接口。注意，在上述示例的前置通知中，serivce bean 可以直接作为 UsageTracked 接口的实现使用。如果以编程方式访问这个 bean，你可以编写如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-instatiation-models"><a class="anchor" href="#aop-schema-instatiation-models"></a>5.3.5. 切面实例化模型</h4>
<div class="paragraph">
<p>单例模型是唯一支持基于 schema 定义的切面的实例化模型。其他实例化模型可能在未来版本中得到支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advisors"><a class="anchor" href="#aop-schema-advisors"></a>5.3.6. 通知</h4>
<div class="paragraph">
<p>“通知”这个概念是由 Spring 1.2 定义的 AOP 支持提出的，在 AspectJ 中没有直接的等价的概念。通知就像是一个小小的独立的切面，有一个唯一的通知。通知本身由一个 bean 表示，并且必须实现 <a href="#aop-api-advice-types">Spring中的通知类型</a> 中描述的接口之一。 通知可以使用 AspectJ 切点表达式。</p>
</div>
<div class="paragraph">
<p>Spring 使用 <code>&lt;aop:advisor&gt;</code> 元素来支持通知这个概念。最常见的情况是将它与事务通知结合使用，在 Spring 中它也有自己的命名空间支持。以下是它的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;aop:advisor</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">advice-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;tx:advice</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;tx:attributes&gt;</span>
                <span class="tag">&lt;tx:method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">propagation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">REQUIRED</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/tx:attributes&gt;</span>
<span class="tag">&lt;/tx:advice&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了上面例子中使用的 <code>pointcut-ref</code> 特性外，还可以使用 <code>pointcut</code> 特性来定义内联的切点表达式。</p>
</div>
<div class="paragraph">
<p>要定义通知的优先级以便通知可以参与排序，请使用 <code>order</code> 特性来定义通知的  <code>Ordered</code> 值。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-example"><a class="anchor" href="#aop-schema-example"></a>5.3.7. 示例</h4>
<div class="paragraph">
<p>我们看看当我们用 schema 支持重写 <a href="#aop-ataspectj-example">示例</a> 中的并发锁失败重试例子是，它是怎么样的。/p>
</div>
<div class="paragraph">
<p>business service 的执行有时会由于并发问题而失败（例如死锁失败）。如果操作重新执行，下一次很有可能成功。 对于适合在这种情况下重试的 business service（不需要返回给用户进行冲突解决的幂等操作），我们希望透明地重试操作以避免客户端看到 <code>PessimisticLockingFailureException</code>。很明显这是一个在服务层中跨越多个 service 的需求，因此非常适合通过某个切面实现。</p>
</div>
<div class="paragraph">
<p>因为我们想重试操作，所以我们需要使用环绕通知，以便我们可以多次调用。以下是基本切面实现的的样子（它只是使用 schema 支持的常规 Java 类）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ConcurrentOperationExecutor</span> <span class="directive">implements</span> Ordered {

        <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> DEFAULT_MAX_RETRIES = <span class="integer">2</span>;

        <span class="directive">private</span> <span class="type">int</span> maxRetries = DEFAULT_MAX_RETRIES;
        <span class="directive">private</span> <span class="type">int</span> order = <span class="integer">1</span>;

        <span class="directive">public</span> <span class="type">void</span> setMaxRetries(<span class="type">int</span> maxRetries) {
                <span class="local-variable">this</span>.maxRetries = maxRetries;
        }

        <span class="directive">public</span> <span class="type">int</span> getOrder() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.order;
        }

        <span class="directive">public</span> <span class="type">void</span> setOrder(<span class="type">int</span> order) {
                <span class="local-variable">this</span>.order = order;
        }

        <span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="type">int</span> numAttempts = <span class="integer">0</span>;
                PessimisticLockingFailureException lockFailureException;
                <span class="keyword">do</span> {
                        numAttempts++;
                        <span class="keyword">try</span> {
                                <span class="keyword">return</span> pjp.proceed();
                        }
                        <span class="keyword">catch</span>(PessimisticLockingFailureException ex) {
                                lockFailureException = ex;
                        }
                } <span class="keyword">while</span>(numAttempts &lt;= <span class="local-variable">this</span>.maxRetries);
                <span class="keyword">throw</span> lockFailureException;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，该切面实现了 <code>Ordered</code> 接口，因此我们可以将其优先级设置高于事务通知（每次我们重试时都希望有一个新事务）。<code>maxRetries</code> 和<code>order</code> 属性都将由 Spring 配置。主要的操作发生在 <code>doConcurrentOperation</code> 环绕通知方法。注意，目前我们正在将重试逻辑应用于所有 <code>businessService()</code>。我们试着 proceed，如果因为 <code>PessimisticLockingFailureException</code> 异常而失败了，只需要再试一次，除非已经耗尽了所有的重试次数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该类与 @AspectJ 示例中使用的类相同，但注解已经去除了。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对应的 Spring 配置是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationRetry</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationExecutor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">idempotentOperation</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;aop:around</span>
                        <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">idempotentOperation</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doConcurrentOperation</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;/aop:aspect&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationExecutor</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.impl.ConcurrentOperationExecutor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxRetries</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意目前我们假设所有的 business service 都是幂等的。如果不是这种情况，为了改进切面使其只重试幂等运算，我们可以定义一个 <code>Idempotent</code> 幂等注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Idempotent {
        <span class="comment">// marker annotation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并将此注解用于 service 操作的实现。将切面修改为只重试幂等操作只涉及改进切点表达式，使得只有 <code>@Idempotent</code> 操作匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">idempotentOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..)) and</span>
                <span class="content">@annotation(com.xyz.myapp.service.Idempotent)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-choosing"><a class="anchor" href="#aop-choosing"></a>5.4. 选择使用哪种 AOP 声明风格</h3>
<div class="paragraph">
<p>一旦你确定某个切面是实现给定需求的最佳方法，那么如何在使用 Spring AOP 或 AspectJ 之间以及 Aspect 语言（代码）风格，@AspectJ 注解风格或 Spring XML 风格之间做出选择？这些决定受到许多因素的影响，包括应用的需求，开发工具和团队对 AOP 的熟悉程度。</p>
</div>
<div class="sect3">
<h4 id="aop-spring-or-aspectj"><a class="anchor" href="#aop-spring-or-aspectj"></a>5.4.1. Spring AOP 还是全面使用 AspectJ ？</h4>
<div class="paragraph">
<p>使用有效的最简单的东西。Spring AOP 比使用全面的 AspectJ 更简单，因为不需要将 AspectJ 编译器/织入器引入到开发和构建过程。如果你只需要通知在 Spring bean 上的执行操作，那么 Spring AOP 就是正确的选择。如果你需要通知没有被 Spring 容器管理的对象（比如域对象），那么你需要使用 AspectJ。如果你希望通知连接点而不是简单的方法执行（例如，字段 get 或 set 连接点等），也需要使用 AspectJ。</p>
</div>
<div class="paragraph">
<p>使用 AspectJ 时，你可以选择 AspectJ 语言语法（也称为“代码风格”）或 @AspectJ 注释风格。显然，如果你没有在使用Java 5+ 那么选择已经为你作出...使用代码风格。如果切面在你的设计中扮演重要角色，并且你可以使用Eclipse 的 <a href="https://www.eclipse.org/ajdt/">AspectJ 开发工具（AJDT）</a>插件，那么 AspectJ 语言语法是首选选项：它更清晰和更简单，因为这种语言是专门用于编写切面的。如果你没有使用 Eclipse，或者只有一些切面且它们在应用程序中不起主要作用，那么你可能需要考虑使用 @AspectJ 风格，并在 IDE 中使用常规的 Java 编译，并在你的构建脚本中添加一个切面织入期。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-or-xml"><a class="anchor" href="#aop-ataspectj-or-xml"></a>5.4.2. 对于 Spring AOP 使用 @AspectJ 还是 XML ?</h4>
<div class="paragraph">
<p>
  如果你已经选择使用 Spring AOP，则你还有个选择，使用 @AspectJ 还是 XML 风格。其中会出现各种折衷考虑。</p>
</div>
<div class="paragraph">
<p>现有的 Spring 用户最熟悉的是 XML 风格，它是由真正的 POJO 支持的。当使用 AOP 作为配置企业服务的工具时，XML 可能是一个不错的选择（一个好的测试就是你是否认为切点表达式是你可能想要独立更改的配置的一部分）。用XML 的风格可以说从你的配置中可以更清楚地看到系统中存在哪些切面。</p>
</div>
<div class="paragraph">
<p>XML 风格有两个缺点。首先，它并没有完全将其需求的实现封装在一个地方。DRY （dont repeat yourself）原则指出，对系统内的任何知识应该有一个单一的，明确的，权威的表示。当使用 XML 风格时，需求被实现的知识被分解为辅助 bean 类的声明和配置文件中的 XML。当使用 @AspectJ 风格时，只有一个模块 - 切面 - 其中封装了这些信息。其次，XML 风格比 @AspectJ 风格稍微有点局限：只支持“singleton”切面的实例化模型，不能组合使用 XML 声明的命名切点。例如，在 @AspectJ 风格，你可以写如下东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(execution(* get*()))
<span class="directive">public</span> <span class="type">void</span> propertyAccess() {}

<span class="annotation">@Pointcut</span>(execution(org.xyz.Account+ *(..))
<span class="directive">public</span> <span class="type">void</span> operationReturningAnAccount() {}

<span class="annotation">@Pointcut</span>(propertyAccess() &amp;&amp; operationReturningAnAccount())
<span class="directive">public</span> <span class="type">void</span> accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 XML 风格的配置中我可以声明前两个切点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">propertyAccess</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* get*())</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">operationReturningAnAccount</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(org.xyz.Account+ *(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>XML 方式的不利之处在于，你无法通过组合这些定义来定义 <code>accountPropertyAccess</code> 切点。</p>
</div>
<div class="paragraph">
<p>@AspectJ 风格支持其他的实例化模型，以及更丰富的切点组合。它具有将切面保持为模块化单元的优点。 它还具有以下优点：Spring AOP 和 AspectJ 都可以理解（并因此消费）@AspectJ 切面，所以如果你稍后决定需要AspectJ 的功能来实现附加要求，那么迁移到基于 AspectJ 方式也非常简单。总的来说，只要切面不仅仅只是简单的“配置”企业服务，Spring 团队就更喜欢使用 @AspectJ 风格。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-mixing-styles"><a class="anchor" href="#aop-mixing-styles"></a>5.5. 混合切面类型</h3>
<div class="paragraph">
<p>在同一个配置中混合使用自动代理支持的 @AspectJ 风格切面，schema 定义的 <code>&lt;aop:aspect&gt;</code> 切面，用 <code>&lt;aop:advisor&gt;</code> 声明的通知，甚至是 Spring 1.2 风格定义的代理和拦截器是完全有可能的。这些都是使用相同的支持机制来实现的，所以让它们共存毫无困难。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-proxying"><a class="anchor" href="#aop-proxying"></a>5.6. 代理机制</h3>
<div class="paragraph">
<p>Spring AOP 使用 JDK 动态代理或者 CGLIB 来为给定对象创建代理。（只要可以选择，JDK 动态代理就是首选）。</p>
</div>
<div class="paragraph">
<p>如果要被代理的目标对象实现了至少一个接口，则将对其使用 JDK 动态代理。所有由目标类型实现的接口都将被代理。如果目标对象没有实现任何接口，则将创建一个 CGLIB 代理。</p>
</div>
<div class="paragraph">
<p>如果你想强制使用 CGLIB 代理（例如，代理目标对象定义的每个方法，而不仅仅是代理由其接口实现的方法），则可以这样做。但是，有一些问题需要考虑：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>final</code> 方法不能被通知，因为他们不能被覆盖。</p>
</li>
<li>
<p>从 Spring 3.2 开始，不再需要将 CGLIB 添加到项目类路径中，因为 CGLIB 类在 org.springframework 下重新打包，并直接包含在 Spring-Core JAR 中。这意味着基于 CGLIB 的代理支持与 JDK 动态代理始终具有相同的工作方式。</p>
</li>
<li>
<p>从 Spring 4.0 开始，代理对象的构造器将不会被调用两次，因为 CGLIB 代理实例将通过 Objenesis 创建。只有当你的 JVM 不允许构造器绕过，你才可能会看到来自 Spring AOP 支持的双重调用和相应的调试日志条目。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要强制使用 CGLIB 代理，请将 <code>&lt;aop:config&gt;</code> 元素的 <code>proxy-target-class</code> 特性的值设置为 true：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config</span> <span class="attribute-name">proxy-target-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- other beans defined here... --&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在使用  @AspectJ 自动代理支持时强制使用 CGLIB 代理，请将 <code>&lt;aop:aspectj-autoproxy&gt;</code> 元素的 <code>'proxy-target-class'</code> 特性的值设置为 <code>true</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy</span> <span class="attribute-name">proxy-target-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>多个 <code>&lt;aop:config/&gt;</code> 片段在运行时会被集中统一到一个的自动代理创建器，该应用程序指定的任何 <code>&lt;aop:config/&gt;</code> 片段（通常来自不同的 XML bean 定义文件）应用最强的代理设置。 这也适用于 <code>&lt;tx:annotation-driven/&gt;</code> 和 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素。</p>
</div>
<div class="paragraph">
<p>明确一点：在 <code>&lt;tx:annotation-driven/&gt;</code>，<code>&lt;aop:aspectj-autoproxy/&gt;</code> 或 <code>&lt;aop:config/&gt;</code> 元素上使用 <code>proxy-target-class="true"</code> 将强制使用 CGLIB 来代理。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-understanding-aop-proxies"><a class="anchor" href="#aop-understanding-aop-proxies"></a>5.6.1. 理解 AOP 代理</h4>
<div class="paragraph">
<p>Spring AOP 是基于代理的。在编写自己的切面或使用 Spring 框架提供的任何基于 Spring AOP 的切面之前，掌握上一句话的真正意义是非常重要的。</p>
</div>
<div class="paragraph">
<p>首先考虑一下如果你有一个普通的，非代理的，没什么特别的，直接的对象引用，如下面的代码片段所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimplePojo</span> <span class="directive">implements</span> Pojo {

        <span class="directive">public</span> <span class="type">void</span> foo() {
                <span class="comment">// this next method invocation is a direct call on the 'this' reference</span>
                <span class="local-variable">this</span>.bar();
        }

        <span class="directive">public</span> <span class="type">void</span> bar() {
                <span class="comment">// some logic...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你在对象引用上调用方法，则该方法会直接在该对象引用上被调用，如下所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-plain-pojo-call.png" alt="aop proxy plain pojo call">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                Pojo pojo = <span class="keyword">new</span> SimplePojo();

                <span class="comment">// this is a direct method call on the 'pojo' reference</span>
                pojo.foo();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当客户端代码的引用是代理时，情况会稍微有所改变。考虑下面的图表和代码片段。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-call.png" alt="aop proxy call">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());
                factory.addInterface(Pojo.class);
                factory.addAdvice(<span class="keyword">new</span> RetryAdvice());

                Pojo pojo = (Pojo) factory.getProxy();

                <span class="comment">// this is a method call on the proxy!</span>
                pojo.foo();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里要理解的关键是 <code>Main</code> 类的 <code>main(..)</code> 中的客户代码 <em>有一个对代理的引用</em>。这意味着对对象引用的方法调用将是对代理的调用，因此代理将能与该特定方法调用相关的所有操作都够委托给拦截器（通知）。不过，一旦调用最终到达目标对象，这个例子中是 <code>SimplePojo</code>，它将执行它自己方法调用，比如 <code>this.bar()</code> 或 <code>this.foo()</code> ，将会在这个对象引用上调用，而不是代理。这具有重要意义。这意味着自我调用不会导致与方法调用相关的通知获得执行机会。</p>
</div>
<div class="paragraph">
<p>好的，那该怎么办呢？最好的方法（“最好”这个词语在这里使用不是很严格）是重构你的代码，使得自我调用不会发生。当然，这确实需要你做一些工作，但它是最好的，侵入性最小的方法。下一个方法绝对是非常可怕的，正因如此我几乎不愿意指出来。通过这个代码你完全可以（呛！尴尬-_-!）把你的类中的逻辑与 Spring AOP 绑定在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimplePojo</span> <span class="directive">implements</span> Pojo {

        <span class="directive">public</span> <span class="type">void</span> foo() {
                <span class="comment">// this works, but... gah!</span>
                ((Pojo) AopContext.currentProxy()).bar();
        }

        <span class="directive">public</span> <span class="type">void</span> bar() {
                <span class="comment">// some logic...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这完全将你的代码耦合到 Spring AOP 中，并且它使得类本身意识到它正在被 AOP 上下文使用的事实，这与 AOP 的目的截然相反。而且这么做在创建代理时，还需要一些额外的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());
                factory.adddInterface(Pojo.class);
                factory.addAdvice(<span class="keyword">new</span> RetryAdvice());
                factory.setExposeProxy(<span class="predefined-constant">true</span>);

                Pojo pojo = (Pojo) factory.getProxy();

                <span class="comment">// this is a method call on the proxy!</span>
                pojo.foo();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，必须记住 AspectJ 没有这个自我调用的问题，因为它不是一个基于代理的 AOP 框架。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-aspectj-programmatic"><a class="anchor" href="#aop-aspectj-programmatic"></a>5.7. 编程方式创建 @AspectJ 代理</h3>
<div class="paragraph">
<p>除了使用 <code>&lt;aop:config&gt;</code> 或
  <code>&lt;aop:aspectj-autoproxy&gt;</code> 在配置中声明切面以外，还可以通过编程方式创建通知目标对象的代理。 有关 Spring AOP API 的全部细节，请参阅下一章。 这里我们要关注使用 @AspectJ 切面自动创建代理的能力。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> 类可用于为一个或多个 @AspectJ 切面通知的目标对象创建代理。这个类的基本用法非常简单，如下所示。 请参阅 javadoc 以获取完整信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// create a factory that can generate a proxy for the given target object</span>
AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory(targetObject);

<span class="comment">// add an aspect, the class must be an @AspectJ aspect</span>
<span class="comment">// you can call this as many times as you need with different aspects</span>
factory.addAspect(<span class="predefined-type">SecurityManager</span>.class);

<span class="comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span>
factory.addAspect(usageTracker);

<span class="comment">// now get the proxy object...</span>
MyInterfaceType proxy = factory.getProxy();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-using-aspectj"><a class="anchor" href="#aop-using-aspectj"></a>5.8. 在 Spring 应用中使用 AspectJ </h3>
<div class="paragraph">
<p>本章到目前为止所介绍的所有有东西都是纯 Spring AOP。在本节中，我们将介绍如何使用 AspectJ 编译器/织入器代替 Spring AOP，或者除了 Spring AOP 之外，如果你的需要 Spring AOP 提供的功能之外的东西</p>
</div>
<div class="paragraph">
<p>Spring 提供了一个小的 AspectJ 切面库，它可以在你的发行版中作为 <code>spring-aspects.jar</code> 单独使用; 你需要将其添加到您的类路径中，以便使用其中的切面。 <a href="#aop-atconfigurable">在 Spring 中使用 AspectJ 对域对象进行依赖注入</a> 和 <a href="#aop-ajlib-other">AspectJ 的其他 Spring 切面</a> 讨论这个库的内容以及如何使用它。<a href="#aop-aj-configure">使用 Spring IoC 配置 AspectJ 切面</a> 讨论了如何依赖注入使用 AspectJ 编译器织入的 AspectJ 切面。最后，<a href="#aop-aj-ltw">在 Spring 框架中使用 AspectJ Load-time 织入</a> 介绍了使用 AspectJ 的 Spring 应用程序的加载时织入。</p>
</div>
<div class="sect3">
<h4 id="aop-atconfigurable"><a class="anchor" href="#aop-atconfigurable"></a>5.8.1. 在 Spring 中使用 AspectJ 对域对象进行依赖注入</h4>
<div class="paragraph">
<p>Spring 容器实例化和配置在应用程序上下文中定义的 bean。也可以要求 bean 工厂配置一个 bean 定义的名字包含在要应用的配置中的预先存在的对象。<code>spring-aspects.jar</code> 包含一个注解驱动的切面，利用这个功能来允许依赖注入任何对象。该支持旨在用于在任何容器控制之外创建的对象。域对象通常属于这一类，因为它们通常是以编程方式使用 <code>new</code> 操作符或通过 ORM 工具作为数据库查询的结果创建的。</p>
</div>
<div class="paragraph">
<p><code>@Configurable</code> 注解将一个类标记为符合 Spring 驱动配置的类。在最简单的情况下，它可以用作标记注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.xyz.myapp.domain</span>;

<span class="keyword">import</span> <span class="include">org.springframework.beans.factory.annotation.Configurable</span>;

<span class="annotation">@Configurable</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Account</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当以这种方式用作标记接口时，Spring 将使用与完全限定类型名称（<code>com.xyz.myapp.domain.Account</code>）同名的 bean 定义（通常是原型作用域的）来配置注解类型的新实例（在这个例子中为 <code>Account</code> ）。 由于 bean 的默认名称是其类型的完全限定名称，因此声明原型定义的一种简便方法就是省略<code>id</code> 特性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.domain.Account</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fundsTransferService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fundsTransferService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要显式指定要使用的原型 bean 定义的名称，可以直接在注解中操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.xyz.myapp.domain</span>;

<span class="keyword">import</span> <span class="include">org.springframework.beans.factory.annotation.Configurable</span>;

<span class="annotation">@Configurable</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Account</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 现在将查找名为 “account” 的 bean 定义，并将其作为定义来配置新的 <code>Account</code> 实例。</p>
</div>
<div class="paragraph">
<p>你也可以使用自动装配来避免必须指定特定的 bean 定义。要使 Spring 通过使用 <code>@Configurable</code> 注解的 <code>autowire</code> 属性来应用自动装配：要么指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code> 要么指定 <code>@Configurable(autowire=Autowire.BY_NAME</code>，以分别按类型或名称的方式自动装配。从 Spring 2.5 开始，最好通过在字段或方法级别使用 <code>@Autowired</code> 或 <code>@Inject</code>（请参阅<a href="#beans-annotation-config">基于注解的容器配置</a>以获取更多详细信息）为你的 <code>@Configurable</code>  bean 指定显式的，注解驱动的依赖注入。</p>
</div>
<div class="paragraph">
<p>最后，您可以使用  <code>dependencyCheck</code> 特性（例如：@Configurable（<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>）为新创建和配置的对象中的对象引用启用Spring 依赖项检查。如果此特性设置为 true，则 Spring 将在配置后验证所有属性（<em>不是基本类型或集合</em>）都已被设置。</p>
</div>
<div class="paragraph">
<p>当然，对它本身使用这个注解不会有任何作用。作用于注解的是 <code>spring-aspects.jar</code> 中的 <code>AnnotationBeanConfigurerAspect</code> 。切面从本质上来说就是“在从 <code>@Configurable</code> 注解的新对象的初始化返回后，根据注解的属性使用 Spring 配置新创建的对象”。在这个上下文中，初始化是指新实例化的对象（例如，用 <code>new</code> 运算符实例化的对象）以及正在经历反序列化（例如，通过 <a href="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html">readResolve()</a>）的可序列化对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>上段中的一个关键词是“实质上”。 在大多数情况下，'<em>after returning from the initialization of a new object</em>' 的确切语义是 OK 的......在这个上下文中，'<em>after initialization</em>' 意味着依赖关系将在对象被创建之后被注入 - 这意味着依赖关系将在类的构造方法体中不可用。如果你希望在构造器执行之前注入依赖项，并且可以在构造器方法体中可用，那么你需要在 <code>@Configurable</code> 声明中定义它，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configurable</span>(preConstruction=<span class="predefined-constant">true</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在 <a href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ编程指南</a> 的 <a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">附录</a> 中找到关于 AspectJ 中各种切点类型语言语义的更多信息。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为此，注解类型必须与 AspectJ 织入器交织在一起 - 你可以使用构建时的Ant 或 Maven 任务来执行此操作（参阅<a href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ开发环境指南</a>）或加载时织入（参阅 <a href="#aop-aj-ltw">在 Spring 框架中的使用AspectJ 加载时织入</a>）。<code>AnnotationBeanConfigurerAspect</code> 本身需要由 Spring 进行配置（为了获得对用来配置新对象的bean 工厂的引用）。如果你使用基于 Java 的配置，只需将 <code>@EnableSpringConfigured</code> 添加到任何 <code>@Configuration</code> 类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableSpringConfigured</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你更倾向于使用基于 XML 的配置，Spring <a href="appendix.html#xsd-config-body-schemas-context"><code>context</code> 命名空间</a> 定义了一个方便的<code>context:spring-configured</code> 元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:spring-configured</span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在配置切面之前创建的 <code>@Configurable</code> 对象实例将会向调试日志发送信息，并且不会发生对该对象的配置。一个例子是当被 Spring 初始化时，Spring 配置中的创建域对象的 bean。在这个例子中，你可以使用“depends-on” bean 特性来手动指定该 bean 依赖于配置切面。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xzy.myapp.service.MyService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- ... --&gt;</span>

<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除非你真的想在运行时依赖它的语义，否则不要通过 bean 配置器切面激活 <code>@Configurable</code> 处理。尤其是你要确保你没有对在容器中注册为普通 Spring bean 的 Bean 类使用<code>@Configurable</code> ：否则会执行两次初始化，，一次通过容器，一次通过切面。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="aop-configurable-testing"><a class="anchor" href="#aop-configurable-testing"></a> @Configurable 对象的单元测试</h5>
<div class="paragraph">
<p><code>@Configurable</code> 支持的目标之一就是支持域对象的独立单元测试而不会遇到与硬编码查找相关的问题。如果 <code>@Configurable</code> 类型没有通过 AspectJ 织入，那么注解在单元测试中没有任何影响，你只要在被测对象中设置 mock 或 stub 属性引用，并照常执行。如果 <code>@Configurable</code> 类型已经通过 AspectJ 织入，那么你仍然可以像平常一样在容器的外部进行单元测试，但是每当你构造一个 <code>@Configurable</code> 对象时，你都会看到一条警告消息指出它没有被 Spring 配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-configurable-container"><a class="anchor" href="#aop-configurable-container"></a>使用多个应用程序上下文</h5>
<div class="paragraph">
<p>用于实现 <code>@Configurable</code> 支持的 <code>AnnotationBeanConfigurerAspect</code> 是一个 AspectJ 单例切面。单例切面的作用域与 <code>static</code> 成员的作用域相同，也就是说每个类加载器有一个定义类型的且面实例。这意味着如果在相同的类加载器层次结构中定义多个应用程序上下文，则需要考虑在何处定义<code>@EnableSpringConfigured</code> 以及将 <code>spring-aspects.jar</code> 放置在类路径中的何处。</p>
</div>
<div class="paragraph">
<p>考虑一个典型的Spring Web
   应用程序配置，其中包含一个共享的父应用程序上下文，它定义了公用 business servsisce 以及支持它们的所有东西，以及一个子应用程序上下文，对应每个包含定义的 servlet 。所有这些上下文将在同一个类加载器层次结构中共存，因此 <code>AnnotationBeanConfigurerAspect</code> 只能拥有对其中一个的引用。在这种情况下，我们建议在共享（父）应用程序上下文中定义 <code>@EnableSpringConfigured</code> bean：这定义了你可能希望注入到域对象中的服务。结果是，你不能使用 @Configurable 机制（可能不是你想要的东西！）来对在子（与 servlet 关连的）上下文中配置中定义的 bean 引用配置域对象。</p>
</div>
<div class="paragraph">
<p>在同一容器中部署多个 web 应用程序时，请确保每个web应用程序使用自己的类加载器加载 <code>spring-aspects.jar</code> 中的类型（例如，将 <code>spring-aspects.jar</code> 放在 <code>'WEB-INF/lib'</code> 中）。如果 <code>spring-aspects.jar</code> 仅添加到容器范围的类路径（因此由共享的父类加载器加载），则所有 Web 应用程序将共享相同的切面实例，这可能不是您想要的。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-ajlib-other"><a class="anchor" href="#aop-ajlib-other"></a>5.8.2.  AspectJ 的其他 Spring 切面</h4>
<div class="paragraph">
<p>除了 <code>@Configurable</code> 切面，<code>spring-aspects.jar</code>  还包含一个 AspectJ 切面，用来驱动 Spring 对带有 <code>@Transactional</code> 注解的类型和方法进行事务管理。这主要是为那些希望在 Spring 容器之外使用Spring 框架的事务支持的用户而设计的。</p>
</div>
<div class="paragraph">
<p><code>AnnotationTransactionAspect</code> 切面是用来翻译 <code>@Transactional</code> 注解的。当使用这个切面时，你必须在实现类（且/或实现类中的方法）上添加注解，而不是在实现类实现的接口（如果有的话）上添加注解。AspectJ 遵循 Java 的规则，也就是接口上的注解是不能被继承的。</p>
</div>
<div class="paragraph">
<p>类上的 <code>@Transactional</code> 注解为类中任意 <em>public</em> 方法指定了一个默认的事务管理语义。</p>
</div>
<div class="paragraph">
<p>类中方法上的 <code>@Transactional</code> 注解覆盖了类注解（如果存在）给定的默认事务管理语义。任何可见的方法都可以被注解，包括 private 方法。直接对非 public 方法进行注解是获取这些方法执行的事务划分的唯一方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>自 Spring Framework 4.2 以来，<code>spring-aspects</code> 提供了一个类似于为标准的 <code>javax.transaction.Transactional</code> 注解提供完全相同的功能的切面。查看 <code>JtaAnnotationTransactionAspect</code> 获取更多细节。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于那些希望使用 Spring 配置和事务管理支持但不希望（或不能）使用注解的 AspectJ 程序员，<code>spring-aspects.jar</code> 还包含可以扩展以提供自己的切点定义的抽象切面。 有关更多信息，请参阅 <code>AbstractBeanConfigurerAspect</code> 和<code>AbstractTransactionAspect</code> 切面的源代码。作为一个例子，以下摘录展示了如何使用与完全限定的类名匹配的原型 bean 定义来编写切面，以配置域模型中定义的所有对象实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect DomainObjectConfiguration <span class="directive">extends</span> AbstractBeanConfigurerAspect {

        <span class="directive">public</span> DomainObjectConfiguration() {
                setBeanWiringInfoResolver(<span class="keyword">new</span> ClassNameBeanWiringInfoResolver());
        }

        <span class="comment">// the creation of a new bean (any object in the domain model)</span>
        <span class="directive">protected</span> pointcut beanCreation(<span class="predefined-type">Object</span> beanInstance) :
                initialization(<span class="keyword">new</span>(..)) &amp;&amp;
                SystemArchitecture.inDomainModel() &amp;&amp;
                <span class="local-variable">this</span>(beanInstance);

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-configure"><a class="anchor" href="#aop-aj-configure"></a>5.8.3. 使用 Spring IoC 配置 AspectJ 切面</h4>
<div class="paragraph">
<p>在 Spring 应用程序中使用 AspectJ 切面的时候，希望和期望能够使用 Spring 来配置这些切面是很自然的。AspectJ 运行时本身负责创建切面，且通过 Spring 配置 AspectJ 创建的切面的方法取决于切面使用的 AspectJ 实例化模型（per-xxx子句）。</p>
</div>
<div class="paragraph">
<p>AspectJ 的大多数切面都是单例切面。这些切面的配置非常简单：只需简单地创建一个引用切面类型的 bean 定义，并包含一个 bean 特性 <code>'factory-method="aspectOf"'</code>。这确保了 Spring 通过询问AspectJ 来获得切面实例，而不是试图创建一个实例本身。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profiler</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.profiler.Profiler</span><span class="delimiter">&quot;</span></span>
                <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aspectOf</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span><span class="tag">&gt;</span>

        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profilingStrategy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jamonProfilingStrategy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>非单例切面的配置比较困难：但是，一旦切面实例被 AspectJ 运行时创建，通过创建原型 bean 定义并使用 <code>spring-aspects.jar</code> 中的 <code>@Configurable</code> 支持来配置切面实例是可能的。</p>
</div>
<div class="paragraph">
<p>如果您想要使用 AspectJ 编写一些 @AspectJ 切面（例如，为域模型类型使用 load-time 织入）或者你希望与 Spring AOP 一起使用的其他 @AspectJ 切面，并且这些切面都使用 Spring 进行配置 ，那么你需要告诉 Spring AOP @AspectJ 自动代理支持，在配置中定义的 @AspectJ 切面的哪个确切子集应该用于自动代理。你可以通过在<code>&lt;aop:aspectj-autoproxy/&gt;</code> 声明中使用一个或多个 <code>&lt;include/&gt;</code> 元素来完成此操作。每个 <code>&lt;include/&gt;</code> 元素指定一个命名模式，并且只有名字与至少一个模式相匹配的 bean 才会用于Spring AOP 的自动代理配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy&gt;</span>
        <span class="tag">&lt;aop:include</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thisBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;aop:include</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thatBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/aop:aspectj-autoproxy&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不要被 <code>&lt;aop:aspectj-autoproxy/&gt;</code> 元素的名字误导：使用它将导致 Spring AOP 代理的创建。@AspectJ 风格切面声明也只用在这里，但 AspectJ 运行时不会被包含。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw"><a class="anchor" href="#aop-aj-ltw"></a>5.8.4. 在 Spring 框架中使用 AspectJ Load-time 织入</h4>
<div class="paragraph">
<p>加载时织入（LTW）是指在将 AspectJ 切面加载到 Java 虚拟机（JVM）中时将 AspectJ 切面织入到应用程序的类文件中的过程。本节的重点是在 Spring 框架的特定上下文中配置和使用 LTW：本节不是对 LTW 的介绍。有关 LTW 细节的详细信息以及仅使用 AspectJ 配置 LTW（Spring 完全不参与），请参阅<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html"> AspectJ 开发环境指南的 LTW 部分</a>。</p>
</div>
<div class="paragraph">
<p>Spring 框架为 AspectJ LTW 带来的附加价值是对织入过程进行更细粒度的控制。‘Vanilla’ AspectJ LTW 是使用 Java（5+）代理实现的，该代理在启动 JVM 时通过指定VM参数来开启。因此，这是一个JVM 域的设置，在某些情况下可能是 OK 的，但通常有点过于粗糙。启用 Spring 的 LTW 使你能够基于每个类加载器开启 LTW，这显然是更细粒度的控制，并且在“单JVM-多应用”环境中可以更有意义（例如在典型的应用服务器环境）。</p>
</div>
<div class="paragraph">
<p>而且，<a href="#aop-aj-ltw-environments">在某些环境中</a>，这种支持可以在 <em>不修改应用服务器启动脚本</em> 的情况下进行加载时织入，修改脚本需要添加 <code>-javaagent:path/to/aspectjweaver.jar</code> 或（如本节后面所述）<code>-javaagent:path/to/org.springframework.instrument-{version}.jar</code>（以前称为 <code>spring-agent.jar</code>）。开发人员只需修改构成应用程序上下文的一个或多个文件，以启用加载时织入，而不是依赖通常负责部署配置（如启动脚本）的管理员。</p>
</div>
<div class="paragraph">
<p>现在安利（推销哈哈）部分结束，让我们先来看一下使用 Spring 的 AspectJ LTW 的一个简单例子，然后详细介绍下面例子中介绍的元素。有关完整示例，请参阅 <a href="https://github.com/spring-projects/spring-petclinic">Petclinic 示例应用程序</a>。</p>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-first-example"><a class="anchor" href="#aop-aj-ltw-first-example"></a>第一个示例</h5>
<div class="paragraph">
<p>假设你是应用程序开发人员，负责诊断系统中某些性能问题的原因。我们要做的就是打开一个简单的 profiling 切面，而不是开发一个 profiling 工具，这将使我们能够很快得到一些性能指标，以便我们能够之后立即将更细粒度的剖析工具应用到特定的区域。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这里呈现的示例使用 XML 风格的配置，你也可以使用 <a href="#beans-java">Java 配置</a> 来配置和使用 @AspectJ。具体来说，<code>@EnableLoadTimeWeaving</code> 注解可以用来替代 <code>&lt;context:load-time-weaver/&gt;</code>（详见 <a href="#aop-aj-ltw-spring">下文</a>）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面是一个 profiling 切面。没有太花哨的东西，只是一个快速和简陋的基于时间的剖析器，使用 @AspectJ 风格的切面声明 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">foo</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang.ProceedingJoinPoint</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Around</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Pointcut</span>;
<span class="keyword">import</span> <span class="include">org.springframework.util.StopWatch</span>;
<span class="keyword">import</span> <span class="include">org.springframework.core.annotation.Order</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ProfilingAspect</span> {

        <span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">methodsToBeProfiled()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">Object</span> profile(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                StopWatch sw = <span class="keyword">new</span> StopWatch(getClass().getSimpleName());
                <span class="keyword">try</span> {
                        sw.start(pjp.getSignature().getName());
                        <span class="keyword">return</span> pjp.proceed();
                } <span class="keyword">finally</span> {
                        sw.stop();
                        <span class="predefined-type">System</span>.out.println(sw.prettyPrint());
                }
        }

        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(public * foo..*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> methodsToBeProfiled(){}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还需要创建一个 <code>META-INF/aop.xml</code> 文件，来通知 AspectJ 织入者我们要将我们的 <code>ProfilingAspect</code> 织入到我们的类中。 这个文件约定，即名为 <code>META-INF/aop.xml</code> 的 Java 类路径上的文件（或多个文件）的存在代表是标准的 AspectJ。/p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="doctype">&lt;!DOCTYPE aspectj PUBLIC &quot;-//AspectJ//DTD//EN&quot; &quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;&gt;</span>
<span class="tag">&lt;aspectj&gt;</span>

        <span class="tag">&lt;weaver&gt;</span>
                <span class="comment">&lt;!-- only weave classes in our application-specific packages --&gt;</span>
                <span class="tag">&lt;include</span> <span class="attribute-name">within</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.*</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/weaver&gt;</span>

        <span class="tag">&lt;aspects&gt;</span>
                <span class="comment">&lt;!-- weave in just this aspect --&gt;</span>
                <span class="tag">&lt;aspect</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.ProfilingAspect</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/aspects&gt;</span>

<span class="tag">&lt;/aspectj&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在轮到配置的 Spring 相关部分。我们需要配置一个 <code>LoadTimeWeaver</code>（所有相关的东西都会在后面解释，现在只要知道这么配置就行）。该加载时织入器是负责将一个或多个 <code>META-INF/aop.xml</code> 文件中的切面配置织入到应用程序中的类的基本组件。 好消息是它不需要很多配置，如下所示（还有一些选项可以指定，稍后会详细介绍）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- a service object; we will be profiling its methods --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">entitlementCalculationService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.StubEntitlementCalculationService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- this switches on the load-time weaving --&gt;</span>
        <strong><span class="tag">&lt;context:load-time-weaver</span><span class="tag">/&gt;</span></strong>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，所有必需的构件（<code>META-INF/aop.xml</code> 文件和 Spring 配置）都已准备就绪，让我们使用 <code>main(..)</code> 方法创建一个简单的驱动程序类，以演示 LTW 的实际应用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">foo</span>;

<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>, Main.class);

                EntitlementCalculationService entitlementCalculationService
                        = (EntitlementCalculationService) ctx.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">entitlementCalculationService</span><span class="delimiter">&quot;</span></span>);

                <span class="comment">// the profiling aspect is 'woven' around this method execution</span>
                entitlementCalculationService.calculateEntitlement();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后还有一件事要做。本节的介绍确实表明，可以使用 Spring 基于每个类加载器选择性地切换 LTW，而且事实确实如此。但是，就这个例子而言，我们将使用 Java 代理（由Spring提供）来开启 LTW。这是我们将用来运行上面的<code>Main</code> 类的命令行：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</pre>
</div>
</div>
<div class="paragraph">
<p><code>-javaagent</code> 是一个用于指定和启用 <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">运行在 JVM 上的工具程序的代理</a> 的标志。Spring 框架附带了一个代理 <code>InstrumentationSavingAgent</code> ，该代理作为上述示例中 <code>-javaagent</code> 参数的值被打包在 <code>spring-instrument.jar</code>中。</p>
</div>
<div class="paragraph">
<p><code>Main</code> 程序执行的输出结果如下所示。（我已经在 <code>calculateEntitlement()</code> 实现中引入了 <code>Thread.sleep(..)</code> 表达式，以便 profiler 实际上捕获非 0 毫秒数的内容 - <code>01234</code> 毫秒不是 AOP 的开销时间:)）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre>
</div>
</div>
<div class="paragraph">
<p>由于这个 LTW 是通过使用成熟的 AspectJ 来实现的，所以我们不仅仅限于可以通知 Spring beans，<code>Main</code> 程序中的下列细微变化将产生相同的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">foo</span>;

<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>, Main.class);

                EntitlementCalculationService entitlementCalculationService =
                        <span class="keyword">new</span> StubEntitlementCalculationService();

                <span class="comment">// the profiling aspect will be 'woven' around this method execution</span>
                entitlementCalculationService.calculateEntitlement();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，在上面的程序中，我们只是简单地启动了 Spring 容器，然后在 Spring 的上下文之外创建了 <code>StubEntitlementCalculationService</code> 的新实例...prifiling 通知仍然被织入了。</p>
</div>
<div class="paragraph">
<p>不可否认这个例子很简单...但是 LTW 支持的基础知识都已经包含在上面的例子中了，本节的其余部分将详细解释每一个配置和用法的背后的理由。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本例中使用的 <code>ProfilingAspect</code> 可能很基础，但是却非常有用。 这是开发人员在开发过程中（很显然）可以使用的开发时切面的一个很好的例子，然后很容易在部署到 UAT 或生产中的应用程序的构建中将其排除。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-the-aspects"><a class="anchor" href="#aop-aj-ltw-the-aspects"></a>切面</h5>
<div class="paragraph">
<p>您在 LTW 中使用的切面必须是 AspectJ 切面。它们可以用 AspectJ 语言本身编写，也可以用 @AspectJ 风格编写。这意味着你的切面是有效的 AspectJ 和 Spring AOP 切面。而且，编译的切面类需要在类路径中可用</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-aop_dot_xml"><a class="anchor" href="#aop-aj-ltw-aop_dot_xml"></a>'META-INF/aop.xml'</h5>
<div class="paragraph">
<p>AspectJ LTW 基础结构使用一个或多个 <code>META-INF/aop.xml</code> 文件进行配置，这些文件位于 Java 类路径上（直接或者通常在 jar 文件中）。</p>
</div>
<div class="paragraph">
<p>这个文件的结构和内容在主要的 AspectJ 参考文档中详细介绍，感兴趣的读者可以参考 <a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">这个资源</a>。 （这个部分很简短，但 <code>aop.xml</code> 文件是 100％ 的 AspectJ - 没有与 Spring 相关的信息或语义适用于它，所以没有额外的价值拿来贡献，所以相比于 AspectJ 开发人员写的相当满意的部分改头换面，我们只是带你领进门。）</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-libraries"><a class="anchor" href="#aop-aj-ltw-libraries"></a>必须的库 （JARS）</h5>
<div class="paragraph">
<p>要使用Spring 框架对 AspectJ LTW 的支持，你至少需要以下库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-aop.jar</code> （2.5 及之后的版本，加上所有强制必须的依赖项）</p>
</li>
<li>
<p><code>aspectjweaver.jar</code> （1.6.8 及之后的版本）(version 1.6.8 or later)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你正在使用 <a href="#aop-aj-ltw-environment-generic">Spring 提供的代理启动 instrumentation</a>，你还需要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-instrument.jar</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-spring"><a class="anchor" href="#aop-aj-ltw-spring"></a>Spring 配置</h5>
<div class="paragraph">
<p>Spring LTW 支持中的关键组件是 <code>LoadTimeWeaver</code> 接口（在 <code>org.springframework.instrument.classloading</code> 包中）以及 Spring 发行版附带的大量实现。<code>LoadTimeWeaver</code> 负责在运行时向 <code>ClassLoader</code> 添加一个或多个 <code>java.lang.instrument.ClassFileTransformers</code> ，这为所有感兴趣的的应用打开了大门，其中一个就是 LTW 切面。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你不熟悉运行时类文件转换的思路，我们鼓励你在继续之前阅读 <code>java.lang.instrument</code>  包的 javadoc API 文档。这不是一件很麻烦的事情，因为在那里有 - 虽然有点烦人 -重要的小文档...哪里有很多关键的接口和类，至少在你阅读本节时可以参考。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为特定的 <code>ApplicationContext</code> 配置 <code>LoadTimeWeaver</code> 可以像添加一行配置一样简单。（注意，你几乎肯定会需要使用 <code>ApplicationContext</code> 作为你的 Spring 容器 - 通常 <code>BeanFactory</code> 是满足需求的，因为 LTW 支持使用 <code>BeanFactoryPostProcessors</code>。）</p>
</div>
<div class="paragraph">
<p>要启用 Spring 框架的 LTW 支持，你需要配置一个 <code>LoadTimeWeaver</code>，通常使用 <code>@EnableLoadTimeWeaving</code> 注解完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableLoadTimeWeaving</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果你更喜欢基于 XML 的配置，可以使用 <code>&lt;context:load-time-weaver/&gt;</code> 元素。注意这个元素是在 <code>context</code> 命名空间中定义的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:load-time-weaver</span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上述配置将自动为ni 定义并注册一些 LTW 特定的基础结构 bean，例如 <code>LoadTimeWeaver</code> 和 <code>AspectJWeavingEnabler</code> 。默认的 <code>LoadTimeWeaver</code> 是 <code>DefaultContextLoadTimeWeaver</code> 类，它试图装饰一个自动检测到的 <code>LoadTimeWeaver</code>：将被 “自动检测到” 的 <code>LoadTimeWeaver</code> 的确切类型取决于你的运行时环境（总结在下表中）。</p>
</div>
<table id="aop-aj-ltw-spring-env-impls" class="tableblock frame-all grid-all spread">
<caption class="title">Table 13. DefaultContextLoadTimeWeaver LoadTimeWeavers</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">运行时环境</th>
<th class="tableblock halign-left valign-top"><code>LoadTimeWeaver</code> 实现</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Oracle&#8217;s
<a href="http://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebLogicLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Oracle&#8217;s <a href="http://glassfish.dev.java.net/">GlassFish</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GlassFishLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in <a href="https://tomcat.apache.org/">Apache Tomcat</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Red Hat&#8217;s <a href="http://www.jboss.org/jbossas/">JBoss AS</a> or <a href="http://www.wildfly.org/">WildFly</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JBossLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in IBM&#8217;s <a href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSphereLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">用 Spring <code>InstrumentationSavingAgent</code> 启动 JVM <em>(java
-javaagent:path/to/spring-instrument.jar)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InstrumentationLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">降级，期望潜在的类加载器遵循通用约定（例如，适用于 <code>TomcatInstrumentableClassLoader</code> 和 <a href="http://www.caucho.com/">Resin</a>）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReflectiveLoadTimeWeaver</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意这些只是使用 <code>DefaultContextLoadTimeWeaver</code> 时自动检测到的 <code>LoadTimeWeaver</code>：当然你可以指定希望使用哪个 <code>LoadTimeWeaver</code> 实现。</p>
</div>
<div class="paragraph">
<p>要使用 Java 配置指定特定的 <code>LoadTimeWeaver</code> 实现需要实现 <code>LoadTimeWeavingConfigurer</code> 接口并覆盖 <code>getLoadTimeWeaver()</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableLoadTimeWeaving</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> <span class="directive">implements</span> LoadTimeWeavingConfigurer {

        <span class="annotation">@Override</span>
        <span class="directive">public</span> LoadTimeWeaver getLoadTimeWeaver() {
                <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveLoadTimeWeaver();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用基于 XML 的配置，则可以在 <code>&lt;context:load-time-weaver/&gt;</code> 元素上指定完全限定的类名称作为 <code>weaver-class</code> 特性的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:load-time-weaver</span>
                        <span class="attribute-name">weaver-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由配置定义和注册的 <code>LoadTimeWeaver</code> 可以在以后著名的 <code>loadTimeWeaver</code> 名字从 Spring 容器中检索。记住，<code>LoadTimeWeaver</code> 只是作为 Spring 的 LTW 基础结构的机制来添加一个或多个 <code>ClassFileTransformer</code> 。执行 LTW 的实际 <code>ClassFileTransformer</code> 是 <code>ClassPreProcessorAgentAdapter</code>（来自 <code>org.aspectj.weaver.loadtime</code> 包）类。请参阅类级别的 <code>ClassPreProcessorAgentAdapter</code> 类的类级别 javadoc 以了解更多细节，因为实际上织入方式的具体细节超出了本节的范围。</p>
</div>
<div class="paragraph">
<p>还有一个最后的配置特性需要讨论：<code>aspectjWeaving</code> 特性（如果使用XML，则为 <code>aspectj-weaving</code>）。这是特性控制是否启用 LTW; 它跟呈现的一样简单。它接受三个可能的值之一，总结如下，如果该属性不存在，则默认值为 <code>autodetect</code> 。</p>
</div>
<table id="aop-aj-ltw-ltw-tag-attrs" class="tableblock frame-all grid-all spread">
<caption class="title">Table 14. AspectJ 织入特性值</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">XML 值</th>
<th class="tableblock halign-left valign-top">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>on</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ 织入已开启，切面会在加载时以适当的方式被织入。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DISABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTW 已关闭，加载时不会有切面被织入。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AUTODETECT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>autodetect</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果Spring LTW 基础结构可以找到至少一个 <code>META-INF/aop.xml</code> 文件，则 AspectJ 织入就处于打开状态，否则处于关闭状态。这是默认值。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-environments"><a class="anchor" href="#aop-aj-ltw-environments"></a>环境相关配置</h5>
<div class="paragraph">
<p>最后一部分包含在应用程序服务器和 Web 容器等环境中使用 Spring LTW 支持时所需的任何其他设置和配置</p>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environment-tomcat"><a class="anchor" href="#aop-aj-ltw-environment-tomcat"></a>Tomcat</h6>
<div class="paragraph">
<p>从历史上看，<a href="https://tomcat.apache.org/">Apache Tomcat</a> 的默认类加载器不支持类转换，这就是为什么 Spring 提供了一个增强的实现来满足这种需求的原因。这个实现名为 <code>TomcatInstrumentableClassLoader</code>，加载器在 Tomcat 6.0 及更高版本上运行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不要在 Tomcat 8.0 及其更高版本上定义 <code>TomcatInstrumentableClassLoader</code>。 相反，让 Spring 通过 <code>TomcatLoadTimeWeaver</code> 策略自动使用 Tomcat 新的本地 <code>InstrumentableClassLoader</code> 工具。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你仍然需要使用 <code>TomcatInstrumentableClassLoader</code>，则可以按照以下方式单独为每个Web 应用注册它：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将 <code>org.springframework.instrument.tomcat.jar</code> 复制到 <em>$CATALINA_HOME</em>/lib 中，其中 <em>$CATALINA_HOME</em> 表示 Tomcat 安装的根目录）</p>
</li>
<li>
<p>引导 Tomcat 通过编辑 Web 应用程序上下文文件来使用自定义类加载器（而不是默认的）：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;Context</span> <span class="attribute-name">path</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/myWebApp</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">docBase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/my/webApp/location</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;Loader</span>
                <span class="attribute-name">loaderClass</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/Context&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Apache Tomcat（6.0+）支持多个上下文位置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务器配置文件 - <em>$CATALINA_HOME/conf/server.xml</em></p>
</li>
<li>
<p>默认的上下文配置 - <em>$CATALINA_HOME/conf/context.xml</em> - 影响所有部署的 Web 应用程序</p>
</li>
<li>
<p>per-web 应用程序配置，可以在服务端的
<em>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</em> 或者在嵌入的 web-app archive 的  <em>META-INF/context.xml</em> 中部署。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了提高效率，建议使用嵌入式 Web 应用程序配置风格，因为它只会影响使用自定义类加载器的应用程序，并且不需要对服务器配置进行任何更改。有关可用上下文位置的更多详细信息，请参阅Tomcat 6.0.x <a href="https://tomcat.apache.org/tomcat-6.0-doc/config/context.html">文档</a>。</p>
</div>
<div class="paragraph">
<p>或者，考虑使用 Spring 提供的通用 VM 代理，在 Tomcat 的启动脚本中指定（参见上文）。这将使所有已部署的Web 应用程序都可以使用这些工具，且不管它们运行在哪个类加载器上。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"><a class="anchor" href="#aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"></a>WebLogic, WebSphere, Resin, GlassFish, JBoss</h6>
<div class="paragraph">
<p> WebLogic Server（版本 10 及以上），IBM WebSphere Application
Server （版本 7 及以上），Resin （3.1 及以上） 和 JBoss（6.x 及以上） 的最新版本提供了有能力进行本地检测的类加载器。Spring 的本地 LTW 利用这样的类加载器来启用 AspectJ 织入。，你只需过通过前面描述的方法就能激活加载时织入来启用 LTW。具体而言，你不需要修改启动脚本添加 <code>-javaagent:path/to/spring-instrument.jar</code>。</p>
</div>
<div class="paragraph">
<p>注意 GlassFish 基础组件类加载器在它的 EAR 环境中可用。对于 GlassFish web 应用，遵循上面列出的 Tomcat 设置说明。</p>
</div>
<div class="paragraph">
<p>注意在 JBoss 6.x 上，需要禁用应用服务器扫描以防止应用程序启动之前先加载类。一个快速的解决方法是在构建中添加一个名为 <code>WEB-INF/jboss-scanning.xml</code> 的文件，内容如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;scanning</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:scanning:1.0</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environment-generic"><a class="anchor" href="#aop-aj-ltw-environment-generic"></a>通用 Java 应用</h6>
<div class="paragraph">
<p>不支持或者不被现有的 <code>LoadTimeWeaver</code> 实现支持的环境中需要类基础组件时，JDK 代理就是唯一的解决方案了。对于此类情况，Spring 提供了 <code>InstrumentationLoadTimeWeaver</code> ，它需要 Spring 相关的 VM 代理 <code>org.springframework.instrument-{version}.jar</code>（之前称为 <code>spring-agent.jar</code>）。</p>
</div>
<div class="paragraph">
<p>要使用它，必须通过提供以下 JVM 选项来使用 Spring 代理启动虚拟机：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-javaagent:/path/to/org.springframework.instrument-{version}.jar</pre>
</div>
</div>
<div class="paragraph">
<p>注意，对 VM 启动脚本的修改可能会阻止你使用应用程序服务器环境（具体取决于您的操作策略）。另外，JDK 代理将会测试整个虚拟机，这个代价会很高。</p>
</div>
<div class="paragraph">
<p>出于性能原因，只有在目标环境（如 <a href="https://www.eclipse.org/jetty/">Jetty</a>）没有（或不支持）专用 LTW 时，才推荐使用此配置。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-resources"><a class="anchor" href="#aop-resources"></a>5.9. 更多资源</h3>
<div class="paragraph">
<p>有关 AspectJ 的更多信息可以在 <a href="https://www.eclipse.org/aspectj">AspectJ 网站</a> 上找到。</p>
</div>
<div class="paragraph">
<p>由Adrian Colyer 等人（Addison-Wesley，2005）撰写的 <em>Eclipse AspectJ</em> 一书为 AspectJ 语言提供了一个全面的介绍和参考。</p>
</div>
<div class="paragraph">
<p>Ramnivas Laddad （Manning, 2009）撰写的 <em>AspectJ in Action，第二版</em> 受到强烈推荐；这备注重点聚焦 AspectJ，不过也探索了很多通用的 AOP 主题（有一定深度）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api"><a class="anchor" href="#aop-api"></a>6. Spring AOP APIs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="aop-api-introduction"><a class="anchor" href="#aop-api-introduction"></a>6.1. 简介</h3>
<div class="paragraph">
<p>上一章介绍了 Spring 使用 @AspectJ 和基于模式的切面定义对 AOP 的支持。在本章中，我们将讨论 Spring 1.2 应用程序中使用的较低级别的 Spring AOP API 和 AOP 支持。对于新的应用程序，我们推荐使用前一章中介绍的 Spring 2.0 及更高版本的 AOP 支持，但是在处理现存应用程序或阅读书籍和文章时，您可能会遇到 Spring 1.2 风格的示例。Spring 4.0 向后兼容 Spring 1.2，本章描述的所有内容在 Spring 4.0 中完全支持。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts"><a class="anchor" href="#aop-api-pointcuts"></a>6.2. Spring 中的切点 API </h3>
<div class="paragraph">
<p>让我们看看 Spring 如何处理关键的切点概念。</p>
</div>
<div class="sect3">
<h4 id="aop-api-concepts"><a class="anchor" href="#aop-api-concepts"></a>6.2.1. 概念</h4>
<div class="paragraph">
<p>Spring 的切点模型使切点可以独立于通知类型进行重用。针对不同的通知可以使用相同的切点。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.aop.Pointcut</code> 接口是核心接口，用于瞄准对特定的类和方法的通知。 完整的接口如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Pointcut</span> {

        ClassFilter getClassFilter();

        MethodMatcher getMethodMatcher();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>Pointcut</code> 接口分隔成两个部分，以便重用类和方法的 matching 部分，和细粒度的组合操作（例如与另一个方法 matcher 的“联合”）。 </p>
</div>
<div class="paragraph">
<p><code>ClassFilter</code> 接口用于将其切点限制为给定的一组目标类。如果 <code>matches()</code> 方法总是返回 true，则所有的目标类都将被匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ClassFilter</span> {

        <span class="type">boolean</span> matches(<span class="predefined-type">Class</span> clazz);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MethodMatcher</code> 接口通常更加重要。完整接口如下所示： </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodMatcher</span> {

        <span class="type">boolean</span> matches(<span class="predefined-type">Method</span> m, <span class="predefined-type">Class</span> targetClass);

        <span class="type">boolean</span> isRuntime();

        <span class="type">boolean</span> matches(<span class="predefined-type">Method</span> m, <span class="predefined-type">Class</span> targetClass, <span class="predefined-type">Object</span><span class="type">[]</span> args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>matches(Method, Class)</code> 方法用于测试此切点是否匹配目标类上的给定方法。 在创建 AOP 代理时可以执行此评估，以避免需要对每个方法调用进行测试。如果对于给定的方法，接受两个参数的 matches 方法返回 true，并且 MethodMatcher 的 <code>isRuntime()</code>  方法返回 true，则将在每个方法调用时调用接受3个参数的 matches 方法。这使得切点可以在目标通知执行之前立即查看传递给方法调用的参数。</p>
</div>
<div class="paragraph">
<p>大多数 MethodMatchers 都是静态的，这意味着它们 <code>isRuntime()</code> 方法返回 false。在这种情况下，接受3个参数的 matches 方法永远不会被调用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果可能的话，试着将切点设置为静态，从而允许 AOP 框架在创建 AOP 代理时缓存切点评估的结果。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcut-ops"><a class="anchor" href="#aop-api-pointcut-ops"></a>6.2.2. 切点上的操作</h4>
<div class="paragraph">
<p>Spring 支持切点操作：特别是联合和交集。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>联合意味着任意切点只要其中之一匹配的方法。</p>
</li>
<li>
<p>交集点意味着两个切点都要同时匹配的方法。</p>
</li>
<li>
<p>通常联合更有用。</p>
</li>
<li>
<p>切点可以使用 <em>org.springframework.aop.support.Pointcuts</em> 类中的静态方法，也可以使用同一个包中的 <em>ComposablePointcut</em> 类来组合。但是，使用 AspectJ 切点表达式通常是更简单的方法。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-aspectj"><a class="anchor" href="#aop-api-pointcuts-aspectj"></a>6.2.3. AspectJ 表达式切面</h4>
<div class="paragraph">
<p>从2.0开始，Spring 使用的最重要的切点类型是 <code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>。这是一个使用 AspectJ 提供的库来解析 AspectJ 切点表达式字符串的切点。</p>
</div>
<div class="paragraph">
<p>有关被支持的 AspectJ 切点基本类型的讨论，请参阅上一章。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-impls"><a class="anchor" href="#aop-api-pointcuts-impls"></a>6.2.4. 便捷的切点实现</h4>
<div class="paragraph">
<p>Spring 提供了几个方便的切点实现。有些开箱即用;其他的用于在特定于应用程序的切点中进行子类化。</p>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-static"><a class="anchor" href="#aop-api-pointcuts-static"></a>静态切点</h5>
<div class="paragraph">
<p>静态切点基于方法和目标类，方法的参数不列入考虑范围。对于大多数用途来说，静态切点已经足够，而且是最佳的。当一个方法第一次被调用时，Spring 可能只对静态切入点进行一次性评估：在这之后，不需要再为每次方法调执行切入点评估。</p>
</div>
<div class="paragraph">
<p>考虑 Spring 包含的一些静态切点实现。</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-regex"><a class="anchor" href="#aop-api-pointcuts-regex"></a>正则表达式切点</h6>
<div class="paragraph">
<p>指定静态切点的一个显而易见的方法是用正则表达式。Spring 之外的几个 AOP 框架使这种方法成为可能。<code>org.springframework.aop.support.JdkRegexpMethodPointcut</code> 是一个通用的正则表达式切点，使用 JDK 1.4+ 中的正则表达式支持。</p>
</div>
<div class="paragraph">
<p>使用<code>JdkRegexpMethodPointcut</code> 类，就可以提供一个模式字符串清单。如果其中任何一个匹配，那么这个切点的评估结果会是 true（因此结果就是这些切点的有效“联合”）。</p>
</div>
<div class="paragraph">
<p>使用方法如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">settersAndAbsquatulatePointcut</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.support.JdkRegexpMethodPointcut</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">patterns</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*set.*<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*absquatulate<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 提供了一个方便的类，<code>RegexpMethodPointcutAdvisor</code>，它还允许我们引用一个通知（记住，通知可以是一个拦截器，前置通知，异常通知等）。在后台，Spring 将使用 <code>JdkRegexpMethodPointcut</code>。 使用 <code>RegexpMethodPointcutAdvisor</code> 简化了装配，因为一个 bean 同时封装了切点和通知，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">settersAndAbsquatulateAdvisor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.support.RegexpMethodPointcutAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">advice</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanNameOfAopAllianceInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">patterns</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*set.*<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*absquatulate<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>RegexpMethodPointcutAdvisor</em> 适用于所有通知类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-attribute-driven"><a class="anchor" href="#aop-api-pointcuts-attribute-driven"></a>Attribute 驱动的切点</h6>
<div class="paragraph">
<p>元数据驱动的切点是静态切点中的重要类型。它使用元数据特性的值：通常是源代码级别的元数据。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-dynamic"><a class="anchor" href="#aop-api-pointcuts-dynamic"></a>动态切点</h5>
<div class="paragraph">
<p>动态切点比静态切点代价更大。它们考虑了方法实参以及静态信息。这意味着它们必须用评估每个方法调用；结果不能被缓存，因为实参会有所不同。</p>
</div>
<div class="paragraph">
<p>The main example is the <code>control flow</code> pointcut.</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-cflow"><a class="anchor" href="#aop-api-pointcuts-cflow"></a>控制流切点</h6>
<div class="paragraph">
<p>Spring 控制流切点在概念上类似于 AspectJ cflow 切点，虽然功能较弱。（目前没有办法指定一个切点在另一个切点匹配的连接点下面执行）。一个控制流切点匹配当前的调用栈。例如，如果连接点是由 <code>com.mycompany.web</code> 包中的方法或 <code>SomeCaller</code> 类调用的，则可能会触发它。控制流切点使用 <code>org.springframework.aop.support.ControlFlowPointcut</code> 类来指定。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与其他动态切点相比，控制流切点在运行时评估的代价更大。在 Java 1.4 中，成本约为其他动态切点的5倍。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-superclasses"><a class="anchor" href="#aop-api-pointcuts-superclasses"></a>6.2.5. 切点超类</h4>
<div class="paragraph">
<p>Spring 提供了有用的切点超类来帮助你实现自己的切点。</p>
</div>
<div class="paragraph">
<p>由于静态切点非常有用，因此你可能继承 StaticMethodMatcherPointcut 得到子类，如下所示。只需要实现一个抽象方法（也可以重写其他方法来自定义行为）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TestStaticPointcut</span> <span class="directive">extends</span> StaticMethodMatcherPointcut {

        <span class="directive">public</span> <span class="type">boolean</span> matches(<span class="predefined-type">Method</span> m, <span class="predefined-type">Class</span> targetClass) {
                <span class="comment">// return true if custom criteria match</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也存在针对动态切点的超类。</p>
</div>
<div class="paragraph">
<p>你可以在 Spring 1.0 RC2 及更高版本中使用任何通知类型的自定义切=点。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-custom"><a class="anchor" href="#aop-api-pointcuts-custom"></a>6.2.6. 自定义切点</h4>
<div class="paragraph">
<p>由于 Spring AOP 中的切点是 Java 类，而不是语言特性（如 AspectJ 中的），所以可以声明自定义的切点，无论是静态的还是动态的。Spring 中的自定义切点可以任意复杂。 但是，如果可能的话，建议使用AspectJ切入点表达式语言。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p> Spring 的后续版本可能支持由 JAC 提供的 “语义切点” ：例如，“更改目标对象中的实例变量的所有方法”。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advice"><a class="anchor" href="#aop-api-advice"></a>6.3. Spring 中的通知 API</h3>
<div class="paragraph">
<p>现在我们来看看Spring AOP如何处理通知。</p>
</div>
<div class="sect3">
<h4 id="aop-api-advice-lifecycle"><a class="anchor" href="#aop-api-advice-lifecycle"></a>6.3.1. 通知的生命周期</h4>
<div class="paragraph">
<p>每个通知都是一个 Spring bean。通知实例可以被所有被通知的对象共享，或者对每个被通知对象都是唯一的。 这对应于与类一一对应或与实例一一对应的通知。</p>
</div>
<div class="paragraph">
<p>与类一一对应的通知最常使用。适用于事务通知器等通用通知。这些不依赖于代理对象的状态或添加新的状态; 他们只是在方法和参数上进行操作。</p>
</div>
<div class="paragraph">
<p>与实例一一对应的通知适合与引入，以支持混合。在这种情况下，通知将状态添加到代理对象。</p>
</div>
<div class="paragraph">
<p>可以在同一个 AOP 代理中混合使用共享通知和原型通知。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-types"><a class="anchor" href="#aop-api-advice-types"></a>6.3.2. Spring 中的通知类型</h4>
<div class="paragraph">
<p>Spring 提供了几种开箱即用的通知类型，并且可以扩展以支持任意的通知类型。让我们看看基本概念和标准通知类型。</p>
</div>
<div class="sect4">
<h5 id="aop-api-advice-around"><a class="anchor" href="#aop-api-advice-around"></a>拦截环绕通知</h5>
<div class="paragraph">
<p>Spring 中最基本的通知类型是 <em>拦截环绕通知</em>.</p>
</div>
<div class="paragraph">
<p>Spring 使用方法拦截来满足 AOP Alliance 接口的要求。实施环绕通知的 MethodInterceptors 应该实现以下接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodInterceptor</span> <span class="directive">extends</span> Interceptor {

        <span class="predefined-type">Object</span> invoke(MethodInvocation invocation) <span class="directive">throws</span> <span class="predefined-type">Throwable</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>invoke()</code> 方法的 <code>MethodInvocation</code> 参数暴露正在调用的方法；目标连接点；AOP 代理；和方法的参数。<code>invoke()</code> 方法应该返回调用的结果：连接点的返回值。</p>
</div>
<div class="paragraph">
<p>一个简单的 <code>MethodInterceptor</code> 实现如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DebugInterceptor</span> <span class="directive">implements</span> MethodInterceptor {

        <span class="directive">public</span> <span class="predefined-type">Object</span> invoke(MethodInvocation invocation) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Before: invocation=[</span><span class="delimiter">&quot;</span></span> + invocation + <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>);
                <span class="predefined-type">Object</span> rval = invocation.proceed();
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Invocation returned</span><span class="delimiter">&quot;</span></span>);
                <span class="keyword">return</span> rval;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意对 MethodInvocation 的 <code>proceed()</code> 方法的调用。它沿着拦截器链向着连接点前进。大多数拦截器都会调用这个方法，并返回它的返回值。然而，MethodInterceptor 与任何环绕通知一样，可以返回不同的值或抛出异常，而不是调用 proceed 方法。但是，如果没有充分的理由你不会这样做！</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>MethodInterceptors 提供与其他符合 AOP 联盟的 AOP 实现的互操作性。本节其余部分讨论的其他通知类型采用 Spring 特有的方式实现常见的 AOP 概念。尽管在使用最具体的通知类型方面有优势，但如果你希望在另一个AOP 框架中运行该切面，请使用 MethodInterceptor 环绕通知。注意，切点目前不能在框架之间互操作，并且AOP 联盟当前不定义切点接口。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-before"><a class="anchor" href="#aop-api-advice-before"></a>前置通知</h5>
<div class="paragraph">
<p>一个更简单的通知类型是 <em>前置通知</em>。它不需要 <code>MethodInvocation</code> 对象，因为它只会在进入方法之前被调用。</p>
</div>
<div class="paragraph">
<p>前置通知主要优点是不需要调用 <code>proceed()</code> 方法，因此不可能出于意外而无法执行拦截器链。</p>
</div>
<div class="paragraph">
<p><code>MethodBeforeAdvice</code> 接口如下所示。（Spring 的 API 设计允许在字段前置通知，尽管通常对象用于属性拦截，且不像 Spring 会实现它）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodBeforeAdvice</span> <span class="directive">extends</span> BeforeAdvice {

        <span class="type">void</span> before(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target) <span class="directive">throws</span> <span class="predefined-type">Throwable</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意返回类型是 <code>void</code>。前置通知可以在连接点执行之前插入自定义行为，但不能更改返回值。 如果前置通知引发异常，则会中止进一步执行拦截器链。异常将传播回拦截器链。如果它不是受检异常，或者它在被调用方法的签名上抛出，则它会被直接传递给客户端; 否则它将被 AOP 代理封装在未受检异常中。</p>
</div>
<div class="paragraph">
<p>Spring中的前置通知的一个例子，它计算所有的方法调用次数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CountingBeforeAdvice</span> <span class="directive">implements</span> MethodBeforeAdvice {

        <span class="directive">private</span> <span class="type">int</span> count;

        <span class="directive">public</span> <span class="type">void</span> before(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                ++count;
        }

        <span class="directive">public</span> <span class="type">int</span> getCount() {
                <span class="keyword">return</span> count;
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>前置通知可用于任何切点。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-throws"><a class="anchor" href="#aop-api-advice-throws"></a>异常通知</h5>
<div class="paragraph">
<p><em>异常通知</em> 在连接点抛出异常返回之后被调用。Spring 提供了类型化的异常通知。注意这意味着 <code>org.springframework.aop.ThrowsAdvice</code> 接口不包含任何方法：它是一个标记接口，用于标识给定对象实现一个或多个类型化的异常通知方法。它们的形式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">afterThrowing([<span class="predefined-type">Method</span>, args, target], subclassOfThrowable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有最后一个参数是必需的。方法签名可以有一个或四个参数，具体取决于通知方法是否对方法和参数感兴趣。 以下类是异常通知的示例。</p>
</div>
<div class="paragraph">
<p>如果抛出 <code>RemoteException</code>（包括子类）异常，则调用以下通知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">RemoteThrowsAdvice</span> <span class="directive">implements</span> ThrowsAdvice {

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="exception">RemoteException</span> ex) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// Do something with remote exception</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果抛出 <code>ServletException</code>，将调用以下通知。与上面的通知不同，它声明了4个参数，以便它可以访问被调用的方法，方法参数和目标对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ServletThrowsAdviceWithArguments</span> <span class="directive">implements</span> ThrowsAdvice {

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target, ServletException ex) {
                <span class="comment">// Do something with all arguments</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个例子说明了如何在单个类中使用这两种方法，该类同时处理 <code>RemoteException</code> 和 <code>ServletException</code> 。 任何数量的异常通知方法可以合并到一个类中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">CombinedThrowsAdvice</span> <span class="directive">implements</span> ThrowsAdvice {

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="exception">RemoteException</span> ex) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// Do something with remote exception</span>
        }

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target, ServletException ex) {
                <span class="comment">// Do something with all arguments</span>
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果异常通知方法本身抛出异常，它将覆盖原始异常（即更改抛出给用户的异常）。重写的异常通常是RuntimeException; 这与任何方法签名都是兼容的。但是，如果异常通知方法抛出一个受检异常，它必须匹配目标方法的声明异常，因此在某种程度上与特定的目标方法签名相关联。<em>不要抛出与目标方法签名不兼容的未声明受检异常！</em></p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>异常通知可用于任何切点。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-after-returning"><a class="anchor" href="#aop-api-advice-after-returning"></a>返回通知</h5>
<div class="paragraph">
<p>Spring 中的返回通知必须实现 <em>org.springframework.aop.AfterReturningAdvice</em> 接口，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AfterReturningAdvice</span> <span class="directive">extends</span> Advice {

        <span class="type">void</span> afterReturning(<span class="predefined-type">Object</span> returnValue, <span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target)
                        <span class="directive">throws</span> <span class="predefined-type">Throwable</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回通知可以访问返回值（不能修改），调用的方法，方法参数和目标。</p>
</div>
<div class="paragraph">
<p>下面的返回通知计算所有未抛出异常的方法调用次数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CountingAfterReturningAdvice</span> <span class="directive">implements</span> AfterReturningAdvice {

        <span class="directive">private</span> <span class="type">int</span> count;

        <span class="directive">public</span> <span class="type">void</span> afterReturning(<span class="predefined-type">Object</span> returnValue, <span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target)
                        <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                ++count;
        }

        <span class="directive">public</span> <span class="type">int</span> getCount() {
                <span class="keyword">return</span> count;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此通知不会更改执行路径。如果它抛出一个异常，异常将被抛到拦截器链而不是返回值。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>返回通知可用于任何切点。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-introduction"><a class="anchor" href="#aop-api-advice-introduction"></a>引入通知</h5>
<div class="paragraph">
<p>Spring 将引入通知作为一种特殊的拦截通知。 i</p>
</div>
<div class="paragraph">
<p>引入需要一个 <code>IntroductionAdvisor</code>，和一个 <code>IntroductionInterceptor</code>，实现下面的接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionInterceptor</span> <span class="directive">extends</span> MethodInterceptor {

        <span class="type">boolean</span> implementsInterface(<span class="predefined-type">Class</span> intf);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 AOP Alliance <code>MethodInterceptor</code> 接口继承的 <code>invoke()</code> 方法必须实现这个引入：即，如果被调用的方法位于引入的接口上，引入拦截器负责处理方法调用 - 它不能调用 <code>proceed()</code> 。</p>
</div>
<div class="paragraph">
<p>引入通知不能用于任何切点，因为它仅适用于类级别，而不是方法级别。你只能使用 <code>IntroductionAdvisor</code> 引入通知，它有以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionAdvisor</span> <span class="directive">extends</span> Advisor, IntroductionInfo {

        ClassFilter getClassFilter();

        <span class="type">void</span> validateInterfaces() <span class="directive">throws</span> <span class="exception">IllegalArgumentException</span>;
}

<span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionInfo</span> {

        <span class="predefined-type">Class</span><span class="type">[]</span> getInterfaces();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有 <code>MethodMatcher</code>，也没有 <code>Pointcut</code> 与引入通知关联。 只有类过滤是合乎逻辑的。</p>
</div>
<div class="paragraph">
<p><code>getInterfaces()</code> 方法返回被此通知引入的接口。</p>
</div>
<div class="paragraph">
<p><code>validateInterfaces()</code> 方法用于查看引入的接口是否可以用过配置的 <code>IntroductionInterceptor</code> 实现。</p>
</div>
<div class="paragraph">
<p>我们看一下 Spring test suite 中的一个简单示例。假设我们想将以下的接口引入到一个或多个对象中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lockable</span> {
        <span class="type">void</span> lock();
        <span class="type">void</span> unlock();
        <span class="type">boolean</span> locked();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个 <em>混合</em> 用法。我们希望能够将被通知的对象转换为Lockable，无论他们的类型是什么，并能调用 lock 和 unlock 方法。如果我们调用 lock() 方法，我们希望所有 setter 方法都抛出 <code>LockedException</code> 异常。因此，我们可以添加一个切面，提供使对象不可变的能力，而不需要他们有任何与切面相关的知识：AOP 的一个很好的例子。</p>
</div>
<div class="paragraph">
<p>首先，我们需要一个完成繁重工作的 <code>IntroductionInterceptor</code>。在这种情况下，我们扩展 <code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code> 便捷类。我们可以直接实现 IntroductionInterceptor，但使用 <code>DelegatingIntroductionInterceptor</code> 最适合大多数情况。</p>
</div>
<div class="paragraph">
<p><code>DelegatingIntroductionInterceptor</code> 的设计目的是将引入委托给被引入的接口的实际实现，隐藏对拦截的使用来实现。可以使用构造器参数将代理设置为任何对象；默认委托（当无参构造器被使用时）就是这样的。因此，在下面的示例中，委托是 <code>DelegatingIntroductionInterceptor</code> 的子类 <code>LockMixin</code>。给定的委托（默认是其本身），<code>DelegatingIntroductionInterceptor</code> 实例将查找由委托实现的所有接口（除 IntroductionInterceptor 之外），并支持针对其中任何接口的引入。像 <code>LockMixin</code> 这样的子类可以调用 <code>suppressInterface(Class intf)</code> 方法来压制不应该暴露的接口。但是，无论 <code>IntroductionInterceptor</code> 准备支持多少接口，其所使用的 <code>IntroductionAdvisor</code> 才控制实际暴露的接口。被引入接口将隐藏目标对相同接口的任何实现。</p>
</div>
<div class="paragraph">
<p>因此 <code>LockMixin</code> 扩展了 <code>DelegatingIntroductionInterceptor</code> 并实现了 <code>Lockable</code> 本身。超类会自动提取支持引入的 Lockable ，所以我们不需要手动指定。我们可以用这种方式引入任意数量的接口。</p>
</div>
<div class="paragraph">
<p>注意对 <code>locked</code> 实例变量的使用。这有效地将附加状态添加到目标对象中的状态中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">LockMixin</span> <span class="directive">extends</span> DelegatingIntroductionInterceptor <span class="directive">implements</span> Lockable {

        <span class="directive">private</span> <span class="type">boolean</span> locked;

        <span class="directive">public</span> <span class="type">void</span> lock() {
                <span class="local-variable">this</span>.locked = <span class="predefined-constant">true</span>;
        }

        <span class="directive">public</span> <span class="type">void</span> unlock() {
                <span class="local-variable">this</span>.locked = <span class="predefined-constant">false</span>;
        }

        <span class="directive">public</span> <span class="type">boolean</span> locked() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.locked;
        }

        <span class="directive">public</span> <span class="predefined-type">Object</span> invoke(MethodInvocation invocation) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="keyword">if</span> (locked() &amp;&amp; invocation.getMethod().getName().indexOf(<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>) == <span class="integer">0</span>) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> LockedException();
                }
                <span class="keyword">return</span> <span class="local-variable">super</span>.invoke(invocation);
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常不需要重写 <code>invoke()</code> 方法：<code>DelegatingIntroductionInterceptor</code> 实现 - 在引入方法时调用委托方法，否则继续向联接点进行 - 通常就足够了。 在本例中，我们需要添加一个检查：如果处于锁定模式，则不能调用 setter 方法。</p>
</div>
<div class="paragraph">
<p>引入通知的必要条件很简单。它需要做的只是保存一个独特的 <code>LockMixin</code> 实例，并指定引入的接口 - 在这个例子中，就是 <code>Lockable</code>。 一个更复杂的例子可能会引用引入拦截器（将被定义为原型）：在这个例子中，没有与 <code>LockMixin</code> 相关的配置，因此我们只需使用 <code>new</code> 来创建它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">LockMixinAdvisor</span> <span class="directive">extends</span> DefaultIntroductionAdvisor {

        <span class="directive">public</span> LockMixinAdvisor() {
                <span class="local-variable">super</span>(<span class="keyword">new</span> LockMixin(), Lockable.class);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以非常简单地应用这个通知：它不需要配置。（然而，这是必要的：如果没有 <em>IntroductionAdvisor</em>，就不可能使用 <code>IntroductionInterceptor</code>。）与通常情况一样，通知必须是与实例一一对应，因为它是有状态的。对于每个通知的对象，我们需要一个不同的 <code>LockMixinAdvisor</code> 实例，和不同的 <code>LockMixin</code> 实例。通知包含通知对象状态的一部分。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>Advised.addAdvisor()</code> 方法以编程方式应用此通知器，或者像其他任何通知器一样在 XML 配置中使用推荐的方式。下面讨论的所有代理创建选项，包括“自动代理创建者”，都能正确处理引入和有状态的混合使用。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advisor"><a class="anchor" href="#aop-api-advisor"></a>6.4. Spring 中的通知器 API </h3>
<div class="paragraph">
<p>在 Spring 中，通知器是一个只包含与切点表达式关联的单个通知对象的切面。</p>
</div>
<div class="paragraph">
<p>除了特殊情况的引入外，任何通知器都可以使用任何通知。 <code>org.springframework.aop.support.DefaultPointcutAdvisor</code> 是最常用的通知器类。例如，他可以与 <code>MethodInterceptor</code>，<code>BeforeAdvice</code> 或者 <code>ThrowsAdvice</code> 一起使用。</p>
</div>
<div class="paragraph">
<p>Spring 可以在同一个 AOP 代理中混合使用通知器和通知类型。例如，你可以在一个代理配置中使用环绕通知的拦截，异常通知和前置通知：Spring 将自动创建必要的拦截器链。</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-pfb"><a class="anchor" href="#aop-pfb"></a>6.5. 使用 ProxyFactoryBean 创建 AOP 代理</h3>
<div class="paragraph">
<p>如果你使用 Spring IoC 容器（ApplicationContext 或 BeanFactory）作为业务对象 - 那么你应该 - 你会想使用 Spring 的 AOP FactoryBeans。（记住，工厂 bean 引入了一个间接层，使其能够创建不同类型的对象。）</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Spring AOP support also uses factory beans under the covers.（不懂？？？）</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 Spring 中创建 AOP 代理的基本方法是使用 <em>org.springframework.aop.framework.ProxyFactoryBean</em>。这样可以完全控制将要应用的切点和通知，以及它们的排序。但是，如果你不需要这种控制，则有更简单的选择。</p>
</div>
<div class="sect3">
<h4 id="aop-pfb-1"><a class="anchor" href="#aop-pfb-1"></a>6.5.1. 基础</h4>
<div class="paragraph">
<p>与其他Spring <code>FactoryBean</code> 实现一样，<code>ProxyFactoryBean</code> 引入了间接级别。如果用名称 <code>foo</code> 定义 <code>ProxyFactoryBean</code>，那么引用 <code>foo</code> 的对象不是 <code>ProxyFactoryBean</code> 实例本身，而是由 <code>ProxyFactoryBean 实现 getObject() </code> 方法创建的对象。此方法将创建包装目标对象的 AOP 代理。</p>
</div>
<div class="paragraph">
<p>使用 <code>ProxyFactoryBean</code> 或另一个支持 IoC 的类创建 AOP 代理的最重要的好处之一是，这意味着通知和切点也可以由 IoC 管理。这是一个强大的功能，支持某些难以用其他 AOP 框架实现的方法。例如，一个通知本身可以引用应用对象（除了应该在任何 AOP 框架中可用的目标之外），并受益于依赖注入提供的所有可插入性。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-2"><a class="anchor" href="#aop-pfb-2"></a>6.5.2. JavaBean 属性</h4>
<div class="paragraph">
<p>与 Spring 提供的大多数 <code>FactoryBean</code> 实现一样，<code>ProxyFactoryBean</code> 类本身就是一个 JavaBean。其属性用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>指定你想要代理的目标。</p>
</li>
<li>
<p>指定是否使用 CGLIB（请参阅下文以及 <a href="#aop-pfb-proxy-types">基于 JDK 和 CGLIB 的代理</a>）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一些关键属性是从 <code>org.springframework.aop.framework.ProxyConfig</code> 继承而来的（Spring 中所有 AOP 代理工厂的超类）。这些关键属性包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyTargetClass</code>：如果要代理目标类，而不是目标类的接口，则为 <code>true</code>。如果此属性值设置为 <code>true</code>，则将创建CGLIB代理（也可以参阅 <a href="#aop-pfb-proxy-types">基于 JDK 和 CGLIB 的代理</a>）。</p>
</li>
<li>
<p><code>optimize</code>：控制是否将积极的优化应用于 <em>通过CGLIB创建的</em> 代理。除非完全理解相关 AOP 代理如何处理优化，否则不应该轻率使用此设置。这目前仅用于 CGLIB 代理;它对 JDK 动态代理无效。</p>
</li>
<li>
<p><code>frozen</code>：如果代理配置被冻结，则不再允许更改配置。这对于轻微优化以及在代理创建后不希望调用者能够操作代理（通过<code>Advised</code> 接口）的情况都很有用。此属性的默认值为 <code>false</code>，因此允许更改（如添加其他额外的通知）。</p>
</li>
<li>
<p><code>exposeProxy</code>：确定当前代理是否应该暴露在 <code>ThreadLocal</code>  中，以便目标可以访问它。如果目标需要获取代理并且 <code>exposeProxy</code> 属性设置为true，则目标可以使用 <code>AopContext.currentProxy()</code> 方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ProxyFactoryBean</code> 特有的其他属性包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyInterfaces</code>：接口名字符串数组。如果未提供，则将使用目标类的 CGLIB 代理（也可以参阅 <a href="#aop-pfb-proxy-types">基于 JDK 和 CGLIB 的代理</a>）。</p>
</li>
<li>
<p><code>interceptorNames</code>：要应用的 <code>Advisor</code>，拦截器或其他通知的名字的字符串数组。排序很重要，原则是先到先服务。也就是说列表中的第一个拦截器将是第一个能够拦截调用的拦截器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些名称是当前工厂中的 bean 名称，包括来自祖先工厂的 bean 名称。你不能在这里提及 bean 引用，因为这样做会导致 <code>ProxyFactoryBean</code> 忽略通知的单例设置。</p>
</div>
<div class="paragraph">
<p>你可以附加一个带有星号（<code>*</code>）的拦截器名字。这将导致应用中所有以星号前的部分开头的所有通知器 bean 被应用。使用此功能的示例可以在 <a href="#aop-global-advisors">使用'全局'通知器</a> 中找到。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>singleton：无论如何工厂都应该返回单个对象，不管调用 <code>getObject()</code> 方法的频率如何。几个 <code>FactoryBean</code> 实现提供了这样一种方法。 默认值是 <code>true</code> 。如果你想使用有状态的通知 - 例如，有状态的混合 - 使用原型通知以及单例值 <code>false</code>。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-proxy-types"><a class="anchor" href="#aop-pfb-proxy-types"></a>6.5.3. 基于 JDK 和基于 CGLIB 的代理</h4>
<div class="paragraph">
<p> 本节作为关于 <code>ProxyFactoryBean</code> 如何选择为特定目标对象（即将被代理）创建一个基于JDK 和 CGLIB 的代理的权威性文档。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ProxyFactoryBean</code> 在创建基于 JDK 或 CGLIB 的代理方面的行为在 Spring 的 1.2.x 和 2.0 版本之间发生了变化。现在的 <code>ProxyFactoryBean</code> 展示了类似于 <code>TransactionProxyFactoryBean</code> 类的自动检测接口的语义。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果要被代理的目标对象（以下简称为目标类）的类没有实现任何接口，则将创建一个基于 CGLIB 的代理。这是最简单的情况，因为 JDK 代理是基于接口的，没有接口意味着 JDK 代理是不可能的。只需插入目标 bean，并通过 interceptorNames 属性指定拦截器列表。注意即使 <code>ProxyFactoryBean</code> 的 <code>proxyTargetClass</code> 属性已设置为 <code>false</code>，也会创建基于 CGLIB 的代理。 （显然这是没有意义的，并且最好从 bean 定义中删除，因为它至少是多余的，最坏情况下会令人困惑。）</p>
</div>
<div class="paragraph">
<p>如果目标类实现一个（或多个）接口，则创建的代理类型取决于 <code>ProxyFactoryBean</code> 的配置。</p>
</div>
<div class="paragraph">
<p>如果 <code>ProxyFactoryBean</code> 的 <code>proxyTargetClass</code> 属性已设置为 <code>true</code>，则将创建一个基于 CGLIB 的代理。这很符合逻辑，并且符合最少令人惊讶的原则。即使 <code>ProxyFactoryBean</code> 的 <code>proxyInterfaces</code> 属性已设置为一个或多个完全限定的接口名，但 <code>proxyTargetClass</code> 属性设置为 <code>true</code> 的事实将导致基于 CGLIB 的代理生效。</p>
</div>
<div class="paragraph">
<p>如果 <code>ProxyFactoryBean</code>  的 <code>proxyInterfaces</code> 属性已被设置为一个或多个完全限定的接口名称，则将创建一个基于JDK的代理。创建的代理将实现在 <code>proxyInterfaces</code> 属性中指定的所有接口；如果目标类恰好实现了比 <code>proxyInterfaces</code> 属性中指定的接口多得多的接口，那就很好，但这些多出来的接口将不会被返回的代理实现。</p>
</div>
<div class="paragraph">
<p>如果 <code>ProxyFactoryBean</code>  的 <code>proxyInterfaces</code> 属性属性尚未设置，但目标类 <em>确实实现了一个（或多个）</em> 接口，那么 <code>ProxyFactoryBean</code> 将自动检测目标类是否实现至少一个接口的事实，且将创建基于 JDK 的代理。实际被代理的接口将是目标类实现的所有接口；实际上，这与简单地将目标类实现的每个接口的列表提供给 <code>proxyInterfaces</code> 属性相同。但是，它的工作量要少得多，而且不太容易出现拼写错误。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-intf"><a class="anchor" href="#aop-api-proxying-intf"></a>6.5.4. 代理接口</h4>
<div class="paragraph">
<p>让我们看一下 <code>ProxyFactoryBean</code> 的一个简单示例。这个例子涉及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将被代理的 <em>目标 bean</em>。这是下面示例中的 "personTarget" bean 定义。</p>
</li>
<li>
<p>用于提供通知的 Advisor（通知器）和 Interceptor（拦截器） 。</p>
</li>
<li>
<p>一个 AOP 代理 bean 定义，指定目标对象（personTarget bean）以及要代理的接口以及要应用的通知。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">personTarget</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.PersonImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Tony</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">51</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someProperty</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Custom string property value</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">debugInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.DebugInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">proxyInterfaces</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.Person</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">personTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>myAdvisor<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>debugInterceptor<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，<code>interceptorNames</code> 属性接受一个字符串列表：当前工厂中拦截器或通知器的 bean 名称。通知器，拦截器，前置通知，返回通知，异常通知都可以使用。通知器的排序很重要。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可能想知道为什么列表不包含 bean 引用。原因是如果 ProxyFactoryBean 的 singleton 属性设置为 false，它必须能够返回独立的代理实例。如果任何通知器本身就是一个原型，那么就需要返回一个独立的实例，所以有必要从工厂获得一个原型实例; 保存一个引用是不够的。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的 “person” bean 定义可以用来代替 Person 实现，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Person person = (Person) factory.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>与普通的 Java 对象一样，同一 IoC 上下文中的其他 bean 可以表达强类型依赖关系：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">personUser</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.PersonUser</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span><span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例中的 <code>PersonUser</code> 类将暴露 Person 类型的属性。就其而言，AOP 代理可以透明地用来代替“真实”的 person 实现。但是，它的类是一个动态代理类。可以将它转换成<code>Advised</code> 接口（下面讨论）。</p>
</div>
<div class="paragraph">
<p>可以使用匿名内部 bean 隐藏目标和代理之间的区别，如下所示。只有 <code>ProxyFactoryBean</code> 定义不同; 该通知只是为了完整性考虑：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someProperty</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Custom string property value</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">debugInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.DebugInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">proxyInterfaces</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.Person</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- Use inner bean, not local reference to target --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.PersonImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Tony</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">51</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>myAdvisor<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>debugInterceptor<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这具有如下优点：只有一个 <code>Person</code> 类型的对象：如果我们想阻止应用程序上下文的用户获得对未通知对象的引用，或者需要避免使用 Spring IoC 自动装配出现任何歧义，那么这很有用。ProxyFactoryBean 定义是独立的，这也有一个优势。但是，有时能够从工厂获得未通知的目标实际上可能反而是一个优势：例如，在某些测试场景中。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-class"><a class="anchor" href="#aop-api-proxying-class"></a>6.5.5. 代理类</h4>
<div class="paragraph">
<p>如果您需要代理一个类而不是一个或多个接口，该怎么办？</p>
</div>
<div class="paragraph">
<p>想象一下，在我们上面的示例中，没有 <code>Person</code> 接口：我们需要通知一个名为 <code>Person</code> 的类，它没有实现任何业务接口。在这种情况下，你可以将 Spring 配置为使用 CGLIB 代理，而不是动态代理。只需将上面的 ProxyFactoryBean 上的 <code>proxyTargetClass</code> 属性设置为 true 即可。尽管最好对接口进行编程，而不是类，但在处理遗留代码时，具有通知未实现接口的类的能力会很有用。（一般来说，Spring 不是严格规范的，虽然它可以很容易地应用与良好的实践，但它避免了强制使用某种特定的方式。）</p>
</div>
<div class="paragraph">
<p>如果你愿意，你可以在任何情况下强制使用 CGLIB，即使实现了接口。</p>
</div>
<div class="paragraph">
<p>CGLIB 代理通过在运行时生成目标类的子类来工作。Spring 将这个生成的子类配置为将方法调用委托给原始目标：子类用于实现 <em>Decorator</em> 装饰者模式，在通知中织入。</p>
</div>
<div class="paragraph">
<p>CGLIB 代理通常应该对用户透明。但是，有一些问题需要考虑：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Final</code> 方法不能被通知，因为它们不能被覆盖。</p>
</li>
<li>
<p>不需要将 CGLIB 添加到类路径中。从 Spring 3.2 开始，CGLIB 被重新打包并包含在 Spring-JAR 中。换句话说，与 JDK 动态代理一样，基于 CGLIB 的 AOP 是“开箱即用”的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CGLIB 代理和动态代理之间几乎没有性能差异。从 Spring 1.0 开始，动态代理稍快一点。但是，这可能在未来发生变化。在这种情况下，性能不应该成为决定性的考虑因素。</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-global-advisors"><a class="anchor" href="#aop-global-advisors"></a>6.5.6. 使用'全局' advisor 通知器</h4>
<div class="paragraph">
<p>通过向拦截器名称附加星号，所有具有与星号前的部分匹配的 bean 名称的通知器将被添加到通知链中。 如果你需要添加一组标准的“全局”通知器，这可以派上用场：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">proxy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">service</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>global*<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">global_debug</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.DebugInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">global_performance</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.PerformanceMonitorInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-concise-proxy"><a class="anchor" href="#aop-concise-proxy"></a>6.6. Concise proxy definitions</h3>
<div class="paragraph">
<p>Especially when defining transactional proxies, you may end up with many similar proxy
definitions. The use of parent and child bean definitions, along with inner bean
definitions, can result in much cleaner and more concise proxy definitions.</p>
</div>
<div class="paragraph">
<p>First a parent, <em>template</em>, bean definition is created for the proxy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">txProxyTemplate</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;props&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/prop&gt;</span>
                <span class="tag">&lt;/props&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will never be instantiated itself, so may actually be incomplete. Then each proxy
which needs to be created is just a child bean definition, which wraps the target of the
proxy as an inner bean definition, since the target will never be used on its own anyway.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">txProxyTemplate</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.MyServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is of course possible to override properties from the parent template, such as in
this case, the transaction propagation settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mySpecialService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">txProxyTemplate</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.MySpecialServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;props&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">get*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">find*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">load*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">store*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/prop&gt;</span>
                <span class="tag">&lt;/props&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in the example above, we have explicitly marked the parent bean definition as
<em>abstract</em> by using the <em>abstract</em> attribute, as described
<a href="#beans-child-bean-definitions">previously</a>, so that it may not actually ever be
instantiated. Application contexts (but not simple bean factories) will by default
pre-instantiate all singletons. It is therefore important (at least for singleton beans)
that if you have a (parent) bean definition which you intend to use only as a template,
and this definition specifies a class, you must make sure to set the <em>abstract</em>
attribute to <em>true</em>, otherwise the application context will actually try to
pre-instantiate it.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-prog"><a class="anchor" href="#aop-prog"></a>6.7. Creating AOP proxies programmatically with the ProxyFactory</h3>
<div class="paragraph">
<p>It&#8217;s easy to create AOP proxies programmatically using Spring. This enables you to use
Spring AOP without dependency on Spring IoC.</p>
</div>
<div class="paragraph">
<p>The following listing shows creation of a proxy for a target object, with one
interceptor and one advisor. The interfaces implemented by the target object will
automatically be proxied:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step is to construct an object of type
<code>org.springframework.aop.framework.ProxyFactory</code>. You can create this with a target
object, as in the above example, or specify the interfaces to be proxied in an alternate
constructor.</p>
</div>
<div class="paragraph">
<p>You can add advices (with interceptors as a specialized kind of advice) and/or advisors,
and manipulate them for the life of the ProxyFactory. If you add an
IntroductionInterceptionAroundAdvisor, you can cause the proxy to implement additional
interfaces.</p>
</div>
<div class="paragraph">
<p>There are also convenience methods on ProxyFactory (inherited from <code>AdvisedSupport</code>)
which allow you to add other advice types such as before and throws advice.
AdvisedSupport is the superclass of both ProxyFactory and ProxyFactoryBean.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Integrating AOP proxy creation with the IoC framework is best practice in most
applications. We recommend that you externalize configuration from Java code with AOP,
as in general.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advised"><a class="anchor" href="#aop-api-advised"></a>6.8. Manipulating advised objects</h3>
<div class="paragraph">
<p>However you create AOP proxies, you can manipulate them using the
<code>org.springframework.aop.framework.Advised</code> interface. Any AOP proxy can be cast to this
interface, whichever other interfaces it implements. This interface includes the
following methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Advisor<span class="type">[]</span> getAdvisors();

<span class="type">void</span> addAdvice(Advice advice) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> addAdvice(<span class="type">int</span> pos, Advice advice) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> addAdvisor(Advisor advisor) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> addAdvisor(<span class="type">int</span> pos, Advisor advisor) <span class="directive">throws</span> AopConfigException;

<span class="type">int</span> indexOf(Advisor advisor);

<span class="type">boolean</span> removeAdvisor(Advisor advisor) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> removeAdvisor(<span class="type">int</span> index) <span class="directive">throws</span> AopConfigException;

<span class="type">boolean</span> replaceAdvisor(Advisor a, Advisor b) <span class="directive">throws</span> AopConfigException;

<span class="type">boolean</span> isFrozen();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getAdvisors()</code> method will return an Advisor for every advisor, interceptor or
other advice type that has been added to the factory. If you added an Advisor, the
returned advisor at this index will be the object that you added. If you added an
interceptor or other advice type, Spring will have wrapped this in an advisor with a
pointcut that always returns true. Thus if you added a <code>MethodInterceptor</code>, the advisor
returned for this index will be an <code>DefaultPointcutAdvisor</code> returning your
<code>MethodInterceptor</code> and a pointcut that matches all classes and methods.</p>
</div>
<div class="paragraph">
<p>The <code>addAdvisor()</code> methods can be used to add any Advisor. Usually the advisor holding
pointcut and advice will be the generic <code>DefaultPointcutAdvisor</code>, which can be used with
any advice or pointcut (but not for introductions).</p>
</div>
<div class="paragraph">
<p>By default, it&#8217;s possible to add or remove advisors or interceptors even once a proxy
has been created. The only restriction is that it&#8217;s impossible to add or remove an
introduction advisor, as existing proxies from the factory will not show the interface
change. (You can obtain a new proxy from the factory to avoid this problem.)</p>
</div>
<div class="paragraph">
<p>A simple example of casting an AOP proxy to the <code>Advised</code> interface and examining and
manipulating its advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Advised advised = (Advised) myObject;
Advisor<span class="type">[]</span> advisors = advised.getAdvisors();
<span class="type">int</span> oldAdvisorCount = advisors.length;
<span class="predefined-type">System</span>.out.println(oldAdvisorCount + <span class="string"><span class="delimiter">&quot;</span><span class="content"> advisors</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Add an advice like an interceptor without a pointcut</span>
<span class="comment">// Will match all proxied methods</span>
<span class="comment">// Can use for interceptors, before, after returning or throws advice</span>
advised.addAdvice(<span class="keyword">new</span> DebugInterceptor());

<span class="comment">// Add selective advice using a pointcut</span>
advised.addAdvisor(<span class="keyword">new</span> DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">Added two advisors</span><span class="delimiter">&quot;</span></span>, oldAdvisorCount + <span class="integer">2</span>, advised.getAdvisors().length);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It&#8217;s questionable whether it&#8217;s advisable (no pun intended) to modify advice on a
business object in production, although there are no doubt legitimate usage cases.
However, it can be very useful in development: for example, in tests. I have sometimes
found it very useful to be able to add test code in the form of an interceptor or other
advice, getting inside a method invocation I want to test. (For example, the advice can
get inside a transaction created for that method: for example, to run SQL to check that
a database was correctly updated, before marking the transaction for roll back.)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on how you created the proxy, you can usually set a <code>frozen</code> flag, in which
case the <code>Advised</code> <code>isFrozen()</code> method will return true, and any attempts to modify
advice through addition or removal will result in an <code>AopConfigException</code>. The ability
to freeze the state of an advised object is useful in some cases, for example, to
prevent calling code removing a security interceptor. It may also be used in Spring 1.1
to allow aggressive optimization if runtime advice modification is known not to be
required.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-autoproxy"><a class="anchor" href="#aop-autoproxy"></a>6.9. Using the "auto-proxy" facility</h3>
<div class="paragraph">
<p>So far we&#8217;ve considered explicit creation of AOP proxies using a <code>ProxyFactoryBean</code> or
similar factory bean.</p>
</div>
<div class="paragraph">
<p>Spring also allows us to use "auto-proxy" bean definitions, which can automatically
proxy selected bean definitions. This is built on Spring "bean post processor"
infrastructure, which enables modification of any bean definition as the container loads.</p>
</div>
<div class="paragraph">
<p>In this model, you set up some special bean definitions in your XML bean definition file
to configure the auto proxy infrastructure. This allows you just to declare the targets
eligible for auto-proxying: you don&#8217;t need to use <code>ProxyFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to do this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using an auto-proxy creator that refers to specific beans in the current context.</p>
</li>
<li>
<p>A special case of auto-proxy creation that deserves to be considered separately;
auto-proxy creation driven by source-level metadata attributes.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="aop-autoproxy-choices"><a class="anchor" href="#aop-autoproxy-choices"></a>6.9.1. Autoproxy bean definitions</h4>
<div class="paragraph">
<p>The <code>org.springframework.aop.framework.autoproxy</code> package provides the following
standard auto-proxy creators.</p>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy"><a class="anchor" href="#aop-api-autoproxy"></a>BeanNameAutoProxyCreator</h5>
<div class="paragraph">
<p>The <code>BeanNameAutoProxyCreator</code> class is a <code>BeanPostProcessor</code> that automatically creates
AOP proxies for beans with names matching literal values or wildcards.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanNames</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdk*,onlyJdk</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>myInterceptor<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>ProxyFactoryBean</code>, there is an <code>interceptorNames</code> property rather than a list
of interceptors, to allow correct behavior for prototype advisors. Named "interceptors"
can be advisors or any advice type.</p>
</div>
<div class="paragraph">
<p>As with auto proxying in general, the main point of using <code>BeanNameAutoProxyCreator</code> is
to apply the same configuration consistently to multiple objects, with minimal volume of
configuration. It is a popular choice for applying declarative transactions to multiple
objects.</p>
</div>
<div class="paragraph">
<p>Bean definitions whose names match, such as "jdkMyBean" and "onlyJdk" in the above
example, are plain old bean definitions with the target class. An AOP proxy will be
created automatically by the <code>BeanNameAutoProxyCreator</code>. The same advice will be applied
to all matching beans. Note that if advisors are used (rather than the interceptor in
the above example), the pointcuts may apply differently to different beans.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy-default"><a class="anchor" href="#aop-api-autoproxy-default"></a>DefaultAdvisorAutoProxyCreator</h5>
<div class="paragraph">
<p>A more general and extremely powerful auto proxy creator is
<code>DefaultAdvisorAutoProxyCreator</code>. This will automagically apply eligible advisors in the
current context, without the need to include specific bean names in the auto-proxy
advisor&#8217;s bean definition. It offers the same merit of consistent configuration and
avoidance of duplication as <code>BeanNameAutoProxyCreator</code>.</p>
</div>
<div class="paragraph">
<p>Using this mechanism involves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specifying a <code>DefaultAdvisorAutoProxyCreator</code> bean definition.</p>
</li>
<li>
<p>Specifying any number of Advisors in the same or related contexts. Note that these
<em>must</em> be Advisors, not just interceptors or other advices. This is necessary
because there must be a pointcut to evaluate, to check the eligibility of each advice
to candidate bean definitions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> will automatically evaluate the pointcut contained
in each advisor, to see what (if any) advice it should apply to each business object
(such as "businessObject1" and "businessObject2" in the example).</p>
</div>
<div class="paragraph">
<p>This means that any number of advisors can be applied automatically to each business
object. If no pointcut in any of the advisors matches any method in a business object,
the object will not be proxied. As bean definitions are added for new business objects,
they will automatically be proxied if necessary.</p>
</div>
<div class="paragraph">
<p>Autoproxying in general has the advantage of making it impossible for callers or
dependencies to obtain an un-advised object. Calling getBean("businessObject1") on this
ApplicationContext will return an AOP proxy, not the target business object. (The "inner
bean" idiom shown earlier also offers this benefit.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.BusinessObject1</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- Properties omitted --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.BusinessObject2</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> is very useful if you want to apply the same advice
consistently to many business objects. Once the infrastructure definitions are in place,
you can simply add new business objects without including specific proxy configuration.
You can also drop in additional aspects very easily - for example, tracing or
performance monitoring aspects - with minimal change to configuration.</p>
</div>
<div class="paragraph">
<p>The DefaultAdvisorAutoProxyCreator offers support for filtering (using a naming
convention so that only certain advisors are evaluated, allowing use of multiple,
differently configured, AdvisorAutoProxyCreators in the same factory) and ordering.
Advisors can implement the <code>org.springframework.core.Ordered</code> interface to ensure
correct ordering if this is an issue. The TransactionAttributeSourceAdvisor used in the
above example has a configurable order value; the default setting is unordered.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy-abstract"><a class="anchor" href="#aop-api-autoproxy-abstract"></a>AbstractAdvisorAutoProxyCreator</h5>
<div class="paragraph">
<p>This is the superclass of DefaultAdvisorAutoProxyCreator. You can create your own
auto-proxy creators by subclassing this class, in the unlikely event that advisor
definitions offer insufficient customization to the behavior of the framework
<code>DefaultAdvisorAutoProxyCreator</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-autoproxy-metadata"><a class="anchor" href="#aop-autoproxy-metadata"></a>6.9.2. Using metadata-driven auto-proxying</h4>
<div class="paragraph">
<p>A particularly important type of auto-proxying is driven by metadata. This produces a
similar programming model to .NET <code>ServicedComponents</code>. Instead of defining metadata in
XML descriptors, configuration for transaction management and other enterprise services
is held in source-level attributes.</p>
</div>
<div class="paragraph">
<p>In this case, you use the <code>DefaultAdvisorAutoProxyCreator</code>, in combination with Advisors
that understand metadata attributes. The metadata specifics are held in the pointcut
part of the candidate advisors, rather than in the auto-proxy creation class itself.</p>
</div>
<div class="paragraph">
<p>This is really a special case of the <code>DefaultAdvisorAutoProxyCreator</code>, but deserves
consideration on its own. (The metadata-aware code is in the pointcuts contained in the
advisors, not the AOP framework itself.)</p>
</div>
<div class="paragraph">
<p>The <code>/attributes</code> directory of the JPetStore sample application shows the use of
attribute-driven auto-proxying. In this case, there&#8217;s no need to use the
<code>TransactionProxyFactoryBean</code>. Simply defining transactional attributes on business
objects is sufficient, because of the use of metadata-aware pointcuts. The bean
definitions include the following code, in <code>/WEB-INF/declarativeServices.xml</code>. Note that
this is generic, and can be used outside the JPetStore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.AttributesTransactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">attributes</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">attributes</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">attributes</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.metadata.commons.CommonsAttributes</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> bean definition (the name is not significant, hence
it can even be omitted) will pick up all eligible pointcuts in the current application
context. In this case, the "transactionAdvisor" bean definition, of type
<code>TransactionAttributeSourceAdvisor</code>, will apply to classes or methods carrying a
transaction attribute. The TransactionAttributeSourceAdvisor depends on a
TransactionInterceptor, via constructor dependency. The example resolves this via
autowiring. The <code>AttributesTransactionAttributeSource</code> depends on an implementation of
the <code>org.springframework.metadata.Attributes</code> interface. In this fragment, the
"attributes" bean satisfies this, using the Jakarta Commons Attributes API to obtain
attribute information. (The application code must have been compiled using the Commons
Attributes compilation task.)</p>
</div>
<div class="paragraph">
<p>The <code>/annotation</code> directory of the JPetStore sample application contains an analogous
example for auto-proxying driven by JDK 1.5+ annotations. The following configuration
enables automatic detection of Spring&#8217;s <code>Transactional</code> annotation, leading to implicit
proxies for beans containing that annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.annotation.AnnotationTransactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TransactionInterceptor</code> defined here depends on a <code>PlatformTransactionManager</code>
definition, which is not included in this generic file (although it could be) because it
will be specific to the application&#8217;s transaction requirements (typically JTA, as in
this example, or Hibernate or JDBC):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.jta.JtaTransactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you require only declarative transaction management, using these generic XML
definitions will result in Spring automatically proxying all classes or methods with
transaction attributes. You won&#8217;t need to work directly with AOP, and the programming
model is similar to that of .NET ServicedComponents.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This mechanism is extensible. It&#8217;s possible to do auto-proxying based on custom
attributes. You need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Define your custom attribute.</p>
</li>
<li>
<p>Specify an Advisor with the necessary advice, including a pointcut that is triggered
by the presence of the custom attribute on a class or method. You may be able to use
an existing advice, merely implementing a static pointcut that picks up the custom
attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s possible for such advisors to be unique to each advised class (for example, mixins):
they simply need to be defined as prototype, rather than singleton, bean definitions.
For example, the <code>LockMixin</code> introduction interceptor from the Spring test suite,
shown above, could be used in conjunction with a generic <code>DefaultIntroductionAdvisor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lockMixin</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">test.mixin.LockMixin</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lockableAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.support.DefaultIntroductionAdvisor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lockMixin</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that both <code>lockMixin</code> and <code>lockableAdvisor</code> are defined as prototypes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-targetsource"><a class="anchor" href="#aop-targetsource"></a>6.10. Using TargetSources</h3>
<div class="paragraph">
<p>Spring offers the concept of a <em>TargetSource</em>, expressed in the
<code>org.springframework.aop.TargetSource</code> interface. This interface is responsible for
returning the "target object" implementing the join point. The <code>TargetSource</code>
implementation is asked for a target instance each time the AOP proxy handles a method
invocation.</p>
</div>
<div class="paragraph">
<p>Developers using Spring AOP don&#8217;t normally need to work directly with TargetSources, but
this provides a powerful means of supporting pooling, hot swappable and other
sophisticated targets. For example, a pooling TargetSource can return a different target
instance for each invocation, using a pool to manage instances.</p>
</div>
<div class="paragraph">
<p>If you do not specify a TargetSource, a default implementation is used that wraps a
local object. The same target is returned for each invocation (as you would expect).</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the standard target sources provided with Spring, and how you can use them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When using a custom target source, your target will usually need to be a prototype
rather than a singleton bean definition. This allows Spring to create a new target
instance when required.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-ts-swap"><a class="anchor" href="#aop-ts-swap"></a>6.10.1. Hot swappable target sources</h4>
<div class="paragraph">
<p>The <code>org.springframework.aop.target.HotSwappableTargetSource</code> exists to allow the target
of an AOP proxy to be switched while allowing callers to keep their references to it.</p>
</div>
<div class="paragraph">
<p>Changing the target source&#8217;s target takes effect immediately. The
<code>HotSwappableTargetSource</code> is threadsafe.</p>
</div>
<div class="paragraph">
<p>You can change the target via the <code>swap()</code> method on HotSwappableTargetSource as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">swapper</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">Object</span> oldTarget = swapper.swap(newTarget);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The XML definitions required look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialTarget</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mycompany.OldTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">swapper</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.HotSwappableTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">swappable</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">swapper</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above <code>swap()</code> call changes the target of the swappable bean. Clients who hold a
reference to that bean will be unaware of the change, but will immediately start hitting
the new target.</p>
</div>
<div class="paragraph">
<p>Although this example doesn&#8217;t add any advice - and it&#8217;s not necessary to add advice to
use a <code>TargetSource</code> - of course any <code>TargetSource</code> can be used in conjunction with
arbitrary advice.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-pool"><a class="anchor" href="#aop-ts-pool"></a>6.10.2. Pooling target sources</h4>
<div class="paragraph">
<p>Using a pooling target source provides a similar programming model to stateless session
EJBs, in which a pool of identical instances is maintained, with method invocations
going to free objects in the pool.</p>
</div>
<div class="paragraph">
<p>A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can
be applied to any POJO. As with Spring in general, this service can be applied in a
non-invasive way.</p>
</div>
<div class="paragraph">
<p>Spring provides out-of-the-box support for Commons Pool 2.2, which provides a
fairly efficient pooling implementation. You&#8217;ll need the commons-pool Jar on your
application&#8217;s classpath to use this feature. It&#8217;s also possible to subclass
<code>org.springframework.aop.target.AbstractPoolingTargetSource</code> to support any other
pooling API.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Commons Pool 1.5+ is also supported but deprecated as of Spring Framework 4.2.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sample configuration is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyBusinessObject</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        ... properties omitted
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolTargetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.CommonsPool2TargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetBeanName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxSize</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">25</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the target object - "businessObjectTarget" in the example - <em>must</em> be a
prototype. This allows the <code>PoolingTargetSource</code> implementation to create new instances
of the target to grow the pool as necessary. See the javadocs of
<code>AbstractPoolingTargetSource</code> and the concrete subclass you wish to use for information
about its properties: "maxSize" is the most basic, and always guaranteed to be present.</p>
</div>
<div class="paragraph">
<p>In this case, "myInterceptor" is the name of an interceptor that would need to be
defined in the same IoC context. However, it isn&#8217;t necessary to specify interceptors to
use pooling. If you want only pooling, and no other advice, don&#8217;t set the
interceptorNames property at all.</p>
</div>
<div class="paragraph">
<p>It&#8217;s possible to configure Spring so as to be able to cast any pooled object to the
<code>org.springframework.aop.target.PoolingConfig</code> interface, which exposes information
about the configuration and current size of the pool through an introduction. You&#8217;ll
need to define an advisor like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolConfigAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.MethodInvokingFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetObject</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetMethod</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">getPoolingConfigMixin</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This advisor is obtained by calling a convenience method on the
<code>AbstractPoolingTargetSource</code> class, hence the use of MethodInvokingFactoryBean. This
advisor&#8217;s name ("poolConfigAdvisor" here) must be in the list of interceptors names in
the ProxyFactoryBean exposing the pooled object.</p>
</div>
<div class="paragraph">
<p>The cast will look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">PoolingConfig conf = (PoolingConfig) beanFactory.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Max pool size is </span><span class="delimiter">&quot;</span></span> + conf.getMaxSize());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Pooling stateless service objects is not usually necessary. We don&#8217;t believe it should
be the default choice, as most stateless objects are naturally thread safe, and instance
pooling is problematic if resources are cached.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Simpler pooling is available using auto-proxying. It&#8217;s possible to set the TargetSources
used by any auto-proxy creator.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-prototype"><a class="anchor" href="#aop-ts-prototype"></a>6.10.3. Prototype target sources</h4>
<div class="paragraph">
<p>Setting up a "prototype" target source is similar to a pooling TargetSource. In this
case, a new instance of the target will be created on every method invocation. Although
the cost of creating a new object isn&#8217;t high in a modern JVM, the cost of wiring up the
new object (satisfying its IoC dependencies) may be more expensive. Thus you shouldn&#8217;t
use this approach without very good reason.</p>
</div>
<div class="paragraph">
<p>To do this, you could modify the <code>poolTargetSource</code> definition shown above as follows.
(I&#8217;ve also changed the name, for clarity.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototypeTargetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.PrototypeTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetBeanName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s only one property: the name of the target bean. Inheritance is used in the
TargetSource implementations to ensure consistent naming. As with the pooling target
source, the target bean must be a prototype bean definition.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-threadlocal"><a class="anchor" href="#aop-ts-threadlocal"></a>6.10.4. ThreadLocal target sources</h4>
<div class="paragraph">
<p><code>ThreadLocal</code> target sources are useful if you need an object to be created for each
incoming request (per thread that is). The concept of a <code>ThreadLocal</code> provide a JDK-wide
facility to transparently store resource alongside a thread. Setting up a
<code>ThreadLocalTargetSource</code> is pretty much the same as was explained for the other types
of target source:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">threadlocalTargetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.ThreadLocalTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetBeanName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ThreadLocals come with serious issues (potentially resulting in memory leaks) when
incorrectly using them in a multi-threaded and multi-classloader environments. One
should always consider wrapping a threadlocal in some other class and never directly use
the <code>ThreadLocal</code> itself (except of course in the wrapper class). Also, one should
always remember to correctly set and unset (where the latter simply involved a call to
<code>ThreadLocal.set(null)</code>) the resource local to the thread. Unsetting should be done in
any case since not unsetting it might result in problematic behavior. Spring&#8217;s
ThreadLocal support does this for you and should always be considered in favor of using
ThreadLocals without other proper handling code.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-extensibility"><a class="anchor" href="#aop-extensibility"></a>6.11. Defining new Advice types</h3>
<div class="paragraph">
<p>Spring AOP is designed to be extensible. While the interception implementation strategy
is presently used internally, it is possible to support arbitrary advice types in
addition to the out-of-the-box interception around advice, before, throws advice and
after returning advice.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.aop.framework.adapter</code> package is an SPI package allowing
support for new custom advice types to be added without changing the core framework.
The only constraint on a custom <code>Advice</code> type is that it must implement the
<code>org.aopalliance.aop.Advice</code> marker interface.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>org.springframework.aop.framework.adapter</code> javadocs for further
information.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-resources"><a class="anchor" href="#aop-api-resources"></a>6.12. Further resources</h3>
<div class="paragraph">
<p>Please refer to the Spring sample applications for further examples of Spring AOP:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The JPetStore&#8217;s default configuration illustrates the use of the
<code>TransactionProxyFactoryBean</code> for declarative transaction management.</p>
</li>
<li>
<p>The <code>/attributes</code> directory of the JPetStore illustrates the use of attribute-driven
declarative transaction management.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="null-safety"><a class="anchor" href="#null-safety"></a>7. Null-safety</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although Java does not allow to express null-safety with its type system, Spring Framework
now provides following annotations in the <code>org.springframework.lang</code> package to declare
nullability of APIs and fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a> annotation where specific parameter,
return value or field cannot be <code>null</code> (not needed on parameter and return value
where <code>@NonNullApi</code> and <code>@NonNullFields</code> apply) .</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a> annotation where specific
parameter, return value or field can be <code>null</code>.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a> annotation at package level
declares non-null as the default behavior for parameters and return values.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNullFields.html"><code>@NonNullFields</code></a> annotation at package
level declares non-null as the default behavior for fields.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Framework leverages itself these annotations, but they can also be used in any Spring based
Java project to declare null-safe APIs and optionally null-safe fields. Generic type arguments,
varargs and array elements nullability are not supported yet, but should be in an upcoming
release, see <a href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a> for up-to-date information.
Nullability declaration are expected to be fine-tuned between Spring Framework release,
including minor ones. Nullability of types used inside method bodies is outside of the
scope of this feature.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Libraries like Reactor or Spring Data provide null-safe APIs leveraging this feature.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="use-cases"><a class="anchor" href="#use-cases"></a>7.1. Use cases</h3>
<div class="paragraph">
<p>In addition to providing an explicit declaration for Spring Framework API nullability,
these annotation can be used by IDE (such as IDEA or Eclipse) to provide useful
warnings to Java developers related to null-safety in order to avoid <code>NullPointerException</code>
at runtime.</p>
</div>
<div class="paragraph">
<p>They are also used to make Spring API null-safe in Kotlin projects since Kotlin natively
supports <a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>. More details
are available in <a href="kotlin.html#null-safety">Kotlin support documentation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jsr-305-meta-annotations"><a class="anchor" href="#jsr-305-meta-annotations"></a>7.2. JSR 305 meta-annotations</h3>
<div class="paragraph">
<p>Spring annotations are meta-annotated with <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>
annotations (a dormant but widely spread JSR). JSR 305 meta-annotations allows tooling vendors
like IDEA or Kotlin to provide null-safety support in a generic way, without having to hard-code
support for Spring annotations.</p>
</div>
<div class="paragraph">
<p>It is not necessary nor recommended to add JSR 305 dependency in project classpath to
take advantage of Spring null-safe API. Only projects like
Spring-based libraries using null-safety annotations in their codebase should add
<code>com.google.code.findbugs:jsr305:3.0.2</code> with <code>compileOnly</code> Gradle configuration or Maven
<code>provided</code> scope to avoid compile warnings.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. See <a href="overview.html#background-ioc">Inversion of Control</a>
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. See <a href="#beans-factory-collaborators">Dependency Injection</a>
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. But see also <a href="#resources-filesystemresource-caveats">FileSystemResource caveats</a>.
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.0.0.RELEASE<br>
Last updated 2017-09-28 11:00:47 UTC
</div>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/af2821b0/cloudflare-static/email-decode.min.js"></script><script>var rootLink=document.createElement("a");rootLink.setAttribute("href","index.html");rootLink.innerHTML="<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";var p=document.createElement("p");p.appendChild(rootLink);var toc=document.getElementById('toc')
var sectlevel1=toc.getElementsByClassName("sectlevel1")[0]
toc.insertBefore(p,sectlevel1);</script>
<script>if(window.parent==window){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-2728886-23','auto',{'siteSpeedSampleRate':100});ga('send','pageview');}</script></body>
</html>