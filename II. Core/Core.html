<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Core Technologies</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" /><style>article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]) {display:none;height:0}[hidden],template{display:none}script{display:none!important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root) {overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}meta.foundation-mq-small{font-family:"only screen and (min-width: 768px)";width:768px}meta.foundation-mq-medium{font-family:"only screen and (min-width:1280px)";width:1280px}meta.foundation-mq-large{font-family:"only screen and (min-width:1440px)";width:1440px}*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}html,body{font-size:100%}body{background:#fff;color:#34302d;padding:0;margin:0;font-family:"Varela Round",sans-serif;font-weight:normal;font-style:normal;line-height:1;position:relative;cursor:auto}a:hover{cursor:pointer}img,object,embed{max-width:100%;height:auto}object,embed{height:100%}img{-ms-interpolation-mode:bicubic}#map_canvas img,#map_canvas embed,#map_canvas object,.map_canvas img,.map_canvas embed,.map_canvas object{max-width:none!important}.left{float:left!important}.right{float:right!important}.text-left{text-align:left!important}.text-right{text-align:right!important}.text-center{text-align:center!important}.text-justify{text-align:justify!important}.hide{display:none}.antialiased{-webkit-font-smoothing:antialiased}img{display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px}select{width:100%}object,svg{display:inline-block;vertical-align:middle}.center{margin-left:auto;margin-right:auto}.spread{width:100%}p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#0b0a0a;font-weight:normal;margin-top:0;margin-bottom:.25em}div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}a{color:#548e2e;text-decoration:underline;line-height:inherit}a:hover,a:focus{color:#487a28}a img{border:none}p{font-family:inherit;font-weight:normal;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}p aside{font-size:.875em;line-height:1.35;font-style:italic}h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:Montserrat,sans-serif;font-weight:400;font-style:normal;color:#34302d;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#867c74;line-height:0}h1{font-size:2.125em}h2{font-size:1.6875em}h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}h4{font-size:1.125em}h5{font-size:1.125em}h6{font-size:1em}hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}em,i{font-style:italic;line-height:inherit}strong,b{font-weight:bold;line-height:inherit}small{font-size:60%;line-height:inherit}code{font-family:Monaco,Menlo,Consolas,"Courier New",monospace;font-weight:normal;color:rgba(0,0,0,.9)}ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}ul,ol{margin-left:1.5em}ul.no-bullet,ol.no-bullet{margin-left:1.5em}ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}ul.square{list-style-type:square}ul.circle{list-style-type:circle}ul.disc{list-style-type:disc}ul.no-bullet{list-style:none}ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}dl dt{margin-bottom:.3125em;font-weight:bold}dl dd{margin-bottom:1.25em}abbr,acronym{text-transform:uppercase;font-size:90%;color:#34302d;border-bottom:1px dotted #ddd;cursor:help}abbr{text-transform:none}blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}blockquote cite:before{content:"\2014 \0020"}blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}.vcard{display:inline-block;margin:0 0 1.25em 0;border:1px solid #ddd;padding:.625em .75em}.vcard li{margin:0;display:block}.vcard .fn{font-weight:bold;font-size:.9375em}.vevent .summary{font-weight:bold}.vevent abbr{cursor:auto;text-decoration:none;font-weight:bold;border:none;padding:0 .0625em}@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}h1{font-size:2.75em}h2{font-size:2.3125em}h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}h4{font-size:1.4375em}}table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}table thead,table tfoot{background:#f7f8f7;font-weight:bold}table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:#34302d;text-align:left}table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:#34302d}table tr.even, table tr.alt, table tr:nth-of-type(even) {background:#f8f8f7}table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}body{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;tab-size:4}h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}.clearfix:after,.float-group:after{clear:both}*:not(pre) > code {font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}*:not(pre) > code.nobreak {word-wrap:normal}*:not(pre) > code.nowrap {white-space:nowrap}pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:Monaco,Menlo,Consolas,"Courier New",monospace;font-weight:normal;text-rendering:optimizeSpeed}em em{font-style:normal}strong strong{font-weight:normal}.keyseq{color:#6b625c}kbd{font-family:Monaco,Menlo,Consolas,"Courier New",monospace;display:inline-block;color:#34302d;font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2) , 0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2) , 0 0 0 .1em white inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}.keyseq kbd:first-child{margin-left:0}.keyseq kbd:last-child{margin-right:0}.menuseq,.menu{color:#191715}b.button:before,b.button:after{position:relative;top:-1px;font-weight:normal}b.button:before{content:"[";padding:0 3px 0 2px}b.button:after{content:"]";padding:0 2px 0 3px}p a>code:hover{color:rgba(0,0,0,.9)}#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom: 1;position:relative;padding-left:.9375em;padding-right:.9375em}#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}#header:after,#content:after,#footnotes:after,#footer:after{clear:both}#content{margin-top:1.25em}#content:before{content:none}#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) {border-bottom:1px solid #ddddd8;padding-bottom:8px}#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}#header .details span:first-child{margin-left:-.125em}#header .details span.email a{color:rgba(0,0,0,.85)}#header .details br{display:none}#header .details br+span:before{content:"\00a0\2013\00a0"}#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}#header .details br+span#revremark:before{content:"\00a0|\00a0"}#header #revnumber{text-transform:capitalize}#header #revnumber:after{content:"\00a0"}#content > h1:first-child:not([class]) {color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}#toc>ul{margin-left:.125em}#toc ul.sectlevel0>li>a{font-style:italic}#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}#toc ul{font-family:Montserrat,sans-serif;list-style-type:none}#toc li{line-height:1.3334;margin-top:.3334em}#toc a{text-decoration:none}#toc a:active{text-decoration:underline}#toctitle{color:#0b0a0a;font-size:1.2em}@media only screen and (min-width:768px){#toctitle{font-size:1.375em}body.toc2{padding-left:15em;padding-right:0}#toc.toc2{margin-top:0!important;background-color:#f1f1f1;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}#toc.toc2>ul{font-size:.9em;margin-bottom:0}#toc.toc2 ul ul{margin-left:0;padding-left:1em}#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}body.toc2.toc-right{padding-left:0;padding-right:15em}body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}#toc.toc2{width:20em}#toc.toc2 #toctitle{font-size:1.375em}#toc.toc2>ul{font-size:.95em}#toc.toc2 ul ul{padding-left:1.25em}body.toc2.toc-right{padding-left:0;padding-right:20em}}#content #toc{border-style:solid;border-width:1px;border-color:#d7d7d7;margin-bottom:1.25em;padding:1.25em;background:#f1f1f1;-webkit-border-radius:4px;border-radius:4px}#content #toc>:first-child{margin-top:0}#content #toc>:last-child{margin-bottom:0}#footer{max-width:100%;background-color:#34302d;padding:1.25em}#footer-text{color:#cbcfd2;line-height:1.44}.sect1{padding-bottom:.625em}@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}.sect1+.sect1{border-top:1px solid #efefed}#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:normal}#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#34302d;text-decoration:none}#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#262321}.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Varela Round",sans-serif;font-size:1rem;font-style:italic}table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}.admonitionblock>table td.icon{text-align:center;width:80px}.admonitionblock>table td.icon img{max-width:initial}.admonitionblock>table td.icon .title{font-weight:bold;font-family:Montserrat,sans-serif;text-transform:uppercase}.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}.exampleblock>.content>:first-child{margin-top:0}.exampleblock>.content>:last-child{margin-bottom:0}.sidebarblock{border-style:solid;border-width:1px;border-color:#d7d7d7;margin-bottom:1.25em;padding:1.25em;background:#f1f1f1;-webkit-border-radius:4px;border-radius:4px}.sidebarblock>:first-child{margin-top:0}.sidebarblock>:last-child{margin-bottom:0}.sidebarblock>.content>.title{color:#0b0a0a;margin-top:0;text-align:center}.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint {background:#f5f5f5}.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint {background:#f2f1f1}.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{border:1px solid #ddd;-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}.literalblock.output pre{color:#f5f5f5;background-color:rgba(0,0,0,.9)}.listingblock pre.highlightjs{padding:0}.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}.listingblock>.content{position:relative}.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}.listingblock:hover code[data-lang]:before{display:block}.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}.listingblock.terminal pre .command:not([data-prompt]):before {content:"$"}table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}table.pyhltable td.code{padding-left:.75em;padding-right:0}pre.pygments .lineno, table.pyhltable td:not(.code) {color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}pre.pygments .lineno{display:inline-block;margin-right:.25em}table.pyhltable .linenodiv{background:none!important;padding-right:0!important}.quoteblock{margin:0 1em 1.25em 1.5em;display:table}.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}.quoteblock blockquote{margin:0;padding:0;border:0}.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#0b0a0a;text-shadow:0 1px 2px rgba(0,0,0,.1)}.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}.quoteblock .quoteblock blockquote:before{display:none}.verseblock{margin:0 1em 1.25em 1em}.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}.verseblock pre strong{font-weight:400}.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}.quoteblock .attribution br,.verseblock .attribution br{display:none}.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}.quoteblock.abstract{margin:0 0 1.25em 0;display:block}.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}table.tableblock{max-width:100%;border-collapse:separate}table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}table.frame-all{border-width:1px}table.frame-sides{border-width:0 1px}table.frame-topbot{border-width:1px 0}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}table thead th,table tfoot th{font-weight:bold}tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:#34302d;font-weight:bold}p.tableblock>code:only-child{background:none;padding:0}p.tableblock{font-size:1em}td>div.verse{white-space:pre}ol{margin-left:1.75em}ul li ol{margin-left:1.5em}dl dd{margin-left:1.125em}dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}ul.inline>li>*{display:block}.unstyled dl dt{font-weight:normal;font-style:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.hdlist>table,.colist>table{border:0;background:none}.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}td.hdlist1{font-weight:bold;padding-bottom:1.25em}.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}.colist>table tr>td:first-of-type img{max-width:initial}.colist>table tr>td:last-of-type{padding:.25em 0}.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}.imageblock>.title{margin-bottom:0}.imageblock.thumb,.imageblock.th{border-width:6px}.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}.image.left{margin-right:.625em}.image.right{margin-left:.625em}a.image{text-decoration:none;display:inline-block}a.image object{pointer-events:none}sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}sup.footnote a,sup.footnoteref a{text-decoration:none}sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}#footnotes .footnote:last-of-type{margin-bottom:0}#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}.gist .file-data>table td.line-data{width:99%}div.unbreakable{page-break-inside:avoid}.big{font-size:larger}.small{font-size:smaller}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa}.black{color:#000}.black-background{background-color:#000}.blue{color:#0000bf}.blue-background{background-color:#0000fa}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa}.gray{color:#606060}.gray-background{background-color:#7d7d7d}.green{color:#006000}.green-background{background-color:#007d00}.lime{color:#00bf00}.lime-background{background-color:#00fa00}.maroon{color:#600000}.maroon-background{background-color:#7d0000}.navy{color:#000060}.navy-background{background-color:#00007d}.olive{color:#606000}.olive-background{background-color:#7d7d00}.purple{color:#600060}.purple-background{background-color:#7d007d}.red{color:#bf0000}.red-background{background-color:#fa0000}.silver{color:#909090}.silver-background{background-color:#bcbcbc}.teal{color:#006060}.teal-background{background-color:#007d7d}.white{color:#bfbfbf}.white-background{background-color:#fafafa}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00}span.icon>.fa{cursor:default}.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#3f6a22}.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}.conum[data-value]{display:inline-block;color:#fff!important;background-color:#34302d;-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}.conum[data-value] *{color:#fff!important}.conum[data-value]+b{display:none}.conum[data-value]:after{content:attr(data-value)}pre .conum[data-value]{position:relative;top:-.125em}b.conum *{color:inherit!important}.conum:not([data-value]):empty {display:none}.admonitionblock{border-left:4px solid #6db33f;background-color:#ebf1e7;padding:1.2em 0;margin:30px 0;width:auto}#toc a:hover{text-decoration:underline}.admonitionblock>table{margin-bottom:0}.admonitionblock>table td.content{border-left:none}</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<style>.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 .5em 0 .25em}.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}table.CodeRay td{vertical-align:top;line-height:1.45}table.CodeRay td.line-numbers{text-align:right}table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}table.CodeRay td.code{padding:0 0 0 .5em}table.CodeRay td.code>pre{padding:0}.CodeRay .debug{color:#fff!important;background:navy!important}.CodeRay .annotation{color:#007}.CodeRay .attribute-name{color:navy}.CodeRay .attribute-value{color:#700}.CodeRay .binary{color:#509}.CodeRay .comment{color:#998;font-style:italic}.CodeRay .char{color:#04d}.CodeRay .char .content{color:#04d}.CodeRay .char .delimiter{color:#039}.CodeRay .class{color:#458;font-weight:bold}.CodeRay .complex{color:#a08}.CodeRay .constant,.CodeRay .predefined-constant{color:teal}.CodeRay .color{color:#099}.CodeRay .class-variable{color:#369}.CodeRay .decorator{color:#b0b}.CodeRay .definition{color:#099}.CodeRay .delimiter{color:#000}.CodeRay .doc{color:#970}.CodeRay .doctype{color:#34b}.CodeRay .doc-string{color:#d42}.CodeRay .escape{color:#666}.CodeRay .entity{color:#800}.CodeRay .error{color:#808}.CodeRay .exception{color:inherit}.CodeRay .filename{color:#099}.CodeRay .function{color:#900;font-weight:bold}.CodeRay .global-variable{color:teal}.CodeRay .hex{color:#058}.CodeRay .integer,.CodeRay .float{color:#099}.CodeRay .include{color:#555}.CodeRay .inline{color:#000}.CodeRay .inline .inline{background:#ccc}.CodeRay .inline .inline .inline{background:#bbb}.CodeRay .inline .inline-delimiter{color:#d14}.CodeRay .inline-delimiter{color:#d14}.CodeRay .important{color:#555;font-weight:bold}.CodeRay .interpreted{color:#b2b}.CodeRay .instance-variable{color:teal}.CodeRay .label{color:#970}.CodeRay .local-variable{color:#963}.CodeRay .octal{color:#40e}.CodeRay .predefined{color:#369}.CodeRay .preprocessor{color:#579}.CodeRay .pseudo-class{color:#555}.CodeRay .directive{font-weight:bold}.CodeRay .type{font-weight:bold}.CodeRay .predefined-type{color:inherit}.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}.CodeRay .key{color:#808}.CodeRay .key .delimiter{color:#606}.CodeRay .key .char{color:#80f}.CodeRay .value{color:#088}.CodeRay .regexp .delimiter{color:#808}.CodeRay .regexp .content{color:#808}.CodeRay .regexp .modifier{color:#808}.CodeRay .regexp .char{color:#d14}.CodeRay .regexp .function{color:#404;font-weight:bold}.CodeRay .string{color:#d20}.CodeRay .string .string .string{background:#ffd0d0}.CodeRay .string .content{color:#d14}.CodeRay .string .char{color:#d14}.CodeRay .string .delimiter{color:#d14}.CodeRay .shell{color:#d14}.CodeRay .shell .delimiter{color:#d14}.CodeRay .symbol{color:#990073}.CodeRay .symbol .content{color:#a60}.CodeRay .symbol .delimiter{color:#630}.CodeRay .tag{color:teal}.CodeRay .tag-special{color:#d70}.CodeRay .variable{color:#036}.CodeRay .insert{background:#afa}.CodeRay .delete{background:#faa}.CodeRay .change{color:#aaf;background:#007}.CodeRay .head{color:#f8f;background:#505}.CodeRay .insert .insert{color:#080}.CodeRay .delete .delete{color:#800}.CodeRay .change .change{color:#66f}.CodeRay .head .head{color:#f4f}</style>
</head>
<body id="spring-core" class="book toc2 toc-left">
<div id="header">
<h1>核心技术</h1>
<div class="details">
<span id="revnumber">version 5.0.0.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#beans">1. IoC容器</a>
<ul class="sectlevel2">
<li><a href="#beans-introduction">1.1. Spring IoC 容器和 beans 介绍</a></li>
<li><a href="#beans-basics">1.2. 容器概述</a></li>
<li><a href="#beans-definition">1.3. Bean 概述</a></li>
<li><a href="#beans-dependencies">1.4. 依赖</a></li>
<li><a href="#beans-factory-scopes">1.5. Bean 的作用域</a></li>
<li><a href="#beans-factory-nature">1.6. 自定义 bean 的特性</a></li>
<li><a href="#beans-child-bean-definitions">1.7. Bean 定义的继承</a></li>
<li><a href="#beans-factory-extension">1.8. 容器的扩展点</a></li>
<li><a href="#beans-annotation-config">1.9. 基于注解的容器配置</a></li>
<li><a href="#beans-classpath-scanning">1.10. 类路径扫描和管理组件</a></li>
<li><a href="#beans-standard-annotations">1.11. 使用 JSR 330 标准注解</a></li>
<li><a href="#beans-java">1.12. 基于 Java 的容器配置</a></li>
<li><a href="#beans-environment">1.13. 环境抽象</a></li>
<li><a href="#context-load-time-weaver">1.14. 注册 LoadTimeWeaver</a></li>
<li><a href="#context-introduction">1.15. ApplicationContext 的其他作用</a></li>
<li><a href="#beans-beanfactory">1.16. BeanFactory</a></li>
</ul>
</li>
<li><a href="#resources">2. 资源</a>
<ul class="sectlevel2">
<li><a href="#resources-introduction">2.1. 简介</a></li>
<li><a href="#resources-resource">2.2. 资源接口</a></li>
<li><a href="#resources-implementations">2.3. 内置的资源实现</a></li>
<li><a href="#resources-resourceloader">2.4. ResourceLoader 接口</a></li>
<li><a href="#resources-resourceloaderaware">2.5. ResourceLoaderAware 接口</a></li>
<li><a href="#resources-as-dependencies">2.6. 资源依赖</a></li>
<li><a href="#resources-app-ctx">2.7. 应用上下文和资源路径</a></li>
</ul>
</li>
<li><a href="#validation">3. 验证、数据绑定和类型转换</a>
<ul class="sectlevel2">
<li><a href="#validation-introduction">3.1. 简介</a></li>
<li><a href="#validator">3.2. 使用 Spring 对的Validator 接口来进行数据验证</a></li>
<li><a href="#validation-conversion">3.3. 从解析代码到错误信息</a></li>
<li><a href="#beans-beans">3.4. Bean 操作和 BeanWrapper</a></li>
<li><a href="#core-convert">3.5. Spring 类型转换</a></li>
<li><a href="#format">3.6. Spring 字段格式化</a></li>
<li><a href="#format-configuring-formatting-globaldatetimeformat">3.7. 配置全局日期和时间格式</a></li>
<li><a href="#validation-beanvalidation">3.8. Spring 验证</a></li>
</ul>
</li>
<li><a href="#expressions">4. Spring 表达式语言 (SpEL)</a>
<ul class="sectlevel2">
<li><a href="#expressions-intro">4.1. 简介</a></li>
<li><a href="#expressions-features">4.2. 功能概述</a></li>
<li><a href="#expressions-evaluation">4.3. 使用 Spring 表达式接口进行表达式运算</a></li>
<li><a href="#expressions-beandef">4.4. bean 定义的表达式支持</a></li>
<li><a href="#expressions-language-ref">4.5. 语言引用</a></li>
<li><a href="#expressions-example-classes">4.6. 例子用用到的类</a></li>
</ul>
</li>
<li><a href="#aop">5. 使用 Spring 进行面向切面编程</a>
<ul class="sectlevel2">
<li><a href="#aop-introduction">5.1. 接见</a></li>
<li><a href="#aop-ataspectj">5.2. @AspectJ 支持</a></li>
<li><a href="#aop-schema">5.3. 基于 Schema 的 AOP 支持</a></li>
<li><a href="#aop-choosing">5.4. 选择使用哪种 AOP 声明样式</a></li>
<li><a href="#aop-mixing-styles">5.5. 混合切面类型</a></li>
<li><a href="#aop-proxying">5.6. 代理机制</a></li>
<li><a href="#aop-aspectj-programmatic">5.7. 编程创建 @AspectJ 代理</a></li>
<li><a href="#aop-using-aspectj">5.8. 在 Spring 应用中使用 AspectJ</a></li>
<li><a href="#aop-resources">5.9. 更多资源</a></li>
</ul>
</li>
<li><a href="#aop-api">6. Spring AOP APIs</a>
<ul class="sectlevel2">
<li><a href="#aop-api-introduction">6.1. 简介</a></li>
<li><a href="#aop-api-pointcuts">6.2. Spring 中的切点（Pointcut） API</a></li>
<li><a href="#aop-api-advice">6.3. Spring 中的通知（Advice） API</a></li>
<li><a href="#aop-api-advisor">6.4. Spring 中的通知者（Advisor） 的 API</a></li>
<li><a href="#aop-pfb">6.5. 使用 ProxyFactoryBean 创建 AOP 代理</a></li>
<li><a href="#aop-concise-proxy">6.6. 精简的代理定义</a></li>
<li><a href="#aop-prog">6.7. 使用 ProxyFactory 编程创建爱你 AOP 代理</a></li>
<li><a href="#aop-api-advised">6.8. 操作被通知对象</a></li>
<li><a href="#aop-autoproxy">6.9. 使用自动代理（"auto-proxy"）功能</a></li>
<li><a href="#aop-targetsource">6.10. 使用 TargetSources</a></li>
<li><a href="#aop-extensibility">6.11. 定义新的通知（Advice）类型 </a></li>
<li><a href="#aop-api-resources">6.12. 耕作资源</a></li>
</ul>
</li>
<li><a href="#null-safety">7. Null 安全（NPE空指针异常）</a>
<ul class="sectlevel2">
<li><a href="#use-cases">7.1. 使用用例</a></li>
<li><a href="#jsr-305-meta-annotations">7.2. JSR 305 元注解</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>参考文档的这个部分的涵盖了 Spring 框架中所有最重要的技术。</p>
</div>
<div class="paragraph">
<p>这其中重中之重是 Spring 框架的控制反转（IoC）容器。对 Spring 框架的 IoC 容器的彻底处理表现在紧随其后的 Spring 的面向切面编程（AOP）技术的全面覆盖。Spring 框架有它自己的 AOP 框架，它在概念上很容易理解，而且它在 Java 企业级开发中成功的以最佳方式解决了80%的 AOP 需求点。</p>
</div>
<div class="paragraph">
<p>它还提供了Spring 集成 AspectJ (目前在Java企业开发届最丰富的 - 从功能的角度 - 当然也是最成熟的 AOP 实现) 的覆盖。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans"><a class="anchor" href="#beans"></a>1. IoC 容器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="beans-introduction"><a class="anchor" href="#beans-introduction"></a>1.1. Spring IoC 容器和 beans 介绍</h3>
<div class="paragraph">
<p>本章涵盖了所有控制反转（IoC）<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>原则的 Spring 框架实现。IoC 也被称为
<em>依赖注入</em>（DI）。这是对象定义它们依赖关系的一个过程，即，与它们一起运作的其他对象，只有通过构造器参数、传递参数给工厂方法，或者在对象实例构造完成或工厂方法返回对象实例之后才能设置对象属性。然后当创建bean时，容器再将那些依赖对象<em>注入</em> 进去。 这个过程从根本上颠倒了bean本身通过使用类的直接构建或者通过一种机制例如<em>服务定位</em> 模式来控制依赖对象的实例化或定位，因此叫做<em>控制反转</em>（IoC）。</p>
</div>
<div class="paragraph">
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是 Spring 框架 IoC 容器的基础。
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a>
接口提供了一种能管理任何类型对象的高级配置机制。
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>
是 <code>BeanFactory</code> 的一个子接口。 它更容易与以下功能集成：Spring 的AOP功能；消息资源处理（用于国际化）；事件发布；应用层特定上下文如 <code>WebApplicationContext</code> 在Web应用中的使用。</p>
</div>
<div class="paragraph">
<p>总之， <code>BeanFactory</code> 提供了配置框架和基本功能， <code>ApplicationContext</code> 添加了更多企业级专用功能。 <code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个全面超集, 在本章专门用来叙述 Spring 的 IoC 容器。想要了解更多有关用 <code>BeanFactory</code> 代替 <code>ApplicationContext</code> 的信息，请参考<a href="#beans-beanfactory">The BeanFactory</a>。</p>
</div>
<div class="paragraph">
<p>在 Spring 中，构成应用程序主干并由 Spring IoC <em>容器</em> 管理的对象称为 <em>beans</em>。Bean 是由 Spring IoC 容器实例化、组装或者管理的对象。否则，bean 仅仅只是应用程序中许多对象中的一个。Beans 和它们之间的<em>依赖</em> 关系都反映在容器使用的<em>配置元数据</em> 中了。</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-basics"><a class="anchor" href="#beans-basics"></a>1.2. 容器概述</h3>
<div class="paragraph">
<p> <code>org.springframework.context.ApplicationContext</code> 接口代表了 Spring IoC 容器并且负责初始化，配置，装配上述的 beans。容器通过读取配置元数据获取关于实例化、配置和装配的操作指南。配置元数据以XML, Java注解，或者Java代码的形式表示。它展示了组成你的应用程序的对象和这些对象之间丰富的相互依赖关系。</p>
</div>
<div class="paragraph">
<p> Spring 提供了几个开箱即用的 <code>ApplicationContext</code> 接口的实现。在独立的应用程序中，常见的做法是创建 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a>
或者 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"><code>FileSystemXmlApplicationContext</code></a> 接口的实例。考虑到XML已经成为定义配置元数据的传统文件格式，你可以引导容器使用Java注解或者以元数据格式呈现的代码，这是通过提供少量用于声明对这些额外元数据格式支持的XML配置来实现的。</p>
</div>
<div class="paragraph">
<p>在大多数应用场景中，不需要显式用户代码来实例化一个或多个 Spring IoC 容器。举个例子，在一个web应用场景中，一个含有八行（左右）的<code>web.xml</code>模板web描述XML文件就足够了（点击查看 <a href="#context-create">web应用的简单 ApplicationContext 实例化</a>）。如果你在 Eclipse 驱动的开发环境中使用<a href="https://spring.io/tools/sts">Spring 工具套装</a>，那么点几下鼠标或敲几下键盘就能很容易创建这个模板配置文件。</p>
</div>
<div class="paragraph">
<p>下图高度概括了 Spring 的工作原理。 应用程序中的类会跟配置元数据结合起来以便在 <code>ApplicationContext</code> 创建和初始化以后，你可以得到一个完全配置好而且可执行的系统或者应用。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/container-magic.png" alt="container magic">
</div>
<div class="title">Figure 1. Spring IoC 容器</div>
</div>
<div class="sect3">
<h4 id="beans-factory-metadata"><a class="anchor" href="#beans-factory-metadata"></a>1.2.1. 配置元数据</h4>
<div class="paragraph">
<p> 正如前图所示，Spring IoC 容器使用这样一种<em>配置元数据</em> 形式：此配置元数据展示了作为应用开发者，你是如何告诉 Spring 容器来实例化，配置和组装应用中的对象的。</p>
</div>
<div class="paragraph">
<p>配置元数据传统上使用既简单又直观的XML格式，本章大多数时候使用它来传递 pring IoC 容器核心概念和功能特点。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>基于XML的元数据并<em>不是</em> 唯一允许的配置元数据格式。Spring IoC 容器本身与配置元数据实际的编写格式是<em>完全</em> 解耦的。目前，许多开发者选择<a href="#beans-java">基于 Java 代码的配置</a> 为他们的 Spring 应用配置元数据。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关对 Spring 容器使用其他格式的元数据，请参见： </p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-annotation-config">基于注解的配置</a>: Spring 2.5 引入了对基于注解配置元数据的支持。</p>
</li>
<li>
<p><a href="#beans-java">基于Java 代码的配置</a>：从 Spring 3.0 开始，JavaConfig 项目提供的很多功能成为了 Spring 框架核心的一部分。因此你可以使用Java而不使用XML文件在你的应用程序类之外定义 beans。要使用这些新功能，请参见<code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code> 和 <code>@DependsOn</code> 注解。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring 配置由容器必须管理的至少一个且通常不止一个的bean定义组成。基于XML的配置元数据配置中展示了这些 beans 被配置为顶层的 <code>&lt;beans/&gt;</code> 标签中的<code>&lt;bean/&gt;</code> 元素。Java 配置往往在有<code>@Configuration</code> 注解的类中使用 <code>@Bean</code> 注解的方法来配置。</p>
</div>
<div class="paragraph">
<p>这些bean定义与构成你的应用程序的实际对象相对应。通常你会在其中定义服务层对象，数据访问对象（DAOs），视图对象如 Struts <code>Action</code> 实例，基础架构对象如 Hibernate
  <code>SessionFactories</code>, JMS <code>Queues</code>, 等等。 容器中通常不会配置细粒度的与对象，因为创建和加载域对象通常是 DAOs 和 业务逻辑的责任。 不过你可以使用集成了 AspectJ 的 Spring 来配置那些在 IoC 容器控制范围之外创建的对象。参见 <a href="#aop-atconfigurable">在 Spring 中使用 AspectJ 对域对象进行依赖注入</a>.</p>
</div>
<div class="paragraph">
<p>下例表示了基于XML的配置元数据的基本结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>属性 <code>id</code> 是用来标识唯一 bean 定义的字符串。
属性 <code>class</code>  定义 bean 的类型并且使用的是全限定类型。id 的值表示的是协作对象。在本例中没有展示用于引用协作对象的XML；更多相关信息参见<a href="#beans-dependencies">依赖</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-instantiation"><a class="anchor" href="#beans-factory-instantiation"></a>1.2.2. 容器的实例化</h4>
<div class="paragraph">
<p>Spring IoC 容器的实例化非常直截了当。向 <code>ApplicationContext</code> 构造器提供的某个定位路径或者多个路径实际上都是资源字符串，通过这些字符串，容器从各种外部资源--如本地文件系统，Java <code>CLASSPATH</code> 等等--加载配置元数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在你了解了Spring 的 IoC 容器之后，您可能想了解更多关于 Spring 的资源抽象的内容，正如在 <a href="#resources">资源</a> 里描述的，它提供了一种的从某种URI形式的地址中读取输入流的便捷机制。尤其是，<code>资源</code> 路径用于构建应用上下文，如在<a href="#resources-app-ctx">应用上下文和资源路径</a>描述的那样。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的例子表示的是服务层对象 <code>(services.xml)</code> 的配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- services --&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">petStore</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.services.PetStoreServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的例子表示的是数据访问对象 <code>daos.xml</code> 的配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">itemDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.jpetstore.dao.jpa.JpaItemDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前一个例子中，服务层由 <code>PetStoreServiceImpl</code> 和两个 <code>JpaAccountDao</code> 和 <code>JpaItemDao</code> （基于 JPA 对象/关系映射标准）类型的数据访问对象组成。
 <code>property name</code> 元素指的是这个 JavaBean 的属性名，<code>ref</code> 元素指的是另一个 bean 定义的名字。在 <code>id</code> 和 <code>ref</code> 之间的这种联系表示的是协作对象之间的依赖关系。有关配置对象的依赖关系的详细信息，参见
<a href="#beans-dependencies">依赖</a>。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-xml-import"><a class="anchor" href="#beans-factory-xml-import"></a>基于XML的配置元数据文件的组合</h5>
<div class="paragraph">
<p>将 bean 定义分别放在在多个XML文件中是很有用的。通常每个单独的XML配置文件对应应用架构中的每一个逻辑层或者每一个模块。</p>
</div>
<div class="paragraph">
<p>你可以利用应用上下文构造器来加载来自所有这些XML片段中的 bean 定义。这个构造器接受多个 <code>资源</code> 地址，就像前一小节中展示的那样。或者，使用一个或多个 <code>&lt;import/&gt;</code> 元素来加载其他一个或多个文件中的 bean 定义。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">resources/messageSource.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/resources/themeSource.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，外部的 bean 定义从三个文件被加载进来:
<code>services.xml</code>，<code>messageSource.xml</code> 和 <code>themeSource.xml</code>。对于进行导入操作的定义文件来说，所有的地址路径都是相对路径，所以 <code>services.xml</code> 必须与做导入操作的文件放在同一个目录或者同一个类路径，而 <code>messageSource.xml</code> 和 <code>themeSource.xml</code> 必须放在做导入操作的文件地址的下层 <code>resource</code> 地址中。如您所见，最前面的斜杠可以忽略不写，不过鉴于这些都是相对路径，最好彻底抛弃使用这个斜杠。这些被导入文件的内容，包括最顶层的 <code>&lt;beans/&gt;</code> 元素，也必须满足 Spring Schema 的有效定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以使用相对路径 “../” 来引用父目录中的文件，不过我们不推荐这么做。这么做会创建当前应用之外的文件依赖关系。尤其是我们不推荐对 "classpath:" URLs （比如，"classpath:../services.xml"）使用这种引用，因为运行时解析过程会选择它最近的类路径根目录然后查看他的父目录。类路径配置的更改会导致解析过程中选择的目录是其他错误的目录。</p>
</div>
<div class="paragraph">
<p>你应该始终使用完全限定资源地址而不是相对路径：比如，"file:C:/config/services.xml" 或者 "classpath:/config/services.xml"。但是，请注意这么做会把你应用程序的配置和具体的绝对路径耦合起来。通常对于此类绝对路径，举个例子，我们会使用在JVM 系统运行时的属性解析的 "${&#8230;&#8203;}" 占位符，达到解耦的目的。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Import 导入指令是 beans 命名空间本身提供的一个功能。除了普通的 bean 定义，其他跟多配置功能定义在 Spring 提供的 “context” 和 “util” 命名空间中。</p>
</div>
</div>
<div class="sect4">
<h5 id="groovy-bean-definition-dsl"><a class="anchor" href="#groovy-bean-definition-dsl"></a>Groovy Bean 定义的 DSL</h5>
<div class="paragraph">
<p>再如对于外部配置元数据，bean 定义还可以通过 Spring 的 Groovy Bean 定义 DSL，这种方式在 Grails 框架中被大家熟知。通常，这样的配置将以如下结构存在于“.groovy”扩展名文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">beans {
    dataSource(BasicDataSource) {
        driverClassName = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.hsqldb.jdbcDriver</span><span class="delimiter">&quot;</span></span>
        url = <span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:hsqldb:mem:grailsDB</span><span class="delimiter">&quot;</span></span>
        username = <span class="string"><span class="delimiter">&quot;</span><span class="content">sa</span><span class="delimiter">&quot;</span></span>
        password = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>
        settings = [mynew:<span class="string"><span class="delimiter">&quot;</span><span class="content">setting</span><span class="delimiter">&quot;</span></span>]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean -&gt;
            dataSource = dataSource
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种配置风格基本上等同于XML bean 定义，它甚至还支持 Spring XML配置的命名空间。另外它也允许通过 “importBeans” 导入指令导入XML bean 定义文件。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-client"><a class="anchor" href="#beans-factory-client"></a>1.2.3. 容器的使用</h4>
<div class="paragraph">
<p><code>ApplicationContext</code> 是一个高级工厂接口，它维护不同的 beans 及其依赖的注册表。使用方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> 可以获取 bean 实例。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 能让你用以下方式读取 bean 定义及访问 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// create and configure beans</span>
ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// retrieve configured instance</span>
PetStoreService service = context.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">petStore</span><span class="delimiter">&quot;</span></span>, PetStoreService.class);

<span class="comment">// use configured instance</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; userList = service.getUsernameList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 Groovy 配置，引导过程看起来非常相似，只是上下文实现不同，它是 Groovy 感知的（但也能理解XML bean 定义）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.groovy</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.groovy</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>最灵活是与reader代理如相对于XML文件的<code>XmlBeanDefinitionReader</code> 结合起来的 <code>GenericApplicationContext</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();
<span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>);
   context.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用 Groovy 文件对应的<code>GroovyBeanDefinitionReader</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();
<span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string"><span class="delimiter">&quot;</span><span class="content">services.groovy</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.groovy</span><span class="delimiter">&quot;</span></span>);
   context.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要的话，这些reader代理可以在同一个 <code>ApplicationContext</code> 中混合匹配，这样就可以从不同的配置源读取 bean 定义了。</p>
</div>
<div class="paragraph">
<p>然后你就可以使用 <code>getBean</code> 方法获取你的 bean 实例了。 <code>ApplicationContext</code> 接口还有其他几个获取 bean 实例的方法，但是在理想情况下，你的应用程序代码不应该使用它们。事实上，你的应用程序代码完全不应该调用 <code>getBean()</code> 方法，这样也就完全没有对 Spring API的依赖了。举个例子，Spring 与 web 框架的集成提供了对各种web框架组件如 controller 和 JSF 托管 bean 的依赖注入，允许你通过元数据（如：一个自动装配注解）声明对某一具体 bean 的依赖。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-definition"><a class="anchor" href="#beans-definition"></a>1.3. Bean 概述</h3>
<div class="paragraph">
<p>Spring IoC 容器管理一个或多个 <em>bean</em>。这些bean是由您提供给容器的配置元数据创建的。例如，以XML中
<code>&lt;bean/&gt;</code> 的形式定义。</p>
</div>
<div class="paragraph">
<p>在容器本身内部，这些 bean 的定义表现为 <code>BeanDefinition</code> 对象，它们包括（among other information）以下元数据：:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>包限定类名：</em> 一般是被定义 bean 的实际实现类的类名。</p>
</li>
<li>
<p>跟 bean 行为有关的配置元素，这些元素说明 bean 在容器中如何行事（作用域，生命周期回调等等）。</p>
</li>
<li>
<p> 对 bean 完成自身行为需要的其他 bean 的引用；这些引用也被称为 <em>写协作者</em> 或者 <em>依赖项</em>。</p>
</li>
<li>
<p>在新创建的对象中设置的其他配置设定，例如，在管理连接池的 bean 中使用的连接数，池的大小限制。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此元数据被转换为构成每个 bean 定义的以一组属性。</p>
</div>
<table id="beans-factory-bean-definition-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. The bean definition</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Explained in&#8230;&#8203;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">实例化 bean</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-beanname">bean 的命名</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">scope</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes">Bean 的作用域</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor arguments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">依赖注入</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">autowiring mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-autowire">自动装配协作者</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lazy-initialization mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lazy-init">懒加载的 bean</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">initialization method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-initializingbean">初始化回调</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">destruction method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-disposablebean">销毁回调</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了包含如何创建具体 bean 信息的 bean 定义， <code>ApplicationContext</code> 实现类们还允许注册用户在容器之外的地方创建的现存的 bean。这是通过调用 ApplicationContext BeanFactory 接口 <code>getBeanFactory()</code> 方法实现的， 这个方法会返回 BeanFactory 的实现类 <code>DefaultListableBeanFactory</code>。 <code>DefaultListableBeanFactory</code> 支持通过 <code>registerSingleton(..)</code> 和<code>registerBeanDefinition(..)</code> 注册bean。不过，典型的应用程序只使用通过元数据定义的 bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bean 元数据和手动提供的单例实例应该尽可能早地注册，以便容器在自动注入和其他内省步骤能恰当地使用它们。虽然在一定程度上支持对现有元数据和单例实例的覆盖，但在运行时（对工厂的并发调用）对新的 bean 的注册并没有被正式支持，因为这可能导致并发访问异常，和/或 bean 容器的状态不一致。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-beanname"><a class="anchor" href="#beans-beanname"></a>1.3.1. Bean 的命名</h4>
<div class="paragraph">
<p>每个 bean 有一个或多个标识符。这些标识符在 bean 的宿主容器内必须是唯一的。bean 通常只有一个标识符，但如果它需要多个标识符，那么那些其他标识符就会被视为别名。</p>
</div>
<div class="paragraph">
<p>在基于XML的配置元数据中，你可以使用 <code>id</code> 和/或 <code>name</code> 属性来指定 bean 的标识符。<code>id</code> 属性允许你唯一确定一个id。按照惯例，这些名字都是由字母数字（‘myBean’，‘fooService',等等）组成的，但是也有可嗯呢该包含特殊字符。如果你想对 bean 引入其他别名，也可以在 <code>name</code> 属性中指定它们，它们之间用逗号（<code>,</code>），分号（<code>;</code>），或者空格分隔。
 作为历史记录，在 Spring 3.1 版本之前，<code>id</code> 属性被定义成 <code>xsd:ID</code> 类型，它对组成id的字符作了限制。对于 3.1 版本，属性被定义成 <code>xsd:string</code> 类型。注意虽然 bean <code>id</code> 的唯一性不在被XML解析器强制要求，但容器依然强制要求它的唯一性。</p>
</div>
<div class="paragraph">
<p>为 bean 提供一个name或者id不是强制要求的。如果 bean 没有被显示提供name或者id，那么容器会为它生成一个唯一的名称。但是，如果你想要利用 <code>ref</code> 元素或者 <a href="#beans-servicelocator">服务定位器</a> 模式查询通过对名称查询来指向那个 bean，那么你必须向 bean 提供一个name。不向 bean 提供名称 的动机与使用 <a href="#beans-inner-beans"> 内部 bean</a> 和 <a href="#beans-factory-autowire">自动装配协作者</a> 相关，换句话说在使用 <a href="#beans-inner-beans"> 内部 bean</a> 和 <a href="#beans-factory-autowire">自动装配协作者</a> 的时候才会选择不向 bean 提供名称。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bean 的命名规范</div>
<div class="paragraph">
<p>这个规范就是在对 bean 命名时，采用标准 Java 规范对实例字段命名。即，bean 的名字以小写字母开头，之后采用驼峰式命名法。举几个这样的例子（不包括引号）<code>'accountManager'</code>，
  <code>'accountService'</code>， <code>'userDao'</code>，<code>'loginController'</code> 等等。</p>
</div>
<div class="paragraph">
<p>Bean 命名的一致性会使你的配置信息更易于阅读和理解，如果你用的是 Spring AOP，那么在对一组name相关的 bean 配置advice通知的时候一致性会有很大的帮助。（这里说的不是很清楚，个人理解是不是aop的时候方便些通配符对同一组name的bean拦截比较方便。或者说是否跟 Spring 操作bean的时候用到反射的比较方便。请大神补充。）</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 会在类路径组件扫描过程中根据上面的规则为未命名的组件生成 bean 的name：基本上是先取简单类名并将其首字母转换成小写。不过，在前两个都是大写字母的（不常见的）特殊情况下，将会保留原来的大小写格式。这些跟 <code>java.beans.Introspector.decapitalize</code> 定义的用了相同的规则（也就是 Spring 在这里用到的）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-beanname-alias"><a class="anchor" href="#beans-beanname-alias"></a>在 bean 定义之外添加 bean 的别名</h5>
<div class="paragraph">
<p>对 bean 定义本身来说，你可以给 bean 的 <code>id</code> 属性指定一个名称，给 <code>name</code> 属性指定多个名称，这样就为 bean 提供了多个名称。这些名称对着同一个 bean 来说都是等效的别名而且在某些情况下很有用，例如，允许应用程序中每个组件通过使用特定于该组件本身的 bean 名称来引用一个公共依赖项。（不是很明白这句话的意思。）</p>
</div>
<div class="paragraph">
<p>在 bean 实际定义的地方制定所有别名并不总是满足需求的。有时候也需要为在别处定义的 bean 引入别名。在大型系统中是很常见的，配置文件被分割开来放入每个子系统中，每个子系统拥有一套它自己的对象定义集。在基于XML的配置元数据中，你可以使用 <code>&lt;alias/&gt;</code>  元素来达到这个目的。/p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fromName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">toName</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，同一容器中被命名为 <code>fromName</code> 的 bean，在使用了别名定义之后，也可以用 <code>toName</code> 来代指。</p>
</div>
<div class="paragraph">
<p>例如，子系统A的配置元数据可以通过 <code>subsystemA-dataSource</code> 来指向DataSource。子系统B的配置元数据可以通过 <code>subsystemB-dataSource</code> 来指向DataSource。当组合使用这个两个子系统的主应用程序时，主程序可以通过 <code>myApp-dataSource</code> 来指向DataSource。要使者三个名称指向同一个对象，你应该在MyApp的配置元数据中添加如下别名定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemB-dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;alias</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">alias</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myApp-dataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样每个组件和主应用程序就能通过一个独一无二并且保证不会和其他定义（有效地创建一个命名空间）冲突的名称来指向dataSource，而且他们指向的是同一个 bean。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Java 配置</div>
<div class="paragraph">
<p>如果你使用的是 Java 配置，可以用 <code>@Bean</code> 注解来设置 bean 的别名，详情参见 <a href="#beans-java-bean-annotation">使用 @Bean 注解</a>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-class"><a class="anchor" href="#beans-factory-class"></a>1.3.2. 实例化 bean</h4>
<div class="paragraph">
<p>Bean 定义本质上其实就是创建对象的配方（蓝图）。容器在收到请求的时候会查找这个已经被命名的 bean 的蓝图，然后使用 bean 定义封装的配置元数据来创建（或者获取）这个 bean 对应的真正的对象实例。</p>
</div>
<div class="paragraph">
<p>如果你使用基于XML的配置元数据，则需要在 <code>&lt;bean/&gt;</code> 元素的 <code>class</code> 属性中指定需要被实例化的对象的具体类型（或者类）。这个 <code>class</code> 属性在 <code>BeanDefinition</code> 内部是一个 <code>Class</code> property，它通常是强制要求的
 （对于异常情况，请参见 <a href="#beans-factory-class-instance-factory-method">使用实例工厂方法实例化 bean</a> 和 <a href="#beans-child-bean-definitions">Bean 定义的继承</a>。）。
有两种方式使用 <code>Class</code> property：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常情况下，容器本身直接通过反射调用对应构造器来创建这个 bean 对象，这有点类似于在 Java 中使用 <code>new</code>  操作符来创建对象。</p>
</li>
<li>
<p>另一种少见的情况是，指定包含用于创建对象的 <code>静态</code> 工厂方法的实际类，容器会通过调用类的 <code>静态</code> <em>工厂</em> 方法来创建 bean。从 <code>静态</code> 工厂方法调用中返回的对象类型可能是同一个类或者完全不同的类。</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<div class="title">内部类名称</div>
<p>如果你想在 bean 定义中配置一个 <code>静态</code> 嵌套类，你必须使用这个嵌套类的 <em>二进制</em> 类名。</p>
</div>
<div class="paragraph">
<p>例如，在 <code>com.example</code> 包下有个叫做 <code>Foo</code> 的类，并且这个 <code>Foo</code> 类有一个叫做  <code>Bar</code> 的 <code>静态</code> 嵌套类，那么这个 bean 定义的 <code>'class'</code>
属性值就应该是 &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p><code>com.example.Foo$Bar</code></p>
</div>
<div class="paragraph">
<p>注意名称中的 <code>$</code> 字符将嵌套类名与外部类名分隔开。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-ctor"><a class="anchor" href="#beans-factory-class-ctor"></a>使用构造器实例化</h5>
<div class="paragraph">
<p>当你通过构造器创建 bean 时，所有正常类对 Spinrg 都是可用的，并且都与 Spring 兼容。也就是说，正在开发的类不需要实现任何特定的接口，也不需要以特定方式编码。只要指定 bean 的类就足够了。但是，因为它会依赖于你使用的 IoC 类型，所以你需要一个默认的（空）构造器。</p>
</div>
<div class="paragraph">
<p>Spring IoC 容器几乎可以管理你想让它管理的 <em>任何</em> 类；而不仅仅限于管理真正的 JavaBeans。大部分 Spring 用户更愿意为容器中的 JavaBeans 提供一个默认的（无参）构造器，和get、set方法。你还可以在容器中使用更多外来的非bean风格的类。例如，即使你需要使用一个完全不遵循 JavaBean 规范的遗留连接池，Spring 也能管理它。</p>
</div>
<div class="paragraph">
<p>你可以在基于XML的配置元数据中庸一下方式配置 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBeanTwo</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关给构造器提供参数（如有必要）和在对象构造完成之后设置对象实例属性的机制，参见 <a href="#beans-factory-collaborators">依赖注入</a>。</p>
  
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-static-factory-method"><a class="anchor" href="#beans-factory-class-static-factory-method"></a>使用静态工厂方法实例化</h5>
<div class="paragraph">
<p>在定义你用静态工厂方法创建的 bean 时，你可以使用 <code>class</code> 属性来指定包含 <code>静态</code> 工厂方法的类和用来配置工厂方法名称的名为 <code>factory-method</code> 的属性。你应该能够调用此方法（如稍后所述的可选参数）并且返回一个活动的对象，然后将它视为是通过构造器创建的对象。这种用法通常是为了在遗留代码中调用 <code>静态</code> 工厂。</p>
</div>
<div class="paragraph">
<p>下面的 bean 定义指明了这个 bean 会被工厂方法所创建。该定义没有指定返回对象的类型（类），只说明这个类包含这个工厂方法。在本例中，<code>createInstance()</code> 方法必须是一个 <em>静态</em> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ClientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ClientService</span> {
        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();
        <span class="directive">private</span> ClientService() {}

        <span class="directive">public</span> <span class="directive">static</span> ClientService createInstance() {
                <span class="keyword">return</span> clientService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于向工厂方法提供（可选）参数和在对象从工厂返回之后设置对象属性的机制，参见 <a href="#beans-factory-properties-detailed">依赖和配置的详情</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-instance-factory-method"><a class="anchor" href="#beans-factory-class-instance-factory-method"></a>使用实例工厂方法实例化</h5>
<div class="paragraph">
<p>与通过 <a href="#beans-factory-class-static-factory-method">静态工厂方法</a>实例化类似，实例工厂方法实例化从容器中调用已存在的 bean 的非静态方法来创建新的 bean。要使用这种机制，让 <code>class</code> 属性为空，对于 <code>factory-bean</code> 属性，配置某个当前（或者 父/祖先）容器中的 bean 的名称，改 bean 包含可以被调用来创建对象的实例方法。在 <code>factory-method</code> 属性中配置工厂方法本身的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.DefaultServiceLocator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createClientServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> {

        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();

        <span class="directive">public</span> ClientService createClientServiceInstance() {
                <span class="keyword">return</span> clientService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个工厂类也可以配置多个工厂方法，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.DefaultServiceLocator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">clientService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createClientServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceLocator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createAccountServiceInstance</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultServiceLocator</span> {

        <span class="directive">private</span> <span class="directive">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();

        <span class="directive">private</span> <span class="directive">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();

        <span class="directive">public</span> ClientService createClientServiceInstance() {
                <span class="keyword">return</span> clientService;
        }

        <span class="directive">public</span> AccountService createAccountServiceInstance() {
                <span class="keyword">return</span> accountService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法表明，工厂 bean 本身可以通过依赖注入（DI）被管理和配置。 参见 <a href="#beans-factory-properties-detailed">依赖和配置的详情</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 Spring 文档中 <em> factory bean</em> 指的是在 Spring 容器中配置的 bean，该 bean 将会通过 <a href="#beans-factory-class-instance-factory-method">实例</a> 或者
  <a href="#beans-factory-class-static-factory-method">静态</a> 工厂方法创建对象。相比之下，<code>FactoryBean</code> （注意大小写）特指 Spring 的 <a href="#beans-factory-extension-factorybean"><code>FactoryBean</code> </a>。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-dependencies"><a class="anchor" href="#beans-dependencies"></a>1.4. 依赖</h3>
<div class="paragraph">
<p>典型的企业级应用程序不是由一个简单的对象（或者 Spring 属于中的 bean）组成的。即使是最简单的应用也会有几个对象协作，来将它作为一个连贯的应用程序呈现给终端用户。下一节讲解释如何从定义独立的 bean 到定义其对象可以相互协作已经实现某个目标的应用。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-collaborators"><a class="anchor" href="#beans-factory-collaborators"></a>1.4.1. 依赖注入</h4>
<div class="paragraph">
<p><em>依赖注入</em> (DI)  是对象定义它们依赖关系的一个过程，即，与它们一起运作的其他对象，只有通过构造器参数、传递参数给工厂方法，或者在对象实例构造完成或工厂方法返回对象实例之后才能设置对象属性。然后当创建bean时，容器再将那些依赖对象<em>注入</em> 进去。 这个过程从根本上颠倒了bean本身通过使用类的直接构建或者通过一种机制例如<em>服务定位</em> 模式来控制依赖对象的实例化或定位，因此叫做<em>控制反转</em>（IoC）。
</div>
<div class="paragraph">
<p>符合 DI 原则的代码会更简洁，且当我们知道对象之间的以依赖关系时，解耦也会更有效率。对象不会试图查询它的依赖项，也不知道依赖项的地址或者类。 因此，你的类会变得更容易测试，特别是当依赖项是接口或者抽象基类时你可以在单元测试中使用stub或者mock实现。</p>
</div>
<div class="paragraph">
<p>DI 存在两种形式，<a href="#beans-constructor-injection">基于构造器的依赖注入</a> 和 <a href="#beans-setter-injection">基于setter的依赖注入</a>。</p>
</div>
<div class="sect4">
<h5 id="beans-constructor-injection"><a class="anchor" href="#beans-constructor-injection"></a>基于构造器的依赖注入</h5>
<div class="paragraph">
<p><em>基于构造器</em> 的依赖注入是由容器调用一个带有多个参数的构造函数来完成的，每个参数代表一个依赖项。调用具有特定参数的 <code>静态</code> 工厂方法来构造 bean 与调用构造器几乎是一样的，这与对构造器参数和 <code>静态</code> 工厂方法的讨论差不多。下面的例子给出了一个只能通过构造器注入来实现依赖注入的类。注意这个类并没有什么 <em>特别之处</em>，它是一个不依赖与容器特定接口，基类或者注解的普通POJO。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span>
        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span>
        <span class="directive">public</span> SimpleMovieLister(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-ctor-arguments-resolution"><a class="anchor" href="#beans-factory-ctor-arguments-resolution"></a>构造器参数解析</h6>
<div class="paragraph">
<p>构造器使用参数类型的匹配来进行参数解析。如果 bean 定义的构造器参数中不存在潜在的歧义，那么 bean 定义中配置的构造器的参数顺序就是这个 bean 实例化的时候向它适配的构造器提供参数的顺序。
 考虑下面这个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">x.y</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">public</span> Foo(Bar bar, Baz baz) {
                <span class="comment">// ...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不存在潜在的歧义，假设 <code>Bar</code> 类和 <code>Baz</code> 类不存在继承关系。那么下面的配置没有问题，而且你不用在 <code>&lt;constructor-arg/&gt;</code> 元素中显式说明构造器的参数索引且/或类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当引用另一个 bean 时，类型是已知的，匹配正确（像前一个例子一样）。当使用简单类型比如 <code>&lt;value&gt;true&lt;/value&gt;</code>时，Spring 就确定不了这个值的类型了，因此也就无法匹配类型了。考虑下面的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">examples</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// Number of years to calculate the Ultimate Answer</span>
        <span class="directive">private</span> <span class="type">int</span> years;

        <span class="comment">// The Answer to Life, the Universe, and Everything</span>
        <span class="directive">private</span> <span class="predefined-type">String</span> ultimateAnswer;

        <span class="directive">public</span> ExampleBean(<span class="type">int</span> years, <span class="predefined-type">String</span> ultimateAnswer) {
                <span class="local-variable">this</span>.years = years;
                <span class="local-variable">this</span>.ultimateAnswer = ultimateAnswer;
        }
}</code></pre>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-type"></a>构造器参数类型匹配</div>
<div class="content">
<div class="paragraph">
<p>在前一个场景中，如果你用 <code>type</code> 属性显式指定了构造器参数的类型，容器就 <em>可以</em> 对简单类型进行类型匹配。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">int</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java.lang.String</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-index"></a>构造器参数索引</div>
<div class="content">
<div class="paragraph">
<p>使用 <code>index</code> 属性来显式指定构造器参数的索引。比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">index</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了解决多个简单类型值的歧义性之外，指定索引还解决了构造器参数具有两个相同类型参数的歧义性。注意索引是从 0 开始的。</p>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-name"></a>构造器参数名称</div>
<div class="content">
<div class="paragraph">
<p>你还可以使用构造器形参来消除值的歧义性问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">years</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">7500000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ultimateAnswer</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">42</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>记住为了让它顺利起作用，你的代码必须使用debug模式编译，以便 Spring 可以从构造器中查找形参名称。如果不能（或者不想）用debug模式编译，你可以使用 <a href="http://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> JDK 注解来显式命名你的构造器参数。样例类如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">examples</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// Fields omitted</span>

        <span class="annotation">@ConstructorProperties</span>({<span class="string"><span class="delimiter">&quot;</span><span class="content">years</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">ultimateAnswer</span><span class="delimiter">&quot;</span></span>})
        <span class="directive">public</span> ExampleBean(<span class="type">int</span> years, <span class="predefined-type">String</span> ultimateAnswer) {
                <span class="local-variable">this</span>.years = years;
                <span class="local-variable">this</span>.ultimateAnswer = ultimateAnswer;
        }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-setter-injection"><a class="anchor" href="#beans-setter-injection"></a>基于 Setter 的依赖注入</h5>
<div class="paragraph">
<p><em>基于 Setter</em> 的依赖注入是在调用 bean 无参构造器或者无参 <code>静态</code> 工厂方法实例化之后，由容器调用 bean 的 setter 实现的。</p>
</div>
<div class="paragraph">
<p>下面的例子给出了一个只能通过纯 setter 注入来进行以依赖注入的类。这是个传统的 Java 类。它是一个不依赖与容器特定接口，基类或者注解的普通POJO。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span>
        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 对它管理的 bean 支持基于构造器的依赖注入和基于 setter 的依赖注入。它还支持在一些依赖已经通过构造器方式注入以后，再用基于 seter 的方式进行依赖注入。使用 <code>BeanDefinition</code> 形式进行依赖配置，结合 <code>PropertyEditor</code> 实例可以对属性的格式进行转换。不过，大多数 Spring 用户不直接操作这些类(比如，以编程方式)，而是使用XML的 <code>bean</code> 定义，组件注解（比如：使用了<code>@Component</code>，<code>@Controller</code> 等注解的类），或者对带有 <code>@Configuration</code> 注解的 Java 类使用 <code>@Bean</code> 方法。然后这些在内部转换为 <code>BeanDefinition</code> 的实例且被用来加载到整个 Spring IoC 容器实例。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">使用基于构造器的依赖注入还是基于 setter 的依赖注入？</div>
<div class="paragraph">
<p>由于你可以混合使用基于构造器的依赖注入还是基于 setter 的依赖注入，有经验的做法是将构造器用于配置 <em>强制依赖项</em>，将 setter 方法用于配置 <em>可选依赖项</em>。注入在 setter 方法使用 <a href="#beans-required-annotation">@Required</a> 注解会使得这个属性被检查是否注入的必要依赖项。</p>
</div>
<div class="paragraph">
<p>Spring 团队通常提倡使用构造器注入，因为它可以使得应用组件成为 <em>不可变对象</em>，且可以确保所需的依赖不为 <code>null</code>。而且基于构造器注入的组件总是会以一个已经完全初始化好的状态返回给客户端（调用）代码。附注，含有大量构造器参数的代码是一种很不好的代码风格，这意味着这个类可能包含太多的职责了，应该对它进行重构以更好进行职责分离。</p>
</div>
<div class="paragraph">
<p>如果对可选的依赖项提供合理的默认值，那么建议只采用基于 Setter 的注入。否则必须对每处使用依赖项的代码都必须进行非空检查。setter 注入的一个好处是 setter 方法使得类的对象实例很容易再配置或者再注入。<a href="integration.html#jmx">JMX MBeans</a> 的管理就是 setter 注入的一个极佳的例子。
</div>
<div class="paragraph">
<p>对具体类应该使用最适合它的依赖注入方式。有时候，当遇到没有源码的第三方类时，它已经为了做好了选择。例如，如果一个第三方类没有暴露任何 setter 方法，那么用构造器注入进行依赖注入就是你唯一的选择了。</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-dependency-resolution"><a class="anchor" href="#beans-dependency-resolution"></a>依赖解析过程</h5>
<div class="paragraph">
<p>容器进行 bean 依赖解析的步骤如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根据描述所有 bean 的配置元数据创建并初始化 <code>ApplicationContext</code>。配置元数据可以是XML，Java 代码，或者注解。</p>
</li>
<li>
<p>对于每一个 bean，它的依赖项会以属性，构造器参数，或者静态工厂方法（如果你用静态工厂方法代替普通构造器）参数。这些依赖项会在 <em>bean 真正被创建的时候</em> 提供给 bean。</p>
</li>
<li>
<p>每一个属性或者构造器参数其实都是根据实际定义set的值或者是对容器中另一个 bean 的引用。</p>
</li>
<li>
<p>每一个属性或者构造器参数都会从它们的指定形式转换成那个属性或者构造器参数的实际类型。默认情况下，Spring
能将 string 类型的值转换为所有内建类型，比如 <code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code>，等等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring 容器被创建以后会验证每个 bean 的配置。不过 bean 的属性直到 bean <em>被真正创建</em> 才会被设置。那些被设置为需要预实例化（默认设置）的单例 bean  会在容器创建之后创建。作用域在 <a href="#beans-factory-scopes">Bean scopes</a> 中定义。否则，只有在被请求是 bean 才会被创建。bean 的创建可能会导致它的依赖项、他的依赖的依赖项（以此类推）创建和赋值。注意依赖关系之间的解析匹配错误可能会在之后出现，即，受影响的 bean 第一次创建的时候。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">循环依赖</div>
<div class="paragraph">
<p>如果你使用构造器注入，可能会出现无法处理的循环依赖的情况。</p>
</div>
<div class="paragraph">
<p>例如：类需要通过构造器注入B类的实例，B类需要通过构造器注入A类的实例。如果你为A类和B类相互注入对方的实例，Spring IoC 容器会在运行时检测到循环引用，然后抛出 <code>BeanCurrentlyInCreationException</code> 异常。</p>
</div>
<div class="paragraph">
<p>一个解决方案是修改某个类的源代码使其通过 setter 而不是构造器注入。或者，避免使用构造器注入，仅用 setter 注入。换句话说你可以用 setter 注入来处理循环依赖，虽然不推荐这么做。</p>
</div>
<div class="paragraph">
<p>与 <em>通常情况</em> （不含循环依赖）不同，bean A 和 bean B 之间的循环依赖迫使其中一个 bean 在完全初始化之前就注入到另一个 bean 中（经典的先有鸡还是先有蛋的问题）。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以信任 Spring 会正确解决这个问题。它会在加载时检测配置问题，如对不存在的 bean 的引用和循环依赖。Spring 会在 bean 被真正创建后尽可能晚地设置 bean 的属性和解析 bean 之间的依赖关系。这意味着对于已经正确加载的 Spring 容器，当你之后向容器请求一个对象时，如果创建这个对象或者它的至少一个依赖项出现问题，那么容器还是会抛出异常。例如，bean 可能会因为缺少属性值或者属性值无效而抛出异常。这个对某些配置问题潜在的延迟可见性问题正是为什么 <code>ApplicationContext</code> 默认实现单例 bean 预实例化的原因。在这些 bean 真正被需要之前，当 <code>ApplicationContext</code> 创建的时候会花费一些时间和内存使得你能够尽早发现配置问题，而不是在 bean 被请求之后。当然你仍然可以覆盖这个默认行为而把 bean 设置成懒加载模式而不是预实例化模式。</p>
</div>
<div class="paragraph">
<p>如果不存在循环依赖，那么当一个或多个协作 bean 被注入到依赖它们的 bean 时，每个协作 bean 都会在被注入之前 <em>完全</em> 配置好。这意味着如果 bean A 依赖 bean B，那么 Spring IoC 会在调用 bean A 的 setter 将 bean B 注入之前先将 bean B 完全配置好。换句话说，当一个 bean 完成实例化（如果不是一个预实例化模式的单例 bean），那么久说明它所有的依赖项都配设置好了，相关的生命周期方法（如 <a href="#beans-factory-lifecycle-initializingbean">配置初始化方法</a> 或者 <a href="#beans-factory-lifecycle-initializingbean">初始化 bean 回调方法</a>）也已经被调用了。
</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-some-examples"><a class="anchor" href="#beans-some-examples"></a>依赖注入举例</h5>
<div class="paragraph">
<p>下面的例子使用基于XML的配置元数据来配置基于 setter 的依赖注入。Spring XML 配置文件的其中一小部分详述了一些 bean 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>

        <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanTwo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">integerProperty</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">private</span> AnotherBean beanOne;

        <span class="directive">private</span> YetAnotherBean beanTwo;

        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">public</span> <span class="type">void</span> setBeanOne(AnotherBean beanOne) {
                <span class="local-variable">this</span>.beanOne = beanOne;
        }

        <span class="directive">public</span> <span class="type">void</span> setBeanTwo(YetAnotherBean beanTwo) {
                <span class="local-variable">this</span>.beanTwo = beanTwo;
        }

        <span class="directive">public</span> <span class="type">void</span> setIntegerProperty(<span class="type">int</span> i) {
                <span class="local-variable">this</span>.i = i;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面个的例子中，setter 方法声明与XML文件中具体指定的属性匹配。下面的例子使用基于构造器的依赖注入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span>
        <span class="tag">&lt;constructor-arg&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/constructor-arg&gt;</span>

        <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">int</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">private</span> AnotherBean beanOne;

        <span class="directive">private</span> YetAnotherBean beanTwo;

        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">public</span> ExampleBean(
                AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i) {
                <span class="local-variable">this</span>.beanOne = anotherBean;
                <span class="local-variable">this</span>.beanTwo = yetAnotherBean;
                <span class="local-variable">this</span>.i = i;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>bean 定义中指定的构造器参数会被作为 <code>ExampleBean</code> 构造器参数使用。</p>
</div>
<div class="paragraph">
<p>现在考虑这个例子的一个变形，Spring 被告知调用 <code>静态</code> 工厂方法而不使用构造器来返回这个对象实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createInstance</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">anotherExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yetAnotherBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.YetAnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="comment">// a private constructor</span>
        <span class="directive">private</span> ExampleBean(...) {
                ...
        }

        <span class="comment">// a static factory method; the arguments to this method can be</span>
        <span class="comment">// considered the dependencies of the bean that is returned,</span>
        <span class="comment">// regardless of how those arguments are actually used.</span>
        <span class="directive">public</span> <span class="directive">static</span> ExampleBean createInstance (
                AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="type">int</span> i) {

                ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);
                <span class="comment">// some other operations...</span>
                <span class="keyword">return</span> eb;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>&lt;constructor-arg/&gt;</code> 元素向 <code>静态</code> 工厂方法提供参数，这与使用构造器注入配置一模一样。工厂方法返回的对象的类类型不必与包含此 <code>静态</code> 工厂方法的类类型一致，虽然在这个例子中它们是一样的。实例（非静态）工厂方法的使用本质上完全一样（除了使用 <code>factory-bean</code> 属性代替<code>class</code> 属性之外），所以其细节不在这里讨论了。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-properties-detailed"><a class="anchor" href="#beans-factory-properties-detailed"></a>1.4.2. 依赖和配置详情</h4>
<div class="paragraph">
<p>如前一节所述，你可以将 bean 的属性和构造器参数定义为对其他托管 bean （协作者）的引用，或者定义为内联值。为了实现这个功能，Spring 的基于XML的配置元数据在它的 <code>&lt;property/&gt;</code> 和 <code>&lt;constructor-arg/&gt;</code> 元素中支持子元素类型。</p>
</div>
<div class="sect4">
<h5 id="beans-value-element"><a class="anchor" href="#beans-value-element"></a>直接值（基本类型，String类型，等等）。</h5>
<div class="paragraph">
<p><code>&lt;property/&gt;</code> 元素的 <code>value</code> 属性指定了一个属性或构造器参数作为可读的字符串表示。Spring 的 <a href="#core-convert-ConversionService-API">转换服务</a> 将这些值从 <code>String</code> 转成属性或参数的真实类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">driverClassName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mysql.jdbc.Driver</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:mysql://localhost:3306/mydb</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">root</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterkaoli</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的例子为了更简洁的XML配置使用了<a href="#beans-p-namespace">p-namespace</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
        <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:driverClassName</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mysql.jdbc.Driver</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:url</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:mysql://localhost:3306/mydb</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:username</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">root</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:password</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">masterkaoli</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的XML更加简洁；不过，其中的拼写错误是在运行时发现而不是在编写设计的时候，除非你使用像<a href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> 或者 <a href="https://spring.io/tools/sts">Spring Tool Suite</a> (STS) 这样在创建 bean 定义的时候有自动属性补全功能的IDE。我们非常推荐这样的IDE辅助功能。</p>
</div>
<div class="paragraph">
<p>你还可以这样配置 <code>java.util.Properties</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>
                        jdbc.driver.className=com.mysql.jdbc.Driver
                        jdbc.url=jdbc:mysql://localhost:3306/mydb
                <span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过 JavaBeans 的 <code>PropertyEditor</code> 机制将 <code>&lt;value/&gt;</code> 元素内的文本转换成 <code>java.util.Properties</code> 实例。这是个很好的快捷方式，也是为数不多的几个 Spring 团队更愿意使用嵌入的 <code>&lt;value/&gt;</code> 元素而不是 <code>value</code> 属性风格的地方。</p>
</div>
<div class="sect5">
<h6 id="beans-idref-element"><a class="anchor" href="#beans-idref-element"></a>idref 元素</h6>
<div class="paragraph">
<p><code>idref</code> 元素是在容器中将 <em>id</em> （字符串--不是引用）传递到 <code>&lt;constructor-arg/&gt;</code> 或者 <code>&lt;property/&gt;</code> 的一种简单的错误检测方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theClientBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetName</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;idref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的 bean 定义片段与下面的片段 <em>完全</em> 相等（在运行时）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">client</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theTargetBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第一种配置形式优于第二种，因为 <code>idref</code> 标签允许容器 <em>在部署阶段</em> 验证被引用的，被命名的 bean 是否真实存在。在第二种形式中，传递给 <code>client</code> bean 的 <code>targetName</code> 属性的值不会被验证。拼写错误只有当 <code>client</code> bean 真正实例化完成之后才会被发现（最可能的致命后果）。如果 <code>client</code> bean 是一个 <a href="#beans-factory-scopes">原型</a> bean，拼写错误和产生的异常可能只有在容器部署很长时间之后才会被发现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>idref</code> 元素的 <code>local</code> 属性在4.0 beans xsd 中不再被支持，因为它不再为 <code>bean</code> 引用提供值。当升级到 4.0 模式的时候，你可以轻松将 <code>idref local</code> 引用改成  <code>idref bean</code> 引用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ProxyFactoryBean</code> bean 定义中的 <a href="#aop-pfb-1">AOP 拦截器</a> 配置是 <code>&lt;idref/&gt;</code> 元素传递值常见的地方（至少在 Spring 2.0 以前的版本中）。在指定拦截器名字的时候使用 <code>&lt;idref/&gt;</code> 元素可以防止误拼写拦截器id。</p>
</div>
</div>
</div>
<div class="sect4">-/-/---
<h5 id="beans-ref-element"><a class="anchor" href="#beans-ref-element"></a>对其他 bean 的引用（协作者）</h5>
<div class="paragraph">
<p><code>ref</code> 元素是 <code>&lt;constructor-arg/&gt;</code> 或者 <code>&lt;property/&gt;</code>
定义元素的最终元素。在这个元素中，设置 bean 的指定属性值，值为对容器管理的另一个 bean （一个协作者）的引用。被引用 bean 是这个 bean 的一个依赖，这个 bean 的属性需要被设置，而且在属性设置之前会根据需要对其进行初始化。（如果协作者是一个单例 bean，它有可能已经被容器初始化。）所有引用最终都是对另一个对象的引用。作用域和验证功能取决于你是否通过对象的 <code>bean</code>, <code>local,</code> 或者 <code>parent</code> 属性指定它的 id/name。</p>
</div>
<div class="paragraph">
<p>通过 <code>&lt;ref/&gt;</code> 标签的 bean 属性指定目标 bean 是最普遍的形式，这允许你在统一容器或父容器中创建对任何 bean 的引用，不论它是否在同一个XML文件中。 <code>bean</code> 属性的值可能与目标 bean 的 <code>id</code> 属性相同，或者是目标 bean 的多个 <code>name</code> 属性之一。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>parent</code> 属性指定目标 bean 会创建一个对当前容器的父容器中 bean 的引用。 <code>parent</code> 属性的值可能与目标 bean 的 <code>id</code> 属性相同，或者与目标 bean 的多个 <code>name</code> 属性其中之一相同，且目标 bean 必须位于当前容器的父容器中。当你有多个层次划分的容器或者需要将某个父容器中已存在的 bean 包装成与它同名的代理 bean 的时候，可以使用此 bean 引用变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- in the parent context --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.SimpleAccountService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- in the child (descendant) context --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="error">&lt;</span><span class="error">!</span><span class="attribute-name">--</span> <span class="attribute-name">bean</span> <span class="attribute-name">name</span> <span class="attribute-name">is</span> <span class="attribute-name">the</span> <span class="attribute-name">same</span> <span class="attribute-name">as</span> <span class="attribute-name">the</span> <span class="attribute-name">parent</span> <span class="attribute-name">bean</span> <span class="attribute-name">--</span><span class="tag">&gt;</span>
        class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;<span class="error">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span> <span class="comment">&lt;!-- notice how we refer to the parent bean --&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ref</code> 元素的 <code>local</code> 属性在 4.0 beans xsd 中不再被支持，因为它在再为 <code>bean</code> 引用提供值。当升级到 4.0 模式的时候，你可以轻松将 <code>idref local</code> 引用改成  <code>idref bean</code> 引用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-inner-beans"><a class="anchor" href="#beans-inner-beans"></a>内部 bean</h5>
<div class="paragraph">
<p>在 <code>&lt;property/&gt;</code> 或者 <code>&lt;constructor-arg/&gt;</code> 元素中定义的 bean 称为 <em>内部 bean</em> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">outer</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Fiona Apple</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">25</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>内部 bean 定义不要求定义 id 或 name；即使指定了，容器也不会用它来作为标识符。容器也会在创建时忽略 <code>scope</code> 标志：内部 bean <em>总是</em> 匿名的，且 <em>总是 </em>由外部 bean 创建的。除了被注入到封闭的 bean 中或者单独访问它们，不可能将内部 bean 注入到协作 bean 中。</p>
</div>
<div class="paragraph">
<p>一种很少见到的情况是，有可能从自定义作用域中收到销毁回调方法，例如对于一个包含在单例 bean 中的 request 作用域内部 bean 来说：内部 bean 的创建过程会与包含它的 bean 绑定在一起，但销毁回调方法允许它参与到 request 域的生命周期中。这并不是一个常见的应用场景；内部 bean 的作用域通常跟包含它的 bean 作用域一样。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-collection-elements"><a class="anchor" href="#beans-collection-elements"></a>集合</h5>
<div class="paragraph">
<p>在<code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, 和 <code>&lt;props/&gt;</code> 元素中，分别对应设置 Java <code>Collection</code> 类型的 <code>List</code>, <code>Set</code>, <code>Map</code>, and <code>Properties</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">moreComplexObject</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ComplexObject</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;props&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">administrator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2b3b6bfbbbcbba1a6a0b3a6bda092b7aab3bfa2beb7fcbda0b5">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a7d4d2d7d7c8d5d3e7c2dfc6cad7cbc289c8d5c0">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d6b2b3a0b3bab9a6bbb3b8a296b3aeb7bba6bab3f8b9a4b1">[email&#160;protected]</a><span class="tag">&lt;/prop&gt;</span>
                <span class="tag">&lt;/props&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someList</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>a list element followed by a reference<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someMap</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;map&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">an entry</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">just some string</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span> =<span class="string"><span class="delimiter">&quot;</span><span class="content">a ref</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/map&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someSet</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;value&gt;</span>just some string<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myDataSource</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>map类型的key或者value，set类型的value值可以是以下元素的任意一种：</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">bean | ref | idref | list | set | map | props | value | null</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-merging"><a class="anchor" href="#beans-collection-elements-merging"></a>集合合并</h6>
<div class="paragraph">
<p>Spring 容器还支持集合的 <em>合并</em>。应用开发者可以定义父集合类型的 <code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code> 或 <code>&lt;props/&gt;</code> 元素，也可以定义能够继承和覆盖服集合元素值的子类型集合元素 <code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>，<code>&lt;set/&gt;</code> 或 <code>&lt;props/&gt;</code>。也就是说，子类型集合的值是合并父类型集合元素和子类型集合元素的结果，其中子类型集合元素覆盖父类型集合中指定的值。</p>
</div>
<div class="paragraph">
<p><em>关于合并的这节讨论了父-子 bean 的机制。对父-子 bean 定义不熟悉的读者在继续下面的学习之前可以去阅读 <a href="#beans-child-bean-definitions">相关章节</a>。</em></p>
</div>
<div class="paragraph">
<p>下面的例子展示了集合的合并：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ComplexObject</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;props&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">administrator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c2d28212522253f383e2d38233e0c29342d213c2029622f2321">administrator@example.com</a><span class="tag">&lt;/prop&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5f2c2a2f2f302d2b1f3a273e322f333a713c3032">support@example.com</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;/props&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">child</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">adminEmails</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span>
                        <span class="tag">&lt;props</span> <span class="attribute-name">merge</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sales</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2251434e475162475a434f524e470c414d4f">sales@example.com</a><span class="tag">&lt;/prop&gt;</span>
                                <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">support</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="295a5c5959465b5d694c51484459454c074a46075c42">support@example.co.uk</a><span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;/props&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意 <code>child</code> bean 定义中 <code>adminEmails</code> 属性的 <code>&lt;props/&gt;</code> 元素使用了 <code>merge=true</code> 属性。当容器解析并实例化 <code>child</code> bean 的时候，由此产生的实例包含一个 <code>adminEmails</code> <code>Properties</code> 集合，这个集合是 child <code>adminEmails</code> 集合和 parent <code>adminEmails</code> 集合合并的结果。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</pre>
</div>
</div>
<div class="paragraph">
<p>child <code>Properties</code> 集合中的值继承了parent <code>&lt;props/&gt;</code> 的所有 property 元素，而 child 的 <code>support</code> 值覆盖了 parent 集合中的值。</p>
</div>
<div class="paragraph">
<p><code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>，和 <code>&lt;set/&gt;</code>集合类型中的合并与上面类似。对于特定的 <code>&lt;list/&gt;</code> 元素，语义与 <code>List</code> 集合类型相关，即，保留集合的<code>有序性</code>；父集合的值先于子集合中的所有值。对于 <code>Map</code>, <code>Set</code>，和 <code>Properties</code> 集合类型，不存在有序性。因此，对于容器内部使用的与 <code>Map</code>, <code>Set</code>，和 <code>Properties</code> 实现相关的集合类型，排序语义是无效的。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-merge-limitations"><a class="anchor" href="#beans-collection-merge-limitations"></a>集合合并的局限性</h6>
<div class="paragraph">
<p>不能合并不同的集合类型（如 <code>Map</code> 和 <code>List</code>），如果你视图这么做，那么程序将会抛出相应的 <code>异常</code>。<code>merge</code> 属性必须在更低级别的，继承的，自定义中指定；在父集合定义中指定 <code>merge</code> 属性是冗余的，而且不会进行你想要的合并。</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-strongly-typed"><a class="anchor" href="#beans-collection-elements-strongly-typed"></a>强类型集合</h6>
<div class="paragraph">
<p>随着 Java 5 中泛型的引入，你可以使用强类型集合。也就是说，你可以声明一个只能包含 <code>String</code> 元素（举个例子）的 <code>Collection</code> 类型。如果你使用 Spring 的依赖注入将强类型 <code>Collection</code> 注入到 bean 中，你可以利用 Spring 的类型转换支持，在将元素添加在 <code>Collection</code> 之前，将强类型 <code>Collection</code> 实例转换为适当的类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Float</span>&gt; accounts;

        <span class="directive">public</span> <span class="type">void</span> setAccounts(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Float</span>&gt; accounts) {
                <span class="local-variable">this</span>.accounts = accounts;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accounts</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;map&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">9.99</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">2.75</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">six</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3.99</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;/map&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>foo</code> bean 的 <code>accounts</code> 属性准备注入时，可以通过反射获得强类型 <code>Map&lt;String, Float&gt;</code> 的元素类型信息。这样 Spring 的类型转换底层模块就能将各种不同的值元素识别为 <code>Float</code> 类型，将字符串值 <code>9.99, 2.75</code>，和 <code>3.99</code> 转换成真正的 <code>Float</code> 类型。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-null-element"><a class="anchor" href="#beans-null-element"></a>Null和空字符串值</h5>
<div class="paragraph">
<p>Spring 将属性的空参数都处理为空字符串（empty <code>Strings</code>）。下面基于XML的配置元数据片段将电子邮件属性设置为空字符串 <code>String</code> 值（""）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的例子与下面的Java代码是等价的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;null/&gt;</code> 元素处理 <code>null</code> 值。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;null</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的配置与下面的Java代码等价：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">exampleBean.setEmail(<span class="predefined-constant">null</span>)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-p-namespace"><a class="anchor" href="#beans-p-namespace"></a>使用 p-namespace 的XML简化配置</h5>
<div class="paragraph">
<p>p-namespace 可以让你 <code>bean</code> 元素的属性而不是嵌套 <code>&lt;property/&gt;</code> 元素来描述属性值和/或协作 bean。</p>
</div>
<div class="paragraph">
<p>Spring 支持含有 <a href="appendix.html#xsd-configuration">命名空间</a> 的扩展配置，命名空间是基于XML Schema 定义的。本章讨论的 <code>beans</code> 配置形势是在XML Schema 文件中定义的。但是 p-namespace 不在XSD文件中定义而只存在于 Spring core 中。</p>
</div>
<div class="paragraph">
<p>下面的例子给出了两个解析结果相同的XML片段：第一个使用标准XML形势，第二个使用了 p-namespace。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classic</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.ExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo@bar.com</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">p-namespace</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.ExampleBean</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:email</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo@bar.com</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子显示在 bean 定义中p-namespace 中有个一个叫 email 的属性。这会告知 Spring 包含一个 property 声明。如前面所述，p-namespace 没有 schema 定义，因此你可以将特性值名（attribute）设到属性值（property）上。</p>
</div>
<div class="paragraph">
<p>下面的例子包括两个 bean 定义，它们都引用了另一个 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:p</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/p</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">john-classic</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">John Doe</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">spouse</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">john-modern</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">John Doe</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">p:spouse-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jane</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.example.Person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Jane Doe</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所见，这个例子不仅包含使用 p-namespace 的属性值，还使用了一种特殊形式来声明属性值引用。第一个 bean 定义使用 <code>&lt;property name="spouse" ref="jane"/&gt;</code> 来创建从 bean <code>john</code> 到 bean <code>jane</code> 的引用，而第二个 bean 定义将 <code>p:spouse-ref="jane"</code> 作为一个特性值使用来定义从 bean <code>john</code> 到 bean <code>jane</code> 的引用。在这个例子中，<code>spouse</code> 是属性名，而 <code>-ref</code> 部分表示这不是一个直接值而是一个对其他 bean 的引用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>p-namespace 不像标准XML形式那么灵活。例如，声明属性引用的形式会与以 <code>Ref</code> 结尾的属性冲突，而标准XML形式并不会。我们建议你谨慎选择使用哪种形式并及时与你的团队沟通，以避免输出同时使用三种配置形式的XML文档。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-c-namespace"><a class="anchor" href="#beans-c-namespace"></a>使用 c-namespace 的XML简化配置</h5>
<div class="paragraph">
<p>与 <a href="#beans-p-namespace">使用 p-namespace 的XML简化配置</a>类似，<em>c-namespace</em> 在 Spring 3.1中被引入，它允许使用内联属性配置构造器参数而不是嵌套的 <code>constructor-arg</code> 元素。</p>
</div>
<div class="paragraph">
<p>回顾一下 <a href="#beans-constructor-injection">基于构造器的依赖注入</a> 中使用的 <code>c:</code> 命名空间：/p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:c</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/c</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- traditional declaration --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="62040d0d220003104c010d0f">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- c-namespace declaration --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:bar-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:baz-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:email</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="82e4ededc2e0e3f0ace1edef">[email&#160;protected]</a></span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>c:</code> 命名空间使用与 <code>p:</code> 命名空间相同的协议，通过名字（如果是 bean 引用添加 <code>-ref</code> 后缀）设置构造器参数。同样，它也需要被声明，虽然它不在XSD Schema 中定义（但是存在于 Spring core 中）。</p>
</div>
<div class="paragraph">
<p>对于无法使用构造函数参数名称的罕见情况（通常如果字节码编译没有调试信息），可以降级使用参数索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:_0-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">c:_1-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">baz</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于XML语法的要求，索引前面需要加上 <code>_</code> 下划线前缀，因为XML是属性名不能以数字开头（即使某些IDE允许）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在实践中，构造器解析 <a href="#beans-factory-ctor-arguments-resolution">机制</a> 在匹配参数方面非常高效，所以如无必要，我们建议在所有配置中都使用名称符号。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-compound-property-names"><a class="anchor" href="#beans-compound-property-names"></a>复合属性名</h5>
<div class="paragraph">
<p>当设置 bean 属性时，你可以使用复合或者嵌套的属性名，只要路径中除了最后的属性名所有其他部分都不为 <code>null</code>。考虑以下 bean 定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.Bar</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fred.bob.sammy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p> <code>foo</code> bean 有一个 <code>fred</code> 属性， <code>fred</code> 有一个 <code>bob</code>属性， <code>bob</code> 属性有一个 <code>sammy</code> 属性，最后的 <code>sammy</code> 属性设置值为 <code>123</code>。为了成功这样配置，<code>foo</code> 的 <code>fred</code> 属性和 <code>fred</code> 的 <code>bob</code> 属性在 bean 创建之后必须是非 <code>null</code> 的，否则会抛出 <code>NullPointerException</code> 异常。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-dependson"><a class="anchor" href="#beans-factory-dependson"></a>1.4.3. 使用 depends-on</h4>
<div class="paragraph">
<p>如果一个 bean 是另一个 bean 的依赖项，那么这通常意味着这个 bean 被设置为另一个 bean 的属性。通常使用基于XML的配置元数据的 <a href="#beans-ref-element"><code>&lt;ref/&gt;</code> 元素</a> 来实现。但有时 bean 之间的依赖是间接的；例如，类中的静态初始化程序需要被如数据库驱动注册这样的"bean"触发。<code>depends-on</code> 特性可以显式强制一个或多个 bean 在他的使用者 bean 初始化之前完成初始化。下面的例子使用 <code>depends-on</code> 特性表示对单个 bean 的依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ManagerBean</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了表示对多个 bean 的依赖关系，你需要提供一个 bean 名字列表作为 <code>depends-on</code> 特性的值，中间用逗号，空格或者分号隔开，作为有效的分隔符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanOne</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager,accountDao</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">manager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">ManagerBean</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.jdbc.JdbcAccountDao</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bean 定义中的 <code>depends-on</code> 特性既可以指定初始化时依赖也可以指定仅对 <a href="#beans-factory-scopes-singleton">单例</a> bean 有效的销毁时依赖。依赖 bean 定义了一个于给定 bean 之间 的 <code>depends-on</code> 关系，依赖 bean 会在给定 bean 销毁之前先行销毁。因此 <code>depends-on</code> 还可以控制shutdown的顺序。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-lazy-init"><a class="anchor" href="#beans-factory-lazy-init"></a>1.4.4. 懒加载 bean</h4>
<div class="paragraph">
<p>默认情况下，<code>ApplicationContext</code> 接口的各种实现以一种“饥渴”态度将所有 <a href="#beans-factory-scopes-singleton">单例</a> bean 作为初始化过程的一部分进行创建和配置。一般来说，这种预实例化是可取的，因为配置或者周围环境中的错误会被立即发现，而不是几小时后甚至几天后才发现。当这种行为 <em>不</em> 必要时，你可以通过将此单例 bean 定义标记为“懒加载”来防止它被预实例化。配置为懒加载的 bean 会告知 IoC 容器在第一次被请求是才创建对象，而不是在应用程序启动时。</p>
</div>
<div class="paragraph">
<p>在 XML 配置中，懒加载行为通过对 <code>&lt;bean/&gt;</code> 元素的 <code>lazy-init</code> 特性的控制来实现；例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lazy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.ExpensiveToCreateBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">lazy-init</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">not.lazy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.AnotherBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>ApplicationContext</code> 读入上面的配置后，<code>ApplicationContext</code> 启动时名字为 <code>lazy</code> 的 bean 不会进行预实例化，而名字为 <code>not.lazy</code> 的 bean 就会进行预实例化。</p>
</div>
<div class="paragraph">
<p>不过，当一个懒加载 bean 是另一个 <em>非</em> 懒加载单例 bean 的依赖的时候，<code>ApplicationContext</code> 还是会在启动阶段创建此懒加载 bean，因为它必须满足成为这些单例 bean 依赖的要求。懒加载 bean 会被注入到在某处的其他非懒加载的单例 bean 中。</p>
</div>
<div class="paragraph">
<p>你也可以在容器级别使用 <code>&lt;beans/&gt;</code> 元素的 <code>default-lazy-init</code> 特性控制懒加载特性；例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-lazy-init</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-autowire"><a class="anchor" href="#beans-factory-autowire"></a>1.4.5. 自动装配协作者</h4>
<div class="paragraph">
<p>Spring 容器可以 <em>自动装配</em> 协作 bean 之间的关系。你可以允许 Spring 通过检查 <code>ApplicationContext</code> 的内容来为你的 bean 自动解析它的协作者（其他 bean）。自动装备具有以下优势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动装配可以显著减少需要指定的属性或者构造器参数。（其他机制例如 <a href="#beans-child-bean-definitions">本章其它地方</a> 讨论过的 bean 模板在这方面也很有价值。）</p>
</li>
<li>
<p>自动装配可以在对象变化时更新配置。例如，如果你需要增加一个类的依赖项，依赖项会满足自动装配需求而不需要你去修改配置。因此自动装配在开发阶段尤其有用，而且在基础代码更加稳定时可以切换为显式装配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在使用基于 XML 的配置元数据时<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup>，你可以通过 <code>&lt;bean/&gt;</code> 元素的 <code>autowire</code> 特性为一个 bean 定义指定自动装配模式。自动装配功能有四种模式。 你可以单独指定每个 bean 的自动装配模式且选择自动装配那些 bean。</p>
</div>
<table id="beans-factory-autowiring-modes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. 自动装配模式</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">模式</th>
<th class="tableblock halign-left valign-top">对应解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认） 不自动装配。Bean 引用必须通过 <code>ref</code> 元素来定义。更改默认配置不推荐用于较大的部署，因为显示指定协作者更易控制且更清晰。从某种程度上说，它记录了系统的结构。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过属性名称自动装配。Spring 寻找与需要自动装配的属性同名的 bean。例如，如果一个 bean 被设置为通过名称自动装配，且它有一个 <em>master</em> 属性（也就是说，它有一个 <em>setMaster(..)</em> 方法），Spring 会寻找名为 <code>master</code> 的 bean 定义，并用它来设置属性值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byType</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果容器中恰有一个某属性类型的 bean，那么就允许属性通过类型自动装配这个 bean。如果此类型的 bean 不止一个，那么就会抛出致命异常，说明你不能使用 <em>byType</em> 来自动装配那个 bean。如果没有匹配到 bean，则不会有任何错误产生；属性也不会被设置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">constructor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 <em>byType</em> 类似，但适用于构造器参数。如果容器中没有与此构造器参数匹配的 bean，就会抛出致命异常。 </p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用 <em>byType</em> 或者 <em>constructor</em> 自动装配模式，你可以装配数组和类型确定的集合。在这些情况下，容器内 <em>所有</em> 匹配期望类型的自动装配候选都会被提供以满足依赖性。如果期望的键类型是 <code>String</code>，你可以自动装配强类型的 Map。所有匹配期望类型的 Map 值组成所有 bean 实例，所有对应的 bean 名称组成这些 Map 的键。</p>
</div>
<div class="paragraph">
<p>你可以讲依赖检查与自动装配结合起来，依赖检查会在自动装配完成后进行。</p>
</div>
<div class="sect4">
<h5 id="beans-autowired-exceptions"><a class="anchor" href="#beans-autowired-exceptions"></a>自动装配的局限性的劣势</h5>
<div class="paragraph">
<p>当自动装配在整个工程中一致使用时其效果最好。如果普遍情况没有使用自动装配，仅仅在一两个 bean 定义中使用自动装配可能会让开发者感到困惑。</p>
</div>
<div class="paragraph">
<p>思考一下自动装配的局限性的劣势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>property</code> 和 <code>constructor-arg</code> 的显式设置总是会覆盖自动装配。 你不能自动装配所谓的  <em>简单</em> 属性如原子类型，<code>Strings</code>，和 <code>Classes</code>（以及这些简单类型的数组）。这是设计上的限制。</p>
</li>
<li>
<p>自动装配比显式装配更具有不确定性。如上表所述，尽管 Spring 可以小心地尽量避免对有可能导致无法预料结果的歧义性情况进行猜测，但 Spring 管理的对象之间的关系已经不再被显示的记录。</p>
</li>
<li>
<p>对于 Spring 容器中用于生成文档的工具来说，装配信息可能不能被获取。</p>
</li>
<li>
<p>容器中的多个 bean 定义可能会匹配 setter 方法或者构造器参数指定的需要自动装配的类型。对于数组，集合或者 Map 来说，这不一定是个问题。不过对于期望单个值的依赖项而言，这种歧义性并不能被随意消除。如果没有一个唯一 bean 被匹配到，那么将会抛出异常。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在后面的场景中，你有几个选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>抛弃自动装配而支持显式装配。</p>
</li>
<li>
<p>像下一节描述的那样通过设置 bean 定义的 <code>autowire-candidate</code> 特性为 <code>false</code> 来避免自动装配。</p>
</li>
<li>
<p>通过设置 <code>&lt;bean/&gt;</code> 元素的 <code>primary</code> 特性为 <code>true</code> 来指定某个 bean 定义为 <em>主</em> 候选 bean。</p>
</li>
<li>
<p>通过基于注解的配置来实现更多细粒度的控制，如 <a href="#beans-annotation-config">基于注解的容器配置</a> 中所描述的。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-autowire-candidate"><a class="anchor" href="#beans-factory-autowire-candidate"></a>将某个 bean 排除出自动装配</h5>
<div class="paragraph">
<p>基于对每个 bean 都操作的策略，你可以把某个 bean 排除出自动装配。在 Spring 的XML形式中，将 <code>&lt;bean/&gt;</code> 元素的 <code>autowire-candidate</code> 特性设置为 <code>false</code>；容器会使得此指定的 bean 定义对于自动装配基础模块不可用（包括注解风格的配置如 <a href="#beans-autowired-annotation"><code>@Autowired</code></a>）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>autowire-candidate</code> 特性被设计成只对基于类型的自动装配产生影响。它不会影响基于名称装配的显式引用。结果就是，基于名称的自动装配仍然会将名称匹配的 bean 注入进去。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你也可以根据 bean 名称的匹配模式限制自动装配的候选 bean。顶层 <code>&lt;beans/&gt;</code> 元素的 <code>default-autowire-candidates</code> 特性接受一个或多个模式。例如，为了限制任何以 <em>Repository</em> 结尾的自动装配候选 bean，可以提供一个 *Repository 值。对于多个模式，可以定义一个逗号为分隔符的列表。对 bean 定义的 <code>autowire-candidate</code> 特性显示设置的值 <code>true</code> 或者 <code>false</code> 优先级最高，对于这些 bean 来说，模式匹配规则不起作用。</p>
</div>
<div class="paragraph">
<p>对于那些你不想要通过自动装配注入到其它 bean 的 bean 来说，这些技术是很有用的。这不是说某个被排除的 bean 自身不能通过自动装配来进行配置。更确切地说，这个 bean 本身就不是一个为了自动装配到其它 bean 的候选 bean。
</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-method-injection"><a class="anchor" href="#beans-factory-method-injection"></a>1.4.6. 方法注入</h4>
<div class="paragraph">
<p>在大多数应用场景中，容器中大部分 bean 都是 <a href="#beans-factory-scopes-singleton">单例 bean</a>。当一个单例 bean 需要与其他单例 bean 协作时，或者当一个非单例 bean 需要与其他非单例 bean 协作时，你通常通过将一个 bean 定义为另一个 bean 的属性来达到这种依赖关系。但是当 bean 的生命周期不同时问题就出现了。假设单例 bean A 需要使用（可能 A 中每个方法的调用都会使用）非单例（原型） bean B。容器只会创建单例 bean A 一次，所以只有一次设置 A 的属性的机会。容器无法在每次需要的时候向 bean A 提供一个 bean B 的新实例。</p>
</div>
<div class="paragraph">
<p>这个问题的一种解决方案是放弃一些控制反转。你可以通过让 bean A 实现 <code>ApplicationContextAware</code> 接口使它能 <a href="#beans-factory-aware">感知容器</a>，然后当每次 bean A 需要 bean B 的时候通过 <a href="#beans-factory-client">对容器调用 getBean("B") 方法</a> 请求（通常是新得）bean B 的实例。下面是使用这个方法的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span>
<span class="keyword">package</span> <span class="namespace">fiona.apple</span>;

<span class="comment">// Spring-API imports</span>
<span class="keyword">import</span> <span class="include">org.springframework.beans.BeansException</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContextAware</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">CommandManager</span> <span class="directive">implements</span> ApplicationContextAware {

        <span class="directive">private</span> ApplicationContext applicationContext;

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Map</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="directive">protected</span> Command createCommand() {
                <span class="comment">// notice the Spring API dependency!</span>
                <span class="keyword">return</span> <span class="local-variable">this</span>.applicationContext.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">command</span><span class="delimiter">&quot;</span></span>, Command.class);
        }

        <span class="directive">public</span> <span class="type">void</span> setApplicationContext(
                        ApplicationContext applicationContext) <span class="directive">throws</span> BeansException {
                <span class="local-variable">this</span>.applicationContext = applicationContext;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的例子其实是不可取的，因为它将业务代码与 Spring 框架耦合起来了，并且业务代码能感知 Spring 框架。作为 Spring IoC 某种程度上的高级特性，方法注入就用了一种简洁的方式处理这个问题。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>你可以在 <a href="https://spring.io/blog/2004/08/06/method-injection/">这个博客</a> 中了解跟多关于犯法注入的动机。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lookup-method-injection"><a class="anchor" href="#beans-factory-lookup-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>查找方法注入是容器的一种覆盖 <em>其管理的 bean</em> 中的方法的能力，它可以返回容器中对另一个命名 bean 的查找结果。 查找通常会涉及原型 bean，如前一小节描述的场景中那样。Spring 框架通过使用 GBLIB 库实现这个方法注入，CGLIB 库的字节码生成功能会动态生成一个覆盖这个方法的子类。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>为了使这个动态子类正常工作，这个被 Spring bean 容器子类化的类不能是 <code>final</code> 的，且那些会被覆盖的方法也不能是 <code>final</code> 的。</p>
</li>
<li>
<p>对一个含有 <code>abstract</code> 方法的类进行单元测试，要求你对这个类进行子类化，并且还要提供这个 <code>abstract</code> 方法的 stub 实现。</p>
</li>
<li>
<p>对于要求获得具体类的组建扫描，具体方法也是必要的。</p>
</li>
<li>
<p>另一个关键限制是查找方法不适用于工厂方法，特别是不适用于配置类中的 <code>@Bean</code> 方法，因为容器并不负责在这种情况下创建实例，因此也不能在如此快速的过程中创建一个子在运行时生成的子类。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>看一下前一个代码片段中的 <code>CommandManager</code> 类，可以看到 Spring 容器会动态地覆盖 <code>createCommand()</code> 方法的实现。<code>CommandManager</code> 类将不会有任何 Spring 依赖，重写的例子如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">fiona.apple</span>;

<span class="comment">// no more Spring imports!</span>

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command interface</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="comment">// okay... but where is the implementation of this method?</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户类包含要被注入的方法（这个例子中是 <code>CommandManager</code>），将要被注入的方法需要以下格式的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;public</span><span class="error">|</span><span class="attribute-name">protected</span><span class="tag">&gt;</span> [abstract] <span class="tag">&lt;return-type&gt;</span> theMethodName(no-arguments);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这个方法是 <code>abstract</code>的，那么动态生成的子类会实现这个方法。否则，动态生成的子类会覆盖原始类中定义的具体方法。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fiona.apple.AsyncCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">commandManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fiona.apple.CommandManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;lookup-method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">createCommand</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <em>commandManager</em> bean 在任何需要 <em>myCommand</em> bean 的实例时，它都会调用自己的 <code>createCommand()</code> 方法。如果确实需要的话，你必须仔细将 <code>myCommand</code> bean 作为原型 bean 来部署。如果它是作为 <a href="#beans-factory-scopes-singleton">原型</a> bean 部署的，那么每次都会返回同一个 <code>myCommand</code> 实例。</p>
</div>
<div class="paragraph">
<p>另一种选择，在基于注解的组件模型中，你可以通过 <code>@Lookup</code> 注解声明一个查找方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                Command command = createCommand();
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="annotation">@Lookup</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">myCommand</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再或者，还有一种更地道的方式，你可以依靠被解析的目标 bean 的查找方法的声明返回类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                MyCommand command = createCommand();
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="annotation">@Lookup</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> MyCommand createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>需要注意的是对于使用注解的这些方法，你需要提供他们的基础实现，以便兼容 Spring 的组件扫描规则，因为 Spring 的组件扫描规则默认会忽略抽象类。不过对于显式注册或者显式导入的 bean 类没有这个限制。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>另一种可以访问不同作用域的目标 bean  是通过 <code>ObjectFactory</code>/<code>Provider</code> 注入点。查看 <a href="#beans-factory-scopes-other-injection">Scoped beans as dependencies</a>。</p>
</div>
<div class="paragraph">
<p>感兴趣的读者可能会发现 <code>ServiceLocatorFactoryBean</code> (在 <code>org.springframework.beans.factory.config</code> 包中) 使用的就是这种方法。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-arbitrary-method-replacement"><a class="anchor" href="#beans-factory-arbitrary-method-replacement"></a>任意方法替换</h5>
<div class="paragraph">
<p>对 bean 中任意方法替换的能力是另一种相比查找方法注入更少使用的方法注入形式，这种能力能将被管理 bean 的任意方法替换为另一个方法实现。用户可以安全跳过本小节剩余部分直到真正用到这个功能的时候再来看。</p>
</div>
<div class="paragraph">
<p>在基于XML的配置元数据中，对于一个已经部署的 bean，你可以使用 <code>replaced-method</code> 元素将现有的方法实现替换为其他方法实现。考虑下面的类，有一个我们想要覆盖的 computeValue 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyValueCalculator</span> {

        <span class="directive">public</span> <span class="predefined-type">String</span> computeValue(<span class="predefined-type">String</span> input) {
                <span class="comment">// some real code...</span>
        }

        <span class="comment">// some other methods...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现了 <code>org.springframework.beans.factory.support.MethodReplacer</code> 接口的类提供了一个新的方法定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ReplacementComputeValue</span> <span class="directive">implements</span> MethodReplacer {

        <span class="directive">public</span> <span class="predefined-type">Object</span> reimplement(<span class="predefined-type">Object</span> o, <span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// get the input value, work with it, and return a computed result</span>
                <span class="predefined-type">String</span> input = (<span class="predefined-type">String</span>) args[<span class="integer">0</span>];
                ...
                return ...;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>部署的原始类及其指定要覆盖的方法的 bean 定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myValueCalculator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.z.MyValueCalculator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span>
        <span class="tag">&lt;replaced-method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">computeValue</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">replacer</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replacementComputeValue</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;arg-type&gt;</span>String<span class="tag">&lt;/arg-type&gt;</span>
        <span class="tag">&lt;/replaced-method&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">replacementComputeValue</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">a.b.c.ReplacementComputeValue</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在 <code>&lt;replaced-method/&gt;</code> 元素中使用一个或者多个 <code>&lt;arg-type/&gt;</code> 元素来区别需要覆盖的方法的方法签名。只有在类中进行了方法重载且有多个重载变形的时候，参数的签名才是必需的。方便起见，string类型的参数可能是全限定名的一个子串。例如，下面所有形式都能匹配 <code>java.lang.String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">java.lang.String
<span class="predefined-type">String</span>
Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为参数的数量经常已经足够区分每个可能的选择，这个允许给出匹配参数类型的最短字符串的快捷方式会让你少打很多字。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-scopes"><a class="anchor" href="#beans-factory-scopes"></a>1.5. Bean 的作用域</h3>
<div class="paragraph">
<p>当你创建一个 bean 定义，你就通过 bean 定义创建了一个用于创建类的真实实例的一个 <em>recipe</em>。把 bean 定义当做一个 recipe， 这个想法很重要，因为这意味着，对于同一个类，你可以从它的同一个 recipe 中创建许多对象实例。</p>
</div>
<div class="paragraph">
<p>你不仅可以控制要插入到对象种的各种依赖项和配置值，而且还能管理对象的 <em>作用域</em>，这里的对象都是由特定 bean 定义创建的。这个方法很强大而且很灵活，你可以用过配置文件 <em>选择</em> 你创建的这些对象的作用域，而不是在 Java 类级别的内置对象作用域。Bean 定义的时候，可以在多个作用域中选择一种，对它进行部署：Spring 框架支持6中开箱即用的作用域，其中5中当且仅当你使用能感知web的 <code>ApplicationContext</code> 时才可用。</p>
</div>
<div class="paragraph">
<p>下面的作用域是支持开箱即用的。你也可以创建 <a href="#beans-factory-scopes-custom">自定义作用域。</a></p>
</div>
<table id="beans-factory-scopes-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Bean 作用域</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">作用域</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-singleton">singleton（单例）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（默认）对于每个 Spring IoC 容器，其中单个 bean 定义对应创建单个对应的单个对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-prototype">prototype（原型）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义可以创建任意个数个对应的对象实例。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-request">request（请求域）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为单个 HTTP 请求的生命周期；也就是说，每个 HTTP 请求都有属于它自己的根据 bean 定义创建的对象实例。只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-session">session（会话域）</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为单个 HTTP 会话的生命周期；只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-application">application</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为<code>ServletContext</code> 的生命周期；只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#websocket-stomp-websocket-scope">websocket</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个 bean 定义创建的对象实例作用域为<code>WebSocket</code> 的生命周期；只有在感知web的 Spring <code>ApplicationContext</code> 中有效。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 3.0 中可以用 <em>thread scope</em> ，但默认情况下没有注册。更多信息，请参看文档 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code>SimpleThreadScope</code></a>。关于如何注册 <em>thread scope</em> 或者任何其他自定义作用域的指南，参看 <a href="#beans-factory-scopes-custom-using">使用自定义作用域</a>。
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-singleton"><a class="anchor" href="#beans-factory-scopes-singleton"></a>1.5.1. singleton 单例作用域</h4>
<div class="paragraph">
<p>单例 bean 只管理一个 <em>共享</em> 实例，所有对 id 与 bean 定义匹配的 bean 的请求都会由 Spring 容器返回同一个特定的实例。</p>
</div>
<div class="paragraph">
<p>换言之，当你定一个了一个作用域为单例的 bean 定义时，Spring IoC 容器会根据 bean 定义创建一个 <em>唯一确定</em> 的对象实例。这个单独的实例会被存储在专门存放这些单例 bean 的缓存中，接下来对这个已命名 bean 的 <em>所有后续请求和应用</em> 都会返回缓存中的那个对象实例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/singleton.png" alt="singleton">
</div>
</div>
<div class="paragraph">
<p>Spring 中的单例 bean 概念不同于《设计模式》书中定义的单例模式。设计模式中的单例是对对象的作用域进行硬编码，这样每个类加载器 <em>只能创建一个</em> 特定类的实例。对 Spring 单例作用域最好的叙述是 <em>每个容器每个类</em>。意思就是如果你在一个 Spring 容器中为一个特定的类定义了一个 bean，Spring 就只会根据这个 bean 定义只创建这个类的唯一一个对象实例。<em>单例作用域是 Spring 的默认作用域</em>。想要在XML中定义一个单例 bean，你可以按照下面的例子编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">singleton</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-prototype"><a class="anchor" href="#beans-factory-scopes-prototype"></a>1.5.2. prototype 原型作用域</h4>
<div class="paragraph">
<p>对 bean 部署非单例的原型作用域会导致每次对特定 bean 的请求都会 <em>产生一个新的 bean 对象实例</em>。也就是说，这个 bean 会被注入到另一个 bean 中或者你通过调用容器得得 <code>getBean()</code> 方法来请求它。作为一种通用规则，通常原型作用域适用于所有有状态 bean，单例作用域适用于无状态 bean。</p>
</div>
<div class="paragraph">
<p>下图阐释了 Spring 的原型作用域。<em>数据访问对象（DAO）通常不会被配置为原型 bean，因为典型的 DAO 不会有任何会话状态；对这个作者来说单例 bean 图的核心的重用更容易。</em></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/prototype.png" alt="prototype">
</div>
</div>
<div class="paragraph">
<p>下面的例子在XML中定义了一个原型 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">accountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultAccountService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他作用域相比，Spring 不负责管理原型 bean 的整个生命周期：容器会初始化，配置，要不然就是装配原型对象，并将其传递给客户代码，之后不再对此原型实例跟踪记录。因此，虽然不管什么作用域 <em>初始化</em> 阶段的回调方法都会在所有对象上执行，但在原型 bean 的情况下不会调用配置的 <em>销毁</em> 回调方法。客户代码必须手动清理原型作用域对象并释放这个原型 bean 拥有的高代价资源。为了使 Spring 容器释放原型作用域 bean 拥有的资源，可以试试使用自定义的 <a href="#beans-factory-extension-bpp">bean post-processor</a>，它有用对需要清理的 bean 的引用。</p>
</div>
<div class="paragraph">
<p>在某些方面，对于原型作用域的 bean，Spring 容器的角色就像 Java 中 <code>new</code> 操作符的替代品。所有在这个节点之后的声明周期管理都必须有客户代码处理。（关于更多 Spring 容器中 bean 的生命周期的细节，参见 <a href="#beans-factory-lifecycle">生命周期回调</a>。）</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-sing-prot-interaction"><a class="anchor" href="#beans-factory-scopes-sing-prot-interaction"></a>1.5.3. 含有原型 bean 依赖项的单例 bean</h4>
<div class="paragraph">
<p>当你使用含有原型 bean 依赖项的单例作用域 bean 时，注意 <em>依赖解析发生在实例化时间</em>。那么如果你使用依赖注入将原型作用域 bean 注入到单例作用域 bean 时，将会实例化一个新的原型 bean 并将它注入到这个单例 bean 中。The prototype instance is the sole instance that is ever supplied to the ingleton-scoped bean.（不知何意）。</p>
</div>
<div class="paragraph">
<p>但是，假设要在运行时让单例作用域 bean 不断重复获取原型作用域 bean 的新实例。你不能把原型作用域 bean 注入到你的单例 bean 中，因为注入只在 Spring 容器实例化单例 bean 和解析并注入它的依赖项的时候发生一次。如果你在运行时不止一次需要原型 bean 的新实例，参见 <a href="#beans-factory-method-injection">方法注入</a></p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-other"><a class="anchor" href="#beans-factory-scopes-other"></a>1.5.4. Request（请求作用域）, session（会话作用域）, application（应用作用域）, and WebSocket（websocket作用域）</h4>
<div class="paragraph">
<p><code>request</code>, <code>session</code>, <code>application</code>，和<code>websocket</code> 作用域只在你使用有 web 感知能力的 Spring <code>ApplicationContext</code> 实现时可用（如 <code>XmlWebApplicationContext</code>）。如果你在普通的 Spring IoC 容器如 <code>ClassPathXmlApplicationContext</code> 中使用这些作用域，会有 <code>IllegalStateException</code> 异常抛出，向你投诉你使用了未知的 bean 作用域。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-web-configuration"><a class="anchor" href="#beans-factory-scopes-other-web-configuration"></a>初始化 web 配置</h5>
<div class="paragraph">
<p>为了支持 <code>request</code>, <code>session</code>, <code>application</code>，和
  <code>websocket</code> 作用域级别的 bean（web 作用域 bean），在你定义 bean 之前需要进行一些小的初始化配置。（这个初始化设置对于标准作用域 <code>singleton</code> 和 <code>prototype</code> 是不需要的。）</p>
</div>
<div class="paragraph">
<p>如何完成这个初始化设置取决于你使用的特定的 Servlet 环境。</p>
</div>
<div class="paragraph">
<p>如果你在 Spring Web MVC 中访问具有作用域的 bean，实际上也就是在请求内部由 Spring <code>DispatcherServlet</code> 来处理，那么不需要特殊的设置：<code>DispatcherServlet</code> 已经暴露了所有相关的状态。</p>
</div>
<div class="paragraph">
<p>如果你使用 Servlet 2.5 web 容器，请求在Spring <code>DispatcherServlet</code> 之外被处理（例如，当使用 JSF 或者 Struts 的时候），你需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于 Servlet 3.0+，这可以通过 <code>WebApplicationInitializer</code> 接口编码实现。或者，对于更早的容器，在 web 应用程序的 <code>web.xml</code> 文件中添加如下声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        ...
        <span class="tag">&lt;listener&gt;</span>
                <span class="tag">&lt;listener-class&gt;</span>
                        org.springframework.web.context.request.RequestContextListener
                <span class="tag">&lt;/listener-class&gt;</span>
        <span class="tag">&lt;/listener&gt;</span>
        ...
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>再或者，如果你的监听器配置有点问题，可以考虑使用 Spring 的 <code>RequestContextFilter</code>。过滤器映射依赖于周围的 web 应用配置，因此你需要的时候你不得不适当的修改之。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        ...
        <span class="tag">&lt;filter&gt;</span>
                <span class="tag">&lt;filter-name&gt;</span>requestContextFilter<span class="tag">&lt;/filter-name&gt;</span>
                <span class="tag">&lt;filter-class&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/filter-class&gt;</span>
        <span class="tag">&lt;/filter&gt;</span>
        <span class="tag">&lt;filter-mapping&gt;</span>
                <span class="tag">&lt;filter-name&gt;</span>requestContextFilter<span class="tag">&lt;/filter-name&gt;</span>
                <span class="tag">&lt;url-pattern&gt;</span>/*<span class="tag">&lt;/url-pattern&gt;</span>
        <span class="tag">&lt;/filter-mapping&gt;</span>
        ...
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code>, <code>RequestContextListener</code>，和<code>RequestContextFilter</code> 完成的都是同样的工作，也就是将 HTTP 请求对象绑定到为这个请求提供服务的 <code>线程</code> 上。这使得具有 request 作用域和 session 作用域的 bean 在之后调用链中都是可用的。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-request"><a class="anchor" href="#beans-factory-scopes-request"></a>Request 作用域</h5>
<div class="paragraph">
<p>考虑以下 bean 定义的 XML 配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">loginAction</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.LoginAction</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">request</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过使用 <code>loginAction</code> bean 定义为每一个 HTTP 请求创建一个新的 <code>LoginAction</code> bean 实例。也就是说，<code>loginAction</code> bean 是具有 HTTP request 级别作用域的 bean。对于这个创建好的实例的内部状态，你可以想怎么改变就怎么改变，因为其他根据这同一个 <code>loginAction</code> bean 定义创建出来的实例根本看不到这些状态的改变；他们对于每一个不同的请求都是独有的。当请求处理完成时，这个处于请求作用域级别的 bean 就会被销毁。</p>
</div>
<div class="paragraph">
<p>当你使用注解驱动的组件或者 Java Config 时，添加了 <code>@RequestScope</code> 注解的组件会具有  <code>request</code> 作用域。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@RequestScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">LoginAction</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-session"><a class="anchor" href="#beans-factory-scopes-session"></a>Session 作用域</h5>
<div class="paragraph">
<p>考虑以下 bean 定义的 XML 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过使用 <code>userPreferences</code> bean 定义为每一个 HTTP 请求 <code>Session</code> 生命周期创建一个新的 <code>UserPreferences</code> bean 实例。也就是说，<code>userPreferences</code> bean 是具有对应 HTTP <code>Session</code> 级别作用域的 bean。正如具有 <code>request</code> 作用域 的 bean，对于这个创建好的实例的内部状态，你可以想怎么改变就怎么改变，须知其他根据这同一个 <code>userPreferences</code> bean 定义创建出来的实例也看不到这些状态的改变，他们对于每一个不同的 HTTP <code>Session</code> 都是独有的。当 HTTP <code>Session</code> 最终销毁的时候，作用域与之对应的 bean 也就销毁了。</p>
</div>
<div class="paragraph">
<p>当你使用注解驱动的组件或者 Java Config 时，添加了 <code>@SessionScope</code> 注解的组件会具有  <code>session</code> 作用域。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@SessionScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">UserPreferences</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-application"><a class="anchor" href="#beans-factory-scopes-application"></a>Application 作用域</h5>
<div class="paragraph">
<p>考虑以下 bean 定义的 XML 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">appPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.AppPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">application</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring 容器通过使用 <code>appPreferences</code> bean 定义为整个个 web 应用创建一个新的 <code>AppPreferences</code> bean 实例。也就是说，<code>appPreferences</code> bean 是具有 <code>ServletContext</code> 级别作用域的 bean，它作为一个正则 <code>ServletContext</code> 特性被存储起来。某种程度上讲，这与 Spring 的单例 bean 有点类似，但在两个重要方面有所不同：他是对于每个  <code>ServletContext</code> 的单例，而不是对于每个 Spring 'ApplicationContext' （任何给定的 web 应用中可能会有不止一个 ApplicationContext）的单例，它真正是作为一个 <code>ServletContext</code> 特性而被暴露出来也因此可见。</p>
</div>
<div class="paragraph">
<p>当你使用注解驱动的组件或者 Java Config 时，添加了 <code>@ApplicationScope</code> 注解的组件会具有  <code>application</code> 作用域。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><strong><span class="annotation">@ApplicationScope</span></strong>
<span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppPreferences</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-injection"><a class="anchor" href="#beans-factory-scopes-other-injection"></a>作为依赖项的作用域 bean</h5>
<div class="paragraph">
<p>Spring IoC 容器不仅管理你的对象（bean） 的实例化，也管理协作者（或者依赖项）的装配。如果你想要将（例如）一个具有 HTTP request 作用域的 bean 注入到另一个具有更长生命周期作用域的 bean 中，你可以选择注入这个作用域 bean 的 AOP 代理。即，你需要注入一个与此作用域对象暴露相同公共接口的代理对象，但还能从相关作用域（如一个 HTTP request）获取真实的目标对象并且对代理方法的调用能作用于真正的对象。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你也可以在 <code>singleton</code> 作用域的 bean 之间使用 <code>&lt;aop:scoped-proxy/&gt;</code>，通过一个中间代理应用进行序列化，并且能通过反序列化重新获取目标单例 bean。</p>
</div>
<div class="paragraph">
<p>如果对 <code>prototype</code> 作用域的 bean 声明 <code>&lt;aop:scoped-proxy/&gt;</code> ，对这个共享代理的每次方法调用都会导致一次（调用朝向的？）目标 bean 新实例的创建。</p>
</div>
<div class="paragraph">
<p>而且，作用域代理并不是唯一以生命周期安全形式访问小作用域 bean 的方式。你也可以简单地声明你的注入点（例如，构造器/setter 参数或者自动装配域）为 <code>ObjectFactory&lt;MyTargetBean&gt;</code>，允许每次需要的时候通过 <code>getObject()</code> 调用按需获取当前实例————这里并没有对其进行保持或者分开存储。</p>
</div>
<div class="paragraph">
<p>作为一个扩展变形，你可以声明 <code>ObjectProvider&lt;MyTargetBean&gt;</code>，他提供了几个附加的访问变形，包括 <code>getIfAvailable</code> 和 <code>getIfUnique</code>。</p>
</div>
<div class="paragraph">
<p>JSR-330 中称它为 <code>Provider</code>，对于每次获取尝试使用 <code>Provider&lt;MyTargetBean&gt;</code> 声明和对应 <code>get()</code> 调用。关于JSR-330整体的更多细节请看 <a href="#beans-standard-annotations">此处</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>虽然下面例子中的配置只有一行，但对于理解它背后的“why”和“how”很重要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop</span>
                <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- instructs the container to proxy the surrounding bean --&gt;</span>
                <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.SimpleUserService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- a reference to the proxied userPreferences bean --&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过将一个子 <code>&lt;aop:scoped-proxy/&gt;</code> 元素插入到一个定义域 bean 定义（参见 <a href="#beans-factory-scopes-other-injection-proxies">选择要创建的代理类型</a> 和
  <a href="appendix.html#xsd-configuration">基于 Schema 的XML配置</a>）来创建这样一个代理。为什么具有<code>request</code>，<code>session</code> 和自定义作用域级别的 bean 定义需要 <code>&lt;aop:scoped-proxy/&gt;</code> 元素呢？让我们查看一下下面的单例 bean 定义并将它与你需要定义的为面所述的定义域比较一下（注意下面的 <code>userPreferences</code> bean 定义是不完整的）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中，具有 HTTP <code>Session</code> 作用域的 bean <code>userPreferences</code> 被注入到单例 bean <code>userManager</code> 中。这里的要点是 <code>userManager</code> bean 是一个单例 bean；每个容器只会对它进行 <em>一次</em> 实例化，他的依赖项（这个例子中只有一个，就是 <code>userPreferences</code> bean）也只会被注入一次。这意味着 <code>userManager</code> bean 将只能对确定的同一个 <code>userPreferences</code> 对象进行操作，也就是说最初被注入的那个对象。</p>
</div>
<div class="paragraph">
<p>当你将一个短生命周期的作用域 bean 注入到一个长生命周期的作用域 bean 时，这不是你想要它们表现出来的行为，例如将一个具有 HTTP <code>Session</code> 作用域的协作 bean 作为依赖项注入到一个单例 bean 中。当然，你需要一个单一的 <code>userManager</code> 对象，而对于 HTTP <code>Session</code> 的生命周期，你需要一个与具体所谓 HTTP <code>Session</code> 对应的 <code>userPreferences</code> 对象。因此，容器创建了一个与 <code>UserPreferences</code> 类（理想情况下应该是一个 <code>UserPreferences</code> 实例）暴露相同公共接口的对象，可以通过作用域机制（HTTP request，<code>Session</code>，等等）获取真正的 <code>UserPreferences</code> 对象。容器将这个代理对象注入到 <code>userManager</code> bean 中，而 <code>userManager</code> bean 不会感知 <code>UserPreferences</code> 引用其实是一个代理。在这里例子中，当 <code>UserManager</code> 实例调用依赖注入的 <code>UserPreferences</code> 对象方法时，它其实调用的是代理对象的方法。之后代理对象从 HTTP <code>Session</code> 中获取真正的 <code>UserPreferences</code> 对象，然后将方法调用委托给已经获取的真正 <code>UserPreferences</code> 对象。/p>
</div>
<div class="paragraph">
<p>因此当你将具有 <code>request</code> 和 <code>session</code> 作用域 bean 注入到协作对象中时，你需要以下正确的完整的配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-scopes-other-injection-proxies"><a class="anchor" href="#beans-factory-scopes-other-injection-proxies"></a>选择要创建的代理类型</h6>
<div class="paragraph">
<p>默认情况下，当容器为具有 <code>&lt;aop:scoped-proxy/&gt;</code> 元素标记的 bean 创建代理时，会创建一个基于 GBLIB 的代理。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>GBLIB 代理只拦截共有方法调用。不要在这个代理上调用非共有方法；这些调用不会被委托给具有作用域的目标对象。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另一种选择，你可以将 Spring 容器配置为为此类具有作用域的 bean 创建标准 JDK 的基于接口的代理，这是通过将 <code>&lt;aop:scoped-proxy/&gt;</code> 元素的 <code>proxy-target-class</code> 特性设为  <code>false</code> 实现的。使用 JDK 的基于接口的代理意味着你不需要在你的应用程序类路径中添加额外的库来支持这种代理。不过，这也意味着具有作用域 bean 的类必须实现至少一个接口，且注入这个作用域 bean 的所有协作者都必须通过它自身的某个接口来引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="comment">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultUserPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">session</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;aop:scoped-proxy</span> <span class="attribute-name">proxy-target-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.UserManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userPreferences</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>更多关于对基于类对的代理或者基于接口的代理的选择，参见<a href="#aop-proxying">代理机制</a>。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-custom"><a class="anchor" href="#beans-factory-scopes-custom"></a>1.5.5. 自定义作用域</h4>
<div class="paragraph">
<p>Bean 的作用域机制是可扩展的；你可以定义你自己的作用域，或者可以对现存的作用域进行重定义，尽管后者被认为是一种不好的实践，你不能覆盖内置的 <code>singleton</code> 和 <code>prototype</code> 作用域。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-creating"><a class="anchor" href="#beans-factory-scopes-custom-creating"></a>创建自定义作用域</h5>
<div class="paragraph">
<p>要将你的自定义作用域集成到 Spring 容器，你需要实现 <code>org.springframework.beans.factory.config.Scope</code> 接口，一节将叙述这个接口。对于怎样实现你自己的作用域，参见 Spring 框架本身和 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html"><code>Scope</code> javadocs</a> 提供的实现，里面有更多你需要实现这些方法的细节。</p>
</div>
<div class="paragraph">
<p><code>Scope</code> 接口有四个可以从作用域中取对象，删对象和允许他们被销毁的方法。i</p>
</div>
<div class="paragraph">
<p>下面的方法从其作用域返回对象。以 session 作用域为例，它返回具有 session 作用域的 bean（如果它不存在，方法就会返回这个 bean 的新实例，然后将它绑定到 sesion 中以便以后引用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Object</span> get(<span class="predefined-type">String</span> name, <span class="predefined-type">ObjectFactory</span> objectFactory)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的方法从其作用域删除对象。以 session 作用域为例，它从其作用域中删除具有 session 作用域的 bean。此对象应该被返回，但如果指定名字的对象那个没找到会返回 null。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Object</span> remove(<span class="predefined-type">String</span> name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当作用域被销毁或者当作用域中指定的对象被销毁时，下面的方法会注册作用域应该执行的回调方法。关于销毁回调犯法的更多信息参见 javadocs 或者 Spring 作用域实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerDestructionCallback(<span class="predefined-type">String</span> name, <span class="predefined-type">Runnable</span> destructionCallback)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的方法从其作用域获得会话标识符。每个作用域的标识符都是不同的。对于 session 作用域实现，这个标识符就是 session 标识符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> getConversationId()</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-using"><a class="anchor" href="#beans-factory-scopes-custom-using"></a>Using a custom scope</h5>
<div class="paragraph">
<p>在你编写或测试一个或者多个自定义 <code>Scope</code> 实现之后，你需要使 Spring 容器能够感知这些新作用域。下面的方法是在 Spring 容器中注册新 <code>Scope</code> 的核心方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> registerScope(<span class="predefined-type">String</span> scopeName, Scope scope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法在 <code>ConfigurableBeanFactory</code> 接口中声明，这个接口在与 Spring 通过 BeanFactory 属性装载到一起的大多数具体的 <code>ApplicationContext</code> 实现中是可用的。</p>
</div>
<div class="paragraph">
<p><code>registerScope(..)</code> 方法的第一个实参是与作用域相关的唯一的名字；Spring 容器本身就有这些名字的例子如 <code>singleton</code> 和 <code>prototype</code>。registerScope(..)</code> 方法的第二个实参是你想注册和使用的自定义 <code>Scope</code> 实现的真正实例。</p>
</div>
<div class="paragraph">
<p>假设你编写了你自定义的 <code>Scope</code> 实现，并按一下方式注册。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面例子使用的 <code>SimpleThreadScope</code> 已经包含在 Spring 中，但默认没有注册。用法与你自己的自定义 <code>Scope</code> 实现一样。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Scope threadScope = <span class="keyword">new</span> SimpleThreadScope();
beanFactory.registerScope(<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span>, threadScope);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后创建具有你自定义 <code>Scope</code> 规则的 bean 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于自定义 <code>Scope</code> 实现，你不受限于只能通过编程注册。你还可以使用声明式的 <code>Scope</code> 注册，采用 <code>CustomScopeConfigurer</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop</span>
                <span class="content">http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.CustomScopeConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scopes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;map&gt;</span>
                                <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.SimpleThreadScope</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                <span class="tag">&lt;/entry&gt;</span>
                        <span class="tag">&lt;/map&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thread</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Rick</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;aop:scoped-proxy</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.Foo</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当你在 <code>FactoryBean</code> 实现中配置 <code>&lt;aop:scoped-proxy/&gt;</code> 时，表示的是这个工厂 bean 本身具有作用域，而不是只通过 <code>getObject()</code> 方法返回的对象。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-nature"><a class="anchor" href="#beans-factory-nature"></a>1.6. 对 bean 的性质进行自定义</h3>
<div class="sect3">
<h4 id="beans-factory-lifecycle"><a class="anchor" href="#beans-factory-lifecycle"></a>1.6.1. 生命周期回调</h4>
<div class="paragraph">
<p>为了能与容器对 bean 生命周期管理交互，你可以实现 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。容器在初始化 bean 时会调用 <code>InitializingBean</code> 的 <code>afterPropertiesSet()</code> 方法，在销毁 bean 时会调用 <code>DisposableBean</code> 的 <code>destroy()</code>方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR-250 的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解通常被认为是在现代 Spring 应用中接收声明周期回调的最佳实践。使用这些注解意味着你的 bean 与特定的 Spring 接口不再耦合在一起了。关于细节参见<a href="#beans-postconstruct-and-predestroy-annotations">@PostConstruct 和 @PreDestroy</a>。</p>
</div>
<div class="paragraph">
<p>如果你不想使用 JSR-250 注解但仍寻求消除耦合，那么可以考虑使用 init-method 和 destroy-method 对象定义元数据。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 Spring 内部，Spring 框架使用 <code>BeanPostProcessor</code> 实现来处理任何它能发现的回调接口并调用合适的方法。如果你需要自定义 Spring 不能提供的开箱即用的功能或其他生命周期行为，你可以自己实现一个 <code>BeanPostProcessor</code> 接口。关于更多信息，参见 <a href="#beans-factory-extension">容器扩展点</a>。</p>
</div>
<div class="paragraph">
<p>除了初始化回调方法和销毁毁掉方法，Spring 管理的对象也可以实现 <code>Lifecycle</code> 接口以便这些对象能参与到容器自身生命周期驱动的启动和关闭过程。</p>
</div>
<div class="paragraph">
<p>这小节叙述了生命周期回调的接口。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-initializingbean"><a class="anchor" href="#beans-factory-lifecycle-initializingbean"></a>初始化回调</h5>
<div class="paragraph">
<p><code>org.springframework.beans.factory.InitializingBean</code> 接口允许 bean 在容器对它设置完所有必须属性之后执行初始化工作。<code>InitializingBean</code> 接口指定了一个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> afterPropertiesSet() <span class="directive">throws</span> <span class="exception">Exception</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>建议你不要使用 <code>InitializingBean</code> 接口，因为它将代码与 Spring 进行了不必要的耦合。作为替代方法，你可以使用 <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a> 注解或者指定一个 POJO 初始化方法。对于基于XML的配置元数据，你可以使用 <code>init-method</code> 特性来指定一个返回值为 void 的无入参方法的方法名。对于 Java 配置，你可以使用 <code>@Bean</code> 的 <code>initMethod</code> 特性，参见 <a href="#beans-java-lifecycle-callbacks">接收声明周期回调</a>。 例如，下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="comment">// do some initialization work</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;等价于&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">AnotherExampleBean</span> <span class="directive">implements</span> InitializingBean {

        <span class="directive">public</span> <span class="type">void</span> afterPropertiesSet() {
                <span class="comment">// do some initialization work</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但没有将代码与 Spring 耦合起来。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-disposablebean"><a class="anchor" href="#beans-factory-lifecycle-disposablebean"></a>销毁回调</h5>
<div class="paragraph">
<p>实现 <code>org.springframework.beans.factory.DisposableBean</code> 接口允许 bean 在包含它的容器销毁时得到一个回调方法。<code>DisposableBean</code> 接口指定了一个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> destroy() <span class="directive">throws</span> <span class="exception">Exception</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>建议你不要使用 <code>DisposableBean</code> 接口，因为它将代码与 Spring 进行了不必要的耦合。作为替代方法，你可以使用 <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a> 接口或者指定一个 bean 定义支持的通用方法。对于基于XML的配置元数据，你可以使用 <code>&lt;bean/&gt;</code> 元素的 <code>destroy-method</code> 特性。对于 Java 配置，你可以使用 <code>@Bean</code> 的 <code>destroyMethod</code> 特性，参见 <a href="#beans-java-lifecycle-callbacks">接收声明周期回调</a>。例如，下面的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.ExampleBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">cleanup</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleBean</span> {

        <span class="directive">public</span> <span class="type">void</span> cleanup() {
                <span class="comment">// do some destruction work (like releasing pooled connections)</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exampleInitBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.AnotherExampleBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">AnotherExampleBean</span> <span class="directive">implements</span> DisposableBean {

        <span class="directive">public</span> <span class="type">void</span> destroy() {
                <span class="comment">// do some destruction work (like releasing pooled connections)</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但没有将代码与 Spring 耦合起来。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;bean&gt;</code> 元素的 <code>destroy-method</code> 特性会被赋予一个特殊值 <code>(inferred)</code>，它会引导 Spring 自动检测指定 bean 类的公有 <code>close</code> 或者
<code>shutdown</code> 方法（可以匹配任何实现 <code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 的类）。为了将此行为应用到一个完整的 bean 集合中，这个特殊<code>(inferred)</code> 值也可以被设置到 <code>&lt;beans&gt;</code> 元素的 <code>default-destroy-method</code> 特性上（参见 <a href="#beans-factory-lifecycle-default-init-destroy-methods">默认初始化和销毁方法</a>）。注意着也是 Java 配置的默认行为。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-default-init-destroy-methods"><a class="anchor" href="#beans-factory-lifecycle-default-init-destroy-methods"></a> 默认初始化和销毁方法</h5>
<div class="paragraph">
<p>如果你不使用 Spring 指定的 <code>InitializingBean</code> 和 <code>DisposableBean</code> 回调接口编写初始化和销毁方法回调，你可以编写名为 <code>init()</code>，<code>initialize()</code>，<code>dispose()</code> 等等这样的方法。这些生命周期回调方法的名字应该在从整个工程中都是标准化的，这样所有开发者都能使用同样的方法名也能保证一致性。</p>
</div>
<div class="paragraph">
<p>你可以对 Spring 容器进行配置，使它能查找每个 bean 的初始化和销毁回调方法。这意味着作为一个应用开发者，你可以编写你自己的应用类并使用名为 <code>init()</code> 的初始化回调方法，而不必在每个 bean 定义真配置一个 <code>init-method="init"</code> 特性。Spring IoC 容器会在 bean 创建的时候告诉那个方法（按照前面叙述的标准生命周期回调约定）。这个特性也强迫初始化和销毁方法回调的命名规则必须有一致性约束。</p>
</div>
<div class="paragraph">
<p>假设你的初始化回调方法名为 <code>init()</code>，销毁回调方法名为 <code>destroy()</code>。你的类会与下面例子类似。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultBlogService</span> <span class="directive">implements</span> BlogService {

        <span class="directive">private</span> BlogDao blogDao;

        <span class="directive">public</span> <span class="type">void</span> setBlogDao(BlogDao blogDao) {
                <span class="local-variable">this</span>.blogDao = blogDao;
        }

        <span class="comment">// this is (unsurprisingly) the initialization callback method</span>
        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="keyword">if</span> (<span class="local-variable">this</span>.blogDao == <span class="predefined-constant">null</span>) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">The [blogDao] property must be set.</span><span class="delimiter">&quot;</span></span>);
                }
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">default-init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.DefaultBlogService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogDao</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blogDao</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>位于顶层 <code>&lt;beans/&gt;</code> 元素的 <code>default-init-method</code> 特性会让 Spring IoC 容器将 bean 中名为 <code>init</code> 的方法识别为初始化回调方法。当 bean 被创建和装配的时候，如果它又这么一个方法，那么它将会在适当的时候被调用。</p>
</div>
<div class="paragraph">
<p>类似的，你可以在顶层 <code>&lt;beans/&gt;</code> 元素的 <code>default-destroy-method</code> 特性（在XML中）中配置销毁方法回调。</p>
</div>
<div class="paragraph">
<p>在现有 bean 类已经有不符合命名规范的回调方法的情况下，你可以（在XML中）通过在 <code>&lt;bean/&gt;</code> 的 <code>init-method</code> 和 <code>destroy-method</code> 特性中方法名来覆盖默行为。</p>
</div>
<div class="paragraph">
<p> Spring 容器保证一旦 bean 被提供所有依赖项后，它就会立即执行配置的初始化回调。因此初始化回调会在原始 bean 引用上调用，这意味着这个时候 AOP 拦截器等还不能应用到这个 bean 中。首先目标 bean 被完整创建出来，然后才会应用带有拦截器链的 AOP 代理（举个例子）。如果目标 bean 和代理分别被独立定义了，那么你的的代码甚至能绕过代理直接与原始目标 bean 进行交互。因此将拦截器应用到初始化方法上可能会导致不一致性，因为这么做会使目标 bean 的生命周期与它的代理/拦截器互相耦合，且当你的代码与原始目标 bean 交互时导致出现奇怪的语义。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-combined-effects"><a class="anchor" href="#beans-factory-lifecycle-combined-effects"></a>组合生命周期机制</h5>
<div class="paragraph">
<p>从 Spring 2.5 开始，你有三个选择来控制 bean 的声明周期行为：<a href="#beans-factory-lifecycle-initializingbean"><code>InitializingBean</code></a> 和
<a href="#beans-factory-lifecycle-disposablebean"><code>DisposableBean</code></a> 回调接口；自定义
<code>init()</code> 和 <code>destroy()</code> 方法；<a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解</a>。你可以将这些机制结合起来控制一个给定的 bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果一个 bean 配置了多种生命周期机制，且每种机制都配置了不同的方法名，那么每个配置的方法都会按下表所列的顺序分别执行。但是，如果不同机制配置了相同的方法名——例如，在不止一个生命周期机制中配置了同名的初始化方法 <code>init()</code> ——那么这个方法就会像前一小节说的那样只执行一次。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于同一个 bean，配置了多个声明周期，并有不同的初始化方法，那么他们的调用顺序如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有 <code>@PostConstruct</code> 注解的方法</p>
</li>
<li>
<p><code>InitializingBean</code> 回调接口定义的 <code>afterPropertiesSet()</code> 方法</p>
</li>
<li>
<p>自定义的 <code>init()</code> 方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>销毁方法也以相同的顺序调用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有 <code>@PreDestroy</code> 注解的方法</p>
</li>
<li>
<p><code>DisposableBean</code> 回调接口定义的 <code>destroy()</code> 方法</p>
</li>
<li>
<p>自定义的 <code>destroy()</code> 方法</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-processor"><a class="anchor" href="#beans-factory-lifecycle-processor"></a>启动和关闭回调方法</h5>
<div class="paragraph">
<p><code>Lifecycle</code> 接口为任何有用它自己生命周期需求的对象定义了一些必备的基本方法（例如开始和停止某个后台处理过程）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lifecycle</span> {

        <span class="type">void</span> start();

        <span class="type">void</span> stop();

        <span class="type">boolean</span> isRunning();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何 Spring 管理的对象都可以实现那个接口。当 <code>ApplicationContext</code> 本身接收到开始和停止信号时，例如运行时的停止/重启场景，它会级联调用所有上下文中定义的 <code>Lifecycle</code> 实现。这个功能是通过将 <code>LifecycleProcessor</code> 作为委托来完成的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">LifecycleProcessor</span> <span class="directive">extends</span> Lifecycle {

        <span class="type">void</span> onRefresh();

        <span class="type">void</span> onClose();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>LifecycleProcessor</code> 本身是 <code>Lifecycle</code> 接口的继承接口。另外它还添加了另外两个方法来响应上下文的刷新和关闭。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意常规的 <code>org.springframework.context.Lifecycle</code> 接口只是一个显式的开始/停止通知的协议，并不意味着上下文刷新时的自动启动。考虑实现 <code>org.springframework.context.SmartLifecycle</code> 接口而不是通过指定 bean 的自动启动来进行细粒度的控制(包括启动阶段)。还要注意的是停止通知并不保证一定会在销毁之前到来：在正常关闭的时候，所有 <code>Lifecycle</code> bean 会在通用销毁回调传递之前首先收到停止通知；但是对于上下文生命周期的热刷新和取消刷新尝试，只有调用销毁方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>启动和关闭调用的顺序是很重要的。如果任何两个对象之间存在一个依赖关系，那么依赖方会在它的依赖项之后启动，且会在它的依赖项之前停止。但是，有时候直接依赖关系是未知的。你可能只知道某个类型的对象应该在另一个类型的对象之前启动。在那种情况下，<code>SmartLifecycle</code> 定义了另一种选择，即在它的父接口 <code>Phased</code> 中定义了 <code>getPhase()</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Phased</span> {

        <span class="type">int</span> getPhase();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">SmartLifecycle</span> <span class="directive">extends</span> Lifecycle, Phased {

        <span class="type">boolean</span> isAutoStartup();

        <span class="type">void</span> stop(<span class="predefined-type">Runnable</span> callback);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>启动的时候，最低 phase 的对象先启动，停止的时候，正好相反，最高 phase 的对象先停止。因此对于一个实现了 <code>SmartLifecycle</code> 接口的对象，如果它的 <code>getPhase()</code> 方法返回 <code>Integer.MIN_VALUE</code>，那么它就会最先启动，最后停止。在 phase 范围的另一端，一个 <code>Integer.MAX_VALUE</code> 值表明对象应该最后启动，最先停止（可能是因为它依赖其他正在运行的进程）。当考虑 phase 值的设定时，还有一点很重要，那就是说任何没有实现 <code>SmartLifecycle</code> 接口的“正常”对象的 phase 默认值是0。因此，任何为负值的 phase 值意味着此对象应该在标准组件启动之前启动（在它们停止之后停止）；当phase 为正值的时候刚好相反。</p>
</div>
<div class="paragraph">
<p>正如你所见，<code>SmartLifecycle</code> 定义的 stop 方法接收一个回调。任何实现在实现的关闭进程完成之后都必须调用那个回调的 <code>run()</code> 方法。这使得在需要是可以进行异步关闭，因为 <code>LifecycleProcessor</code> 接口的默认实现 <code>DefaultLifecycleProcessor</code> 会为一组对象的每个阶段等待直到超时，然后调用回调方法。默认的每个阶段的超时时间是30秒。你可以通过在上下文中定一个名为“lifecycleProcessor”的 bean 来覆盖默认的生命周期处理器（lifecycle processor）实例。如果你只是想修改超时值，那么下面的定义就足够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lifecycleProcessor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.DefaultLifecycleProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">timeoutPerShutdownPhase</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">10000</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如上面提到的，<code>LifecycleProcessor</code> 接口为上下文的刷新和关闭也定义了回调。后者会简单地驱动关闭进程就像显式调用了 <code>stop()</code> 方法，但它只会在上下文关闭的时候执行。另一方面，refresh 回调使 <code>SmartLifecycle</code> bean 的另一个特性可用。回调会在上下文刷新的时候（在所有对象实例化和初始化完成之后）被调用，默认生命周期处理器会在那个时间点检查每个 <code>SmartLifecycle</code> 对象的 <code>isAutoStartup()</code> 方法返回的布尔值。如果返回的是“true”，那么对象就会立即启动而不是等待上下文的显式调用或者它自己的 <code>start()</code> 方法（与上下文刷新不同，对于一个标准的上下文实现，它的启动不会自动发生）。与依赖关系一样，“phase” 值也会以前面叙述的相同方式来决定启动顺序。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-shutdown"><a class="anchor" href="#beans-factory-shutdown"></a>在非web应用中优雅地关闭 Spring IoC 容器</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本节只适用于非 web 应用。Spring 的基于web的 code>ApplicationContext</code> 实现已经有相关代码来处理当相关的web应用关闭时，如何优雅地关闭 Spring IoC 容器。h</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你正在一个非web应用环境中使用 Spring IoC 容器；例如，在一个富客户端桌面环境中；你可以在 JVM 中注册一个关闭 hook。这么做保证了一次优雅的关闭且会调用所有单例 bean 的相关销毁方法以便释放所有资源。当然你仍然必须正确配置和实现这些销毁回调方法。</p>
</div>
<div class="paragraph">
<p>为注册一个关闭 hook，你可以调用 <code>ConfigurableApplicationContext</code> 接口中声明的 <code>registerShutdownHook()</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context.ConfigurableApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);

                <span class="comment">// add a shutdown hook for the above context...</span>
                ctx.registerShutdownHook();

                <span class="comment">// app runs here...</span>

                <span class="comment">// main method exits, hook is called prior to the app shutting down...</span>
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-aware"><a class="anchor" href="#beans-factory-aware"></a>1.6.2. ApplicationContextAware 和 BeanNameAware</h4>
<div class="paragraph">
<p>当 <code>ApplicationContext</code> 创建了一个实现了 <code>org.springframework.context.ApplicationContextAware</code> 接口的对象实例，这个实例会拥有一个指向那个 <code>ApplicationContext</code> 的引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ApplicationContextAware</span> {

        <span class="type">void</span> setApplicationContext(ApplicationContext applicationContext) <span class="directive">throws</span> BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此 bean 可以通过 <code>ApplicationContext</code> 接口，或者通过将这个接口（如暴露额外功能的 <code>ConfigurableApplicationContext</code>）强转成它已知子类的引用来以编码方式操控创建它们的 <code>ApplicationContext</code>。这种能力的其中一个用途是可以以编程方式对其他 bean 进行检索。有时候这种能力很有用；但是一般情况下你应该避免使用它，因为它将代码与 Spring  合起来了，而且也没有遵守控制反转风格，在控制反转中协作者是作为属性提供给 bean 的。<code>ApplicationContext</code> 的其他方法有提供文件资源访问的，发布应用事件的，访问 <code>MessageSource</code> 的。这些额外特性在 <a href="#context-introduction">ApplicationContext 的额外能力</a> 叙述。</p>
</div>
<div class="paragraph">
<p>从Spring 2.5 开始，自动装备成为另一种获取 <code>ApplicationContext</code> 引用的备用选择。“传统的”  <code>constructor</code> 和 <code>byType</code> 自动装配模式（如 <a href="#beans-factory-autowire">自动装配协作者</a> 中叙述的那样) 可以分别为构造器实参和 setter 方法形参提供 <code>ApplicationContext</code> 类型的依赖项。使用新的基于注解的自动装配特性会更加具有灵活性，包括自动装配域的能力和自动装配多参数方法的能力。如果你这么做，那么 <code>ApplicationContext</code> 就会被自动装配到域中，构造器实参或方法形参中，如果此问题中的域，构造器实参或方法形参都期望获得 <code>ApplicationContext</code> 类型以依赖并带有 <code>@Autowired</code> 注解。更多信息，参见 <a href="#beans-autowired-annotation">@Autowired</a>。</p>
</div>
<div class="paragraph">
<p>当 <code>ApplicationContext</code> 创建了一个实现了 <code>org.springframework.beans.factory.BeanNameAware</code> 接口的类，这个类会拥有与它相关的对象定义中定义的名称的引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">BeanNameAware</span> {

        <span class="type">void</span> setBeanName(<span class="predefined-type">String</span> name) <span class="directive">throws</span> BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个回调会在很多正常 bean 属性设置之后，但是在如 <code>InitializingBean</code> 的 <em>afterPropertiesSet</em> 或者自定义 init-method 这样的初始化调用之前被调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="aware-list"><a class="anchor" href="#aware-list"></a>1.6.3. 其他 Aware 接口</h4>
<div class="paragraph">
<p>除了上面讨论的 <code>ApplicationContextAware</code> 和 <code>BeanNameAware</code>，Spring 还提供了一系列 <code>Aware</code> 接口，这些接口允许 bean 向表明他们需要一个确定的基础结构依赖项。下面总结了一些最重要的 <code>Aware</code> 接口 —— 作为通用规则，依赖项的名字是推断他们是什么类型依赖的一个很好的依据：</p>
</div>
<table id="beans-factory-nature-aware-list" class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. Aware 接口</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名字</th>
<th class="tableblock halign-left valign-top">注入的依赖项</th>
<th class="tableblock halign-left valign-top">具体解释入口</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEventPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event publisher of the enclosing <code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the ApplicationContext</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanClassLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class loader used to load the bean classes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">Instantiating beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanFactoryAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>BeanFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanNameAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the declaring bean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware">ApplicationContextAware and BeanNameAware</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BootstrapContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in
JCA aware <code>ApplicationContext</code>s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#cci">JCA CCI</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LoadTimeWeaverAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defined <em>weaver</em> for processing class definition at load time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#aop-aj-ltw">Load-time weaving with AspectJ in the Spring Framework</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageSourceAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured strategy for resolving messages (with support for parametrization and
internationalization)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the ApplicationContext</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotificationPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring JMX notification publisher</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#jmx-notifications">Notifications</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured loader for low-level access to resources</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#resources">Resources</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletConfigAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>再次提醒注意，对这些接口的使用将会使你的代码与 Spring API 绑定在一起，而且这不符合控制反转风格。因此，建议只对那些需要以编程方式访问容器的基础结构 bean 使用这种方式。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-child-bean-definitions"><a class="anchor" href="#beans-child-bean-definitions"></a>1.7. Bean definition inheritance</h3>
<div class="paragraph">
<p>Bean 定义中可以包含很多配置信息，包括构造器参数，属性值，容器相关的特定信息如初始化方法，静态工厂方法名等等。子定义会继承父定义的配置数据。子定义可以按需覆盖一些值，或者添加一些其他值。使用父子 bean 定义会重用很多代码，节省很多打字时间。实际上，这也是模板的一种形式。</p>
</div>
<div class="paragraph">
<p>如果你以编程方式使用 <code>ApplicationContext</code> 接口，那么子 bean 定义就可以通过<code>ChildBeanDefinition</code> 类来表示。大多数用于不会在这个层级使用它们，而是在某种像 <code>ClassPathXmlApplicationContext</code> 这样的组件中以声明的方式配置 bean 定义。当你是用基于XML的配置元数据时，你可以使用 <code>parent</code> 特性来表示这是个子 bean 定义，父 bean 就被指定为这个特性的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.TestBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritsWithDifferentClass</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.DerivedTestBean</span><span class="delimiter">&quot;</span></span>
                <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBean</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialize</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">override</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果子 bean 定义没有指定，那么它就会使用父定义中的 bean 定义，而且子定义还可以覆盖符定义。在后一种情况下，子定义必须与父定义兼容，也就是它必须接受父定义的属性值。</p>
</div>
<div class="paragraph">
<p>子 bean 定义会从父定义中继承作用域，构造器参数值，属性值，可以覆盖父定义中的方法，可以增加添加新值的选择。任何你指定的作用域，初始化方法，销毁方法，和/或 <code>静态</code> 工厂方法设置都将会覆盖相应的父定义中的配置。</p>
</div>
<div class="paragraph">
<p>其他剩下的设置 <em>都是</em> 从子定义获取的：<em>依赖</em>，<em>自动装配模式</em>，<em>依赖项检测</em>，<em>单例</em>，<em>懒加载</em>。</p>
</div>
<div class="paragraph">
<p>前面的例子显式地通过 <code>abstract</code> 特性将父 bean 定义标记为抽象的。如果父定义没有指定具体的类，那么将父 bean 定义标记为 <code>abstract</code> 是必须的，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBeanWithoutClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">parent</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritsWithClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.DerivedTestBean</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">inheritedTestBeanWithoutClass</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">init-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialize</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">override</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>父 bean 定义不能仅仅靠它自己实例化，因为它是不完整的，而且显式地被标记为 <code>抽象的</code>。如果某个定义是<code>abstract</code>，那么它只能作为一个纯净的 bean 定义模板，也就是专门为子定义服务的父定义。如果你试图通过将它作为另一个 bean 的引用属性值来单独使用这样一个 <code>abstract</code> 父 bean，或者用这个父 bean id 显式地调用<code>getBean()</code>，那么程序将会返回一个错误。类似地，容器内部的 <code>preInstantiateSingletons()</code> 方法也会忽略抽象 bean 定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ApplicationContext</code> 默认预实例化所有单例 bean。因此，如果你有一个已经指定了一个具体的类（父）bean 定义，且你只想要将它作为一个模板，那么你必须确保将它的 <em>abstract</em> 特性设置成 <em>true</em>（至少对于单例 bean 这是很重要的），否则应用上下文会（试图）预实例化这个 <code>abstract</code> bean。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-extension"><a class="anchor" href="#beans-factory-extension"></a>1.8. 容器的扩展点</h3>
<div class="paragraph">
<p>通常，应用开发者不需要使用继承 <code>ApplicationContext</code> 实现类的子类。相反，Spring IoC 容器可以通过插入特定集成接口的实现类来进行扩展。接下来的计小节将会叙述这些集成接口。</p>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-bpp"><a class="anchor" href="#beans-factory-extension-bpp"></a>1.8.1. 使用 BeanPostProcessor 来自定义 bean</h4>
<div class="paragraph">
<p><code>BeanPostProcessor</code> 接口定义了一些 <em>回调方法</em>，你可以在这些方法中实现你自己的（或者副高容器默认的）实例化逻辑，依赖解析逻辑等等。如果你想要在 Spring 容器完成实例化，配置，和初始化 bean 工作之后实现某些自定义逻辑，你可以插入一个或者多个 <code>BeanPostProcessor</code> 实现。</p>
</div>
<div class="paragraph">
<p>你可以配置多个 <code>BeanPostProcessor</code> 实例，而且可以通过设置 <code>order</code> 属性控制这些 <code>BeanPostProcessor</code> 的执行顺序。不过只有实现 <code>Ordered</code> 接口的 <code>BeanPostProcessor</code> 实现才能设置这个属性；如果你编写自己的 <code>BeanPostProcessor</code> 实现，你也应该考虑实现 <code>Ordered</code> 接口。详情咨询 <code>BeanPostProcessor</code> 和 <code>Ordered</code> 接口的 javadoc。也可以参见下面的 <a href="#beans-factory-programmatically-registering-beanpostprocessors">编程方式注册 <code>BeanPostProcessor</code></a> 笔记。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>BeanPostProcessor</code> 对 bean（或者对象）<em>实例</em> 进行操作；也就是说，首先 Spring IoC 容器实例化一个 bean 实例，然后 <code>BeanPostProcessor</code> 完成它们的工作。</p>
</div>
<div class="paragraph">
<p><code>BeanPostProcessor</code> 的作用域是绑定到每个容器上的，也是说它的作用域就是它所在容器的声明周期。只有你在使用容器分层的情况下，才会可能于此相关。如果你在一个容器中定义了一个 <code>BeanPostProcessor</code>，它只会对那个容器中的 bean 进行 post-process 操作。换句话说，某个容器中定义的 bean 不会被另一个容器中定义的 <code>BeanPostProcessor</code> 执行 post-process 操作，即使这两个容器是同一容器家族一部分。</p>
</div>
<div class="paragraph">
<p>为了修改真正的 bean 定义（例如，定义 bean 的 <em>blueprint</em> ），你需要使用 <a href="#beans-factory-extension-factory-postprocessors">使用 BeanFactoryPostProcessor 自定义配置元数据</a> 中描述的 <code>BeanFactoryPostProcessor</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口恰好由两个回调方法组成。当这个类在容器中注册为 post-processor 时，对于容器创建的每个 bean 实例，在容器初始化方法（如 InitializingBean 的 <em>afterPropertiesSet()</em> 和任何声明的初始化方法）调用 <em>之前</em>，以及在任何 bean 初始化回调之后，post-processor 都会从容器中得到一个回调。post-processor 可以对这个 bean 实例采取任何操作，包括完全忽略回调方法。 bean 的 post-processor 通常会检查回调接口或者将 bean 包装成一个代理。某些 Spring AOP 基础接口类也会以 bean post-processors 的形式实现以便提供代理包装逻辑。</p>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 会对配置元数据中实现 <code>BeanPostProcessor</code> 接口的任何 bean 进行 <em>自动检测</em>。<code>ApplicationContext</code> 将这些 bean 注册为 post-processors，这样就能在后面创建这些 bean 时调用它们。Bean post-processors 可以像其他任何 bean 一样被部署到容器当中。</p>
</div>
<div class="paragraph">
<p>注意当你在一个配置类上使用 <code>@Bean</code> 工厂方法声明 <code>BeanPostProcessor</code> 时，工厂方法返回的类型应该是实现类本身或者至少是 <code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口，这样就能清晰地表明那个 bean 的 post-processor 特性。否则 <code>ApplicationContext</code> 不会再完全创建好它之前就通过类型对它进行自动检测。因为 <code>BeanPostProcessor</code> 需要很早实例化以便能够在上下文中应用到其他 bean 的初始化过程，所以早起的类型检测是非常关键的。</p>
</div>
<div id="beans-factory-programmatically-registering-beanpostprocessors" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">编程方式注册 BeanPostProcessors</div>
<div class="paragraph">
<p>虽然推荐的 <code>BeanPostProcessor</code> 注册的方式是通过 <code>ApplicationContext</code> 的自动检测（如上所述），但你也可以通过使用 <code>ConfigurableBeanFactory</code> 的 <code>addBeanPostProcessor</code> 方法来以编程的方式来注册它。当你需要在注册之前对它进行条件逻辑的评估时，或者需要在上下文层级中夸上下文复制 bean 的后处理器，这是很有用的。注意用编程方式添加 <code>BeanPostProcessor</code> 不需要考虑 <code>Ordered</code> 接口。这里 <em>注册顺序</em> 就规定了执行顺序。还要注意的是以编程方式注册的 <code>BeanPostProcessor</code> 永远都在那些通过自动检测注册的 <code>BeanPostProcessor</code> 之前执行，无论任何显式的指定顺序是怎么样的。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">BeanPostProcessors 和 AOP 自动代理</div>
<div class="paragraph">
<p>实现了 <code>BeanPostProcessor</code> 接口的类是特殊的且会被容器区别对待。 所有 <code>BeanPostProcessor</code> 和它们直接引用的 bean 会被当做 <code>ApplicationContext</code> 特殊启动阶段的一部分在启动时就被实例化。之后，所有的 <code>BeanPostProcessor</code> 都会以有序形式注册，并适用于容器中所有之后的 bean。因为 AOP 自动代理是作为 <code>BeanPostProcessor</code> 本身实现的，所以无论是 <code>BeanPostProcessor</code> 还是他们直接引用的 bean 都没有资格进行自动代理，因此自动代理也就无法织入它们。</p>
</div>
<div class="paragraph">
<p>对于任何此类 bean，你会看到一条信息日志消息：“<em>Bean foo 没有资格被所有 BeanPostProcessor 接口处理（例如：不适合自动代理）</em>”。</p>
</div>
<div class="paragraph">
<p>注意如果你有 bean 通过自动装配或者 <code>@Resource</code> 注解（可能降级到自动装配）注入到 <code>BeanPostProcessor</code> 中，当搜索类型匹配依赖候选 bean 时，Spring 可能会访问未预料到的 bean，因此要使它们没有资格被自动代理或者被其他类型的bean post-processing 处理。例如，如果你有一个注解为 <code>@Resource</code> 的依赖项，它的 field/setter 名并没有与声明的 bean 直接对应且也没有使用 name 特性，那么 Spring 就会通过类型匹配去访问其他 bean。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的例子展示了如何在 <code>ApplicationContext</code> 中编写，注册和使用 <code>BeanPostProcessor</code>。</p>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-hw"><a class="anchor" href="#beans-factory-extension-bpp-examples-hw"></a>Example: Hello World, BeanPostProcessor-style</h5>
<div class="paragraph">
<p>这第一个例子阐述了基本用法。这个例子展示了一个自定义 <code>BeanPostProcessor</code> 实现，其中调用了每个 bean 的 <code>toString()</code> 方法，它它们被容器创建时将结果字符串打印在系统控制台上。</p>
</div>
<div class="paragraph">
<p>下面是自定义 <code>BeanPostProcessor</code> 实现类定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">scripting</span>;

<span class="keyword">import</span> <span class="include">org.springframework.beans.factory.config.BeanPostProcessor</span>;
<span class="keyword">import</span> <span class="include">org.springframework.beans.BeansException</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">InstantiationTracingBeanPostProcessor</span> <span class="directive">implements</span> BeanPostProcessor {

        <span class="comment">// simply return the instantiated bean as-is</span>
        <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessBeforeInitialization(<span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) {
                <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span>
        }

        <span class="directive">public</span> <span class="predefined-type">Object</span> postProcessAfterInitialization(<span class="predefined-type">Object</span> bean, <span class="predefined-type">String</span> beanName) {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Bean '</span><span class="delimiter">&quot;</span></span> + beanName + <span class="string"><span class="delimiter">&quot;</span><span class="content">' created : </span><span class="delimiter">&quot;</span></span> + bean.toString());
                <span class="keyword">return</span> bean;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:lang</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/lang</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/lang</span>
                <span class="content">http://www.springframework.org/schema/lang/spring-lang.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;lang:groovy</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messenger</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">script-source</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:org/springframework/scripting/groovy/Messenger.groovy</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;lang:property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Fiona Apple Is Just So Dreamy.</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/lang:groovy&gt;</span>

        <span class="comment">&lt;!--
        when the above bean (messenger) is instantiated, this custom
        BeanPostProcessor implementation will output the fact to the system console
        --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">scripting.InstantiationTracingBeanPostProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>InstantiationTracingBeanPostProcessor</code> 是怎样被简单定义的。它甚至都没有名字，但因为它是个 bean 所有它能像其他任何 bean 一样被依赖注入。（前面的配置还定义了一个由 Groovy 脚本支持的 bean。Spring 动态语言支持在 <a href="integration.html#dynamic-language">动态语言支持</a> 中进行了详细的阐述。）</p>
</div>
<div class="paragraph">
<p>下面的简单 Java 应用执行了前面的代码和配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.context.ApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;
<span class="keyword">import</span> <span class="include">org.springframework.scripting.Messenger</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">scripting/beans.xml</span><span class="delimiter">&quot;</span></span>);
                Messenger messenger = (Messenger) ctx.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">messenger</span><span class="delimiter">&quot;</span></span>);
                <span class="predefined-type">System</span>.out.println(messenger);
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的应用输出结果如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-rabpp"><a class="anchor" href="#beans-factory-extension-bpp-examples-rabpp"></a>Example: The RequiredAnnotationBeanPostProcessor</h5>
<div class="paragraph">
<p>使用与自定义 <code>BeanPostProcessor</code> 实现结合的回调接口或者注解是扩展 Spring IoC 容器的一种常见手段。其中一个例子是 Spring 的 <code>RequiredAnnotationBeanPostProcessor</code> ——一个附带在 Spring 分发包中的 <code>BeanPostProcessor</code> 实现，它能保证 bean 上所有带有（任意）注解的 JavaBean 属性都能真正（配置成）用值进行依赖注入。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factory-postprocessors"><a class="anchor" href="#beans-factory-extension-factory-postprocessors"></a>1.8.2. BeanFactoryPostProcessor 中的自定义配置元数据</h4>
<div class="paragraph">
<p>下一个我们要关注的扩展点是 <code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>。这个接口的语义与其他 The semantics of <code>BeanPostProcessor</code> 类似，但有一个主要不同点：<code>BeanFactoryPostProcessor</code> 可以操作 <em>bean 配置元数据 </em>；也就是，Spring IoC 容器允许 <code>BeanFactoryPostProcessor</code> 读取配置元数据，并且允许它在容器实例化任何 bean（<code>BeanFactoryPostProcessor</code> 本身除外）之前修改它。</p>
</div>
<div class="paragraph">
<p>你可以配置多个 <code>BeanFactoryPostProcessor</code>，并通过设置 <code>order</code> 属性控制他们执行的顺序。不过只有当 <code>BeanFactoryPostProcessor</code> 实现 <code>order</code> 接口后你才能设置这个属性。如果你编写你自己的 <code>BeanFactoryPostProcessor</code>，你也应该考虑实现 <code>BeanFactoryPostProcessor</code> 接口。更多细节咨询 <code>BeanFactoryPostProcessor</code> 和 <code>Ordered</code> 接口的 javadoc。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你要修改真正的 bean <em>实例</em>（例如，从配置元数据创建的对象），那你应该使用 <code>BeanPostProcessor</code>（在上面的<a href="#beans-factory-extension-bpp">使用 BeanPostProcessor 自定义 bean</a> 中有阐述）。虽然在 <code>BeanFactoryPostProcessor</code> 中处理 bean 实例在技术上是可行的（例如，使用 <code>BeanFactory.getBean()</code>），但是这么做会导致 bean 的过早是实例化，违反标准的容器生命周期。这可能会造成负面影响，如跳过 bean 的 post processing。</p>
</div>
<div class="paragraph">
<p><code>BeanFactoryPostProcessor</code> 的作用域是绑定到每个容器上的，也是说它的作用域就是它所在容器的生命周期。只有你在使用容器分层的情况下，才会可能于此相关。如果你在一个容器中定义了一个 <code>BeanFactoryPostProcessor</code>，它只适用于那个容器中的 bean定义。某个容器中定义的 bean 不会被另一个容器中定义的 <code>BeanFactoryPostProcessor</code> 执行 post-process 操作，即使这两个容器是同一容器家族一部分。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了使对定义容器的配置元数据的修改生效，当一个 bean 工厂 post-processor 在 <code>ApplicationContext</code> 中声明时，它就会自动执行。Spring 包含许多预定义好的 bean 工厂 post-processors，如 <code>PropertyOverrideConfigurer</code> 和
  <code>PropertyPlaceholderConfigurer</code>。举个例子，为了注册自定义的属性编辑器，你也可以使用自定义的 <code>BeanFactoryPostProcessor</code>。</p>
</div>
<div id="null" class="paragraph">
<p><code>ApplicationContext</code> 会自动检测任何部署在它上面的实现了 <code>BeanFactoryPostProcessor</code> 接口的 bean。在适当的时间，它会将它们作为 bean 工厂 post-processor 使用。你可以想其它任何你使用的 bean 那样部署这些 post-processor bean。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>和 <code>BeanPostProcessor</code> 一样，通常你不会将 <code>BeanFactoryPostProcessor</code> 配置成懒加载模式。如果没有其它 bean 引用 <code>Bean(Factory)PostProcessor</code>，那么作为 post-processor 这个 <code>Bean(Factory)PostProcessor</code>  根本不会被实例化。因此，将它标记为懒加载也会被忽略，即使你在声明 <code>&lt;beans /&gt;</code> 元素的时候，将它的 <code>default-lazy-init</code> 特性设置为 <code>true</code>，<code>Bean(Factory)PostProcessor</code> 也会被急切地实例化。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-factory-placeholderconfigurer"><a class="anchor" href="#beans-factory-placeholderconfigurer"></a>Example: the Class name substitution PropertyPlaceholderConfigurer</h5>
<div class="paragraph">
<p>你可以谁使用 <code>PropertyPlaceholderConfigurer</code> 读取单独配置文件具体化 bean 定义中的属性值，这样的单独文件使用标准的 Java <code>Properties</code> 格式。这么做可以让部署者可以自定义环境相关的属性值如数据库 URL 和密码，而屏蔽了对容器主要 XML 定义文件的修改的复杂性，及其带来的风险。</p>
</div>
<div class="paragraph">
<p>考虑下面基于XML的配置元数据片段，其中定义了一个带有占位符的 <code>DataSource</code>。这个例子展示了外部 <code>Properties</code> 文件配置属性。在运行时，<code>PropertyPlaceholderConfigurer</code> 会应用与这个元数据，然后替换 DataSource 的一些属性。这些需要替换的值会以 <code>${property-name}</code> 的占位符形式指定，遵循 Ant /  log4j / JSP EL 风格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">locations</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/foo/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">destroy-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.commons.dbcp.BasicDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">driverClassName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.driverClassName}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>真正的值来自另一个用标准 Java <code>Properties</code> 格式写的文件：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre>
</div>
</div>
<div class="paragraph">
<p>因此，<code>${jdbc.username}</code> 字符串会在运行时用‘sa’代替，其它与属性文件中的key匹配的占位符值也会以同样方式被替换。<code>PropertyPlaceholderConfigurer</code> 会检查 bean 定义中大多数属性和特性的占位符。此外，占位符的前缀和后缀都可以自定义。</p>
</div>
<div class="paragraph">
<p>自从 Spring 2.5 引入了 <code>context</code> 命名空间， 可以用一个专门的配置元素来配置属性占位符。<code>location</code> 特性中可以配置属性文件的地址，多个地址之间用逗号隔开。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/foo/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PropertyPlaceholderConfigurer</code> 不仅能查找指定的 <code>Properties</code> 文件中的属性。默认情况下，如果它没有在指定属性文件中找到需要的属性，它就会查找 Java <code>System</code> 属性。你可以通过设置配置器的 <code>systemPropertiesMode</code> 属性自定义查找行为，属性支持下面三个整形值：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>never</em> (0): 不检查系统属性</p>
</li>
<li>
<p><em>fallback</em> (1): 如果没有在指定文件中解析成功就检查系统属性。这也是默认设置。</p>
</li>
<li>
<p><em>override</em> (2): 在查找指定属性文件之前，先检查系统属性。这使得系统属性可以覆盖任何其他属性源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consult the <code>PropertyPlaceholderConfigurer</code> javadocs for more information.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当你在运行时需要选择一个特殊的实现类的时候，使用 <code>PropertyPlaceholderConfigurer</code> 来替换类名就变得很有用了。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">locations</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>classpath:com/foo/strategy.properties<span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;value&gt;</span>custom.strategy.class=com.foo.DefaultStrategy<span class="tag">&lt;/value&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">serviceStrategy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${custom.strategy.class}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果某个类在运行时不能被解析为一个有效类，那么在 <code>ApplicationContext</code> 的 <code>preInstantiateSingletons()</code> 阶段如果它不是一个懒加载类，当它要被创建的时候，就会解析失败。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-overrideconfigurer"><a class="anchor" href="#beans-factory-overrideconfigurer"></a>Example: the PropertyOverrideConfigurer</h5>
<div class="paragraph">
<p><code>PropertyOverrideConfigurer</code> 是另一个与 <code>PropertyPlaceholderConfigurer</code> 类似的 bean 工厂 post-processor，但与后者不同，原始定义的 bean 属性可以有默认值也可以完全没有值。如果用于覆盖的 <code>Properties</code> 文件没有找到某个 bean 属性的入口，那么就会使用默认的上下文定义。</p>
</div>
<div class="paragraph">
<p>注意 bean definition 并不会感知到被覆盖了，所以不能从XML定义文件中马上明显地得知正在使用用于覆盖的配置器。在多个 <code>PropertyOverrideConfigurer</code> 实例为同一个 bean 属性定义了不同值的情况下，根据覆盖机制，最后一个有效。</p>
</div>
<div class="paragraph">
<p>属性文件配置行格式如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>beanName.property=value</pre>
</div>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre>
</div>
</div>
<div class="paragraph">
<p>这个例子文件可以在一个包含名为 <em>dataSource</em> 的 bean 的容器定义中使用，<em>dataSource</em> 有 <em>driver</em> 和 <em>driver</em> 属性。</p>
</div>
<div class="paragraph">
<p>复合属性名也是被支持的，只要保证除了属性名的最后部分其他每部分都是非空的（假设有构造器初始化）。在本例中：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>foo.fred.bob.sammy=123</pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><code>foo</code> bean 有一个 <code>fred</code> 属性，<code>fred</code> 属性有一个 <code>bob</code> 属性， <code>bob</code> 有一个 <code>sammy</code> 属性，最后将 <code>bob</code> 设置为标量值 <code>123</code>。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>指定的覆盖值总是字面值（literal values）；它们不会被转换成对 bean 的引用。就算XML bean 定义的原始值指定的是对 bean 的引用，这个规范也同样适用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>随着 <code>context</code> 命名空间在 Spring 2.5 中被引入，使用专用配置元素配置属性覆盖也成为了可能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:property-override</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:override.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factorybean"><a class="anchor" href="#beans-factory-extension-factorybean"></a>1.8.3. 使用 FactoryBean 自定义实例化逻辑</h4>
<div class="paragraph">
<p>使那些本身是工厂的对象实现 <code>org.springframework.beans.factory.FactoryBean</code> 接口。</p>
</div>
<div class="paragraph">
<p><code>FactoryBean</code> 接口是 Spring IoC 容器实例化逻辑的一个可插入点。如果你的初始化代码很复杂，相比用大量（潜在）冗余的XML来描述，选择用 Java 代码来描述会更好，那么你可以创建你自己的 <code>FactoryBean</code>，在其中编写复杂的初始化逻辑，然后再将这个自定义 <code>FactoryBean</code> 插入到容器中。</p>
</div>
<div class="paragraph">
<p><code>FactoryBean</code> 接口中有三个方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object getObject()</code>：返回一个词工厂创建的对象实例。这个实例可以被共享，当然这取决于工厂返回的是单例对象实例还是原型对象实例。</p>
</li>
<li>
<p><code>boolean isSingleton()</code>：如果这个 <code>FactoryBean</code> 返回单例实例，那么就返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
<li>
<p><code>Class getObjectType()</code>：返回 <code>getObject()</code> 方法返回的对象的类型，或者如果事先不知道类型就返回 <code>null</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>FactoryBean</code> 的概念和接口在 Spring 框架很多地方都用到了；Spring 本身附带了超过50个 <code>FactoryBean</code> 接口的实现。</p>
</div>
<div class="paragraph">
<p>当你需要向容器请求一个真正的 <code>FactoryBean</code> 实例本身而不是它生产的 bean 时，在你调用 <code>ApplicationContext</code> 的 <code>getBean()</code> 方法时，需要在 bean 的 id 前面加上一个 ampersand 符号（<code>&amp;</code>）。所以给定一个 id 为 <code>myBean</code> 的 <code>FactoryBean</code>，在容器中调用 <code>getBean("myBean")</code> 会返回 <code>FactoryBean</code> 生产的 bean；而调用 <code>getBean("&amp;myBean")</code> 会返回 <code>FactoryBean</code> 实例本身。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-annotation-config"><a class="anchor" href="#beans-annotation-config"></a>1.9. 基于注解的容器配置</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">注解配置 Spring 比 XML 配置更好吗？</div>
<div class="paragraph">
<p>基于注解的配置引出了这样一个问题：这种方式是否比XML配置更好。给个简短的答案那就是 <em>那得看情况</em>（废话，老外也学会辩证唯物了？）。长一点的回答是每种方式都有它的有优缺点，通常由开发者决定更适合的策略。由于他们不同的定义方式，注解会在声明中提供很多少下文，导致配置更精简。但是，在不接触源码或者重新编译的情况下装配组件方面，XML更有优势。一些开发者更倾向于装配配置更接近于源代码，而另一些人认为带有注解的类已经不再是 POJO 类了，此外，这使得配置变得去中心化和更难以控制。</p>
</div>
<div class="paragraph">
<p>无论你怎么选择，Spring 能同事适应这两种风格，甚至你可以将它们混合使用。值得说明的是，Spring 通过其 <a href="#beans-java">JavaConfig</a> 选项允许注解以一种非入侵的方式被使用，而不用接触目标组件的源代码，也不涉及哪些工具，所有的配置风格都由 <a href="https://spring.io/tools/sts">Spring Tool Suite</a> 支持。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>基于注解的配置是一种可以代替 XML 设置的方式，它依赖于字节码元数据来装配组件，而不是用尖括号声明。 开发者通过将注解配置在相关类，方法或者字段声明上，将配置移动到组件类本身中，一次代替用XML描述 bean 的装配。正如
  <a href="#beans-factory-extension-bpp-examples-rabpp">Example: The RequiredAnnotationBeanPostProcessor</a> 里描述的，使用 <code>BeanPostProcessor</code> 与注解结合是扩展 Spring IoC 容器的常+用方式。例如，Spring 2.0 引入了强制需求属性值的 <a href="#beans-required-annotation">@Required</a> 注解。Spring 2.5 使以同样的通用方式驱动 Spring 的依赖注入变为可能。本质上讲，<code>@Autowired</code> 注解提供了与 <a href="#beans-factory-autowire">自动装配协作者</a> 中描述的同样的能力，但是它具有更细粒度的控制能力和更广泛的适用性。Spring 2.5 还增加了对 JSR-250 注解的支持，如 <code>@PostConstruct</code> 和 <code>@PreDestroy</code>。Spring 3.0 增加了对包含在 javax.inject 包中的 JSR-330 （Java 的依赖注入）注解的支持，如 <code>@Inject</code> 和 <code>@Named</code>。更多这些注解的细节参见 <a href="#beans-standard-annotations">相关章节</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注解注入在XML注入之前执行，因此对于通过两种方式装配的属性，XML配置会覆盖注解配置。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与以往一样，您可以将它们注册为单独的 bean 定义，也可以通过在基于XML的 Spring 配置（注意 <code>context</code> 命名空间的引入）中包含以下标记进行隐式注册：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>（隐式注册的 post-processors 包括
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a>，
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a>，
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a>，
以及前面提到的
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a>。）</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;context:annotation-config/&gt;</code> 只会对定义它的应用上下文中的 bean 进行注解查找。这意味着，如果你为 <code>DispatcherServlet</code> 在 <code>WebApplicationContext</code> 中配置了 <code>&lt;context:annotation-config/&gt;</code>，它只会在你的控制器中检测带有 <code>@Autowired</code> 的 bean，而不会检测服务层。更多细节参见 <a href="web.html#mvc-servlet">DispatcherServlet</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-required-annotation"><a class="anchor" href="#beans-required-annotation"></a>1.9.1. @Required</h4>
<div class="paragraph">
<p><code>@Required</code> 注解应用于属性的 setter 方法，如下面的例子所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Required</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个注解简单明了地表明受影响的 bean 属性（也就是被注解配置的 bean 属性）必须在配置阶段通过 bean 定义中显式的属性值或者通过自动装配进行设置。如果受影响的 bean 属性没有设置，容器会抛出异常；这相当于它具有快速失败特性，从而避免出现 <code>NullPointerException</code> 或者之后出现此类其他异常。不过我们仍然建议你在 bean 类本身内部加入断言，例如，在初始化方法中。这么做可以强制那些引用和值成功配置，甚至你都可以在容器外部使用它们也不用担心出现异常。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation"><a class="anchor" href="#beans-autowired-annotation"></a>1.9.2. @Autowired</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面的一些例子使用了 JSR 330 的 <code>@Inject</code> 注解代替  Spring 的 <code>@Autowired</code> 注解。更多细节参见 <a href="#beans-standard-annotations">这里</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以将 <code>@Autowired</code> 注解用于构造器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="directive">final</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从 Spring Framework 4.3 开始，如果目标 bean 只定义了一个构造器，那么在这样的构造器上配置 <code>@Autowired</code> 就变得不再必要。但如果有好几个构造器可用，那么至少有一个需要被注解以便告诉容器使用哪一个。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>不出所料，你还可以将 <code>@Autowired</code> 注解应用于“传统的” setter 方法： </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以将注解应用到具有任何名字的方法和/或多个参数上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> prepare(MovieCatalog movieCatalog,
                        CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.movieCatalog = movieCatalog;
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以将 <code>@Autowired</code> 应用于字段上，甚至于构造器混合使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="directive">final</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保你在使用 <code>@Autowired</code> 注解注入的点的时候，对目标组件（例如， <code>MovieCatalog</code>，<code>CustomerPreferenceDao</code>）的类型声明的一致性。否则注入可能会由于在运行时找不到类型匹配而失败。</p>
</div>
<div class="paragraph">
<p>对于通过类路径扫描到的基于XML定义的 bean 或者 组件类，容器通常都会预先知道它们的实际类型。不过对于 <code>@Bean</code> 工厂方法，你需要确保声明的返回类型足够表达对象本身的信息。对于实现多个接口的组件或者可能被它们的实现类类型所引用的组件，考虑在工厂方法中声明符合要求的最具体的返回烈性。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过给期望获得数组类型的字段或方法添加注解，也可以从 <code>ApplicationContext</code> 中获得此特定类型的所有 bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog<span class="type">[]</span> movieCatalogs;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这同样适用于集合类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">Set</span>&lt;MovieCatalog&gt; movieCatalogs;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs(<span class="predefined-type">Set</span>&lt;MovieCatalog&gt; movieCatalogs) {
                <span class="local-variable">this</span>.movieCatalogs = movieCatalogs;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你希望数组或列表中的项按特定顺序排列，你可以让你的 bean 实现 <code>org.springframework.core.Ordered</code> 接口或者使用 <code>@Order</code> 或者标准 <code>@Priority</code> 注解。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>甚至类型化的 Map 也能被自动装配，只要它的 key 是 <code>String</code> 类型的。Map 的所有 value 会包括所有期望类型的 bean，所有的 key 都包括对应的 bean 名字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, MovieCatalog&gt; movieCatalogs;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieCatalogs(<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, MovieCatalog&gt; movieCatalogs) {
                <span class="local-variable">this</span>.movieCatalogs = movieCatalogs;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，如果没有候选bean 是可用的，那么自动装配就会失败；默认行为将带有注解的方法，构造器，字段作为已经指明了 <em>required</em> 的依赖项。可以通过下面展示的方式改变这种行为。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>(required = <span class="predefined-constant">false</span>)
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每个类只有一个被注解构造器可以用 <em>required</em> 标记，不过可以注解多个非必须的构造器。在那种情况下，每个构造器都在候选之列，且 Spring 会使用那个满足依赖的 <em>最贪婪</em> 的构造器，也就是那个入参最多的构造器。</p>
</div>
<div class="paragraph">
  <p><code>相比于直接使用 @Required 注解，我们更建议你使用 @Autowired 的 <em>required</em> 特性</code>。<em>required</em> 特性表示对于自动装配此属性是不必须的，如果它不能被自动装配，那它就会被忽略。另一方面，<code>@Required</code> 的语义会更强，它强制由容器支持的任何方式都必须设置这个属性。如果没有值被注入，就会抛出相应异常。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以将 <code>@Autowired</code> 用于那些众所周知的可解析依赖接口： <code>BeanFactory</code>，<code>ApplicationContext</code>，<code>Environment</code>，<code>ResourceLoader</code>，
<code>ApplicationEventPublisher</code>，和 <code>MessageSource</code>。这些接口和它们的扩展类（如 <code>ConfigurableApplicationContext</code> 或者 <code>ResourcePatternResolver</code>）可以被自动解析，而不需要特殊的设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> ApplicationContext context;

        <span class="directive">public</span> MovieRecommender() {
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Autowired</code>，<code>@Inject</code>，<code>@Resource</code>，和 <code>@Value</code> 注解都是由 Spring <code>BeanPostProcessor</code> 实现处理的，这反过来意味着在你自己的 <code>BeanPostProcessor</code> 或 <code>BeanFactoryPostProcessor</code> 类型中你不能使用这些注解（如果有的话）。这些类型必须显式地通过XML或者通过使用 Spring <code>@Bean</code> 方法来 ‘wired up’。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-primary"><a class="anchor" href="#beans-autowired-annotation-primary"></a>1.9.3. 使用 @Primary 对基于注解的自动装配进行微调</h4>
<div class="paragraph">
<p>因为根据类型自动装配会出现有多个候选的问题，所以常常需要对这个选择过程进行更多的控制。其中一种方式是采用 Spring 的 <code>@Primary</code> 注解。<code>@Primary</code> 表示当一个单值依赖项具有多个候选 bean 时，某个指定的 bean 具有更高的优先级。如果刚好一个‘primary’ bean 存在于候选中，那么它就会是那个被自动装配的值。</p>
</div>
<div class="paragraph">
<p>下设如下配置将 <code>firstMovieCatalog</code> 定义为 <em>primary</em> <code>MovieCatalog</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieConfiguration</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Primary</span></strong>
        <span class="directive">public</span> MovieCatalog firstMovieCatalog() { ... }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> MovieCatalog secondMovieCatalog() { ... }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据这个配置，下面的 <code>MovieRecommender</code> 将会自动装配 <code>firstMovieCatalog</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对应的 bean 定义如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span> <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">primary</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-qualifiers"><a class="anchor" href="#beans-autowired-annotation-qualifiers"></a>1.9.4. 使用 @qualifier 对基于注解的自动装配进行微调</h4>
<div class="paragraph">
<p>当自动装配过程中有多个实例需要确定其中一个主要候选时，<code>@Primary</code> 是一种按类型自动装配的有效方式。 如果对这个选择过程需要更多的控制时，可以使用 Spring 的 <code>@Qualifier</code> 注解。为了将类型匹配集合收窄到每个参数对应一个特定的 bean ，你可以将 qualifier 的值与特定的值关联起来。最简单的情况下，这可以是一个纯描述的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Qualifier</code> 注解也可以配置构造器参数或者方法参数上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> MovieCatalog movieCatalog;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> prepare(<strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>)</strong>MovieCatalog movieCatalog,
                        CustomerPreferenceDao customerPreferenceDao) {
                <span class="local-variable">this</span>.movieCatalog = movieCatalog;
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对应的 bean 定义如下。限定符值为 “main” 的 bean 会通过和它具有相同值的构造器参数装配起来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>

                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>

                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于匹配的回退，bean 名字会被作为默认的限定值。因此你可以定义一个 id 为“main”的 bean 来代替嵌套的限定符元素，匹配结果是一样的。不过，尽管你可以使用这个约定来根据名字引用特定的 bean，但是从根本上讲，<code>@Autowired</code> 是使用可选语义限定符进行类型驱动注入的。这意味着限定符的值，即使退化到 bean 的名字，也总是会从语义上收窄匹配集合；他们没有从语义上将引用表示为最一个唯一 bean id 的引用。像“main”或者“EMEA”或者“persistent”这样的就算是好的限定符值，他们表达了独立于 bean <code>id</code> 的特定组件的特性，即使前面例子中像这个 bean 一样的匿名bean会自动生成 id。</p>
</div>
<div class="paragraph">
<p>如上面讨论的，限定符也可用于类型化的集合上，比如 <code>Set&lt;MovieCatalog&gt;</code>。在这个例子中，根据声明限定符匹配的所有 bean 会以集合形式被注入。这暗示了限定符不一定是要唯一的；它们只是简单地构成过滤规则。例如，你可以定义多个具有同一个限定符值“action”的 code>MovieCatalog</code> bean，所有这些 bean 都会被注入到带有 <code>@Qualifier("action")</code> 注解的 <code>Set&lt;MovieCatalog&gt;</code> 中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你想通过名字表示注解驱动注入，不要以使用 <code>@Autowired</code> 为主，即使在技术上能够通过 <code>@Qualifier</code> 值来引用 bean 名字。相反，你应该使用 JSR-250 <code>@Resource</code> 注解，它在语义上被定义为根据组件唯一的名字来定位一个特定目标组件，声明的类型与匹配过称无关。<code>@Autowired</code> 则具有不同的语义：在根据类型选择候选 bean 之后，这个特定的 String 限定符值被认为只在被选类型的候选 bena 中，例如，在具有相同限定符标签的 bean 中匹配一个“account”限定符。</p>
</div>
<div class="paragraph">
<p>对于那些本身被定义为集合/map 或者数组类型的 bean 来说，<code>@Resource</code> 是个很好的解决方案，适用于根据唯一名字区分的特定集合或者数组。也就是说，从 Spring 4.3 起，集合/map 或者数组类也可以通过 Spring 的 <code>@Autowired</code> 类型匹配算法，只要元素的类型信息在 <code>@Bean</code> 的返回类型签名或者集合继承家族中保存了。在这种情况下，限定符值可以用来在相同类型的集合中区分，如前一段概括的那样。</p>
</div>
<div class="paragraph">
<p>从 Spring 4.3 开始，<code>@Autowired</code> 也支持自我引用注入，例如，将当前注入的 bean 引用返回给 bean 自己。注入自我注入只是一个备用方案；对其他组件的正常依赖总是优先考虑的。在那个意义上，自我引用并不会参与到正常的候选选择且因此也不会成为主要方式；相反，他们具有最低优先级。在实践中，自我引用只是最后的手段，例如，通过bean的事务代理调用同一实例的其它方法：在考虑抽取受影响方法来隔离代理 bean 的场景中。或者，使用 <code>@Resource</code> 来根据 bean 的唯一名字将当前 bean 的代理返回给当前 bean。</p>
</div>
<div class="paragraph">
<p><code>@Autowired</code> 可以应用于字段，构造器，多参数方法，这会在参数级别通过限定符注解缩减候选项，相比之下， <code>@Resource</code> 只支持字段和 bean 属性单参数 setter 方法。因此，如果你的注入目标是构造器或者多参数方法，必须使用限定符。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以创建你自己的自定义限定符注解。简单定义一个注解，在你自己的定义中提供 @Qualifier 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<strong><span class="annotation">@Qualifier</span></strong>
<span class="directive">public</span> <span class="annotation">@interface</span> Genre {

        <span class="predefined-type">String</span> value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后你就可以在自动装配的字段和参数上使用这个自定义限定符了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">private</span> MovieCatalog actionCatalog;

        <span class="directive">private</span> MovieCatalog comedyCatalog;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> setComedyCatalog(<strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)</strong> MovieCatalog comedyCatalog) {
                <span class="local-variable">this</span>.comedyCatalog = comedyCatalog;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，提供候选 bean 定义的信息。你可以在 <code>&lt;bean/&gt;</code> 标签中添加 <code>&lt;qualifier/&gt;</code> 作为子元素，然后指定 <code>type</code> 和 <code>value</code> 以匹配你的自定义限定符注解。类型通过注解的全限定类名来匹配。或者，如果没有名字冲突的风险，使用短类名更加方便。两种方式都在下面的例子中呈现了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.Genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">movieRecommender</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MovieRecommender</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <a href="#beans-classpath-scanning">类路径扫描和被管理的组件</a> 中，你会看到一种代替在XML中提供限定符元数据的基于注解的方法。特别参见 <a href="#beans-scanning-qualifiers">使用注解提供限定符元数据</a>。</p>
</div>
<div class="paragraph">
<p>在某些情况下，可能使用不带值的注解就够用了。这在为了某个更加通用的目的使用注解时会非常有用，而且可以应用于多个夸类型的依赖项上。例如，当因特网不可用时，你可能会想要提供一个 <em>offline</em> 目录供搜索。首先定义一个简单的注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Qualifier</span>
<span class="directive">public</span> <span class="annotation">@interface</span> Offline {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将这个注解添加到要被自动装配的字段或者属性上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <strong><span class="annotation">@Offline</span></strong>
        <span class="directive">private</span> MovieCatalog offlineCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，bean 定义至于要一个限定符类型 <code>type</code> 就够了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <strong><span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Offline</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></strong>
        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以自定义一个接受额外命名特性或者代替这个简单 <code>value</code> 特性的限定符注解。如果要被自动注入的字段或者参数指定了多个值，那么 bean 定义必须匹配所有这些被当做自动装配选项的特性值。考虑下面的注解定义例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.FIELD, <span class="predefined-type">ElementType</span>.PARAMETER})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Qualifier</span>
<span class="directive">public</span> <span class="annotation">@interface</span> MovieQualifier {

        <span class="predefined-type">String</span> genre();

        <span class="predefined-type">Format</span> format();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子中，<code>Format</code> 是一个枚举类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">enum</span> <span class="predefined-type">Format</span> {
        VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要自动装配的字段都用自定义限定符注解了，且包含了两个属性的值：<code>genre</code> 和 <code>format</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.VHS, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog actionVhsCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.VHS, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog comedyVhsCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.DVD, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog actionDvdCatalog;

        <span class="annotation">@Autowired</span>
        <span class="annotation">@MovieQualifier</span>(format=<span class="predefined-type">Format</span>.BLURAY, genre=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> MovieCatalog comedyBluRayCatalog;

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，bean 定义应该包括所有匹配的限定符值。这个例子还展示了 bean 的 <em>meta</em> 特性可以用来代替 <code>&lt;qualifier/&gt;</code> 子元素。如果 <code>&lt;qualifier/&gt;</code> 可用，它和它的特性优先级更高，但是如果没有这样限定符，那么自动装配机制会将 <code>&lt;meta/&gt;</code> 标签中的值作为备用，如下面例子中后面两个 bean 的定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MovieQualifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">VHS</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/qualifier&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;qualifier</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MovieQualifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">VHS</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;attribute</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/qualifier&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">DVD</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.SimpleMovieCatalog</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">BLURAY</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;meta</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">genre</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Comedy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-generics-as-qualifiers"><a class="anchor" href="#beans-generics-as-qualifiers"></a>1.9.5. 将泛型作为自动装配限定符使用</h4>
<div class="paragraph">
<p>除了 <code>@Qualifier</code> 注解，也可以使用 Java 泛型类型作为限定符的一种隐式方式。例如，假设有如下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> StringStore stringStore() {
                <span class="keyword">return</span> <span class="keyword">new</span> StringStore();
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> IntegerStore integerStore() {
                <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设上面的 bean 实现了一个泛型接口，例如 <code>Store&lt;String&gt;</code> 和
<code>Store&lt;Integer&gt;</code>，你可以 <code>@Autowire</code> <code>Store</code> 接口，<em>泛型</em> 就会被当做限定符使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Autowired</span>
<span class="directive">private</span> Store&lt;<span class="predefined-type">String</span>&gt; s1; <span class="comment">// &lt;String&gt; qualifier, injects the stringStore bean</span>

<span class="annotation">@Autowired</span>
<span class="directive">private</span> Store&lt;<span class="predefined-type">Integer</span>&gt; s2; <span class="comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>泛型限定符也适用于在自动装配 Lists，Maps 和 Arrays 时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span>
<span class="comment">// Store&lt;String&gt; beans will not appear in this list</span>
<span class="annotation">@Autowired</span>
<span class="directive">private</span> <span class="predefined-type">List</span>&lt;Store&lt;<span class="predefined-type">Integer</span>&gt;&gt; s;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-custom-autowire-configurer"><a class="anchor" href="#beans-custom-autowire-configurer"></a>1.9.6. CustomAutowireConfigurer</h4>
<div class="paragraph">
<p>The
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a>
是一个 <code>BeanFactoryPostProcessor</code>，它使你可以注册你自己的自定义限定符注解类型，即使他们没有使用 Spring <code>@Qualifier</code> 注解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customAutowireConfigurer</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.annotation.CustomAutowireConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customQualifierTypes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;value&gt;</span>example.CustomQualifier<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AutowireCandidateResolver</code> 通过以下方式决定自动装配的候选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个 bean 定义的 <code>autowire-candidate</code> 值</p>
</li>
<li>
<p><code>&lt;beans/&gt;</code> 元素任意可用的 <code>default-autowire-candidates</code> 模式</p>
</li>
<li>
<p> <code>@Qualifier</code> 注解和任何在 <code>CustomAutowireConfigurer</code> 注册的自定义注解</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当多个 bean 都有资格成为自动装配候选 bean 时，“primary” bean 的决定规则如下：如果候选项中恰好有一个 bean 定义有一个设置为 <code>true</code> 的 <code>primary</code> 特性，它就会被选为 “primary” bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-resource-annotation"><a class="anchor" href="#beans-resource-annotation"></a>1.9.7. @Resource</h4>
<div class="paragraph">
<p>Spring 也支持对字段或者 bean 属性 setter 方法使用 JSR-250 <code>@Resource</code> 注解。这在Java EE 5和6中的一种常见模式，例如在 JSF 1.2 管理的 bean 或者 JAX-WS 2.0 端点。Spring 对它自己管理的对象也支持这种模式。</p>
</div>
<div class="paragraph">
<p><code>@Resource</code> 接受一个名称特性，默认情况下，Spring 将该值理解为要注入的 bean 的名字。换句话说，它遵循 <em>根据名字注入</em> 的语义，如本例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <strong><span class="annotation">@Resource</span>(name=<span class="string"><span class="delimiter">&quot;</span><span class="content">myMovieFinder</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有显式指定名字，默认名字就会从字段名或者 setter 方法获取。如果是字段，就接受字段名；如果是 setter 方法，就接受 bean 属性名。所以下面的例子将把名为“movieFinder”的 bean 注入到它的 setter 方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <strong><span class="annotation">@Resource</span></strong>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>被注解的名字被有 <code>CommonAnnotationBeanPostProcessor</code> 感知能力的 <code>ApplicationContext</code> 解析成为 bean 的名字。如果你显式地配置了 Spring 的 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>，则这些名字可以通过 JNDI 被解析。不过还是建议你依赖默认行为，简单实用 Spring 的 JNDI 查找功能来保持间接级别。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在使用 <code>@Resource</code> 而没有显式指定名字的情况下，与 <code>@Autowired</code> 类似，<code>@Resource</code> 会找到主要类型类匹配而不是特定的被命名 bean，并且解析已知的可解析依赖： <code>BeanFactory</code>，<code>ApplicationContext</code>，<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>，和 <code>MessageSource</code> 接口。</p>
</div>
<div class="paragraph">
<p>因此在下面的例子中，<code>customerPreferenceDao</code> 字段首先查找名为 customerPreferenceDao 的 bean，然后退化到查找 <code>CustomerPreferenceDao</code> 类型的 primary 类型匹配。“context” 字段是基于已知可解析依赖类型 <code>ApplicationContext</code> 注入的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="annotation">@Resource</span>
        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Resource</span>
        <span class="directive">private</span> ApplicationContext context;

        <span class="directive">public</span> MovieRecommender() {
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-postconstruct-and-predestroy-annotations"><a class="anchor" href="#beans-postconstruct-and-predestroy-annotations"></a>1.9.8. @PostConstruct and @PreDestroy</h4>
<div class="paragraph">
<p><code>CommonAnnotationBeanPostProcessor</code> 不仅能识别 <code>@Resource</code> 注解，也能识别 JSR-250 <em>生命周期</em> 注解。对在 Spring 2.5 引入的这些注解的支持，也提供了另一种可以代替在
<a href="#beans-factory-lifecycle-initializingbean">初始化回调</a> 和
<a href="#beans-factory-lifecycle-disposablebean">销毁回调</a> 中描述的那些方法的注解。假设在 Spring 中注册 <code>CommonAnnotationBeanPostProcessor</code>，携带这些注解其中之一的方法所谓对应的 Spring 生命周期接口方法或者显式声明的回调方法在生命周期的同一点被调用。在下面的例子中，缓存在在初始化的时候被预先填充，会在销毁的时候被清除。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CachingMovieLister</span> {

        <span class="annotation">@PostConstruct</span>
        <span class="directive">public</span> <span class="type">void</span> populateMovieCache() {
                <span class="comment">// populates the movie cache upon initialization...</span>
        }

        <span class="annotation">@PreDestroy</span>
        <span class="directive">public</span> <span class="type">void</span> clearMovieCache() {
                <span class="comment">// clears the movie cache upon destruction...</span>
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关于各种生命周期机制组合的细节，参见<a href="#beans-factory-lifecycle-combined-effects">组合生命周期机制</a>。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-classpath-scanning"><a class="anchor" href="#beans-classpath-scanning"></a>1.10. 类路径扫描和被管理的组件</h3>
<div class="paragraph">
<p>本章大多数示例都是用XML来指定在 Spring 容器中生成的每个 <code>BeanDefinition</code> 的配置元数据。前一小节（<a href="#beans-annotation-config">基于注解的配置</a>）展示了如果通过源代码级别的注解提供大量配置元数据。但是，即使在哪些示例中，"基本"的 bean 定义也是在XML文件中显式定义的，注解只是驱动依赖注入。本小节描述了一种通过类路径扫描隐式检测候选组件的方法。候选组件是符合过滤规则的类，且在容器中注册有响应的 bean 定义。这消除了使用XML来执行 bean 注册的需要；相反，你可以使用注解（例如 <code>@Component</code>），AspectJ 类型表达式，或者你自己的自定义过滤规则来选择将哪些类作为 bean 定义注册到容器中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能都成为 Spring 框架核心的一部分。这使得你可以使用 Java 来定义 bean 而不是传统的XML文件。参见 <code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code>，和 <code>@DependsOn</code> 注解的示例，了解如何使用这些新功能。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-stereotype-annotations"><a class="anchor" href="#beans-stereotype-annotations"></a>1.10.1. @Component 以及更多 stereotype 注解</h4>
<div class="paragraph">
<p><code>@Repository</code> 注解是任何实现数据存储角色或者原型的标记（也被称为数据访问对象或者 DAO）。这个注解的用法是自动异常翻译，如 <a href="data-access.html#orm-exception-translation">4.2.2 Exception translation</a> 中所述。</p>
</div>
<div class="paragraph">
<p>Spring 提供了更多的 stereotype 注解：<code>@Component</code>，<code>@Service</code>，<code>@Controller</code>。<code>@Component</code> 是任何受 Spring 管理组件的通用形式。<code>@Repository</code>，<code>@Service</code>，和<code>@Controller</code> 是 对 <code>@Component</code> 的更具体的特殊化，分别对应持久层，服务层和展示层。因此，你可以用 <code>@Component</code> 来注解你的组件类，但是如果你用 <code>@Repository</code>，<code>@Service</code>，或者 <code>@Controller</code> 来代替 <code>@Component</code> 的话，你的类将更适合于被各种工具处理，或者更适合于在具体切面之间的关联。例如，这些 stereotype 注解为切入点提供了理想的目标。<code>@Repository</code>，<code>@Service</code>，和 <code>@Controller</code> 也可能在 Spring 框架以后的版本中携带额外的语义。因此，如果你正在你的服务层使用
<code>@Component</code> 还是 <code>@Service</code> 选择，<code>@Service</code> 明显是更好的选择。同样，如上所述，作为一个标记，<code>@Repository</code> 已经被支持在你的持久层中进行自动异常翻译。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-meta-annotations"><a class="anchor" href="#beans-meta-annotations"></a>1.10.2. 元注解</h4>
<div class="paragraph">
<p>Spring 提供的许多注解都可以在你自己的代码中当做元注解使用。元注释仅仅就是是一个可以用于另一个注解的注解。例如，上面提到的 <code>@Service</code> 注解就是被 <code>@Component</code> 进行元注解的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.TYPE)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Documented</span>
<strong><span class="annotation">@Component</span></strong> <span class="comment">// Spring will see this and treat @Service in the same way as @Component</span>
<span class="directive">public</span> <span class="annotation">@interface</span> Service {

        <span class="comment">// ....</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>元注解还可以被结合使用来创建 <em>组合注解</em>。例如，Spring MVC 的 <code>@RestController</code> 注解就是由 <code>@Controller</code> 和 <code>@ResponseBody</code> 结合创建的。</p>
</div>
<div class="paragraph">
<p>此外，组合注解可以选择性地重新声明元注解属性来允许用户实现自定义操作。当你只想暴露元注解属性的一部分子集时，这会特别有用。例如，Spring 的 <code>@SessionScope</code> 注解将作用域名硬编码为 <code>session</code> 但仍然允许对 <code>proxyMode</code> 的自定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.TYPE, <span class="predefined-type">ElementType</span>.METHOD})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Documented</span>
<span class="annotation">@Scope</span>(WebApplicationContext.SCOPE_SESSION)
<span class="directive">public</span> <span class="annotation">@interface</span> SessionScope {

        <span class="comment">/**
         * Alias for {@link Scope#proxyMode}.
         * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
         */</span>
        <span class="annotation">@AliasFor</span>(annotation = Scope.class)
        ScopedProxyMode proxyMode() <span class="keyword">default</span> ScopedProxyMode.TARGET_CLASS;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后使用 <code>@SessionScope</code> 的时候就不用声明 <code>proxyMode</code> 了，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<strong><span class="annotation">@SessionScope</span></strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SessionScopedService</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者为 <code>proxyMode</code> 赋一个覆盖的值，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<strong><span class="annotation">@SessionScope</span>(proxyMode = ScopedProxyMode.INTERFACES)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SessionScopedUserService</span> <span class="directive">implements</span> UserService {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于更多细节，咨询<a href="appendix.html#annotation-programming-model">Spring 注解编程模型</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-autodetection"><a class="anchor" href="#beans-scanning-autodetection"></a>1.10.3. 自动检测类和注册 bean 定义</h4>
<div class="paragraph">
<p>Spring 能自动检测 stereotyped 类并将相应的 <code>BeanDefinition</code> 注册到 <code>ApplicationContext</code>。例如，一下两个类都可以使用这种自动检测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> SimpleMovieLister(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">JpaMovieFinder</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// implementation elided for clarity</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了自动检测这些类且注册相应的 bean，你需要将 <code>@ComponentScan</code> 添加到你的 <code>@Configuration</code> 类中，其中 <code>basePackages</code> 特性是这两个类的公共父包。（或者，你可以指定由一个逗号/分号/空格分隔的包括每个类的父包的列表。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了简介起见，上面的配置可以使用注解的 <code>value</code> 特性，例如 <code>@ComponentScan("org.example")</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面是使用XML的替代方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对 <code>&lt;context:component-scan&gt;</code> 的使用隐式地启用了<code>&lt;context:annotation-config&gt;</code> 的功能。当使用 <code>&lt;context:component-scan&gt;</code> 是，通常不需要包含 <code>&lt;context:annotation-config&gt;</code> 元素。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对类路径包的扫描要求类路径中存在相应的目录入口。当你使用 Ant 构建 JAR 时，确保不要激活 JAR 任务的 files-only 开关。此外，在某些环境中，基于安全策略类路径目录可能不会暴露出来，例如， JDK 1.7.0_45 及更高版本上的独立应用程序（这需要在你的 manifest 中设置可信库‘Trusted-Library’；参见<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>而且，当你使用 component-scan 元素时，<code>AutowiredAnnotationBeanPostProcessor</code> 和
<code>CommonAnnotationBeanPostProcessor</code> 都是隐式包含的。这意味着这两个组件会被自动检测且装配在一起——所有这些都在没有XML提供任何 bean 配置元数据的情况下实现。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以通过将 <em>annotation-config</em>  特性的值设置为 false 来禁用<code>AutowiredAnnotationBeanPostProcessor</code> 和 <code>CommonAnnotationBeanPostProcessor</code> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-filters"><a class="anchor" href="#beans-scanning-filters"></a>1.10.4. 使用过滤器来自定义扫描</h4>
<div class="paragraph">
<p>默认情况下，使用 <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>，或者本身使用 <code>@Component</code> 注解的自定义注解是唯一被检测到的候选组件。不过，你只需应用自定义过滤器即可修改和扩展此行为。将它们添加为 <code>@ComponentScan</code> 注解的 <em>includeFilters</em> 或者 <em>excludeFilters</em> 参数（或者作为<code>@ComponentScan</code> 元素的 <em>include-filter</em> 或者 <em>exclude-filter</em> 的子元素）。每个过滤器元素都需要 <code>type</code> 和 <code>expression</code> 特性。下表介绍了过滤选项。</p>
</div>
<table id="beans-scanning-filters-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. 过滤类型</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">过滤类型</th>
<th class="tableblock halign-left valign-top">示例表达式</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">annotation （默认）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeAnnotation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">目标组件中呈现的类型级别的注解。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以被目标组件赋值（或者继承/实现）的类（或者接口）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectj</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example..*Service+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个由目标组件匹配的 AspectJ 类型表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org\.example\.Default.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由目标组件类名称匹配的正则表达式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.MyTypeFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.core.type.TypeFilter</code> 接口的自定义实现。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下示例展示了忽略所有 <code>@Repository</code> 注解的配置，改用“stub” repository。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
   <span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>,
                   includeFilters = <span class="annotation">@Filter</span>(type = FilterType.REGEX, pattern = <span class="string"><span class="delimiter">&quot;</span><span class="content">.*Stub.*Repository</span><span class="delimiter">&quot;</span></span>),
                   excludeFilters = <span class="annotation">@Filter</span>(Repository.class))
   <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用XML的等价配置如下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;context:include-filter</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">regex</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">.*Stub.*Repository</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;context:exclude-filter</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">annotation</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.stereotype.Repository</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/context:component-scan&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你也可以通过在注解中设置 <code>useDefaultFilters=false</code> 或者在 <code>&lt;component-scan/&gt;</code> 元素中设置 <code>use-default-filters="false"</code> 来禁用默认过滤器。这会禁用对带有 <code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>，或者 <code>@Configuration</code> 注解类的自动检测。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factorybeans-annotations"><a class="anchor" href="#beans-factorybeans-annotations"></a>1.10.5. 在组件中定义 bean 元数据</h4>
<div class="paragraph">
<p>Spring 组件也可以将 bean 定义元数据提供给容器。你可以使用这同一个 <code>@Bean</code> 注解来定义 <code>@Configuration</code> 注解类中的 bean 元数据。下面是个简单的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="annotation">@Bean</span>
        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean publicInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">publicInstance</span><span class="delimiter">&quot;</span></span>);
        }

        <span class="directive">public</span> <span class="type">void</span> doWork() {
                <span class="comment">// Component method implementation omitted</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个 Spring 组件类，他的 <code>doWork()</code> 方法中包含了与应用相关的业务代码。它还提供了一个具有指向 <code>publicInstance()</code> 工厂方法的 bean 定义。<code>@Bean</code> 注解通过 <code>@Qualifier</code> 注解来标识工厂方法和其他 bean 定义属性，如限定符值。其他可以指定的方法级注解有 <code>@Scope</code>，<code>@Lazy</code>，和自定义限定符注解。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除了用于组件初始化的角色之外，<code>@Lazy</code> 注解还可以用在标记 <code>@Autowired</code> 或者 <code>@Inject</code> 的注入点上。在这种上下文中，它会注入一个懒解析代理。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如前所述，注解支持自动装配的字段和方法，另外还支持 <code>@Bean</code> 方法的自动装配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="directive">private</span> <span class="directive">static</span> <span class="type">int</span> i;

        <span class="annotation">@Bean</span>
        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean publicInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">publicInstance</span><span class="delimiter">&quot;</span></span>);
        }

        <span class="comment">// use of a custom qualifier and autowiring of method parameters</span>
        <span class="annotation">@Bean</span>
        <span class="directive">protected</span> TestBean protectedInstance(
                        <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>) TestBean spouse,
                        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{privateInstance.age}</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> country) {
                TestBean tb = <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">protectedInstance</span><span class="delimiter">&quot;</span></span>, <span class="integer">1</span>);
                tb.setSpouse(spouse);
                tb.setCountry(country);
                <span class="keyword">return</span> tb;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">private</span> TestBean privateInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">privateInstance</span><span class="delimiter">&quot;</span></span>, i++);
        }

        <span class="annotation">@Bean</span>
        <span class="annotation">@RequestScope</span>
        <span class="directive">public</span> TestBean requestScopedInstance() {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">requestScopedInstance</span><span class="delimiter">&quot;</span></span>, <span class="integer">3</span>);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该示例将另一个名为 <code>privateInstance</code> 的 bean 的 <code>Age</code> 属性值自动装配到<code>String</code> 方法参数 <code>country</code> 中。属性的值通过 Spring 表达式的 <code>#{ &lt;expression&gt; }</code> 符号来定义。对于 <code>@Value</code> 注解，表达式解析器会被预先配置以便它在解析表达式文本是查找 bean 的名字。</p>
</div>
<div class="paragraph">
<p>从 Spring Framework 4.3 开始，你还可以声明一个 <code>InjectionPoint</code> 类型的工厂方法参数（或者 <code>DependencyDescriptor</code> 更具体的子类），以便访问触发创建当前 bean 的请求注入点。注意这只适用于实际的 bean 实例创建，而不适用于现有实例的注入。因此，这个特性对原型作用域 bean 来说是很有意义的。对于其他作用域来说，工厂方法将只会看到触发在给定作用域内创建新的 bean 实例的注入点：例如，触发创建懒加载单例 bean 的依赖项。Use the provided injection point metadata with semantic care in such scenarios（？？）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">FactoryMethodComponent</span> {

        <span class="annotation">@Bean</span> <span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> TestBean prototypeInstance(InjectionPoint injectionPoint) {
                <span class="keyword">return</span> <span class="keyword">new</span> TestBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototypeInstance for </span><span class="delimiter">&quot;</span></span> + injectionPoint.getMember());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对常规 Spring 组件的 <code>@Bean</code> 方法的处理方式与 Spring <code>@Configuration</code> 类中对应方法的处理方式是不同的。不同之处在于 <code>@Component</code> 类不使用GGLIB来拦截方法和字段的调用。CGLIB 代理是通过在 <code>@Configuration</code> 类中的 <code>@Bean</code> 方法中调用方法或字段来创建对协作对象的 bean 元数据引用；此类方法不是用普通 Java 语义调用的，而是通过容器来提供对 Spring bean 常用的生命周期管理和代理，甚至当通过编程方式调用 <code>@Bean</code> 方法来引用其它 bean 的时候。相比之下，在一个具有标准 Java 语义的普通 <code>@Component</code> 类的 <code>@Bean</code> 方法中调用方法和字段，不会有特殊的 CGLIB 树立和其他约束条件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以将 <code>@Bean</code> 方法声明为 <code>static</code>，从而允许在不创建包含它们的配置类实例的情况下也可以调用它们。这在定义 post-processor bean 如 <code>BeanFactoryPostProcessor</code> 或者
  <code>BeanPostProcessor</code> 时特别有用，因为这类 bean 会在容器的早期生命周期就被初始化，并且会会在那一刻避免触发配置的其它部分。</p>
</div>
<div class="paragraph">
<p>注意对静态 <code>@Bean</code> 方法的调用永远不会被容器拦截，即使在 <code>@Configuration</code> 类中也是如此（参见上文）。这是由于技术上的限制：CGLIB 子类只能覆盖非静态方法。因此，对另一个 <code>@Bean</code> 的直接调用会产生标准 Java 语义，结果就是工厂方法本身直接返回一个独立的实例。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 方法对于 Java 语言的可见性不会对 Spring 容器中 bean 的定义结果产生直接的影响。就像你可以在非 <code>@Configuration</code> 类任何地方看到的，你可以自由地声明工厂方法，静态方法也一样。 但是，<code>@Configuration</code>类中常规的 <code>@Bean</code> 方法需要被覆盖，比如，它们不能被声明为 <code>private</code> 或是 <code>final</code> 的。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 方法会在给定组件或者是配置类的基类上，以及 Java 8 中被组件或者配置类实现的接口的默认方法上见到。这为构建复杂的配置布局提供了很大的灵活性，甚至从 Spring 4.2 起，通过 Java 8 实现多重继承也是可能的。</p>
</div>
<div class="paragraph">
<p>最后，注意同一个类可能会为同一个 bean 持有多个 <code>@Bean</code> 办法，这是根据运行时可用依赖关系来使用多个工厂方法的一种布局。这与在其他配置场景中选择“最贪婪的”构造器或工厂方法的算法相同：容器将会在构建时选择具有最多可满足依赖项的那个，类似于容器如何在多个 <code>@Autowired</code> 构造器中进行选择。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-name-generator"><a class="anchor" href="#beans-scanning-name-generator"></a>1.10.6. 自动检测组件的命名</h4>
<div class="paragraph">
<p>当组件作为扫描过程的一部分被自动检测时，它的 bean 名字会有该扫描器已知的 <code>BeanNameGenerator</code> 策略生成。默认情况下，Spring 的任何包含 <em>name</em> <code>value</code> 的 stereotype 注解（<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，和 <code>@Controller</code>）都会将此 name 作为名字提供给相应的 bean 定义。</p>
</div>
<div class="paragraph">
<p>如果此类注解不包含任何 <em>name</em> <code>value</code> 或者对于其他任何检测到的组件（如自定义过滤器发现的那些），那么默认的 bean 名字生成器会返回一个小写字母开头的非限定类名。例如，如果一下两个组件被检测到，他们的名字将会是 <code>myMovieLister</code> 和 <code>movieFinderImpl</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">myMovieLister</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieFinderImpl</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你不想依赖默认的 bean 命名策略，你可以提供一个自定义 bean 命名策略。首先，实现 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a> 接口，并且确保实现包含一个默认的无参构造器。然后，在配置扫描器的时候提供全限定类名：</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
   <span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, nameGenerator = MyNameGenerator.class)
   <span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">name-generator</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.MyNameGenerator</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一般规则就是：只要当其他组件可能正在对其进行显式引用时，考虑用注解指定名字。另一方面，只要是容器负责装配，那么自动生成的名字就足够满足使用了。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-scope-resolver"><a class="anchor" href="#beans-scanning-scope-resolver"></a>1.10.7. 提供自动检测组件的作用域</h4>
<div class="paragraph">
<p>与一般的 Spring 管理的组件一样，自动检测组件的默认和最常见的作用域是 <code>singleton</code>。但是，有时候你会需要通过 <code>@Scope</code> 注解来指定其他不同的作用域。只需在注解中提供作用域名即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MovieFinderImpl</span> <span class="directive">implements</span> MovieFinder {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于与 web 有关的特定作用域，参见 <a href="#beans-factory-scopes-other">Request, session, application 和 WebSocket 作用域</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要为作用域解析提供一个自定义策略而不依赖基于注解的方式，需要实现 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a> 接口，并且确保实现中有一个默认的无参构造器。然后，在配置扫描器的时候提供全限定类名：</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, scopeResolver = MyScopeResolver.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">scope-resolver</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example.MyScopeResolver</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用某些非单例作用域时，可能需要为作用域对象生成代理。原因在 <a href="#beans-factory-scopes-other-injection">作为依赖项的作用域 bean</a> 中阐述了。为此，component-scan 元素提供了可用的 <em>scoped-proxy</em> 特性。三个可选的值是：no，interfaces 和 targetClass。例如，下面的配置会最终产生标准 JDK 动态代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>, scopedProxy = ScopedProxyMode.INTERFACES)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
           ...
   }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">scoped-proxy</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interfaces</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-qualifiers"><a class="anchor" href="#beans-scanning-qualifiers"></a>1.10.8. 限定符元数据注解</h4>
<div class="paragraph">
<p><code>@Qualifier</code> 已经在 <a href="#beans-autowired-annotation-qualifiers">使用 @qualifier 对基于注解的自动装配进行微调</a> 讨论过了。本节中的示例演示在你解析自动装配候选项时如何通过 <code>@Qualifier</code> 注解和自定义限定符来实现细粒度控制。因为这些例子都是基于 XML bean 定义的，所以提供给候选 bean 定义的限定符元数据在这里也是通过使用 XML 中 <code>bean</code> 元素的 <code>qualifier</code> 或者 <code>元</code> 子元素来实现的。当你用类路径扫描来对组件进行自动检测时，就在候选类上配置类型级别的限定符元数据注解。以下三个例子展示了这种技术：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ActionMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Genre</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Action</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ActionMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<strong><span class="annotation">@Offline</span></strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CachingMovieCatalog</span> <span class="directive">implements</span> MovieCatalog {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与大多数基于注解的代替方案一样，记住注解元数据是与类定义本身绑定在一起的，而XML中的注解允许多个相同类型的  bean 提供其限定符元数据的变体，因为这种情况下，元数据是与每个实例一一对应的，而不是与每个类一一对应。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-index"><a class="anchor" href="#beans-scanning-index"></a>1.10.9. 生成候选组件的索引</h4>
<div class="paragraph">
<p>虽然类路径扫描速度非常快，但通过在编译时创建静态候选列表，可以提高大型应用程序的启动性能。在这种模式下，应用程序的所有模块都必须使用这种机制，当 <code>ApplicationContext</code> 检测到这样的索引时，它将自动使用这个索引而不是扫描类路径。</p>
</div>
<div class="paragraph">
<p>要生成索引，只需向每个包含组件扫描指令的目标组件的模块添加一个附加依赖项即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencies&gt;</span>
        <span class="tag">&lt;dependency&gt;</span>
                <span class="tag">&lt;groupId&gt;</span>org.springframework<span class="tag">&lt;/groupId&gt;</span>
                <span class="tag">&lt;artifactId&gt;</span>spring-context-indexer<span class="tag">&lt;/artifactId&gt;</span>
                <span class="tag">&lt;version&gt;</span>5.0.0.RELEASE<span class="tag">&lt;/version&gt;</span>
                <span class="tag">&lt;optional&gt;</span>true<span class="tag">&lt;/optional&gt;</span>
        <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;/dependencies&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，对于 Gradle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">dependencies {
        compileOnly(<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework:spring-context-indexer:5.0.0.RELEASE</span><span class="delimiter">&quot;</span></span>)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此过程将生成会被包含在这个 jar 文件中的 <code>META-INF/spring.components</code> 文件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当在你的IDE中使用这个模式是，必须将 <code>spring-context-indexer</code> 注册为注解处理器，以确保候选组件更新时索引是最新的（不过时）。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当在类路径上找到 <code>META-INF/spring.components</code> 时，索引会自动启动。如果索引对于某些库（或者某些用例）是部分可用的，而不是对整个应用可用，那么你可以通过将作为系统属性的或者在类路径根目录的 <code>spring.properties</code>文件中的 <code>spring.index.ignore</code> 设置为 <code>true</code> 来回退到使用常规的类路径布局（例如，完全没有索引）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-standard-annotations"><a class="anchor" href="#beans-standard-annotations"></a>1.11. 使用 JSR 330 标准注解</h3>
<div class="paragraph">
<p>从 Spring 3.0 开始，Spring 提供对 JSR-330 标准注解（依赖注入）的支持。这些注解的扫描方式与 Spring 注解相同。你只需要在你的类路径中添加相关的 jar 包就行了。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您正在使用Maven，则可以在标准Maven存储库（http://repo1.maven.org/maven2/javax/inject/javax.inject/1/）中使用 <code>javax.inject</code> artifact。你可以将以下依赖项添加到你的pom.xml 文件中：
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>javax.inject<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>javax.inject<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>1<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-inject-named"><a class="anchor" href="#beans-inject-named"></a>1.11.1. 用 @Inject 和 @Named 进行依赖注入</h4>
<div class="paragraph">
<p>可以使用 <code>@javax.inject.Inject</code> 来代替 <code>@Autowired</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="directive">public</span> <span class="type">void</span> listMovies() {
                <span class="local-variable">this</span>.movieFinder.findMovies(...);
                ...
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>@Autowired</code> 一样，你可以在字段级别，方法级别和构造器参数级别使用 <code>@Inject</code>。 此外，你可以将注入点声明为 <code>Provider</code>，允许按需访问较短作用域的 bean，或者通过 <code>Provider.get()</code> 调用对其他 bean 的惰性访问。作为以上示例的一个变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Provider</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> <span class="predefined-type">Provider</span>&lt;MovieFinder&gt; movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(<span class="predefined-type">Provider</span>&lt;MovieFinder&gt; movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="directive">public</span> <span class="type">void</span> listMovies() {
                <span class="local-variable">this</span>.movieFinder.get().findMovies(...);
                ...
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想为应该注入的依赖项使用限定名，则应该按如下方式使用 <code>@Named</code> 注释</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">main</span><span class="delimiter">&quot;</span></span>) MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-named"><a class="anchor" href="#beans-named"></a>1.11.2. @Named 和 @ManagedBean: @Component 注解的标准等价注解</h4>
<div class="paragraph">
<p><code>@javax.inject.Named</code> 或者 <code>javax.annotation.ManagedBean</code> 可以用来代替 <code>@Component</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="annotation">@Named</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">movieListener</span><span class="delimiter">&quot;</span></span>)  <span class="comment">// @ManagedBean(&quot;movieListener&quot;) could be used as well</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>@Component</code> 而不指定组件的名称是很常见的。<code>@Named</code> 可以以类似的方式使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.inject.Inject</span>;
<span class="keyword">import</span> <span class="include">javax.inject.Named</span>;

<span class="annotation">@Named</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;

        <span class="annotation">@Inject</span>
        <span class="directive">public</span> <span class="type">void</span> setMovieFinder(MovieFinder movieFinder) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>@Named</code> 或 <code>@ManagedBean</code> 时，可以像使用 Spring 注解一样使用组件扫描：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">org.example</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与 <code>@Component</code> 相比，JSR-330 <code>@Named</code> 和 JSR-250 code>ManagedBean</code> 注解是不可组合的。 请使用 Spring 的 stereotype 模型来构建自定义组件注解。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-standard-annotations-limitations"><a class="anchor" href="#beans-standard-annotations-limitations"></a>1.11.3.JSR-330 标准注解的局限性</h4>
<div class="paragraph">
<p>当你使用标准注解时，重要的是要知道下表中所示的一些重要特性是不可用的：</p>
</div>
<table id="annotations-comparison" class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. Spring 组件模型元素 vs. JSR-330 变体</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring</th>
<th class="tableblock halign-left valign-top">javax.inject.*</th>
<th class="tableblock halign-left valign-top">javax.inject 限制 / 注释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Autowired</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Inject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Inject</code> 没有 ‘required’ 特性；可以用 Java 8 的 <code>Optional</code> 代替。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Component</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Named / @ManagedBean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330 不提供可组合模型，只是别名命名组件的一种方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Scope("singleton")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Singleton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330 的默认作用域就像 Spring 的 <code>prototype</code> 原型作用域。但是，为了保持与 Spring 的一般默认值一致，Spring 容器中声明的 JSR-330 bean 默认是 code>singleton</code> 单例。为了使用除 <code>singleton</code> 单例之外的作用域，您应该使用 Spring 的 <code>@Scope</code> 注解。<code>javax.inject</code> 还提供了 <a href="http://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a> 注解。 不过，这只是为了用来创建自己的注释。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier / @Named</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Qualifier</code> 只是用来构建自定义限定符的元注解。具体的字符串限定符（如 Spring 的具有值的 <code>@Qualifier</code> ）可以通过 <code>javax.inject.Named</code> 关联。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无等价注解</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无等价注解</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Lazy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无等价注解</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provider</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Provider</code> 是 Spring 的 <code>ObjectFactory</code> 的一个直接替代者，只不过它使用一个较短的 <code>get()</code> 方法名。它也可以与 Spring 的 <code>@Autowired</code> 或者带有非注解构造器和setter 方法结合使用。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-java"><a class="anchor" href="#beans-java"></a>1.12. 基于 Java 代码的容器配置</h3>
<div class="sect3">
<h4 id="beans-java-basic-concepts"><a class="anchor" href="#beans-java-basic-concepts"></a>1.12.1. 基本概念: @Bean 和 @Configuration</h4>
<div class="paragraph">
<p>Spring 新的 Java 配置支持中的中心构件是 <code>@Configuration</code> 注解的类和 <code>@Bean</code> 注解的方法。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 注解用于表示一个用来实例化，配置和初始化一个新的对象的方法，对象是由 Spring IoC 容器管理的。对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code> XML配置的人来说，<code>@Bean</code> 注解和 <code>&lt;bean/&gt;</code> 元素具有相同的作用。你可以对任何 Spring <code>@Component</code> 使用 <code>@Bean</code> 注解的方法，但是它们通常和 <code>@Configuration</code> bean 一起使用。</p>
</div>
<div class="paragraph">
<p>用 <code>@Configuration</code> 注解的类表明它的主要目的是作为 bean 定义的来源。此外，<code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 之间的依赖关系。最简单的 <code>@Configuration</code> 类将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> MyService myService() {
                <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的 <code>AppConfig</code> 类将等同于下面的 Spring <code>&lt;beans/&gt;</code> XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.services.MyServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Full @Configuration vs ‘lite’ @Beans 模式？</div>
<div class="paragraph">
<p>当 <code>@Bean</code> 方法在没有使用 <code>@Configuration</code> 注释的类中声明时，它们被称为在“lite”模式下处理。例如，<code>@Component</code> 中声明的 bean 方法或者一个普通的旧类中的 bean 方法将被视为“lite”。</p>
</div>
<div class="paragraph">
<p>与 full <code>@Configuration</code> 不同，lite @Bean <code>@Bean</code> 方法不能轻易地声明 bean 间的依赖关系。通常，一个 <code>@Bean</code> 方法在'lite'模式下运行时不应该调用另一个 <code>@Bean</code> 方法。</p>
</div>
<div class="paragraph">
<p>仅在 <code>@Configuration</code> 类中使用 <code>@Bean</code> 方法是确保始终使用“full”模式的推荐方法。 这将防止同一个 <code>@Bean</code> 方法被意外调用多次，并有助于减少在“lite”模式下操作时难以追踪的细微错误。</p>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@Bean</code> 和 <code>@Configuration</code> 注解将在下面的章节中深入讨论。首先，我们将介绍使用基于Java的配置创建 Spring 容器的各种方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-instantiating-container"><a class="anchor" href="#beans-java-instantiating-container"></a>1.12.2. 使用 AnnotationConfigApplicationContext 创建 Spring 容器</h4>
<div class="paragraph">
<p>下面的章节介绍了 Spring 3.0 的新特性————<code>AnnotationConfigApplicationContext</code>。这种多功能的 <code>ApplicationContext</code> 实现不仅可以接受作为输入的 <code>@Configuration</code> 类，还可以接受用 JSR-330 元数据注解的类和普通的 <code>@Component</code> 类。</p>
</div>
<div class="paragraph">
<p>当用 <code>@Configuration</code> 类作为输入时，<code>@Configuration</code> 类本身会被注册成为一个 bean 定义，且类中所有声明为 <code>@Bean</code> 的方法也会被注册为 bean 定义。</p>
</div>
<div class="paragraph">
<p>当用 <code>@Component</code> 注解类和 JSR-330 类作为输入时，它们被注册为 bean 定义，且假定在必要时这些类中使用了 DI 元数据（例如 <code>@Autowired</code> 或 <code>@Inject</code>）。 </p>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-contstructor"><a class="anchor" href="#beans-java-instantiating-container-contstructor"></a>简单构建</h5>
<div class="paragraph">
<p>在实例化 <code>AnnotationConfigApplicationContext</code> 时，<code>@Configuration</code> 类可以作为输入参数使用，这与实例化 <code>ClassPathXmlApplicationContext</code> 时使用 Spring XML 文件的方式大致相同。 这使得 Spring 容器可以完全无需使用 XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所述，<code>AnnotationConfigApplicationContext</code> 不仅限于可以使用 <code>@Configuration</code> 类。 任何 <code>@Component</code> 或 JSR-330 注解类都可以作为输入提供给构造器。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面假设 <code>MyServiceImpl</code>，<code>Dependency1</code> 和 <code>Dependency2</code> 使用 Spring 依赖注入注解，例如 <code>@Autowired</code> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-register"><a class="anchor" href="#beans-java-instantiating-container-register"></a>以编程方式使用 register(Class&lt;?&gt;&#8230;&#8203;) 来构建容器</h5>
<div class="paragraph">
<p><code>AnnotationConfigApplicationContext</code> 可以使用无参数构造器实例化，然后使用 register() 方法进行配置。以编程方式构建 <code>AnnotationConfigApplicationContext</code> 时，此方法特别有用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
        ctx.register(AppConfig.class, OtherConfig.class);
        ctx.register(AdditionalConfig.class);
        ctx.refresh();
        MyService myService = ctx.getBean(MyService.class);
        myService.doStuff();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-scan"><a class="anchor" href="#beans-java-instantiating-container-scan"></a>使用 scan(String&#8230;&#8203;) 启用组建扫描</h5>
<div class="paragraph">
<p>要启用组件扫描，只需按如下方式注解你的 <code>@Configuration</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ComponentScan</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span>  {
           ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有经验的 Spring 用户会很熟悉下面等价的使用 Spring context:namespace 的XML声明</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在上面的示例中，<code>com.acme</code> 包会被扫描，以查找任何 <code>@Component</code> 注解的类，这些类将在容器中注册为 Spring bean 定义。<code>AnnotationConfigApplicationContext</code> 暴露 <code>scan(String&#8230;&#8203;)</code> 方法以允许你使用相同的组件扫描功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
        ctx.scan(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span>);
        ctx.refresh();
        MyService myService = ctx.getBean(MyService.class);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请记住 <code>@Configuration</code> 类是使用 <code>@Component</code> 进行 <a href="#beans-meta-annotations">元注解</a> 的，所以它们是组件扫描的候选对象！在上面的例子中，假设 <code>AppConfig</code> 是在 <code>com.acme</code> 包（或在它的子包）中声明的，它将在调用 <code>scan()</code> 期间被获取，并且在 <code>refresh()</code> 后，其所有的 <code>@Bean</code> 方法都会被执行且在容器中注册为 bean 定义。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-web"><a class="anchor" href="#beans-java-instantiating-container-web"></a>使用 AnnotationConfigWebApplicationContext 对 Web 应用程序的支持</h5>
<div class="paragraph">
<p><code>AnnotationConfigApplicationContext</code> 的 <code>WebApplicationContext</code> 变体可用于 <code>AnnotationConfigWebApplicationContext</code>。当配置Spring <code>ContextLoaderListener</code> servlet 监听器，Spring MVC <code>DispatcherServlet</code> 等时，可以使用 <code>AnnotationConfigWebApplicationContext</code>。接下来是配置典型 Spring MVC Web 应用程序的 web.xml 代码片段。注意 <code>contextClass</code> context-param 和 init-param 的使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;web-app&gt;</span>
        <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
                instead of the default XmlWebApplicationContext --&gt;</span>
        <span class="tag">&lt;context-param&gt;</span>
                <span class="tag">&lt;param-name&gt;</span>contextClass<span class="tag">&lt;/param-name&gt;</span>
                <span class="tag">&lt;param-value&gt;</span>
                        org.springframework.web.context.support.AnnotationConfigWebApplicationContext
                <span class="tag">&lt;/param-value&gt;</span>
        <span class="tag">&lt;/context-param&gt;</span>

        <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited
                fully-qualified @Configuration classes. Fully-qualified packages may also be
                specified for component-scanning --&gt;</span>
        <span class="tag">&lt;context-param&gt;</span>
                <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
                <span class="tag">&lt;param-value&gt;</span>com.acme.AppConfig<span class="tag">&lt;/param-value&gt;</span>
        <span class="tag">&lt;/context-param&gt;</span>

        <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span>
        <span class="tag">&lt;listener&gt;</span>
                <span class="tag">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/listener-class&gt;</span>
        <span class="tag">&lt;/listener&gt;</span>

        <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span>
        <span class="tag">&lt;servlet&gt;</span>
                <span class="tag">&lt;servlet-name&gt;</span>dispatcher<span class="tag">&lt;/servlet-name&gt;</span>
                <span class="tag">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/servlet-class&gt;</span>
                <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
                        instead of the default XmlWebApplicationContext --&gt;</span>
                <span class="tag">&lt;init-param&gt;</span>
                        <span class="tag">&lt;param-name&gt;</span>contextClass<span class="tag">&lt;/param-name&gt;</span>
                        <span class="tag">&lt;param-value&gt;</span>
                                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
                        <span class="tag">&lt;/param-value&gt;</span>
                <span class="tag">&lt;/init-param&gt;</span>
                <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited
                        and fully-qualified @Configuration classes --&gt;</span>
                <span class="tag">&lt;init-param&gt;</span>
                        <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
                        <span class="tag">&lt;param-value&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/param-value&gt;</span>
                <span class="tag">&lt;/init-param&gt;</span>
        <span class="tag">&lt;/servlet&gt;</span>

        <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span>
        <span class="tag">&lt;servlet-mapping&gt;</span>
                <span class="tag">&lt;servlet-name&gt;</span>dispatcher<span class="tag">&lt;/servlet-name&gt;</span>
                <span class="tag">&lt;url-pattern&gt;</span>/app/*<span class="tag">&lt;/url-pattern&gt;</span>
        <span class="tag">&lt;/servlet-mapping&gt;</span>
<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-bean-annotation"><a class="anchor" href="#beans-java-bean-annotation"></a>1.12.3. 使用 @Bean 注解</h4>
<div class="paragraph">
<p><code>@Bean</code> 是一个方法级注解且直接模拟XML的 <code>&lt;bean/&gt;</code> 元素。注解支持 <code>&lt;bean/&gt;</code> 提供的一些特性，比如：<a href="#beans-factory-lifecycle-initializingbean">init-method</a>，<a href="#beans-factory-lifecycle-disposablebean">destroy-method</a>，<a href="#beans-factory-autowire">autowiring</a> 和 <code>name</code>。</p>
</div>
<div class="paragraph">
<p>你可以在 <code>@Configuration</code> 注解类或 <code>@Component</code> 注解类中使用 <code>@Bean</code> 注解。</p>
</div>
<div class="sect4">
<h5 id="beans-java-declaring-a-bean"><a class="anchor" href="#beans-java-declaring-a-bean"></a>bean 声明</h5>
<div class="paragraph">
<p>要声明一个 bean，只需使用@Bean注释来注释一个方法即可。 您可以使用此方法在 <code>ApplicationContext</code> 中注册一个类型指定为方法返回类型的bean 定义。默认情况下，这个 bean 的名字和方法名相同。 以下是一个 <code>@Bean</code> 方法声明的简单示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferServiceImpl transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述配置完全等同于以下 Spring XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transferService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.TransferServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这两种声明都在 <code>ApplicationContext</code> 中创建了一个名为 <code>transferService</code> 的 bean，它与 TransferServiceImpl 类型的对象实例绑定在一起：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>transferService -&gt; com.acme.TransferServiceImpl</pre>
</div>
</div>
<div class="paragraph">
<p>你也可以用接口（或基类）声明你的 <code>@Bean</code> 方法的返回类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这会将提前类型预测的可见性限制为指定的接口类型（<code>TransferService</code>），因为一旦实例化受影响的单例bean，只有容器知道完整类型（<code>TransferServiceImpl</code>）。非懒加载模式的单例 bean 根据它们的声明顺序被实例化，所以你可能会看到不同的类型匹配结果，这取决于另一个组件试图通过一个非声明类型来匹配（比如 code>@Autowired TransferServiceImpl</code>，一旦 “transferService” bean 已经被实例化它才会解析）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你始终通过声明的服务接口来引用你的类型，那么你的 <code>@Bean</code> 返回类型可以安全地加入该设计决策。但是，对于实现多个接口的组件或可能由其实现类型引用的组件，声明最具体的可能返回类型（至少与引用您的bean 的注入点要求相同）会更加安全。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-dependencies"><a class="anchor" href="#beans-java-dependencies"></a>Bean 依赖项</h5>
<div class="paragraph">
<p><code>@Bean</code> 注解方法可以有任意数量的参数来描述构建 bean 所需的依赖关系。例如，如果我们的 <code>TransferService</code> 需要一个 <code>AccountRepository</code> ，我们可以通过一个方法参数实现这个依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService(AccountRepository accountRepository) {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析机制与基于构造器的依赖注入非常相似，请参阅 <a href="#beans-constructor-injection">相关章节</a> 了解更多细节。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-lifecycle-callbacks"><a class="anchor" href="#beans-java-lifecycle-callbacks"></a>接收生命周期回调</h5>
<div class="paragraph">
<p>任何使用 <code>@Bean</code> 注解定义的类都支持常规生命周期回调，并且可以使用 JSR-250 中的 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解，请参阅 <a href="#beans-postconstruct-and-predestroy-annotations">JSR-250 annotations</a> 注解以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>常规的Spring <a href="#beans-factory-nature">生命周期</a> 回调也被完全支持。如果一个 bean 实现了<code>InitializingBean</code>，<code>DisposableBean</code> 或者 <code>Lifecycle</code>，容器会调用相应的方法。</p>
</div>
<div class="paragraph">
<p>  诸如 <a href="#beans-beanfactory">BeanFactoryAware</a>，<a href="#beans-factory-aware">BeanNameAware</a>，<a href="#context-functionality-messagesource">MessageSourceAware</a>，<a href="#beans-factory-aware">ApplicationContextAware</a> 等的 <code>*Aware</code> 接口的标准集合也完全受支持。</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> 注解支持指定任意的初始化和销毁回调方法，就像 Spring XML bean 元素的  <code>init-method</code> 和 <code>destroy-method</code> 属性一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Foo</span> {

        <span class="directive">public</span> <span class="type">void</span> init() {
                <span class="comment">// initialization logic</span>
        }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">Bar</span> {

        <span class="directive">public</span> <span class="type">void</span> cleanup() {
                <span class="comment">// destruction logic</span>
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(initMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }

        <span class="annotation">@Bean</span>(destroyMethod = <span class="string"><span class="delimiter">&quot;</span><span class="content">cleanup</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Bar bar() {
                <span class="keyword">return</span> <span class="keyword">new</span> Bar();
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，使用具有 public <code>close</code> 或 <code>shutdown</code> 方法的使用 Java 配置定义的 bean 将自动获得一个销毁回调。如果你有一个public <code>close</code> 或 <code>shutdown</code> 方法，并且你不希望在容器关闭的时候调用它，只需要在你的bean定义中添加@Bean（destroyMethod =“”）来禁用默认<code>（inferred）</code>模式。</p>
</div>
<div class="paragraph">
<p>你可能希望为通过 JNDI 获取的资源默认执行此操作，因为对其生命周期的管理在应用程序之外。尤其是，确保始终对<code>DataSource</code> 执行此操作，因为在 Java EE 应用程序服务器上，这是已知的问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">NamingException</span> {
        <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) jndiTemplate.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">MyDS</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，在 <code>@Bean</code> 方法中，通常会选择使用编程式 JNDI 查找：使用 Spring 的 <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> helpers 或直接使用 JNDI <code>InitialContext</code>，而不使用 <code>JndiObjectFactoryBean</code> 变体，因为它会强制你将返回类型声明为 <code>FactoryBean</code> 类型，而不是实际的目标类型，这使得对其他用来引用所提供的资源的 <code>@Bean</code> 方法的交叉引用调用更加困难。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当然，就上面的 <code>Foo</code> 而言，在构造过程中直接调用 <code>init()</code> 方法同样有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Foo foo() {
                Foo foo = <span class="keyword">new</span> Foo();
                foo.init();
            <span class="keyword">return</span> foo;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当您直接使用 Java 时，您可以对对象进行任何操作，而不总是需要依靠容器的生命周期！</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-specifying-bean-scope"><a class="anchor" href="#beans-java-specifying-bean-scope"></a>指定 bean 作用域</h5>
<div class="sect5">
<h6 id="beans-java-available-scopes"><a class="anchor" href="#beans-java-available-scopes"></a>使用 @Scope 注解</h6>
<div class="paragraph">
<p>你可以指定使用 <code>@Bean</code> 注解定义的 bean 应该具有特定的作用域。你可以使用 <a href="#beans-factory-scopes">Bean 作用域</a> 章节中指定的任何标准范围。</p>
</div>
<div class="paragraph">
<p>默认作用域是 <code>singleton</code>，但你可以用 <code>@Scope</code> 注解来覆盖它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConfiguration</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> Encryptor encryptor() {
                <span class="comment">// ...</span>
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-scoped-proxy"><a class="anchor" href="#beans-java-scoped-proxy"></a>@Scope 和作用域代理</h6>
<div class="paragraph">
<p>Spring 提供了一个通过 <a href="#beans-factory-scopes-other-injection">作用域代理</a> 来处理作用域依赖的方便方法。使用 XML 配置时创建这种代理的最简单方法是使用 <code>&lt;aop:scoped-proxy/&gt;</code> 元素。在 Java 中配置 bean 的时候使用 @Scope 注解与 proxyMode 特性的支持是等效的。 默认是没有代理（<code>ScopedProxyMode.NO</code>），但您可以指定 <code>ScopedProxyMode.TARGET_CLASS</code> 或 <code>ScopedProxyMode.INTERFACES</code>。</p>
</div>
<div class="paragraph">
<p>如果你将作用域代理示例从 XML 参考文档（请参阅前面的链接）移植到我们使用 Java 的 <code>@Bean</code> 中，它将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// an HTTP Session-scoped bean exposed as a proxy</span>
<span class="annotation">@Bean</span>
<strong><span class="annotation">@SessionScope</span></strong>
<span class="directive">public</span> UserPreferences userPreferences() {
        <span class="keyword">return</span> <span class="keyword">new</span> UserPreferences();
}

<span class="annotation">@Bean</span>
<span class="directive">public</span> Service userService() {
        UserService service = <span class="keyword">new</span> SimpleUserService();
        <span class="comment">// a reference to the proxied userPreferences bean</span>
        service.setUserPreferences(userPreferences());
        <span class="keyword">return</span> service;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-customizing-bean-naming"><a class="anchor" href="#beans-java-customizing-bean-naming"></a>自定义 bean 命名</h5>
<div class="paragraph">
<p>默认情况下，配置类使用 <code>@Bean</code> 方法的名字作为结果 bean 的名字。不过，这个功能可以通过 <code>name</code> 特性来覆盖。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">myFoo</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-aliasing"><a class="anchor" href="#beans-java-bean-aliasing"></a>Bean 别名</h5>
<div class="paragraph">
<p>正如在 <a href="#beans-beanname">bean 的命名</a> 中所讨论的，有时候需要给一个 bena 赋予多个名字，也被称为<em>bean 的别名</em>。为此，<code>@Bean</code> 注解的 <code>name</code> 特性可以接受一个 String 数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(name = { <span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemA-dataSource</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">subsystemB-dataSource</span><span class="delimiter">&quot;</span></span> })
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// instantiate, configure and return DataSource bean...</span>
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-description"><a class="anchor" href="#beans-java-bean-description"></a>Bean 描述</h5>
<div class="paragraph">
<p>有时候提供一个更详细的 bean 文本描述是很有帮助的。当 bean 被暴露（可能通过JMX）用于监听目的时，这会特别有用。</p>
</div>
<div class="paragraph">
<p>要向 <code>@Bean</code> 添加描述，可以使用 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <strong><span class="annotation">@Description</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Provides a basic example of a bean</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo();
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-configuration-annotation"><a class="anchor" href="#beans-java-configuration-annotation"></a>1.12.4. 使用 @Configuration 注解</h4>
<div class="paragraph">
<p><code>@Configuration</code> 是一个类级别注解，它表明某个对象是某个 bean 定义的来源。<code>@Configuration</code> 类通过 public <code>@Bean</code> 注解方法声明 bean。对 <code>@Configuration</code> 类的 <code>@Bean</code> 方法的调用也可以用来定义 bean 之间的依赖关系。关于基本介绍，参见 <a href="#beans-java-basic-concepts">Basic concepts: @Bean 和 @Configuration</a>。</p>
</div>
<div class="sect4">
<h5 id="beans-java-injecting-dependencies"><a class="anchor" href="#beans-java-injecting-dependencies"></a>Bean 之间依赖关系的注入</h5>
<div class="paragraph">
<p>当 <code>@Bean</code> 之间彼此依赖时，表达这种依赖关系就像调用另一个 bean 方法那样简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Foo foo() {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> Bar bar() {
                <span class="keyword">return</span> <span class="keyword">new</span> Bar();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，<code>foo</code> bean通过构造器注入接收到对 <code>bar</code> 的引用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种声明 bean 间依赖关系的方法只有在 <code>@Configuration</code> 类中声明 <code>@Bean</code> 方法时才起作用。你不能用简单的 <code>@Configuration</code> 类声明 bean 间的依赖关系。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-method-injection"><a class="anchor" href="#beans-java-method-injection"></a>查找方法注入</h5>
<div class="paragraph">
<p>如前所述，<a href="#beans-factory-method-injection">查找方法注入</a> 是一个高级特性，你应该很少使用它。它在一个单例 bean 对原型 bean 依赖时是有用的。使用 Java 对这种类型进行配置提供了一种自然的方式实现这一模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">CommandManager</span> {
        <span class="directive">public</span> <span class="predefined-type">Object</span> process(<span class="predefined-type">Object</span> commandState) {
                <span class="comment">// grab a new instance of the appropriate Command interface</span>
                Command command = createCommand();
                <span class="comment">// set the state on the (hopefully brand new) Command instance</span>
                command.setState(commandState);
                <span class="keyword">return</span> command.execute();
        }

        <span class="comment">// okay... but where is the implementation of this method?</span>
        <span class="directive">protected</span> <span class="directive">abstract</span> Command createCommand();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用Java配置支持，您可以创建 <code>CommandManager</code> 的子类，其中抽象 <code>createCommand()</code> 方法被重写，以便查找新的（原型）command 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
<span class="annotation">@Scope</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> AsyncCommand asyncCommand() {
        AsyncCommand command = <span class="keyword">new</span> AsyncCommand();
        <span class="comment">// inject dependencies here as required</span>
        <span class="keyword">return</span> command;
}

<span class="annotation">@Bean</span>
<span class="directive">public</span> CommandManager commandManager() {
        <span class="comment">// return new anonymous implementation of CommandManager with command() overridden</span>
        <span class="comment">// to return a new prototype Command object</span>
        <span class="keyword">return</span> <span class="keyword">new</span> CommandManager() {
                <span class="directive">protected</span> Command createCommand() {
                        <span class="keyword">return</span> asyncCommand();
                }
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-further-information-java-config"><a class="anchor" href="#beans-java-further-information-java-config"></a>有关基于 Java 的配置如何在内部工作的更多信息</h5>
<div class="paragraph">
<p>以下示例显示了一个被调用了两次的 <code>@Bean</code> 注解方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientService clientService1() {
                ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();
                clientService.setClientDao(clientDao());
                <span class="keyword">return</span> clientService;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientService clientService2() {
                ClientServiceImpl clientService = <span class="keyword">new</span> ClientServiceImpl();
                clientService.setClientDao(clientDao());
                <span class="keyword">return</span> clientService;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> ClientDao clientDao() {
                <span class="keyword">return</span> <span class="keyword">new</span> ClientDaoImpl();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientDao()</code> 在 <code>clientService1()</code> 中被调用一次，在 <code>clientService2()</code> 中也被调用一次。由于此方法创建 <code>ClientDaoImpl</code> 的一个新实例并返回它，通常期望有2个实例（每个 service 一个）。这肯定会有问题：在Spring中，实例化的 bean 默认情况下具有单例 <code>singleton</code> 作用域。下面就是 Spring 魔法所在：所有的 <code>@Configuration</code> 类在 <code>CGLIB</code> 启动时被分类。在子类中，child 方法在调用父方法并创建一个新实例之前首先检查容器是否有缓存的（作用域）bean。请注意，从 Spring 3.2 开始，不再需要将CGLIB添加到类路径中，因为CGLIB类已经在<code>org.springframework.cglib</code> 下重新打包，并直接包含在 Spring-Core JAR 包中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种行为可能会根据您的 bean 的作用域而有所不同。我们在这里讨论单例 bean。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于 CGLIB 在启动时动态添加功能，因此有一些限制，特别是配置类不能是 final 的。但是，从 Spring 4.3 开始，任何构造函数都可以在配置类上使用，包括使用 <code>@Autowired</code>或对默认注入使用单个非默认构造器声明。</p>
</div>
<div class="paragraph">
<p>如果您希望避免任何 CGLIB 限制，请考虑在非 <code>@Configuration</code> 类上声明 <code>@Bean</code> 方法，例如使用简单的 <code>@Component</code> 类。 <code>@Bean</code> 方法之间的跨方法调用将不会被拦截，因此你必须完全依赖于构造器或方法级别的依赖注入。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-composing-configuration-classes"><a class="anchor" href="#beans-java-composing-configuration-classes"></a>1.12.5. 构建基于 Java 的配置</h4>
<div class="sect4">
<h5 id="beans-java-using-import"><a class="anchor" href="#beans-java-using-import"></a>使用 @Import 注解</h5>
<div class="paragraph">
<p>就像在 Spring XML 文件中使用 <code>&lt;import/&gt;</code> 元素来帮助实现配置的模块化一样，<code>@Import</code> 注解允许从另一个配置类加载 <code>@Bean</code> 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigA</span> {

         <span class="annotation">@Bean</span>
        <span class="directive">public</span> A a() {
                <span class="keyword">return</span> <span class="keyword">new</span> A();
        }

}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>(ConfigA.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigB</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> B b() {
                <span class="keyword">return</span> <span class="keyword">new</span> B();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在实例化上下文时，不需要同时指定 <code>ConfigA.class</code> 和 <code>ConfigB.class</code>，只需要显式地提供 <code>ConfigB</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);

        <span class="comment">// now both beans A and B will be available...</span>
        A a = ctx.getBean(A.class);
        B b = ctx.getBean(B.class);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法简化了容器的实例化，因为只有一个类需要处理，而不是要求开发人员在构建过程中记住大量的 <code>@Configuration</code> 类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从Spring Framework 4.2开始，<code>@Import</code> 还支持对常规组件类的引用，类似 <code>AnnotationConfigApplicationContext.register</code> 方法。如果您想避免组件扫描，将一些配置类作为明确定义所有组件的入口点，这个支持特别有用。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="beans-java-injecting-imported-beans"><a class="anchor" href="#beans-java-injecting-imported-beans"></a>被导入的 @Bean 定义的依赖注入</h6>
<div class="paragraph">
<p>上面的例子可以正常工作，不过是简单的。在大多数实际情况中，bean 将在配置类之间相互依赖。当使用 XML 时，这本身不算是个问题，因为没有涉及到编译器，只需声明 <code>ref="someBean"</code> 并相信 Spring 将在容器初始化期间解决它。当然，在使用 <code>@Configuration</code> 类时，Java 编译器会在配置模型上设置约束，因为对其他 bean 的引用必须是有效的 Java 语法。</p>
</div>
<div class="paragraph">
<p>幸运的是，解决这个问题很简单。<a href="#beans-java-dependencies">正如我们已经讨论过的</a>，<code>@Bean</code> 方法可以有任意数量的描述 bean 依赖关系的参数。考虑一个更现实的场景，其中有几个<code>@Configuration</code> 类，每个类都依赖于在其他类中声明的bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService(AccountRepository accountRepository) {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">RepositoryConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository(<span class="predefined-type">DataSource</span> dataSource) {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, RepositoryConfig.class})
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return new DataSource</span>
        }
}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        <span class="comment">// everything wires up across configuration classes...</span>
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有另一种方法可以达到同样的结果。记住，<code>@Configuration</code> 类最终只是容器中的另外一个 bean：这意味着他们可以像其他任何 bean 一样利用 <code>@Autowired</code>和 <code>@Value</code> 注入等等！</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保以这种方式注入的依赖关系只是最简单的一种。 <code>@Configuration</code> 类在上下文的初始化过程的很早起就会被处理，而且强制依赖以这种方式被注入可能会导致未预料的早期初始化。只要有可能，就应该像上面的例子那样，采取基于参数的注入。</p>
</div>
<div class="paragraph">
<p>此外，对 <code>@Bean</code> 注解的 <code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 定义要特别小心。这些应该通常被声明为 <code>static @Bean</code> 方法，而不是触发其包含的配置类的实例化。否则，<code>@Autowired</code> 和 <code>@Value</code> 将不能在配置类本身上工作，因为它太早就被创建为一个 bean 实例。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> AccountRepository accountRepository;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">RepositoryConfig</span> {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">DataSource</span> dataSource;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> RepositoryConfig(<span class="predefined-type">DataSource</span> dataSource) {
                <span class="local-variable">this</span>.dataSource = dataSource;
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, RepositoryConfig.class})
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return new DataSource</span>
        }
}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        <span class="comment">// everything wires up across configuration classes...</span>
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@Configuration</code> 类中的构造器注入仅在 Spring Framework 4.3 及以上版本中受支持。 另请注意，如果目标 bean 只定义了一个构造器，则不需要指定 <code>@Autowired</code>; 在上面的例子中，<code>RepositoryConfig</code> 的构造器不需要 <code>@Autowired</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-injecting-imported-beans-fq"></a>便于导航的全限定导入 bean</div>
<div class="content">
<div class="paragraph">
<p>在上面的场景中，使用 <code>@Autowired</code> 运行良好，并提供了所需的模块化，但是确定自动装配的 bean 定义的确切位置仍然有些模糊。例如，作为一名开发人员查看一下 <code>ServiceConfig</code>，你如何确切知道 <code>@Autowired AccountRepository</code> bean 的声明位置？这在代码中并不明确，这个例子可能刚好是 OK 的。记住，<a href="https://spring.io/tools/sts">Spring Tool Suite</a> 提供的工具可以渲染拓扑图，显示所有组件是怎么连接起来的 - 这可能就是您所需要的。另外，您的Java IDE可以轻松找到 <code>AccountRepository</code> 类型的所有声明和用法，并且会快速向您显示返回该类型的 <code>@Bean</code> 方法的位置。</p>
</div>
<div class="paragraph">
<p>如果这种歧义是不可接受的，并且你希望从 IDE 中的一个 <code>@Configuration</code> 类直接导航到另一个 <code>@Configuration</code>类，请考虑自动装配配置类本身：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> RepositoryConfig repositoryConfig;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="comment">// navigate 'through' the config class to the @Bean method!</span>
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的情况中，在定义 <code>AccountRepository</code> 的地方非常明确。但是，<code>ServiceConfig</code> 与 <code>RepositoryConfig</code> 就非常紧耦合了;这就是一种妥协。通过使用基于接口的或基于抽象类的 <code>@Configuration</code> 类，可以稍微缓解这种紧密耦合。 考虑以下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ServiceConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> RepositoryConfig repositoryConfig;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(repositoryConfig.accountRepository());
        }
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">RepositoryConfig</span> {

        <span class="annotation">@Bean</span>
        AccountRepository accountRepository();
}

<span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultRepositoryConfig</span> <span class="directive">implements</span> RepositoryConfig {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(...);
        }
}

<span class="annotation">@Configuration</span>
<span class="annotation">@Import</span>({ServiceConfig.class, DefaultRepositoryConfig.class})  <span class="comment">// import the concrete config!</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemTestConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="comment">// return DataSource</span>
        }

}

<span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(SystemTestConfig.class);
        TransferService transferService = ctx.getBean(TransferService.class);
        transferService.transfer(<span class="float">100.00</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">A123</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C456</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，<code>ServiceConfig</code> 与具体的 <code>DefaultRepositoryConfig</code> 耦合就比较松散，内置的 IDE 工具仍然有用：开发人员可以轻松获得 <code>RepositoryConfig</code> 实现的类型层次结构。通过这种方式，导航 <code>@Configuration</code> 类及其依赖关系与通常的基于接口的代码导航过程没有区别。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-conditional"><a class="anchor" href="#beans-java-conditional"></a>有条件地包含 @Configuration 类或 @Bean 方法</h5>
<div class="paragraph">
<p>根据系统的不同状态，有时候需要有条件地启用或禁用完整的 <code>@Configuration</code> 类，甚至单个的 <code>@Bean</code> 方法。 一个常见的例子是，只有在 Spring <code>Environment</code> 中启用了特定的 profile 时，才使用 <code>@Profile</code> 注释来激活bean（有关详细信息，请参阅 <a href="#beans-definition-profiles"> Bean 定义 profile</a>）。</p>
</div>
<div class="paragraph">
<p><code>@Profile</code> 注释实际上是使用一个更为灵活的注解 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a> 来实现的。<code>@Conditional</code> 注解表示特定的 <code>org.springframework.context.annotation.Condition</code> 实现，它会在<code>@Bean</code> 注册之前被引用参考。</p>
</div>
<div class="paragraph">
<p><code>Condition</code> 接口的实现只是提供一个返回 <code>true</code> 或 <code>false</code> 的 <code>matches(&#8230;&#8203;)</code> 方法。例如，下面是用于 <code>@Profile</code> 的某个实际 <code>Condition</code> 实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        <span class="keyword">if</span> (context.getEnvironment() != <span class="predefined-constant">null</span>) {
                <span class="comment">// Read the @Profile annotation attributes</span>
                MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
                <span class="keyword">if</span> (attrs != <span class="predefined-constant">null</span>) {
                        <span class="keyword">for</span> (<span class="predefined-type">Object</span> value : attrs.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>)) {
                                <span class="keyword">if</span> (context.getEnvironment().acceptsProfiles(((<span class="predefined-type">String</span><span class="type">[]</span>) value))) {
                                        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
                                }
                        }
                        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
                }
        }
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html">
  <code>@Conditional</code> javadocs</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-combining"><a class="anchor" href="#beans-java-combining"></a>结合 Java 和 XML 配置</h5>
<div class="paragraph">
<p>Spring 对 <code>@Configuration</code> 类的支持并不是瞄准要成为 Spring XML 的 100％完全的替代方案这个目标。Spring XML 的命名空间等一些工具仍然是配置容器的理想方法。在使用 XML 更方便或必要的情况下，您可以选择：使用 <code>ClassPathXmlApplicationContext</code> 的“以 XML 配置为中心”的方式实例化容器，或者使用 <code>AnnotationConfigApplicationContext</code> 和用 <code>@ImportResource</code> 注解根据需要导入 XML 的“以Java 代码注解为中心”的方式实例化容器 。</p>
</div>
<div class="sect5">
<h6 id="beans-java-combining-xml-centric"><a class="anchor" href="#beans-java-combining-xml-centric"></a>以 XML 配置为中心使用 @Configuration 类</h6>
<div class="paragraph">
<p>最好用 XML 配置文件启动 Spring 容器，并以特定方式包含 <code>@Configuration</code> 类。 例如，在使用Spring XML 的大型现有代码库中，根据需要创建 <code>@Configuration</code> 类并将其包含到现有的 XML 文件中会更容易。下面你会看到在这种“以 XML 配置为中心”的情况下使用<code>@Configuration</code> 类的选择。</p>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-declare-as-bean"></a>将 @Configuration 类声明为普通的 Spring <code>&lt;bean/&gt;</code> 元素。</div>
<div class="content">
<div class="paragraph">
<p>记住，<code>@Configuration</code> 类最终只是容器中的 bean 定义。在这个例子中，我们创建了一个名为<code>AppConfig</code> 的 <code>@Configuration</code> 类，并将其作为 <code>&lt;bean/&gt;</code> 定义包含在 <code>system-test-config.xml</code> 中。由于开启了 <code>&lt;context:annotation-config/&gt;</code>，容器将识别 <code>@Configuration</code> 注解 并正确处理在 <code>AppConfig</code> 中声明的@Bean方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> <span class="predefined-type">DataSource</span> dataSource;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> AccountRepository accountRepository() {
                <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);
        }

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> TransferService transferService() {
                <span class="keyword">return</span> <span class="keyword">new</span> TransferService(accountRepository());
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>system-test-config.xml</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="comment">&lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;</span>
        <span class="tag">&lt;context:annotation-config</span><span class="tag">/&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.AppConfig</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.jdbc.datasource.DriverManagerDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>jdbc.properties</strong>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/system-test-config.xml</span><span class="delimiter">&quot;</span></span>);
        TransferService transferService = ctx.getBean(TransferService.class);
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在上面的 <code>system-test-config.xml</code> 中，<code>AppConfig</code> <code>&lt;bean/&gt;</code> 没有声明一个 <code>id</code> 元素。这样做是可以接受的，这也没有必要因为其他bean 将不会引用它，并且也不可能让容器通过名字获取它。同样，对于 <code>DataSource</code> bean，它只能通过类型自动装配，所以不需要显式的bean <code>id</code>。/p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-component-scan"></a> 使用 &lt;context:component-scan/&gt; 来获取 <code>@Configuration</code> 类</div>
<div class="content">
<div class="paragraph">
<p>因为 <code>@Configuration</code> 是用 <code>@Component</code> 注解的元注解，所以 <code>@Configuration</code> 注解的类会自动成为组件扫描的候选对象。与上面的场景一样，我们可以重新定义 <code>system-test-config.xml</code> 来利用组件扫描带来优势。注意，在这种情况下，我们不需要显式声明 <code>&lt;context:annotation-config/&gt;</code>，因为 <code>&lt;context:component-scan/&gt;</code> 启用了相同的功能。</p>
</div>
<div class="paragraph">
<p><strong>system-test-config.xml</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="comment">&lt;!-- picks up and registers AppConfig as a bean definition --&gt;</span>
        <span class="tag">&lt;context:component-scan</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.jdbc.datasource.DriverManagerDataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">url</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-combining-java-centric"><a class="anchor" href="#beans-java-combining-java-centric"></a>使用 @ImportResource 将 XML 引入到以 @Configuration 类为中心的配置</h6>
<div class="paragraph">
<p>在以 <code>@Configuration</code> 类为配置容器的主要机制的应用程序中，仍然可能有必要使用一些 XML。在这些场景中，只需使用 <code>@ImportResource</code>，并根据需要定义 XML 的数量。这样做既实现了“以Java为中心”的方式来配置容器，又将 XML 的使用保持在最低限度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@ImportResource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/properties-config.xml</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.url}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> url;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.username}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> username;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">${jdbc.password}</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> password;

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> DriverManagerDataSource(url, username, password);
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml">properties-config.xml
<span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:property-placeholder</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/acme/jdbc.properties</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);
        TransferService transferService = ctx.getBean(TransferService.class);
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-environment"><a class="anchor" href="#beans-environment"></a>1.13. 环境抽象</h3>
<div class="paragraph">
<p> <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/Environment.html"><code>环境</code></a> 是一个容器中的抽象模型，它模拟了应用程序环境的两个关键方面：<a href="#beans-definition-profiles"><em>profiles</em></a> 和 <a href="#beans-property-source-abstraction"><em>properties</em></a>。</p>
</div>
<div class="paragraph">
<p><em>profile</em> 是一个命名的 bean 定义逻辑组合，当一个给定的 profile 被激活时它可以被注册到容器中。Bean 可能会通过 XML 或者注解赋值给 profile。与 profile 有关的 <code>Environment</code> 对象角色取决于哪个 profile（如果有的话）当前被激活，哪个 profile（如果有的话）应该默认被激活。</p>
</div>
<div class="paragraph">
<p> Properties 几乎在所有的应用中起着重要作用，并可能来自各种来源：properties 文件，JVM 的系统属性，系统环境变量，JNDI，servlet 上下文参数，特定 properties 对象，Map，等等。<code>Environment</code> 对象的角色与 property 相关，它的作用是为用户提供一个方便的服务接口，用于配置属性源并解析它们。</p>
</div>
<div class="sect3">
<h4 id="beans-definition-profiles"><a class="anchor" href="#beans-definition-profiles"></a>1.13.1. Bean 定义 profile</h4>
<div class="paragraph">
<p>Bean 定义 profile 是核心容器中的一种机制，允许在不同的环境中注册不同的 bean。<em>environment</em> 这个词对于不同的用户来说有不同的含义，这个特性可以很多情况都有用，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在开发环境中使用内存数据源 vs 在 QA 或者生产环境中用 JNDI 寻找相同数据源</p>
</li>
<li>
<p>仅在将应用程序部署到某个性能测试环境时注册监听基础组件</p>
</li>
<li>
<p>为客户 A 注册自定义 bean 实现 vs. 为客户 B 注册自定义 bean 实现</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑需要实际应用中的使用 <code>DataSource</code> 的第一个例子。在测试环境中，配置可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-schema.sql</span><span class="delimiter">&quot;</span></span>)
                .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-test-data.sql</span><span class="delimiter">&quot;</span></span>)
                .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们考虑如何将这个应用程序部署到 QA 或生产环境中，假设应用程序的数据源将被注册到生产应用程序服务器的JNDI 目录中。我们的 <code>dataSource</code> bean 现在看起来是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
        <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题是如何根据当前的环境来切换使用这两种变体。随着时间的推移，Spring 用户设计了许多方法来处理这个问题，通常依赖于系统环境变量和包含 <code>${placeholder}</code> 的 XML <code>&lt;import/&gt;</code> 语句的组合，它们根据环境变量值解析正确的配置文件路径。Bean 定义 profile 作为一个核心容器功能为这个问题提供了一种解决方案。</p>
</div>
<div class="paragraph">
<p>如果我们概括一下上面这个特定于环境的 bean 定义的用例，我们最终需要在特定的上下文中注册特定的 bean 定义，而不是在其他上下文中。你可以说你想在场景 A 中注册一个特定的 bean 定义 profile，而在场景 B 中需要注册一个不同的配置文件。我们先看看如何更新我们的配置来反映这个需求。</p>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-java"><a class="anchor" href="#beans-definition-profiles-java"></a>@Profile</h5>
<div class="paragraph">
<p>当一个或多个指定的profile 被激活时，<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a> 注解允许你指定其中一个组件可以被注册。使用我们上面的例子，我们可以如下重写 <code>dataSource</code> 配置： </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">StandaloneDataConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">JndiDataConfig</span> {

        <span class="annotation">@Bean</span>(destroyMethod=<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
                <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
                <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如前所述，通常会在有 <code>@Bean</code> 方法的情况下选择使用编程JNDI查找：使用 Spring 的 <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> 帮助程序或上面展示的直接的 JNDI <code>InitialContext</code> 用法，但不能是 <code>JndiObjectFactoryBean</code> 变体，这会强制你将返回类型声明为 <code>FactoryBean</code> 类型。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p> <code>@Profile</code> 可以被当做 <a href="#beans-meta-annotations">元注释</a> 用于创建自定义 <em>组合注解</em>。以下示例定义了可以直接替代 <code>@Profile("production")</code> 自定义 <code>@Production</code> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.TYPE)
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="annotation">@interface</span> Production {
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果某个 <code>@Configuration</code> 类用了 <code>@Profile</code> 注解，则除非一个或多个指定的 profile 处于激活状态，否则与该类关联的所有 <code>@Bean</code> 方法和 <code>@Import</code> 注解将被绕过（忽略）。 如果一个 <code>@Component</code> 或者 <code>@Configuration</code> 类被标记为 <code>@Profile({"p1", "p2"})</code>，那么这个类将不会被注册/处理，除非 profile 'p1'和/或'p2'被激活。如果一个给定的 profile 以NOT运算符（<code>!</code>）为前缀，那么如果该 profile 没有被激活，注解的元素将被注册。例如，给定 <code>@Profile({"p1", "!p2"})</code>，如果配置文件“p1”处于激活状态或配置文件“p2”未激活，则会发生注册。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Profile</code> 可以在方法级被声明，包括只有一个特定 bean 的 configuration 类，例如，同一个特定 bean 的变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>)
        <strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> standaloneDataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }

        <span class="annotation">@Bean</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span>)
        <strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>)</strong>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> jndiDataSource() <span class="directive">throws</span> <span class="exception">Exception</span> {
                <span class="predefined-type">Context</span> ctx = <span class="keyword">new</span> <span class="predefined-type">InitialContext</span>();
                <span class="keyword">return</span> (<span class="predefined-type">DataSource</span>) ctx.lookup(<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span>);
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <code>@Bean</code> 方法上使用 <code>@Profile</code> 时，可能会遇到一个特殊情况：对于重载的方法名相同的 <code>@Bean</code> 方法（类似于构造器重载），必须在所有重载的方法上一致地声明 <code>@Profile</code> 条件。如果条件不一致，那么只有重载方法中第一个声明的条件会有用。因此 <code>@Profile</code> 不能被用使用特定的参数签名来区分重载方法；同一个 bean 的所有工厂方法之间的解析在创建时遵循 Spring 的构造器解析算法。</p>
</div>
<div class="paragraph">
<p>如果您想定义具有不同 profile 的备用 bean，应该使用不同的 Java 方法名，通过 <code>@Bean</code> 的 name 特性指向同一个 bean 名字，就像上例所示。如果参数签名都是相同的（例如，所有的变体都有无参工厂方法），这是在 Java 类中表示这种布局的唯一方法（因为对特定相同的方法名和参数签名只有一个方法有效）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-xml"><a class="anchor" href="#beans-definition-profiles-xml"></a>XML bean 定义 profiles</h5>
<div class="paragraph">
<p>在 XML 中与 profile 注解对应的是 <code>&lt;beans&gt;</code> 元素的 <code>profile</code> 特性。上面的示例配置可以重写为下面两个 XML 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jdbc</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jdbc</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;jdbc:embedded-database</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/jdbc:embedded-database&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jee</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;jee:jndi-lookup</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">jndi-name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以将这些配置放在同一个文件中以避免使用分割和嵌套的 <code>&lt;beans/&gt;</code> 元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jdbc</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jdbc</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:jee</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/jee</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- other bean definitions --&gt;</span>

        <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jdbc:embedded-database</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;jdbc:script</span> <span class="attribute-name">location</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/test-data.sql</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/jdbc:embedded-database&gt;</span>
        <span class="tag">&lt;/beans&gt;</span>

        <span class="tag">&lt;beans</span> <span class="attribute-name">profile</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">production</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;jee:jndi-lookup</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">jndi-name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">java:comp/env/jdbc/datasource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/beans&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>spring-bean.xsd</code> 被限制为只允许这些元素作为文件中的最后一个元素出现。这在不对 XML 文件造成混乱的前提下提供了灵活性。</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-enable"><a class="anchor" href="#beans-definition-profiles-enable"></a>激活 profile</h5>
<div class="paragraph">
<p>现在我们已经更新了配置，我们仍然需要指示 Spring 哪个 profile 处于激活状态。如果我们现在启动我们的示例应用程序，我们会看到一个 <code>NoSuchBeanDefinitionException</code> 异常抛出，因为容器找不到名为 <code>dataSource</code> 的 Spring bean。</p>
</div>
<div class="paragraph">
<p>激活一个 profile 可以通过几种方式来完成，但最直接的方法是通过 <code>ApplicationContext</code> 的 <code>Environment</code> API 对其进行编程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(<span class="string"><span class="delimiter">&quot;</span><span class="content">development</span><span class="delimiter">&quot;</span></span>);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，profile 还可以通过 <code>spring.profiles.active</code> 属性声明式地激活，该属性可能通过系统环境变量，JVM 系统属性，web.xml 中的 servlet 上下文参数，甚至作为 JNDI 中的条目来指定（请参阅 <a href="#beans-property-source-abstraction">PropertySource 抽象</a>）。在集成测试中，可以通过 <code>spring-test</code> 模块中的 <code>@ActiveProfiles</code> 注解声明来激活 profile（请参阅 <a href="testing.html#testcontext-ctx-management-env-profiles">用环境 profile 进行上下文配置</a>）。</p>
</div>
<div class="paragraph">
<p>注意，profile 不是一个“非此即彼”的或命题; 一次可以激活多个配置文件。采用编程方式，只需向 <code>setActiveProfiles()</code> 方法提供多个 profile 名字，该方法接受<code>String&#8230;&#8203;</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ctx.getEnvironment().setActiveProfiles(<span class="string"><span class="delimiter">&quot;</span><span class="content">profile1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">profile2</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果是声明式方式，<code>spring.profiles.active</code> 可以接受逗号分隔的 profile 名列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">-Dspring.profiles.active=<span class="string"><span class="delimiter">&quot;</span><span class="content">profile1,profile2</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-default"><a class="anchor" href="#beans-definition-profiles-default"></a>默认 profile</h5>
<div class="paragraph">
<p><em>默认</em> profile 表示默认启用的 profile。考虑下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@Profile</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">default</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultDataConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
                <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()
                        .setType(EmbeddedDatabaseType.HSQL)
                        .addScript(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:com/bank/config/sql/schema.sql</span><span class="delimiter">&quot;</span></span>)
                        .build();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 profile 被激活，上面的 <code>dataSource</code> 将被创建; 这可以看作是为一个或多个 bean 提供 <em>默认</em> 定义的一种方式。如果启用了任何 profile，则不会应用 <em>默认</em> profile。</p>
</div>
<div class="paragraph">
<p>默认 profile 的名称可以用 <code>Environment</code> 中的 <code>setDefaultProfiles()</code> 更改，或者使用 <code>spring.profiles.default</code> 属性进行声明式更改。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-property-source-abstraction"><a class="anchor" href="#beans-property-source-abstraction"></a>1.13.2. PropertySource 抽象</h4>
<div class="paragraph">
<p>Spring 的 <code>Environment</code> 抽象提供了对属性资源的可配置层次结构的搜索操作。为了充分解释，考虑下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();
Environment env = ctx.getEnvironment();
<span class="type">boolean</span> containsFoo = env.containsProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Does my environment contain the 'foo' property? </span><span class="delimiter">&quot;</span></span> + containsFoo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码片段中，我们看到了一个高级的方式来询问 Spring 是否为当前环境定义了 <code>foo</code> 属性。为了回答这个问题，<code>Environment</code> 对象对一组 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a> 对象执行搜索。<code>PropertySource</code> 是对任意 key-value 键值对的一个简单抽象，Spring 的 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a> 配置了两个PropertySource 对象，一个表示一组 JVM 系统属性（访问方式 System.getProperties()），一个表示一组系统环境 变量（访问方式 System.getenv()）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这些在 <code>StandardEnvironment</code> 中的默认属性源会用于独立应用程序。<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a> 填充了额外的默认属性源，包括 servlet 配置和 servlet 上下文参数。 它可以选择性地启用 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a> 。有关详细信息，请参阅相关 javadoc。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>具体来说，当你使用 <code>StandardEnvironment</code> 时，如果在运行时时刻存在 <code>foo</code> 系统属性或 <code>foo</code> 环境变量，则对 <code>env.containsProperty("foo")</code> 的调用将返回true。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>搜索的执行是分层进行的。默认情况下，系统属性优先于环境变量，所以如果在调用 <code>env.getProperty("foo")</code> 的时候，<code>foo</code> 属性碰巧在两个地方都有设置，那么系统属性值就“赢了”，并会优先于环境变量而返回。注意，属性值不会被合并，而是被优先级高的 entry 完全覆盖。</p>
</div>
<div class="paragraph">
<p>对于常见的 <code>StandardServletEnvironment</code>，完整的层次结构如下所示，最高优先级 entry 在最上面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ServletConfig 参数（如果适用，例如 在 <code>DispatcherServlet</code> 上下文的情况下）</p>
</li>
<li>
<p>ServletContext 参数 (web.xml context-param entries)</p>
</li>
<li>
<p>JNDI 环境变量 ("java:comp/env/" entries)</p>
</li>
<li>
<p>JVM 系统属性 ("-D" command-line 参数)</p>
</li>
<li>
<p>JVM 系统环境 (操作系统环境变量)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最重要的是，这整个机制是可配置的。也许你有一个自定义的属性来源，你想将他集成到这个搜索过程中。没问题 - 只需实现并实例化您自己的 <code>PropertySource</code> 并将其添加到当前  <code>Environment</code> 的 <code>PropertySources</code> 集合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConfigurableApplicationContext ctx = <span class="keyword">new</span> GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(<span class="keyword">new</span> MyPropertySource());</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码中，<code>MyPropertySource</code> 在搜索中的优先级最高。如果它包含 <code>foo</code> 属性，则这个属性会在任何其他  <code>PropertySource</code> 中的 <code>foo</code> 属性之前被检测到并返回。<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a> API 暴露了许多允许精确操作属性源集的方法。.</p>
</div>
</div>
<div class="sect3">
<h4 id="propertysource"><a class="anchor" href="#propertysource"></a>1.13.3. @PropertySource</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> 注解提供了一个便捷的声明机制，用于将一个 <code>PropertySource</code> 添加到Spring的 <code>Environment</code> 中。</p>
</div>
<div class="paragraph">
<p>给定一个包含键/值对 <code>testbean.name=myTestBean</code> 的文件“app.properties”，下面的 <code>@Configuration</code> 类使用了<code>@PropertySource</code>，以便对 <code>testBean.getName()</code> 的调用返回“myTestBean”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<strong><span class="annotation">@PropertySource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/myco/app.properties</span><span class="delimiter">&quot;</span></span>)</strong>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

 <span class="annotation">@Autowired</span>
 Environment env;

 <span class="annotation">@Bean</span>
 <span class="directive">public</span> TestBean testBean() {
  TestBean testBean = <span class="keyword">new</span> TestBean();
  testBean.setName(env.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">testbean.name</span><span class="delimiter">&quot;</span></span>));
  <span class="keyword">return</span> testBean;
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何在 <code>@PropertySource</code> 资源定位中的 <code>${&#8230;&#8203;}</code> 占位符都会被解析，用于在环境中注册的一组属性源，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@PropertySource</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:/com/${my.placeholder:default/path}/app.properties</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

 <span class="annotation">@Autowired</span>
 Environment env;

 <span class="annotation">@Bean</span>
 <span class="directive">public</span> TestBean testBean() {
  TestBean testBean = <span class="keyword">new</span> TestBean();
  testBean.setName(env.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">testbean.name</span><span class="delimiter">&quot;</span></span>));
  <span class="keyword">return</span> testBean;
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设“my.placeholder”存在于已经注册的一个属性源中，例如系统属性或环境变量，占位符将被解析为相应的值。 如果没有找到，则默认使用“default/path”路径。如果没有指定默认值，而且无法解析属性，则会抛出 <code>IllegalArgumentException</code> 异常。</p>
</div>
</div>
<div class="sect3">
<h4 id="placeholder-resolution-in-statements"><a class="anchor" href="#placeholder-resolution-in-statements"></a>1.13.4. 语句中的占位符解析</h4>
<div class="paragraph">
<p>从历史上看，元素中占位符的值只能根据 JVM 系统属性或环境变量来解决。现在这种情况已经不复存在。由于环境抽象被集成到整个容器中，通过它可以轻松地路由占位符的解析。这意味着你可以用任何你喜欢的方式配置解析过程：改变搜索系统属性和环境变量的优先级，或者完全删除它们; 根据需要添加您自己的属性源来混合使用。</p>
</div>
<div class="paragraph">
<p>具体而言，只要在 <code>Environment</code> 中可用，无论 <code>customer</code> 属性是在哪里定义的，以下语句都可以正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;import</span> <span class="attribute-name">resource</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com/bank/service/${customer}-config.xml</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context-load-time-weaver"><a class="anchor" href="#context-load-time-weaver"></a>1.14. 注册 LoadTimeWeaver</h3>
<div class="paragraph">
<p>当类被加载到 Java 虚拟机（JVM）的时候，Spring 使用 <code>LoadTimeWeaver</code> 对它们进行动态转换。</p>
</div>
<div class="paragraph">
<p>要启用加载时织入，可以将 <code>@EnableLoadTimeWeaving</code> 添加到其中一个 <code>@Configuration</code> 类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableLoadTimeWeaving</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，对于 XML 配置，使用上下文：<code>context:load-time-weaver</code>元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;context:load-time-weaver</span><span class="tag">/&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦配置了 <code>ApplicationContext</code>，该 <code>ApplicationContext</code> 中的任何 bean 都可以实现 <code>LoadTimeWeaverAware</code>，从而接收对加载时 weaver 实例的引用。这与 <a href="data-access.html#orm-jpa">Spring 的 JPA 支持</a> 相结合是非常有用的，JPA 类转换可能需要加载时织入。 有关更多详细信息，请参阅 <code>LocalContainerEntityManagerFactoryBean</code> javadoc。有关 AspectJ 加载时织入的更多信息，请参阅 <a href="#aop-aj-ltw">Spring 框架中使用 AspectJ 进行加载时织入</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="context-introduction"><a class="anchor" href="#context-introduction"></a>1.15. ApplicationContext 的其他附加功能</h3>
<div class="paragraph">
<p>正如本章简介中所讨论的，<code>org.springframework.beans.factory</code> 包提供了用于管理和操作 bean 的基本功能，包括以编程的方式。<code>org.springframework.context</code> 包添加了扩展了 <code>BeanFactory</code> 接口的 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a> 接口，并扩展了其他接口，以更多的面向应用程序框架的风格提供附加功能。很多人以完全声明的方式使用 <code>ApplicationContext</code> ，甚至不是以编程方式创建它，而是依赖诸如 <code>ContextLoader</code> 之类的支持类自动实例化 <code>ApplicationContext</code> ，并将它作为 Java EE Web 应用程序正常启动过程的一部分。</p>
</div>
<div class="paragraph">
<p>为了以更加面向框架的风格增强 <code>BeanFactory</code> 功能，上下文包还提供了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过 <code>MessageSource</code> 接口，<em>以国际化风格访问消息</em>。</p>
</li>
<li>
<p>通过 <code>ResourceLoader</code> 接口 <em>访问资源</em>，例如 URL 和文件。</p>
</li>
<li>
<p>通过使用 <code>ApplicationEventPublisher</code> 接口，将 <em>Event 发布</em> 到实现 <code>ApplicationListener</code> 接口的 bean。</p>
</li>
<li>
<p>通过 <code>HierarchicalBeanFactory</code> 接口 <em>加载多个（层次）上下文</em>，允许每个上下文关注一个特定的层，例如应用程序的 web 层。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="context-functionality-messagesource"><a class="anchor" href="#context-functionality-messagesource"></a>1.15.1. 使用 MessageSource 实现国际化</h4>
<div class="paragraph">
<p><code>ApplicationContext</code> 接口扩展了一个名为 <code>MessageSource</code> 的接口，且提供了国际化（i18n）功能。Spring 还提供了 <code>HierarchicalMessageSource</code> 接口，它可以分层解析消息。这些接口一起为 Spring 消息解析提供了基础。这些接口上定义的方法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从 <code>MessageSource</code> 中检索消息的基本方法。当找不到指定语言环境的消息时，将使用默认消息。</p>
</li>
<li>
<p><code>String getMessage(String code, Object[] args, Locale loc)</code>：基本上与前面的方法相同，但有一点不同：不能指定默认消息; 如果无法找到消息，则抛出 <code>NoSuchMessageException</code> 异常。</p>
</li>
<li>
<p><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面的方法中使用的所有属性也都包装在一个名为 <code>MessageSourceResolvable</code> 的类中，您可以在该方法中使用它。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当一个 <code>ApplicationContext</code> 被加载时，它会自动搜索上下文中定义的 <code>MessageSource</code> bean。该 bean 的名字必须为 <code>messageSource</code>。如果能找到这样一个 bean，所有对前面方法的调用都被委托给这个消息源。如果没有找到消息源，则 <code>ApplicationContext</code> 将尝试查找父容器中包含的同名 bean 。如果找到了这样的 bean，它将使用该 bean 作为 <code>MessageSource</code>。如果 <code>ApplicationContext</code> 找不到任何消息源，就会实例化一个空的 <code>DelegatingMessageSource</code>，以便能够接受对上面定义的方法的调用。</p>
</div>
<div class="paragraph">
<p>Spring 提供了两个 <code>MessageSource</code> 实现，<code>ResourceBundleMessageSource</code> 和
  <code>StaticMessageSource</code>。两者都实现了  <code>HierarchicalMessageSource</code> 以进行消息的嵌套传递。 <code>StaticMessageSource</code> 很少使用，但它提供了以编程方式来添加消息到源的功能。以下示例中显示了 <code>ResourceBundleMessageSource</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ResourceBundleMessageSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">basenames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;list&gt;</span>
                                <span class="tag">&lt;value&gt;</span>format<span class="tag">&lt;/value&gt;</span>
                                <span class="tag">&lt;value&gt;</span>exceptions<span class="tag">&lt;/value&gt;</span>
                                <span class="tag">&lt;value&gt;</span>windows<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;/list&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，假设你在你的类路径中定义了三个 resource bundle ，分别叫做 <code>format</code>，<code>exceptions</code> 和 <code>windows</code>。任何解析消息的请求都将以 JDK 标准方式通过 ResourceBundles 解析消息。为了达到这个例子的目的，假设前两个 resource bundle 文件的内容是...</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span> in format.properties
message=Alligators rock!</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">#</span> in exceptions.properties
argument.required=The {<span class="integer">0</span>} argument is required.</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例中显示了执行 <code>MessageSource</code> 功能的程序。记住，所有 <code>ApplicationContext</code> 实现也是 <code>MessageSource</code> 实现，因此可以转换为 <code>MessageSource</code>接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> message = resources.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Default</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);
        <span class="predefined-type">System</span>.out.println(message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面这个程序的输出结果应该是这样的...</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Alligators rock!</pre>
</div>
</div>
<div class="paragraph">
<p>所以总结一下，<code>MessageSource</code> 被定义在一个名为 <code>beans.xml</code> 的文件中，该文件存在于你的类路径的根目录下。<code>messageSource</code> bean 定义通过其 <code>basenames</code> 属性来引用许多 resource bundle。在列表中传递给 <code>basenames</code> 属性的三个文件存在于类路径的根目录下，分别名为<code>format.properties</code>，<code>exceptions.properties</code>，和 <code>windows.properties</code>。</p>
</div>
<div class="paragraph">
<p>下一个示例展示了参数用于消息查找; 这些参数将被转换为字符串并插入到查找消息中的占位符中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans&gt;</span>

        <span class="comment">&lt;!-- this MessageSource is being used in a web application --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ResourceBundleMessageSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">basename</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exceptions</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

        <span class="comment">&lt;!-- lets inject the above MessageSource into this POJO --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.Example</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messages</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">messageSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Example</span> {

        <span class="directive">private</span> MessageSource messages;

        <span class="directive">public</span> <span class="type">void</span> setMessages(MessageSource messages) {
                <span class="local-variable">this</span>.messages = messages;
        }

        <span class="directive">public</span> <span class="type">void</span> execute() {
                <span class="predefined-type">String</span> message = <span class="local-variable">this</span>.messages.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">argument.required</span><span class="delimiter">&quot;</span></span>,
                        <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">userDao</span><span class="delimiter">&quot;</span></span>}, <span class="string"><span class="delimiter">&quot;</span><span class="content">Required</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);
                <span class="predefined-type">System</span>.out.println(message);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用 <code>execute()</code> 方法的结果输出将是...</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The userDao argument is required.</pre>
</div>
</div>
<div class="paragraph">
<p>关于国际化（i18n），Spring 的各种 <code>MessageSource</code> 实现遵循与标准的 JDK <code>ResourceBundle</code>相同的 locale 解析和回退规则。简而言之，继续前面定义的 <code>messageSource</code> 示例，如果要解析 British（en-GB）locale 的消息，则需要分别创建名为 <code>format_en_GB.properties</code>，<code>exceptions_en_GB.properties</code> 和 <code>windows_en_GB.properties</code> 的三个文件。</p>
</div>
<div class="paragraph">
<p>通常，locale 解析由应用程序的所处的环境决定。在这个例子中，（British）消息将被解析的本地化是手动指定的。</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in exceptions_en_GB.properties
argument.required=Ebagum lad, the {0} argument is required, I say, required.</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) {
        MessageSource resources = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">String</span> message = resources.getMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">argument.required</span><span class="delimiter">&quot;</span></span>,
                <span class="keyword">new</span> <span class="predefined-type">Object</span> <span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">userDao</span><span class="delimiter">&quot;</span></span>}, <span class="string"><span class="delimiter">&quot;</span><span class="content">Required</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Locale</span>.UK);
        <span class="predefined-type">System</span>.out.println(message);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行上面的程序得到的输出结果是...</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ebagum lad, the 'userDao' argument is required, I say, required.</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>MessageSourceAware</code> 接口来获取对已定义的任何 <code>MessageSource</code> 的引用。 任何在实现 <code>MessageSourceAware</code> 接口的 <code>ApplicationContext</code>  中定义的 bean 在被创建和配置的时候都会被应用程序上下文中的 <code>MessageSource</code>注入。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
  <p><em>作为 <code>ResourceBundleMessageSource</code> 的替代着，Spring 提供了一个 <code>ReloadableResourceBundleMessageSource</code> 类。这个变体支持相同的 bundle 文件格式，但比标准的基于 JDK 的 <code>ResourceBundleMessageSource</code> 实现更加灵活。</em> 特别是，它允许从任何 Spring 资源路径（而不仅仅是从类路径）读取文件，并支持热重新加载 bundle 属性文件（同时高效地缓存它们之间）。查看 <code>ReloadableResourceBundleMessageSource</code> javadoc 获取详细信息。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-events"><a class="anchor" href="#context-functionality-events"></a>1.15.2. 标准事件和自定义事件</h4>
<div class="paragraph">
<p><code>ApplicationContext</code> 中的事件处理是通过 <code>ApplicationEvent</code> 类和 <code>ApplicationListener</code> 接口提供的。如果一个实现 <code>ApplicationListener</code> 接口的 bean 被部署到上下文中，则每当 <code>ApplicationEvent</code> 发布到 <code>ApplicationContext</code> 时，都会通知该 bean。实质上，这是标准的 <em>Observer</em> 设计模式。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从 Spring 4.2 开始，事件基础架构得到了显着的改进，并提供了 <a href="#context-functionality-events-annotation">基于注解的模型</a> 以及发布任意事件的能力，这个事件对象不一定是 <code>ApplicationEvent</code> 的扩展对象。当这样的事件对象发布时，我们会将它包装在一个事件中再向你提供。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring 提供一下标准事件：</p>
</div>
<table id="beans-ctx-events-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. 内置事件</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">事件</th>
<th class="tableblock halign-left valign-top">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextRefreshedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 初始化或刷新时发布，例如在 <code>ConfigurableApplicationContext</code> 接口中使用 <code>refresh()</code> 方法。这里的“初始化”指的是所有 bean 都加载完成，所有 post-processor bean 被检测和激活，所有单例 bean 被预实例化，且 <code>ApplicationContext</code> 处于使用就绪状态。只要上下文没有被关闭，如果所选的 <code>ApplicationContext</code> 实际上支持这种“热”刷新，那么 refresh 就可以被多次触发。例如，<code>XmlWebApplicationContext</code> 支持热刷新，而 <code>GenericApplicationContext</code> 就不支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStartedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 启动的时候发布，使用 <code>ConfigurableApplicationContext</code> 接口的 <code>start()</code> 方法。这里的“启动”意思是所有的 <code>Lifecycle</code> bean 接收到显式的启动信号。通常这个信号用于在显式停止后对 bean 的后重新启动，但它也有可能用于启动那些未配置为自动启动的组件，例如在初始化阶段没有启动的组件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStoppedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 停止的时候发布，使用 <code>ConfigurableApplicationContext</code> 接口的 <code>stop()</code> 方法。这里的“停止”意思是所有的 <code>Lifecycle</code> bean 接收到显式的停止信号。已经停止的上下文可以通过对 <code>start()</code> 的调用来重新启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextClosedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>ApplicationContext</code> 关闭的时候发布，使用 <code>ConfigurableApplicationContext</code> 接口的 <code>close()</code> 方法。这里的“关闭”意思是所有的单例 bean 都被销毁。一个关闭的上下文已经走到其生命的终点；它不能被刷新或者重启。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个特定的 web 相关事件，它告诉所有 bean 已经对某个 HTTP 请求进行服务。这个时间会在这个请求完成 <em>之后</em> 发布。此事件只适用于使用 Spring 的 <code>DispatcherServlet</code> 的 web 应用程序。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你也可以创建并发布你的自定义事件。本例演示了一个扩展了 Spring 的 <code>ApplicationEvent</code> 基类的简单类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListEvent</span> <span class="directive">extends</span> ApplicationEvent {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> address;
        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> test;

        <span class="directive">public</span> BlackListEvent(<span class="predefined-type">Object</span> source, <span class="predefined-type">String</span> address, <span class="predefined-type">String</span> test) {
                <span class="local-variable">super</span>(source);
                <span class="local-variable">this</span>.address = address;
                <span class="local-variable">this</span>.test = test;
        }

        <span class="comment">// accessor and other methods...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要发布自定义 <code>ApplicationEvent</code> ，需要在 <code>ApplicationEventPublisher</code> 上调用 <code>publishEvent()</code> 方法。通常这是通过创建一个实现了 <code>ApplicationEventPublisherAware</code> 的类并将其注册为一个 Spring bean 来完成的。 下面的例子演示了这样一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">EmailService</span> <span class="directive">implements</span> ApplicationEventPublisherAware {

        <span class="directive">private</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; blackList;
        <span class="directive">private</span> ApplicationEventPublisher publisher;

        <span class="directive">public</span> <span class="type">void</span> setBlackList(<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; blackList) {
                <span class="local-variable">this</span>.blackList = blackList;
        }

        <span class="directive">public</span> <span class="type">void</span> setApplicationEventPublisher(ApplicationEventPublisher publisher) {
                <span class="local-variable">this</span>.publisher = publisher;
        }

        <span class="directive">public</span> <span class="type">void</span> sendEmail(<span class="predefined-type">String</span> address, <span class="predefined-type">String</span> text) {
                <span class="keyword">if</span> (blackList.contains(address)) {
                        BlackListEvent event = <span class="keyword">new</span> BlackListEvent(<span class="local-variable">this</span>, address, text);
                        publisher.publishEvent(event);
                        <span class="keyword">return</span>;
                }
                <span class="comment">// send email...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在配置时，Spring 容器会检测到 <code>EmailService</code> 实现了 <code>ApplicationEventPublisherAware</code> ，并且会自动调用 <code>setApplicationEventPublisher()</code>。实际上，传入的参数是 Spring 容器本身; 你只需通过 <code>ApplicationEventPublisher</code> 接口与应用程序上下文交互即可。</p>
</div>
<div class="paragraph">
<p>要接收自定义的 <code>ApplicationEvent</code>，需要创建一个实现了 <code>ApplicationListener</code> 的类，并将其注册为一个 Spring bean。下面的例子演示了这样一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListNotifier</span> <span class="directive">implements</span> ApplicationListener&lt;BlackListEvent&gt; {

        <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress;

        <span class="directive">public</span> <span class="type">void</span> setNotificationAddress(<span class="predefined-type">String</span> notificationAddress) {
                <span class="local-variable">this</span>.notificationAddress = notificationAddress;
        }

        <span class="directive">public</span> <span class="type">void</span> onApplicationEvent(BlackListEvent event) {
                <span class="comment">// notify appropriate parties via notificationAddress...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>ApplicationListener</code> 是用你的自定义事件 <code>BlackListEvent</code> 的类型来泛型参数化的。这意味着 <code>onApplicationEvent()</code> 方法可以保持类型安全，避免任何向下转换的需要。你可以根据需要注册多个事件监听器，但注意默认情况下，事件监听器采用同步方式接收事件。这意味着 <code>publishEvent()</code> 方法将会阻塞，直到所有监听器完成事件处理。这种同步和单线程方法的一个优点是，当某个监听器接收到事件时，如果事务上下文可用，它会发布者的事务上下文内运行。如果需要另一个事件发布策略，请参阅Spring的 <code>ApplicationEventMulticaster</code> 接口的 javadoc。</p>
</div>
<div class="paragraph">
<p>以下示例展示了用于注册和配置上述每个类的 bean 定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">emailService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.EmailService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blackList</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>known.spammer@example.org<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>known.hacker@example.org<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>john.doe@example.org<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blackListNotifier</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.BlackListNotifier</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">notificationAddress</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">blacklist@example.org</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>综合起来，当调用 <code>emailService</code> bean 的 <code>sendEmail()</code> 方法时，如果有任何应该列入黑名单的电子邮件地址，就会发布 <code>BlackListEvent</code> 类型的自定义事件。<code>blackListNotifier</code> bean 被注册为一个 <code>ApplicationListener</code>，并且因此接收到 <code>BlackListEvent</code> ，并同时按需通知各方。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring 的事件机制是为了在同一个应用上下文中的 Spring bean 之间进行简单的通信而设计的。但是，对于更复杂的企业集成需求，独立维护的 <a href="https://projects.spring.io/spring-integration/">Spring Integration</a> 项目提供了完整的支持，以构建基于众所周知的 Spring 编程模型的轻量级，<a href="http://www.enterpriseintegrationpatterns.com">面向模式</a> 的事件驱动体系结构。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="context-functionality-events-annotation"><a class="anchor" href="#context-functionality-events-annotation"></a>基于注解的事件监听器</h5>
<div class="paragraph">
<p>从 Spring 4.2 开始，可以通过 <code>EventListener</code> 注解在被托管 bean 的任何公共方法上注册一个事件监听器。<code>BlackListNotifier</code> 可以被重写如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">BlackListNotifier</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> notificationAddress;

        <span class="directive">public</span> <span class="type">void</span> setNotificationAddress(<span class="predefined-type">String</span> notificationAddress) {
                <span class="local-variable">this</span>.notificationAddress = notificationAddress;
        }

        <span class="annotation">@EventListener</span>
        <span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
                <span class="comment">// notify appropriate parties via notificationAddress...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所见，方法签名再次声明了它监听的事件类型，但是这次使用了灵活的名字而并未实现特定的监听器接口。事件类型也可以通过泛型来缩小范围，只要实际事件类型在其实现层次结构中可以解析泛型参数即可。</p>
</div>
<div class="paragraph">
<p>如果你的方法需要监听好几个事件，或者如果你想要不带任何参数来定义它，那么也可以在注解本身上指定事件类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>({ContextStartedEvent.class, ContextRefreshedEvent.class})
<span class="directive">public</span> <span class="type">void</span> handleContextStart() {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以通过注解的 <code>condition</code>  特性添加额外的运行时过滤，该属性定义了一个 <a href="#expressions"><code>SpEL</code> 表达式</a>，如果该表达式匹配就会调用针对特定事件的这个方法。</p>
</div>
<div class="paragraph">
<p>例如，我们的通知器可以被重写为仅在事件的 <code>test</code> 特性等于 <code>foo</code> 的时候被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>(condition = <span class="string"><span class="delimiter">&quot;</span><span class="content">#blEvent.test == 'foo'</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent blEvent) {
        <span class="comment">// notify appropriate parties via notificationAddress...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 <code>SpEL</code>  表达式都会重新评估一个专用的上下文。下表列出了可用于上下文的项目，以便上下文可以将它们用于条件事件处理：</p>
</div>
<table id="context-functionality-events-annotation-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. 事件 SpEL 可用的元数据</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名字</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">事件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实际的 <code>ApplicationEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.event</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数数组</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根对象</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于调用目标的参数（数组）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.args[0]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>参数名</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">评估上下文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意方法参数名。如果因某些情况参数名不可用（例如，没有调试信息），参数名在 <code>#a&lt;#arg&gt;</code> 下也是可用的，<em>#arg</em> 代表参数索引（从0开始）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#blEvent</code> or <code>#a0</code> (one can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> notation as an alias).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意，<code>#root.event</code> 允许您访问基础事件，即使您的方法签名实际上是指已经发布的任意对象。</p>
</div>
<div class="paragraph">
<p>如果您需要发布一个作为处理另一个事件的结果事件，只需更改方法签名以返回应该发布的事件，如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
        <span class="comment">// notify appropriate parties via notificationAddress and</span>
        <span class="comment">// then publish a ListUpdateEvent...</span>
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#context-functionality-events-async">异步监听器</a> 不支持这个功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这个新方法将为每个由上述方法处理的 <code>BlackListEvent</code> 发布一个新的 <code>ListUpdateEvent</code> 。如果您需要发布多个事件，则只需返回事件的 <code>集合</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-async"><a class="anchor" href="#context-functionality-events-async"></a>异步监听器</h5>
<div class="paragraph">
<p>如果你希望某个特定的侦听器对事件进行异步处理，只需重用 <a href="integration.html#scheduling-annotation-support-async">常规 <code>@Async</code> 作为支持</a> 即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="annotation">@Async</span>
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
        <span class="comment">// BlackListEvent is processed in a separate thread</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用异步事件时请注意以下限制：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果事件监听器抛出 <code>异常</code>，它不会被传播给调用者，请查看 <code>AsyncUncaughtExceptionHandler</code> 以获取更多详细信息。</p>
</li>
<li>
<p>这样的事件监听器不能发送回复。如果您需要发送另一个事件作为处理的结果，需要注入 <code>ApplicationEventPublisher</code> 手动发送事件。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-order"><a class="anchor" href="#context-functionality-events-order"></a>监听器排序</h5>
<div class="paragraph">
<p>如果你需要某个监听器在另一个监听器之前被调用，只需在方法生命中添加 <code>@Order</code> 注解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="annotation">@Order</span>(<span class="integer">42</span>)
<span class="directive">public</span> <span class="type">void</span> processBlackListEvent(BlackListEvent event) {
        <span class="comment">// notify appropriate parties via notificationAddress...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-generics"><a class="anchor" href="#context-functionality-events-generics"></a>泛型事件</h5>
<div class="paragraph">
<p>您也可以使用泛型来进一步定义事件的结构。考虑对于 <code>EntityCreatedEvent&lt;T&gt;</code>，其中 <code>T</code> 是创建的实际实体的类型。您可以创建以下侦听器定义用于只接收 <code>Person</code> <code>EntityCreatedEvent</code> 事件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EventListener</span>
<span class="directive">public</span> <span class="type">void</span> onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为类型擦除，只有当被触发的事件正确解析了事件监听器过滤的泛型参数时（这与类PersonCreatedEvent 继承 EntityCreatedEvent <Person> {...}类似）才会有效。</p>
</div>
<div class="paragraph">
<p>在某些情况下，如果所有事件都遵循相同的结构（如上面的事件），则这可能变得非常繁琐。在这种情况下，您可以实现 <code>ResolvableTypeProvider</code> 来引导框架超出运行时环境提供的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">EntityCreatedEvent</span>&lt;T&gt;
                   <span class="directive">extends</span> ApplicationEvent <span class="directive">implements</span> ResolvableTypeProvider {

           <span class="directive">public</span> EntityCreatedEvent(T entity) {
                   <span class="local-variable">super</span>(entity);
           }

           <span class="annotation">@Override</span>
           <span class="directive">public</span> ResolvableType getResolvableType() {
                   <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(),
                                   ResolvableType.forInstance(getSource()));
           }
   }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这不仅适用于 <code>ApplicationEvent</code>，而且适用于作为事件发送的任意对象。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-resources"><a class="anchor" href="#context-functionality-resources"></a>1.15.3. 方便地访问低级资源</h4>
<div class="paragraph">
<p>为了对应用程序上下文的使用和理解达到最佳效果，用户通常应该熟悉 Spring 的 <code>Resource</code> 抽象，如 <a href="#resources">Resources</a> 一章所述。</p>
</div>
<div class="paragraph">
<p>应用程序上下文也是一个 <code>ResourceLoader</code> ，可以用来加载 <code>Resource</code>。<code>Resource</code> 本质上是 JDK 类 <code>java.net.URL</code> 的一个功能更丰富的版本，实际上，<code>Resource</code> 的实现是在适当的情况下包装了一个 <code>java.net.URL</code> 的实例。<code>Resource</code> 可以以透明的方式从几乎任何位置获取低级资源，包括类路径，文件系统位置，任何可用标准 URL 描述的地方以及其他一些变体。如果资源位置字符串是一个没有任何特殊前缀的简单路径，那么这些资源来自特定且适合于实际应用上下文类型。</p>
</div>
<div class="paragraph">
<p>你可以配置一个部署到应用程序上下文中的 bean，以实现特殊的回调接口 <code>ResourceLoaderAware</code>，以便它在初始化时自动回调，同时应用程序上下文本身作为 <code>ResourceLoader</code> 传入。你还可以暴露<code>Resource</code> 类型的属性，用于访问静态资源;他们将像其他任何属性一样被注入。您可以将这些 <code>Resource</code> 属性指定为简单的字符串路径，并依靠能被上下文自动注册的特殊 JavaBean <code>PropertyEditor</code> 将这些文本字符串转换为实际的 <code>Resource</code> 对象。</p>
</div>
<div class="paragraph">
<p>提供给 <code>ApplicationContext</code> 构造器的位置路径实际上是资源字符串，并以简单的形式被视为特定的上下文实现。<code>ClassPathXmlApplicationContext</code> 将简单的位置路径视为类路径位置。你也可以使用带有特殊前缀的位置路径（资源字符串）来强制从类路径或 URL 中加载定义，无论实际的上下文是什么类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-create"><a class="anchor" href="#context-create"></a>1.15.4. web应用的简单 ApplicationContext 实例化</h4>
<div class="paragraph">
<p>你可以使用例如 <code>ContextLoader</code> 以声明方式创建 <code>ApplicationContext</code> 实例。当然，你也可以通过使用 <code>ApplicationContext</code> 的某个实现以编程方式创建 <code>ApplicationContext</code> 实例。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>ContextLoaderListener</code> 注册 <code>ApplicationContext</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context-param&gt;</span>
        <span class="tag">&lt;param-name&gt;</span>contextConfigLocation<span class="tag">&lt;/param-name&gt;</span>
        <span class="tag">&lt;param-value&gt;</span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class="tag">&lt;/param-value&gt;</span>
<span class="tag">&lt;/context-param&gt;</span>

<span class="tag">&lt;listener&gt;</span>
        <span class="tag">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/listener-class&gt;</span>
<span class="tag">&lt;/listener&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>监听器会检查 <code>contextConfigLocation</code> 参数。如果该参数不存在，那么监听器将 <code>/WEB-INF/applicationContext.xml</code> 作为默认值使用。 当参数确实存在时，监听器使用预定义的分隔符（逗号，分号和空格）分隔字符串，并将这些值作为搜索应用程序上下文的位置。Ant 样式的路径模式也被支持。例如 <code>/WEB-INF/*Context.xml</code> 表示所有以 “Context.xml” 结尾的 “WEB-INF” 目录中的所有文件，<code>/WEB-INF/**/*Context.xml</code> 表示所有 “WEB-INF” 任何子目录中的文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="context-deploy-rar"><a class="anchor" href="#context-deploy-rar"></a>1.15.5.将 Spring ApplicationContext 部署为 Java EE RAR 文件</h4>
<div class="paragraph">
<p> 你可以将 Spring ApplicationContext 部署为 RAR 文件，只要将上下文及其所有必需的 bean 类和库 JAR 封装在 Java EE RAR 部署单元中即可。这相当于引导了一个独立的 ApplicationContext，只不过它是在 Java EE 环境中托管，能够访问 Java EE 服务器设施。实际上，部署无头 WAR 文件的场景中，如果只是要在 Java EE 环境中引导 Spring ApplicationContext， RAR 部署比不含任何 HTTP 入口的 WAR 文件更为自然。</p>
</div>
<div class="paragraph">
<p>RAR 部署非常适合不需要 HTTP 入口，仅由消息终结点和定时任务组成的应用程序上下文。在这种情况下，bean 可以使用 JTA 事务管理器和 JNDI 绑定的 JDBC DataSources 和 JMS ConnectionFactory 实例等应用服务器资源，也可以通过 Spring 的标准事务管理和 JNDI 及 JMX 支持的工具向平台的 JMX 服务器注册。应用程序组件还可以通过Spring的 <code>TaskExecutor</code> 抽象与应用程序服务器的 JCA WorkManager 进行交互。</p>
</div>
<div class="paragraph">
<p>查看 <a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a> 类的 javadoc，了解 RAR 部署中涉及的配置细节。</p>
</div>
<div class="paragraph">
<p><em>对于将 Spring ApplicationContext 简单部署为 Java EE RAR 文件：</em> 将所有应用程序类打包到 RAR 文件中, RAR 文件是具有不同文件扩展名的标准 JAR 文件。将所有必需的 JAR 库添加到 RAR 的归档根目录中。 添加一个 “META-INF/ra.xml” 部署描述符（如 <code>SpringContextResourceAdapter</code> javadoc 中所示）和相应的 Spring XML bean 定义文件（通常为“META-INF/applicationContext.xml”），然后将生成的 RAR 文件丢到到您的应用程序服务器的部署目录即可。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种 RAR 部署单位通常是独立的; 它们不会向外界暴露组件，甚至不会暴露给同一应用程序的其他模块。与基于 RAR 的 ApplicationContext 的交互通常通过与其他模块共享的 JMS 目标进行。基于 RAR 的 ApplicationContext 也可以调度一些作业，对文件系统中新增文件（或诸如此类）作出反应。如果需要允许从外部进行同步访问，则可以导出 RMI 端点，这当然也可以被同一机器上的其他应用模块使用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-beanfactory"><a class="anchor" href="#beans-beanfactory"></a>1.16. The BeanFactory</h3>
<div class="paragraph">
<p><code>BeanFactory</code> 为 Spring 的 IoC 功能提供了基础，但是它只能直接用于与其他第三方框架的集成，对Spring 的大多数用户来说，具有悠久的历史。在 Spring 中，<code>BeanFactory</code> 和相关接口（如 <code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>）仍然存在，目的是向后兼容大量与 Spring 集成的第三方框架。 为了与 JDK 1.4 保持兼容或避免依赖 JSR-250，通常第三方组件不能使用更多的现代的新特性，例如 <code>@PostConstruct</code> 或 <code>@PreDestroy</code>。</p>
</div>
<div class="paragraph">
<p>本节提供了 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 之间差异的另一个背景，以及如何通过经典的单例查找直接访问 IoC 容器。</p>
</div>
<div class="sect3">
<h4 id="context-introduction-ctx-vs-beanfactory"><a class="anchor" href="#context-introduction-ctx-vs-beanfactory"></a>1.16.1. BeanFactory 还是 ApplicationContext？</h4>
<div class="paragraph">
<p>尽量使用 <code>ApplicationContext</code>，除非你有充分的理由不这样做。</p>
</div>
<div class="paragraph">
<p>因为 <code>ApplicationContext</code> 包含了 <code>BeanFactory</code> 的所有功能，所以通常推荐使用 <code>BeanFactory</code>，除了一些情况，例如在资源受限的设备上运行的嵌入式应用程序，这些设备的内存消耗可能很重要，少数多余的 KB 可能就会对系统产生影响。 但是，对于大多数典型的企业应用程序和系统，<code>ApplicationContext</code> 才是你想要使用的。 Spring 会大量使用 <a href="#beans-factory-extension-bpp"><code>BeanPostProcessor</code> 扩展点</a>（以影响代理等等）。如果只使用一个普通的 <code>BeanFactory</code> ，那么在您没有采取额外步骤的情况下，相当数量的功能（如事务和AOP）将不会生效。这种情况可能会令人困惑，因为配置没有任何问题。</p>
</div>
<div class="paragraph">
<p>下表列出了 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 接口和实现提供的功能。</p>
</div>
<table id="context-introduction-ctx-vs-beanfactory-feature-matrix" class="tableblock frame-all grid-all spread">
<caption class="title">Table 9. 特性表</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">特性</th>
<th class="tableblock halign-left valign-top"><code>BeanFactory</code></th>
<th class="tableblock halign-left valign-top"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bean instantiation/wiring</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanFactoryPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convenient <code>MessageSource</code> access (for i18n)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEvent</code> publication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要使用 <code>BeanFactory</code> 实现显式注册 bean post-processor，您需要编写如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();
<span class="comment">// populate the factory with bean definitions</span>

<span class="comment">// now register any needed BeanPostProcessor instances</span>
MyBeanPostProcessor postProcessor = <span class="keyword">new</span> MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

<span class="comment">// now start using the factory</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在使用 <code>BeanFactory</code> 实现时显式注册 <code>BeanFactoryPostProcessor</code>，必须编写如下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(<span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// bring in some property values from a Properties file</span>
PropertyPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertyPlaceholderConfigurer();
cfg.setLocation(<span class="keyword">new</span> FileSystemResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc.properties</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// now actually do the replacement</span>
cfg.postProcessBeanFactory(factory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，显式注册步骤都不方便，这就是为什么各种 <code>ApplicationContext</code> 实现比大多数 Spring 支持的应用程序中的纯 <code>BeanFactory</code> 实现更受欢迎的原因之一，特别是在使用 <code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 时。这些机制实现了诸如属性占位符替换和AOP 等重要功能。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resources"><a class="anchor" href="#resources"></a>2. 资源</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="resources-introduction"><a class="anchor" href="#resources-introduction"></a>2.1. 简介</h3>
<div class="paragraph">
<p>对于不同的 URL 前缀，很不幸 Java 的标准 <code>java.net.URL</code> 类和标准处理器并不足够访问低级资源。例如， 没有标准化的 <code>URL</code> 实现可以用来访问类路径或者 <code>ServletContext</code> 相对路径以便获取资源。尽管可以为专门的 URL 前缀注册新的处理器（类似于诸如 <code>http:</code> 之类的前缀的现有处理器），但这通常相当复杂，并且 URL 接口仍然缺少某些期望的功能，例如检查被指向的资源是否存在。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-resource"><a class="anchor" href="#resources-resource"></a>2.2. 资源接口</h3>
<div class="paragraph">
<p>Spring 的 <code>Resource</code> 接口的使命是成为一个用于抽象对低级别资源访问的更加强大的接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Resource</span> <span class="directive">extends</span> InputStreamSource {

        <span class="type">boolean</span> exists();

        <span class="type">boolean</span> isOpen();

        <span class="predefined-type">URL</span> getURL() <span class="directive">throws</span> <span class="exception">IOException</span>;

        <span class="predefined-type">File</span> getFile() <span class="directive">throws</span> <span class="exception">IOException</span>;

        Resource createRelative(<span class="predefined-type">String</span> relativePath) <span class="directive">throws</span> <span class="exception">IOException</span>;

        <span class="predefined-type">String</span> getFilename();

        <span class="predefined-type">String</span> getDescription();

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">InputStreamSource</span> {

        <span class="predefined-type">InputStream</span> getInputStream() <span class="directive">throws</span> <span class="exception">IOException</span>;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Resource</code> 接口中一些最重要的方法是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInputStream()</code>：定位并打开资源，返回一个从资源读取的 <code>InputStream</code> 流。 预计每个调用都会返回一个新的 <code>InputStream</code>。调用方有责任关闭该流。</p>
</li>
<li>
<p><code>exists()</code>：返回一个 <code>boolean</code> 值，表明这个资源是否以物理形式真实存在。</p>
</li>
<li>
<p><code>isOpen()</code>: 返回一个 <code>boolean</code> 值，表示资源是否正在被一个打开的流处理。如果返回值为 <code>true</code>，则 <code>InputStream</code> 不能被多次读取，且只能被读取一次然后关闭以防资源泄露。对于所有常规的资源实现，将返回 <code>false</code>，除了 <code>InputStreamResource</code>。</p>
</li>
<li>
<p><code>getDescription()</code>：返回这个资源的描述符，用于处理资源时的错误输出。这通常是全限定的文件名或资源的实际 URL。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其他方法允许您获取表示资源的实际 <code>URL</code> 或 <code>File</code> 对象（如果底层实现兼容并支持该功能）。</p>
</div>
<div class="paragraph">
<p>当资源被请求时，<code>Resource</code> 抽象以许多方法签名参数的形式在 Spring 本身中被广泛使用。在一些Spring API （比如各种 <code>ApplicationContext</code> 实现的构造函数）的其他方法中，它们接收 <code>String</code> 使用简单或者粗糙的形式创建一个适合于上下文实现的<code>Resource</code>  ，或者通过 <code>String</code> 路径上的特殊前缀，允许调用者指定必须创建和使用特定的 <code>Resource</code> 实现。</p>
</div>
<div class="paragraph">
<p>虽然 <code>Resource</code> 接口被 Spring 和在 Spring 中大量使用，但是在自己的代码中，将作为一个用来访问资源的通用工具类是很有用的，甚至你的代码可以不感知或者不关心 Spring 的其他部分。虽然这会将你的代码与 Spring 耦合起来，但它实际上只是将它与这一小组工具类耦合，这些工具类可以更好地替代 <code>URL</code>，并且可以被认为与你为此目的使用的任何其他库相同。</p>
</div>
<div class="paragraph">
<p>值得注意的是，<code>Resource</code> 抽象并不取代功能：它只是尽可能包装它。例如，<code>UrlResource</code> 包装一个<code>URL</code>，并使用包装的 <code>URL</code> 来完成其工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-implementations"><a class="anchor" href="#resources-implementations"></a>2.3. Built-in Resource implementations</h3>
<div class="paragraph">
<p>There are a number of <code>Resource</code> implementations that come supplied straight out of the
box in Spring:</p>
</div>
<div class="sect3">
<h4 id="resources-implementations-urlresource"><a class="anchor" href="#resources-implementations-urlresource"></a>2.3.1. UrlResource</h4>
<div class="paragraph">
<p>The <code>UrlResource</code> wraps a <code>java.net.URL</code>, and may be used to access any object that is
normally accessible via a URL, such as files, an HTTP target, an FTP target, etc. All
URLs have a standardized <code>String</code> representation, such that appropriate standardized
prefixes are used to indicate one URL type from another. This includes <code>file:</code> for
accessing filesystem paths, <code>http:</code> for accessing resources via the HTTP protocol,
<code>ftp:</code> for accessing resources via FTP, etc.</p>
</div>
<div class="paragraph">
<p>A <code>UrlResource</code> is created by Java code explicitly using the <code>UrlResource</code> constructor,
but will often be created implicitly when you call an API method which takes a <code>String</code>
argument which is meant to represent a path. For the latter case, a JavaBeans
<code>PropertyEditor</code> will ultimately decide which type of <code>Resource</code> to create. If the path
string contains a few well-known (to it, that is) prefixes such as <code>classpath:</code>, it will
create an appropriate specialized <code>Resource</code> for that prefix. However, if it doesn&#8217;t
recognize the prefix, it will assume the this is just a standard URL string, and will
create a <code>UrlResource</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-classpathresource"><a class="anchor" href="#resources-implementations-classpathresource"></a>2.3.2. ClassPathResource</h4>
<div class="paragraph">
<p>This class represents a resource which should be obtained from the classpath. This uses
either the thread context class loader, a given class loader, or a given class for
loading resources.</p>
</div>
<div class="paragraph">
<p>This <code>Resource</code> implementation supports resolution as <code>java.io.File</code> if the class path
resource resides in the file system, but not for classpath resources which reside in a
jar and have not been expanded (by the servlet engine, or whatever the environment is)
to the filesystem. To address this the various <code>Resource</code> implementations always support
resolution as a <code>java.net.URL</code>.</p>
</div>
<div class="paragraph">
<p>A <code>ClassPathResource</code> is created by Java code explicitly using the <code>ClassPathResource</code>
constructor, but will often be created implicitly when you call an API method which
takes a <code>String</code> argument which is meant to represent a path. For the latter case, a
JavaBeans <code>PropertyEditor</code> will recognize the special prefix <code>classpath:</code> on the string
path, and create a <code>ClassPathResource</code> in that case.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-filesystemresource"><a class="anchor" href="#resources-implementations-filesystemresource"></a>2.3.3. FileSystemResource</h4>
<div class="paragraph">
<p>This is a <code>Resource</code> implementation for <code>java.io.File</code> handles. It obviously supports
resolution as a <code>File</code>, and as a <code>URL</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-servletcontextresource"><a class="anchor" href="#resources-implementations-servletcontextresource"></a>2.3.4. ServletContextResource</h4>
<div class="paragraph">
<p>This is a <code>Resource</code> implementation for <code>ServletContext</code> resources, interpreting
relative paths within the relevant web application&#8217;s root directory.</p>
</div>
<div class="paragraph">
<p>This always supports stream access and URL access, but only allows <code>java.io.File</code> access
when the web application archive is expanded and the resource is physically on the
filesystem. Whether or not it&#8217;s expanded and on the filesystem like this, or accessed
directly from the JAR or somewhere else like a DB (it&#8217;s conceivable) is actually
dependent on the Servlet container.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-inputstreamresource"><a class="anchor" href="#resources-implementations-inputstreamresource"></a>2.3.5. InputStreamResource</h4>
<div class="paragraph">
<p>A <code>Resource</code> implementation for a given <code>InputStream</code>. This should only be used if no
specific <code>Resource</code> implementation is applicable. In particular, prefer
<code>ByteArrayResource</code> or any of the file-based <code>Resource</code> implementations where possible.</p>
</div>
<div class="paragraph">
<p>In contrast to other <code>Resource</code> implementations, this is a descriptor for an <em>already</em>
opened resource - therefore returning <code>true</code> from <code>isOpen()</code>. Do not use it if you need
to keep the resource descriptor somewhere, or if you need to read a stream multiple
times.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-bytearrayresource"><a class="anchor" href="#resources-implementations-bytearrayresource"></a>2.3.6. ByteArrayResource</h4>
<div class="paragraph">
<p>This is a <code>Resource</code> implementation for a given byte array. It creates a
<code>ByteArrayInputStream</code> for the given byte array.</p>
</div>
<div class="paragraph">
<p>It&#8217;s useful for loading content from any given byte array, without having to resort to a
single-use <code>InputStreamResource</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-resourceloader"><a class="anchor" href="#resources-resourceloader"></a>2.4. The ResourceLoader</h3>
<div class="paragraph">
<p>The <code>ResourceLoader</code> interface is meant to be implemented by objects that can return
(i.e. load) <code>Resource</code> instances.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ResourceLoader</span> {

        Resource getResource(<span class="predefined-type">String</span> location);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All application contexts implement the <code>ResourceLoader</code> interface, and therefore all
application contexts may be used to obtain <code>Resource</code> instances.</p>
</div>
<div class="paragraph">
<p>When you call <code>getResource()</code> on a specific application context, and the location path
specified doesn&#8217;t have a specific prefix, you will get back a <code>Resource</code> type that is
appropriate to that particular application context. For example, assume the following
snippet of code was executed against a <code>ClassPathXmlApplicationContext</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>What would be returned would be a <code>ClassPathResource</code>; if the same method was executed
against a <code>FileSystemXmlApplicationContext</code> instance, you&#8217;d get back a
<code>FileSystemResource</code>. For a <code>WebApplicationContext</code>, you&#8217;d get back a
<code>ServletContextResource</code>, and so on.</p>
</div>
<div class="paragraph">
<p>As such, you can load resources in a fashion appropriate to the particular application
context.</p>
</div>
<div class="paragraph">
<p>On the other hand, you may also force <code>ClassPathResource</code> to be used, regardless of the
application context type, by specifying the special <code>classpath:</code> prefix:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, one can force a <code>UrlResource</code> to be used by specifying any of the standard
<code>java.net.URL</code> prefixes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Resource template = ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://myhost.com/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table summarizes the strategy for converting <code>String</code>s to <code>Resource</code>s:</p>
</div>
<table id="resources-resource-strings" class="tableblock frame-all grid-all spread">
<caption class="title">Table 10. Resource strings</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Prefix</th>
<th class="tableblock halign-left valign-top">Example</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classpath:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classpath:com/myapp/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loaded from the classpath.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">file:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="file:///data/config.xml" class="bare">file:///data/config.xml</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loaded as a <code>URL</code>, from the filesystem. <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">http:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://myserver/logo.png" class="bare">http://myserver/logo.png</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loaded as a <code>URL</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(none)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/data/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depends on the underlying <code>ApplicationContext</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="resources-resourceloaderaware"><a class="anchor" href="#resources-resourceloaderaware"></a>2.5. The ResourceLoaderAware interface</h3>
<div class="paragraph">
<p>The <code>ResourceLoaderAware</code> interface is a special marker interface, identifying objects
that expect to be provided with a <code>ResourceLoader</code> reference.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ResourceLoaderAware</span> {

        <span class="type">void</span> setResourceLoader(ResourceLoader resourceLoader);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a class implements <code>ResourceLoaderAware</code> and is deployed into an application
context (as a Spring-managed bean), it is recognized as <code>ResourceLoaderAware</code> by the
application context. The application context will then invoke the
<code>setResourceLoader(ResourceLoader)</code>, supplying itself as the argument (remember, all
application contexts in Spring implement the <code>ResourceLoader</code> interface).</p>
</div>
<div class="paragraph">
<p>Of course, since an <code>ApplicationContext</code> is a <code>ResourceLoader</code>, the bean could also
implement the <code>ApplicationContextAware</code> interface and use the supplied application
context directly to load resources, but in general, it&#8217;s better to use the specialized
<code>ResourceLoader</code> interface if that&#8217;s all that&#8217;s needed. The code would just be coupled
to the resource loading interface, which can be considered a utility interface, and not
the whole Spring <code>ApplicationContext</code> interface.</p>
</div>
<div class="paragraph">
<p>As of Spring 2.5, you can rely upon autowiring of the <code>ResourceLoader</code> as an alternative
to implementing the <code>ResourceLoaderAware</code> interface. The "traditional" <code>constructor</code> and
<code>byType</code> autowiring modes (as described in <a href="#beans-factory-autowire">Autowiring collaborators</a>) are now capable
of providing a dependency of type <code>ResourceLoader</code> for either a constructor argument or
setter method parameter respectively. For more flexibility (including the ability to
autowire fields and multiple parameter methods), consider using the new annotation-based
autowiring features. In that case, the <code>ResourceLoader</code> will be autowired into a field,
constructor argument, or method parameter that is expecting the <code>ResourceLoader</code> type as
long as the field, constructor, or method in question carries the <code>@Autowired</code>
annotation. For more information, see <a href="#beans-autowired-annotation">@Autowired</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-as-dependencies"><a class="anchor" href="#resources-as-dependencies"></a>2.6. Resources as dependencies</h3>
<div class="paragraph">
<p>If the bean itself is going to determine and supply the resource path through some sort
of dynamic process, it probably makes sense for the bean to use the <code>ResourceLoader</code>
interface to load resources. Consider as an example the loading of a template of some
sort, where the specific resource that is needed depends on the role of the user. If the
resources are static, it makes sense to eliminate the use of the <code>ResourceLoader</code>
interface completely, and just have the bean expose the <code>Resource</code> properties it needs,
and expect that they will be injected into it.</p>
</div>
<div class="paragraph">
<p>What makes it trivial to then inject these properties, is that all application contexts
register and use a special JavaBeans <code>PropertyEditor</code> which can convert <code>String</code> paths
to <code>Resource</code> objects. So if <code>myBean</code> has a template property of type <code>Resource</code>, it can
be configured with a simple string for that resource, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">template</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the resource path has no prefix, so because the application context itself is
going to be used as the <code>ResourceLoader</code>, the resource itself will be loaded via a
<code>ClassPathResource</code>, <code>FileSystemResource</code>, or <code>ServletContextResource</code> (as appropriate)
depending on the exact type of the context.</p>
</div>
<div class="paragraph">
<p>If there is a need to force a specific <code>Resource</code> type to be used, then a prefix may be
used. The following two examples show how to force a <code>ClassPathResource</code> and a
<code>UrlResource</code> (the latter being used to access a filesystem file).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">template</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">template</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-app-ctx"><a class="anchor" href="#resources-app-ctx"></a>2.7. Application contexts and Resource paths</h3>
<div class="sect3">
<h4 id="resources-app-ctx-construction"><a class="anchor" href="#resources-app-ctx-construction"></a>2.7.1. Constructing application contexts</h4>
<div class="paragraph">
<p>An application context constructor (for a specific application context type) generally
takes a string or array of strings as the location path(s) of the resource(s) such as
XML files that make up the definition of the context.</p>
</div>
<div class="paragraph">
<p>When such a location path doesn&#8217;t have a prefix, the specific <code>Resource</code> type built from
that path and used to load the bean definitions, depends on and is appropriate to the
specific application context. For example, if you create a
<code>ClassPathXmlApplicationContext</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean definitions will be loaded from the classpath, as a <code>ClassPathResource</code> will be
used. But if you create a <code>FileSystemXmlApplicationContext</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean definition will be loaded from a filesystem location, in this case relative to
the current working directory.</p>
</div>
<div class="paragraph">
<p>Note that the use of the special classpath prefix or a standard URL prefix on the
location path will override the default type of <code>Resource</code> created to load the
definition. So this <code>FileSystemXmlApplicationContext</code>&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>will actually load its bean definitions from the classpath. However, it is still a
<code>FileSystemXmlApplicationContext</code>. If it is subsequently used as a <code>ResourceLoader</code>, any
unprefixed paths will still be treated as filesystem paths.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-classpathxml"><a class="anchor" href="#resources-app-ctx-classpathxml"></a>Constructing ClassPathXmlApplicationContext instances - shortcuts</h5>
<div class="paragraph">
<p>The <code>ClassPathXmlApplicationContext</code> exposes a number of constructors to enable
convenient instantiation. The basic idea is that one supplies merely a string array
containing just the filenames of the XML files themselves (without the leading path
information), and one <em>also</em> supplies a <code>Class</code>; the <code>ClassPathXmlApplicationContext</code>
will derive the path information from the supplied class.</p>
</div>
<div class="paragraph">
<p>An example will hopefully make this clear. Consider a directory layout that looks like
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/
  foo/
	services.xml
	daos.xml
    MessengerService.class</pre>
</div>
</div>
<div class="paragraph">
<p>A <code>ClassPathXmlApplicationContext</code> instance composed of the beans defined in the
<code>'services.xml'</code> and <code>'daos.xml'</code> could be instantiated like so&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(
        <span class="keyword">new</span> <span class="predefined-type">String</span><span class="type">[]</span> {<span class="string"><span class="delimiter">&quot;</span><span class="content">services.xml</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">daos.xml</span><span class="delimiter">&quot;</span></span>}, MessengerService.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please do consult the <code>ClassPathXmlApplicationContext</code> javadocs for details
on the various constructors.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-wildcards-in-resource-paths"><a class="anchor" href="#resources-app-ctx-wildcards-in-resource-paths"></a>2.7.2. Wildcards in application context constructor resource paths</h4>
<div class="paragraph">
<p>The resource paths in application context constructor values may be a simple path (as
shown above) which has a one-to-one mapping to a target Resource, or alternately may
contain the special "classpath*:" prefix and/or internal Ant-style regular expressions
(matched using Spring&#8217;s <code>PathMatcher</code> utility). Both of the latter are effectively
wildcards</p>
</div>
<div class="paragraph">
<p>One use for this mechanism is when doing component-style application assembly. All
components can 'publish' context definition fragments to a well-known location path, and
when the final application context is created using the same path prefixed via
<code>classpath*:</code>, all component fragments will be picked up automatically.</p>
</div>
<div class="paragraph">
<p>Note that this wildcarding is specific to use of resource paths in application context
constructors (or when using the <code>PathMatcher</code> utility class hierarchy directly), and is
resolved at construction time. It has nothing to do with the <code>Resource</code> type itself.
It&#8217;s not possible to use the <code>classpath*:</code> prefix to construct an actual <code>Resource</code>, as
a resource points to just one resource at a time.</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-ant-patterns-in-paths"><a class="anchor" href="#resources-app-ctx-ant-patterns-in-paths"></a>Ant-style Patterns</h5>
<div class="paragraph">
<p>When the path location contains an Ant-style pattern, for example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/WEB-INF/*-context.xml
  com/mycompany/**/applicationContext.xml
  file:C:/some/path/*-context.xml
  classpath:com/mycompany/**/applicationContext.xml</pre>
</div>
</div>
<div class="paragraph">
<p>The resolver follows a more complex but defined procedure to try to resolve the
wildcard. It produces a Resource for the path up to the last non-wildcard segment and
obtains a URL from it. If this URL is not a <code>jar:</code> URL or container-specific variant
(e.g. <code>zip:</code> in WebLogic, <code>wsjar</code> in WebSphere, etc.), then a <code>java.io.File</code> is
obtained from it and used to resolve the wildcard by traversing the filesystem. In the
case of a jar URL, the resolver either gets a <code>java.net.JarURLConnection</code> from it or
manually parses the jar URL and then traverses the contents of the jar file to resolve
the wildcards.</p>
</div>
<div class="sect5">
<h6 id="resources-app-ctx-portability"><a class="anchor" href="#resources-app-ctx-portability"></a>Implications on portability</h6>
<div class="paragraph">
<p>If the specified path is already a file URL (either explicitly, or implicitly because
the base <code>ResourceLoader</code> is a filesystem one, then wildcarding is guaranteed to work in
a completely portable fashion.</p>
</div>
<div class="paragraph">
<p>If the specified path is a classpath location, then the resolver must obtain the last
non-wildcard path segment URL via a <code>Classloader.getResource()</code> call. Since this is just
a node of the path (not the file at the end) it is actually undefined (in the
<code>ClassLoader</code> javadocs) exactly what sort of a URL is returned in this case. In
practice, it is always a <code>java.io.File</code> representing the directory, where the classpath
resource resolves to a filesystem location, or a jar URL of some sort, where the
classpath resource resolves to a jar location. Still, there is a portability concern on
this operation.</p>
</div>
<div class="paragraph">
<p>If a jar URL is obtained for the last non-wildcard segment, the resolver must be able to
get a <code>java.net.JarURLConnection</code> from it, or manually parse the jar URL, to be able to
walk the contents of the jar, and resolve the wildcard. This will work in most
environments, but will fail in others, and it is strongly recommended that the wildcard
resolution of resources coming from jars be thoroughly tested in your specific
environment before you rely on it.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="resources-classpath-wildcards"><a class="anchor" href="#resources-classpath-wildcards"></a>The Classpath*: portability classpath*: prefix</h5>
<div class="paragraph">
<p>When constructing an XML-based application context, a location string may use the
special <code>classpath*:</code> prefix:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath*:conf/appContext.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This special prefix specifies that all classpath resources that match the given name
must be obtained (internally, this essentially happens via a
<code>ClassLoader.getResources(&#8230;&#8203;)</code> call), and then merged to form the final application
context definition.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The wildcard classpath relies on the <code>getResources()</code> method of the underlying
classloader. As most application servers nowadays supply their own classloader
implementation, the behavior might differ especially when dealing with jar files. A
simple test to check if <code>classpath*</code> works is to use the classloader to load a file from
within a jar on the classpath:
<code>getClass().getClassLoader().getResources("&lt;someFileInsideTheJar&gt;")</code>. Try this test with
files that have the same name but are placed inside two different locations. In case an
inappropriate result is returned, check the application server documentation for
settings that might affect the classloader behavior.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>classpath*:</code> prefix can also be combined with a <code>PathMatcher</code> pattern in the
rest of the location path, for example <code>classpath*:META-INF/*-beans.xml</code>. In this
case, the resolution strategy is fairly simple: a <code>ClassLoader.getResources()</code> call is
used on the last non-wildcard path segment to get all the matching resources in the
class loader hierarchy, and then off each resource the same PathMatcher resolution
strategy described above is used for the wildcard subpath.</p>
</div>
</div>
<div class="sect4">
<h5 id="resources-wildcards-in-path-other-stuff"><a class="anchor" href="#resources-wildcards-in-path-other-stuff"></a>Other notes relating to wildcards</h5>
<div class="paragraph">
<p>Please note that <code>classpath*:</code> when combined with Ant-style patterns will only work
reliably with at least one root directory before the pattern starts, unless the actual
target files reside in the file system. This means that a pattern like
<code>classpath*:*.xml</code> will not retrieve files from the root of jar files but rather only
from the root of expanded directories. This originates from a limitation in the JDK&#8217;s
<code>ClassLoader.getResources()</code> method which only returns file system locations for a
passed-in empty string (indicating potential roots to search).</p>
</div>
<div class="paragraph">
<p>Ant-style patterns with <code>classpath:</code> resources are not guaranteed to find matching
resources if the root package to search is available in multiple class path locations.
This is because a resource such as</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/mycompany/package1/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>may be in only one location, but when a path such as</p>
</div>
<div class="literalblock">
<div class="content">
<pre>classpath:com/mycompany/**/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>is used to try to resolve it, the resolver will work off the (first) URL returned by
<code>getResource("com/mycompany")</code>;. If this base package node exists in multiple
classloader locations, the actual end resource may not be underneath. Therefore,
preferably, use " `classpath*:`" with the same Ant-style pattern in such a case, which
will search all class path locations that contain the root package.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-filesystemresource-caveats"><a class="anchor" href="#resources-filesystemresource-caveats"></a>2.7.3. FileSystemResource caveats</h4>
<div class="paragraph">
<p>A <code>FileSystemResource</code> that is not attached to a <code>FileSystemApplicationContext</code> (that
is, a <code>FileSystemApplicationContext</code> is not the actual <code>ResourceLoader</code>) will treat
absolute vs. relative paths as you would expect. Relative paths are relative to the
current working directory, while absolute paths are relative to the root of the
filesystem.</p>
</div>
<div class="paragraph">
<p>For backwards compatibility (historical) reasons however, this changes when the
<code>FileSystemApplicationContext</code> is the <code>ResourceLoader</code>. The
<code>FileSystemApplicationContext</code> simply forces all attached <code>FileSystemResource</code> instances
to treat all location paths as relative, whether they start with a leading slash or not.
In practice, this means the following are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">conf/context.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">/conf/context.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As are the following: (Even though it would make sense for them to be different, as one
case is relative and the other absolute.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">/some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In practice, if true absolute filesystem paths are needed, it is better to forgo the use
of absolute paths with <code>FileSystemResource</code> / <code>FileSystemXmlApplicationContext</code>, and
just force the use of a <code>UrlResource</code>, by using the <code>file:</code> URL prefix.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// actual context type doesn't matter, the Resource will always be UrlResource</span>
ctx.getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///some/resource/path/myTemplate.txt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource</span>
ApplicationContext ctx =
        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">file:///conf/context.xml</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="validation"><a class="anchor" href="#validation"></a>3. Validation, Data Binding, and Type Conversion</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="validation-introduction"><a class="anchor" href="#validation-introduction"></a>3.1. Introduction</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">JSR-303/JSR-349 Bean Validation</div>
<div class="paragraph">
<p>Spring Framework 4.0 supports Bean Validation 1.0 (JSR-303) and Bean Validation 1.1
(JSR-349) in terms of setup support, also adapting it to Spring&#8217;s <code>Validator</code> interface.</p>
</div>
<div class="paragraph">
<p>An application can choose to enable Bean Validation once globally, as described in
<a href="#validation-beanvalidation">Spring Validation</a>, and use it exclusively for all validation needs.</p>
</div>
<div class="paragraph">
<p>An application can also register additional Spring <code>Validator</code> instances per
<code>DataBinder</code> instance, as described in <a href="#validation-binder">Configuring a DataBinder</a>. This may be useful for
plugging in validation logic without the use of annotations.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There are pros and cons for considering validation as business logic, and Spring offers
a design for validation (and data binding) that does not exclude either one of them.
Specifically validation should not be tied to the web tier, should be easy to localize
and it should be possible to plug in any validator available. Considering the above,
Spring has come up with a <code>Validator</code> interface that is both basic and eminently usable
in every layer of an application.</p>
</div>
<div class="paragraph">
<p>Data binding is useful for allowing user input to be dynamically bound to the domain
model of an application (or whatever objects you use to process user input). Spring
provides the so-called <code>DataBinder</code> to do exactly that. The <code>Validator</code> and the
<code>DataBinder</code> make up the <code>validation</code> package, which is primarily used in but not
limited to the MVC framework.</p>
</div>
<div class="paragraph">
<p>The <code>BeanWrapper</code> is a fundamental concept in the Spring Framework and is used in a lot
of places. However, you probably will not have the need to use the <code>BeanWrapper</code>
directly. Because this is reference documentation however, we felt that some explanation
might be in order. We will explain the <code>BeanWrapper</code> in this chapter since, if you were
going to use it at all, you would most likely do so when trying to bind data to objects.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s DataBinder and the lower-level BeanWrapper both use PropertyEditors to parse
and format property values. The <code>PropertyEditor</code> concept is part of the JavaBeans
specification, and is also explained in this chapter. Spring 3 introduces a
"core.convert" package that provides a general type conversion facility, as well as a
higher-level "format" package for formatting UI field values. These new packages may be
used as simpler alternatives to PropertyEditors, and will also be discussed in this
chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="validator"><a class="anchor" href="#validator"></a>3.2. Validation using Spring&#8217;s Validator interface</h3>
<div class="paragraph">
<p>Spring features a <code>Validator</code> interface that you can use to validate objects. The
<code>Validator</code> interface works using an <code>Errors</code> object so that while validating,
validators can report validation failures to the <code>Errors</code> object.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider a small data object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> <span class="type">int</span> age;

        <span class="comment">// the usual getters and setters...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re going to provide validation behavior for the <code>Person</code> class by implementing the
following two methods of the <code>org.springframework.validation.Validator</code> interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supports(Class)</code> - Can this <code>Validator</code> validate instances of the supplied <code>Class</code>?</p>
</li>
<li>
<p><code>validate(Object, org.springframework.validation.Errors)</code> - validates the given object
and in case of validation errors, registers those with the given <code>Errors</code> object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Implementing a <code>Validator</code> is fairly straightforward, especially when you know of the
<code>ValidationUtils</code> helper class that the Spring Framework also provides.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonValidator</span> <span class="directive">implements</span> <span class="predefined-type">Validator</span> {

        <span class="comment">/**
         * This Validator validates *just* Person instances
         */</span>
        <span class="directive">public</span> <span class="type">boolean</span> supports(<span class="predefined-type">Class</span> clazz) {
                <span class="keyword">return</span> Person.class.equals(clazz);
        }

        <span class="directive">public</span> <span class="type">void</span> validate(<span class="predefined-type">Object</span> obj, Errors e) {
                ValidationUtils.rejectIfEmpty(e, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name.empty</span><span class="delimiter">&quot;</span></span>);
                Person p = (Person) obj;
                <span class="keyword">if</span> (p.getAge() &lt; <span class="integer">0</span>) {
                        e.rejectValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">negativevalue</span><span class="delimiter">&quot;</span></span>);
                } <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="integer">110</span>) {
                        e.rejectValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">too.darn.old</span><span class="delimiter">&quot;</span></span>);
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>static</code> <code>rejectIfEmpty(..)</code> method on the <code>ValidationUtils</code> class
is used to reject the <code>'name'</code> property if it is <code>null</code> or the empty string. Have a look
at the <code>ValidationUtils</code> javadocs to see what functionality it provides besides the
example shown previously.</p>
</div>
<div class="paragraph">
<p>While it is certainly possible to implement a single <code>Validator</code> class to validate each
of the nested objects in a rich object, it may be better to encapsulate the validation
logic for each nested class of object in its own <code>Validator</code> implementation. A simple
example of a <em>'rich'</em> object would be a <code>Customer</code> that is composed of two <code>String</code>
properties (a first and second name) and a complex <code>Address</code> object. <code>Address</code> objects
may be used independently of <code>Customer</code> objects, and so a distinct <code>AddressValidator</code>
has been implemented. If you want your <code>CustomerValidator</code> to reuse the logic contained
within the <code>AddressValidator</code> class without resorting to copy-and-paste, you can
dependency-inject or instantiate an <code>AddressValidator</code> within your <code>CustomerValidator</code>,
and use it like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CustomerValidator</span> <span class="directive">implements</span> <span class="predefined-type">Validator</span> {

        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Validator</span> addressValidator;

        <span class="directive">public</span> CustomerValidator(<span class="predefined-type">Validator</span> addressValidator) {
                <span class="keyword">if</span> (addressValidator == <span class="predefined-constant">null</span>) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">The supplied [Validator] is </span><span class="delimiter">&quot;</span></span> +
                                <span class="string"><span class="delimiter">&quot;</span><span class="content">required and must not be null.</span><span class="delimiter">&quot;</span></span>);
                }
                <span class="keyword">if</span> (!addressValidator.supports(Address.class)) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">The supplied [Validator] must </span><span class="delimiter">&quot;</span></span> +
                                <span class="string"><span class="delimiter">&quot;</span><span class="content">support the validation of [Address] instances.</span><span class="delimiter">&quot;</span></span>);
                }
                <span class="local-variable">this</span>.addressValidator = addressValidator;
        }

        <span class="comment">/**
         * This Validator validates Customer instances, and any subclasses of Customer too
         */</span>
        <span class="directive">public</span> <span class="type">boolean</span> supports(<span class="predefined-type">Class</span> clazz) {
                <span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);
        }

        <span class="directive">public</span> <span class="type">void</span> validate(<span class="predefined-type">Object</span> target, Errors errors) {
                ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string"><span class="delimiter">&quot;</span><span class="content">firstName</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">field.required</span><span class="delimiter">&quot;</span></span>);
                ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string"><span class="delimiter">&quot;</span><span class="content">surname</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">field.required</span><span class="delimiter">&quot;</span></span>);
                Customer customer = (Customer) target;
                <span class="keyword">try</span> {
                        errors.pushNestedPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">address</span><span class="delimiter">&quot;</span></span>);
                        ValidationUtils.invokeValidator(<span class="local-variable">this</span>.addressValidator, customer.getAddress(), errors);
                } <span class="keyword">finally</span> {
                        errors.popNestedPath();
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Validation errors are reported to the <code>Errors</code> object passed to the validator. In case
of Spring Web MVC you can use <code>&lt;spring:bind/&gt;</code> tag to inspect the error messages, but of
course you can also inspect the errors object yourself. More information about the
methods it offers can be found in the javadocs.</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-conversion"><a class="anchor" href="#validation-conversion"></a>3.3. Resolving codes to error messages</h3>
<div class="paragraph">
<p>We&#8217;ve talked about databinding and validation. Outputting messages corresponding to
validation errors is the last thing we need to discuss. In the example we&#8217;ve shown
above, we rejected the <code>name</code> and the <code>age</code> field. If we&#8217;re going to output the error
messages by using a <code>MessageSource</code>, we will do so using the error code we&#8217;ve given when
rejecting the field ('name' and 'age' in this case). When you call (either directly, or
indirectly, using for example the <code>ValidationUtils</code> class) <code>rejectValue</code> or one of the
other <code>reject</code> methods from the <code>Errors</code> interface, the underlying implementation will
not only register the code you&#8217;ve passed in, but also a number of additional error
codes. What error codes it registers is determined by the <code>MessageCodesResolver</code> that is
used. By default, the <code>DefaultMessageCodesResolver</code> is used, which for example not only
registers a message with the code you gave, but also messages that include the field
name you passed to the reject method. So in case you reject a field using
<code>rejectValue("age", "too.darn.old")</code>, apart from the <code>too.darn.old</code> code, Spring will
also register <code>too.darn.old.age</code> and <code>too.darn.old.age.int</code> (so the first will include
the field name and the second will include the type of the field); this is done as a
convenience to aid developers in targeting error messages and suchlike.</p>
</div>
<div class="paragraph">
<p>More information on the <code>MessageCodesResolver</code> and the default strategy can be found
online in the javadocs of
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/validation/MessageCodesResolver.html"><code>MessageCodesResolver</code></a>
and
<a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html"><code>DefaultMessageCodesResolver</code></a>,
respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-beans"><a class="anchor" href="#beans-beans"></a>3.4. Bean manipulation and the BeanWrapper</h3>
<div class="paragraph">
<p>The <code>org.springframework.beans</code> package adheres to the JavaBeans standard provided by
Oracle. A JavaBean is simply a class with a default no-argument constructor, which follows
a naming convention where (by way of an example) a property named <code>bingoMadness</code> would
have a setter method <code>setBingoMadness(..)</code> and a getter method <code>getBingoMadness()</code>. For
more information about JavaBeans and the specification, please refer to Oracle&#8217;s website (
<a href="http://docs.oracle.com/javase/6/docs/api/java/beans/package-summary.html">javabeans</a>).</p>
</div>
<div class="paragraph">
<p>One quite important class in the beans package is the <code>BeanWrapper</code> interface and its
corresponding implementation ( <code>BeanWrapperImpl</code>). As quoted from the javadocs, the
<code>BeanWrapper</code> offers functionality to set and get property values (individually or in
bulk), get property descriptors, and to query properties to determine if they are
readable or writable. Also, the <code>BeanWrapper</code> offers support for nested properties,
enabling the setting of properties on sub-properties to an unlimited depth. Then, the
<code>BeanWrapper</code> supports the ability to add standard JavaBeans <code>PropertyChangeListeners</code>
and <code>VetoableChangeListeners</code>, without the need for supporting code in the target class.
Last but not least, the <code>BeanWrapper</code> provides support for the setting of indexed
properties. The <code>BeanWrapper</code> usually isn&#8217;t used by application code directly, but by
the <code>DataBinder</code> and the <code>BeanFactory</code>.</p>
</div>
<div class="paragraph">
<p>The way the <code>BeanWrapper</code> works is partly indicated by its name: <em>it wraps a bean</em> to
perform actions on that bean, like setting and retrieving properties.</p>
</div>
<div class="sect3">
<h4 id="beans-beans-conventions"><a class="anchor" href="#beans-beans-conventions"></a>3.4.1. Setting and getting basic and nested properties</h4>
<div class="paragraph">
<p>Setting and getting properties is done using the <code>setPropertyValue(s)</code> and
<code>getPropertyValue(s)</code> methods that both come with a couple of overloaded variants.
They&#8217;re all described in more detail in the javadocs Spring comes with. What&#8217;s important
to know is that there are a couple of conventions for indicating properties of an
object. A couple of examples:</p>
</div>
<table id="beans-beans-conventions-properties-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 11. Examples of properties</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the property <code>name</code> corresponding to the methods <code>getName()</code> or <code>isName()</code>
and <code>setName(..)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the nested property <code>name</code> of the property <code>account</code> corresponding e.g. to
the methods <code>getAccount().setName()</code> or <code>getAccount().getName()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[2]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the <em>third</em> element of the indexed property <code>account</code>. Indexed properties
can be of type <code>array</code>, <code>list</code> or other <em>naturally ordered</em> collection</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[COMPANYNAME]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the value of the map entry indexed by the key <em>COMPANYNAME</em> of the Map
property <code>account</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Below you&#8217;ll find some examples of working with the <code>BeanWrapper</code> to get and set
properties.</p>
</div>
<div class="paragraph">
<p><em>(This next section is not vitally important to you if you&#8217;re not planning to work with
the <code>BeanWrapper</code> directly. If you&#8217;re just using the <code>DataBinder</code> and the <code>BeanFactory</code>
and their out-of-the-box implementation, you should skip ahead to the section about
<code>PropertyEditors</code>.)</em></p>
</div>
<div class="paragraph">
<p>Consider the following two classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Company</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> Employee managingDirector;

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> Employee getManagingDirector() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.managingDirector;
        }

        <span class="directive">public</span> <span class="type">void</span> setManagingDirector(Employee managingDirector) {
                <span class="local-variable">this</span>.managingDirector = managingDirector;
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Employee</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="directive">private</span> <span class="type">float</span> salary;

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> <span class="type">float</span> getSalary() {
                <span class="keyword">return</span> salary;
        }

        <span class="directive">public</span> <span class="type">void</span> setSalary(<span class="type">float</span> salary) {
                <span class="local-variable">this</span>.salary = salary;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code snippets show some examples of how to retrieve and manipulate some of
the properties of instantiated <code>Companies</code> and <code>Employees</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">BeanWrapper company = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Company());
<span class="comment">// setting the company name..</span>
company.setPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Some Company Inc.</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// ... can also be done like this:</span>
PropertyValue value = <span class="keyword">new</span> PropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Some Company Inc.</span><span class="delimiter">&quot;</span></span>);
company.setPropertyValue(value);

<span class="comment">// ok, let's create the director and tie it to the company:</span>
BeanWrapper jim = <span class="keyword">new</span> BeanWrapperImpl(<span class="keyword">new</span> Employee());
jim.setPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jim Stravinsky</span><span class="delimiter">&quot;</span></span>);
company.setPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">managingDirector</span><span class="delimiter">&quot;</span></span>, jim.getWrappedInstance());

<span class="comment">// retrieving the salary of the managingDirector through the company</span>
<span class="predefined-type">Float</span> salary = (<span class="predefined-type">Float</span>) company.getPropertyValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">managingDirector.salary</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-beans-conversion"><a class="anchor" href="#beans-beans-conversion"></a>3.4.2. Built-in PropertyEditor implementations</h4>
<div class="paragraph">
<p>Spring uses the concept of <code>PropertyEditors</code> to effect the conversion between an
<code>Object</code> and a <code>String</code>. If you think about it, it sometimes might be handy to be able
to represent properties in a different way than the object itself. For example, a <code>Date</code>
can be represented in a human readable way (as the <code>String</code> <code>'2007-14-09'</code>), while
we&#8217;re still able to convert the human readable form back to the original date (or even
better: convert any date entered in a human readable form, back to <code>Date</code> objects). This
behavior can be achieved by <em>registering custom editors</em>, of type
<code>java.beans.PropertyEditor</code>. Registering custom editors on a <code>BeanWrapper</code> or
alternately in a specific IoC container as mentioned in the previous chapter, gives it
the knowledge of how to convert properties to the desired type. Read more about
<code>PropertyEditors</code> in the javadocs of the <code>java.beans</code> package provided by Oracle.</p>
</div>
<div class="paragraph">
<p>A couple of examples where property editing is used in Spring:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>setting properties on beans</em> is done using <code>PropertyEditors</code>. When mentioning
<code>java.lang.String</code> as the value of a property of some bean you&#8217;re declaring in XML
file, Spring will (if the setter of the corresponding property has a
<code>Class</code>-parameter) use the <code>ClassEditor</code> to try to resolve the parameter to a <code>Class</code>
object.</p>
</li>
<li>
<p><em>parsing HTTP request parameters</em> in Spring&#8217;s MVC framework is done using all kinds
of <code>PropertyEditors</code> that you can manually bind in all subclasses of the
<code>CommandController</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring has a number of built-in <code>PropertyEditors</code> to make life easy. Each of those is
listed below and they are all located in the <code>org.springframework.beans.propertyeditors</code>
package. Most, but not all (as indicated below), are registered by default by
<code>BeanWrapperImpl</code>. Where the property editor is configurable in some fashion, you can of
course still register your own variant to override the default one:</p>
</div>
<table id="beans-beans-property-editors-tbl" class="tableblock frame-all grid-all spread">
<caption class="title">Table 12. Built-in PropertyEditors</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Class</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayPropertyEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Editor for byte arrays. Strings will simply be converted to their corresponding byte
representations. Registered by default by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClassEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parses Strings representing classes to actual classes and the other way around. When a
class is not found, an <code>IllegalArgumentException</code> is thrown. Registered by default by
<code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomBooleanEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for <code>Boolean</code> properties. Registered by default by
<code>BeanWrapperImpl</code>, but, can be overridden by registering custom instance of it as
custom editor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomCollectionEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property editor for Collections, converting any source <code>Collection</code> to a given target
<code>Collection</code> type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomDateEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for java.util.Date, supporting a custom DateFormat. NOT
registered by default. Must be user registered as needed with appropriate format.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomNumberEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for any Number subclass like <code>Integer</code>, <code>Long</code>, <code>Float</code>,
<code>Double</code>. Registered by default by <code>BeanWrapperImpl</code>, but can be overridden by
registering custom instance of it as a custom editor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FileEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capable of resolving Strings to <code>java.io.File</code> objects. Registered by default by
<code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InputStreamEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One-way property editor, capable of taking a text string and producing (via an
intermediate <code>ResourceEditor</code> and <code>Resource</code>) an <code>InputStream</code>, so <code>InputStream</code>
properties may be directly set as Strings. Note that the default usage will not close
the <code>InputStream</code> for you! Registered by default by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capable of resolving Strings to <code>Locale</code> objects and vice versa (the String format is
<em class="language">[country]</em>[variant], which is the same thing the toString() method of
Locale provides). Registered by default by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capable of resolving Strings to <code>java.util.regex.Pattern</code> objects and vice versa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PropertiesEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capable of converting Strings (formatted using the format as defined in the javadocs
of the <code>java.util.Properties</code> class) to <code>Properties</code> objects. Registered by default
by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringTrimmerEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property editor that trims Strings. Optionally allows transforming an empty string
into a <code>null</code> value. NOT registered by default; must be user registered as needed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>URLEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capable of resolving a String representation of a URL to an actual <code>URL</code> object.
Registered by default by <code>BeanWrapperImpl</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring uses the <code>java.beans.PropertyEditorManager</code> to set the search path for property
editors that might be needed. The search path also includes <code>sun.bean.editors</code>, which
includes <code>PropertyEditor</code> implementations for types such as <code>Font</code>, <code>Color</code>, and most of
the primitive types. Note also that the standard JavaBeans infrastructure will
automatically discover <code>PropertyEditor</code> classes (without you having to register them
explicitly) if they are in the same package as the class they handle, and have the same
name as that class, with <code>'Editor'</code> appended; for example, one could have the following
class and package structure, which would be sufficient for the <code>FooEditor</code> class to be
recognized and used as the <code>PropertyEditor</code> for <code>Foo</code>-typed properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Foo
      FooEditor // the PropertyEditor for the Foo class</pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can also use the standard <code>BeanInfo</code> JavaBeans mechanism here as well
(described
<a href="http://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">in
not-amazing-detail here</a>). Find below an example of using the <code>BeanInfo</code> mechanism for
explicitly registering one or more <code>PropertyEditor</code> instances with the properties of an
associated class.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Foo
      FooBeanInfo // the BeanInfo for the Foo class</pre>
</div>
</div>
<div class="paragraph">
<p>Here is the Java source code for the referenced <code>FooBeanInfo</code> class. This would
associate a <code>CustomNumberEditor</code> with the <code>age</code> property of the <code>Foo</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">FooBeanInfo</span> <span class="directive">extends</span> <span class="predefined-type">SimpleBeanInfo</span> {

        <span class="directive">public</span> <span class="predefined-type">PropertyDescriptor</span><span class="type">[]</span> getPropertyDescriptors() {
                <span class="keyword">try</span> {
                        <span class="directive">final</span> <span class="predefined-type">PropertyEditor</span> numberPE = <span class="keyword">new</span> CustomNumberEditor(<span class="predefined-type">Integer</span>.class, <span class="predefined-constant">true</span>);
                        <span class="predefined-type">PropertyDescriptor</span> ageDescriptor = <span class="keyword">new</span> <span class="predefined-type">PropertyDescriptor</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, Foo.class) {
                                <span class="directive">public</span> <span class="predefined-type">PropertyEditor</span> createPropertyEditor(<span class="predefined-type">Object</span> bean) {
                                        <span class="keyword">return</span> numberPE;
                                };
                        };
                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">PropertyDescriptor</span><span class="type">[]</span> { ageDescriptor };
                }
                <span class="keyword">catch</span> (<span class="exception">IntrospectionException</span> ex) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">Error</span>(ex.toString());
                }
        }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="beans-beans-conversion-customeditor-registration"><a class="anchor" href="#beans-beans-conversion-customeditor-registration"></a>Registering additional custom PropertyEditors</h5>
<div class="paragraph">
<p>When setting bean properties as a string value, a Spring IoC container ultimately uses
standard JavaBeans <code>PropertyEditors</code> to convert these Strings to the complex type of the
property. Spring pre-registers a number of custom <code>PropertyEditors</code> (for example, to
convert a classname expressed as a string into a real <code>Class</code> object). Additionally,
Java&#8217;s standard JavaBeans <code>PropertyEditor</code> lookup mechanism allows a <code>PropertyEditor</code>
for a class simply to be named appropriately and placed in the same package as the class
it provides support for, to be found automatically.</p>
</div>
<div class="paragraph">
<p>If there is a need to register other custom <code>PropertyEditors</code>, there are several
mechanisms available. The most manual approach, which is not normally convenient or
recommended, is to simply use the <code>registerCustomEditor()</code> method of the
<code>ConfigurableBeanFactory</code> interface, assuming you have a <code>BeanFactory</code> reference.
Another, slightly more convenient, mechanism is to use a special bean factory
post-processor called <code>CustomEditorConfigurer</code>. Although bean factory post-processors
can be used with <code>BeanFactory</code> implementations, the <code>CustomEditorConfigurer</code> has a
nested property setup, so it is strongly recommended that it is used with the
<code>ApplicationContext</code>, where it may be deployed in similar fashion to any other bean, and
automatically detected and applied.</p>
</div>
<div class="paragraph">
<p>Note that all bean factories and application contexts automatically use a number of
built-in property editors, through their use of something called a <code>BeanWrapper</code> to
handle property conversions. The standard property editors that the <code>BeanWrapper</code>
registers are listed in <a href="#beans-beans-conversion">the previous section</a>. Additionally,
<code>ApplicationContexts</code> also override or add an additional number of editors to handle
resource lookups in a manner appropriate to the specific application context type.</p>
</div>
<div class="paragraph">
<p>Standard JavaBeans <code>PropertyEditor</code> instances are used to convert property values
expressed as strings to the actual complex type of the property.
<code>CustomEditorConfigurer</code>, a bean factory post-processor, may be used to conveniently add
support for additional <code>PropertyEditor</code> instances to an <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>Consider a user class <code>ExoticType</code>, and another class <code>DependsOnExoticType</code> which needs
<code>ExoticType</code> set as a property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">example</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExoticType</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="directive">public</span> ExoticType(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">DependsOnExoticType</span> {

        <span class="directive">private</span> ExoticType type;

        <span class="directive">public</span> <span class="type">void</span> setType(ExoticType type) {
                <span class="local-variable">this</span>.type = type;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When things are properly set up, we want to be able to assign the type property as a
string, which a <code>PropertyEditor</code> will behind the scenes convert into an actual
<code>ExoticType</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.DependsOnExoticType</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aNameForExoticType</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PropertyEditor</code> implementation could look similar to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// converts string representation to ExoticType object</span>
<span class="keyword">package</span> <span class="namespace">example</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">ExoticTypeEditor</span> <span class="directive">extends</span> <span class="predefined-type">PropertyEditorSupport</span> {

        <span class="directive">public</span> <span class="type">void</span> setAsText(<span class="predefined-type">String</span> text) {
                setValue(<span class="keyword">new</span> ExoticType(text.toUpperCase()));
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we use <code>CustomEditorConfigurer</code> to register the new <code>PropertyEditor</code> with the
<code>ApplicationContext</code>, which will then be able to use it as needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.CustomEditorConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customEditors</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;map&gt;</span>
                        <span class="tag">&lt;entry</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ExoticType</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.ExoticTypeEditor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/map&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-beans-conversion-customeditor-registration-per"><a class="anchor" href="#beans-beans-conversion-customeditor-registration-per"></a>Using PropertyEditorRegistrars</h6>
<div class="paragraph">
<p>Another mechanism for registering property editors with the Spring container is to
create and use a <code>PropertyEditorRegistrar</code>. This interface is particularly useful when
you need to use the same set of property editors in several different situations: write
a corresponding registrar and reuse that in each case. <code>PropertyEditorRegistrars</code> work
in conjunction with an interface called <code>PropertyEditorRegistry</code>, an interface that is
implemented by the Spring <code>BeanWrapper</code> (and <code>DataBinder</code>). <code>PropertyEditorRegistrars</code>
are particularly convenient when used in conjunction with the <code>CustomEditorConfigurer</code>
(introduced <a href="#beans-beans-conversion-customeditor-registration">here</a>), which exposes a
property called <code>setPropertyEditorRegistrars(..)</code>: <code>PropertyEditorRegistrars</code> added to a
<code>CustomEditorConfigurer</code> in this fashion can easily be shared with <code>DataBinder</code> and
Spring MVC <code>Controllers</code>. Furthermore, it avoids the need for synchronization on custom
editors: a <code>PropertyEditorRegistrar</code> is expected to create fresh <code>PropertyEditor</code>
instances for each bean creation attempt.</p>
</div>
<div class="paragraph">
<p>Using a <code>PropertyEditorRegistrar</code> is perhaps best illustrated with an example. First
off, you need to create your own <code>PropertyEditorRegistrar</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.foo.editors.spring</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">CustomPropertyEditorRegistrar</span> <span class="directive">implements</span> PropertyEditorRegistrar {

        <span class="directive">public</span> <span class="type">void</span> registerCustomEditors(PropertyEditorRegistry registry) {

                <span class="comment">// it is expected that new PropertyEditor instances are created</span>
                registry.registerCustomEditor(ExoticType.class, <span class="keyword">new</span> ExoticTypeEditor());

                <span class="comment">// you could register as many custom property editors as are required here...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the <code>org.springframework.beans.support.ResourceEditorRegistrar</code> for an example
<code>PropertyEditorRegistrar</code> implementation. Notice how in its implementation of the
<code>registerCustomEditors(..)</code> method it creates new instances of each property editor.</p>
</div>
<div class="paragraph">
<p>Next we configure a <code>CustomEditorConfigurer</code> and inject an instance of our
<code>CustomPropertyEditorRegistrar</code> into it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.CustomEditorConfigurer</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">propertyEditorRegistrars</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customPropertyEditorRegistrar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customPropertyEditorRegistrar</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.foo.editors.spring.CustomPropertyEditorRegistrar</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, and in a bit of a departure from the focus of this chapter, for those of you
using <a href="web.html#mvc">Spring&#8217;s MVC web framework</a>, using <code>PropertyEditorRegistrars</code> in
conjunction with data-binding <code>Controllers</code> (such as <code>SimpleFormController</code>) can be very
convenient. Find below an example of using a <code>PropertyEditorRegistrar</code> in the
implementation of an <code>initBinder(..)</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">RegisterUserController</span> <span class="directive">extends</span> SimpleFormController {

        <span class="directive">private</span> <span class="directive">final</span> PropertyEditorRegistrar customPropertyEditorRegistrar;

        <span class="directive">public</span> RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
                <span class="local-variable">this</span>.customPropertyEditorRegistrar = propertyEditorRegistrar;
        }

        <span class="directive">protected</span> <span class="type">void</span> initBinder(HttpServletRequest request,
                        ServletRequestDataBinder binder) <span class="directive">throws</span> <span class="exception">Exception</span> {
                <strong><span class="local-variable">this</span>.customPropertyEditorRegistrar.registerCustomEditors(binder);</strong>
        }

        <span class="comment">// other methods to do with registering a User</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This style of <code>PropertyEditor</code> registration can lead to concise code (the implementation
of <code>initBinder(..)</code> is just one line long!), and allows common <code>PropertyEditor</code>
registration code to be encapsulated in a class and then shared amongst as many
<code>Controllers</code> as needed.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert"><a class="anchor" href="#core-convert"></a>3.5. Spring Type Conversion</h3>
<div class="paragraph">
<p>Spring 3 introduces a <code>core.convert</code> package that provides a general type conversion
system. The system defines an SPI to implement type conversion logic, as well as an API
to execute type conversions at runtime. Within a Spring container, this system can be
used as an alternative to PropertyEditors to convert externalized bean property value
strings to required property types. The public API may also be used anywhere in your
application where type conversion is needed.</p>
</div>
<div class="sect3">
<h4 id="core-convert-Converter-API"><a class="anchor" href="#core-convert-Converter-API"></a>3.5.1. Converter SPI</h4>
<div class="paragraph">
<p>The SPI to implement type conversion logic is simple and strongly typed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">Converter</span>&lt;S, T&gt; {

        T convert(S source);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create your own converter, simply implement the interface above. Parameterize <code>S</code>
as the type you are converting from, and <code>T</code> as the type you are converting to. Such a
converter can also be applied transparently if a collection or array of <code>S</code> needs to be
converted to an array or collection of <code>T</code>, provided that a delegating array/collection
converter has been registered as well (which <code>DefaultConversionService</code> does by default).</p>
</div>
<div class="paragraph">
<p>For each call to <code>convert(S)</code>, the source argument is guaranteed to be NOT null. Your
Converter may throw any unchecked exception if conversion fails; specifically, an
<code>IllegalArgumentException</code> should be thrown to report an invalid source value.
Take care to ensure that your <code>Converter</code> implementation is thread-safe.</p>
</div>
<div class="paragraph">
<p>Several converter implementations are provided in the <code>core.convert.support</code> package as
a convenience. These include converters from Strings to Numbers and other common types.
Consider <code>StringToInteger</code> as an example for a typical <code>Converter</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.support</span>;

<span class="directive">final</span> <span class="type">class</span> <span class="class">StringToInteger</span> <span class="directive">implements</span> Converter&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Integer</span>&gt; {

        <span class="directive">public</span> <span class="predefined-type">Integer</span> convert(<span class="predefined-type">String</span> source) {
                <span class="keyword">return</span> <span class="predefined-type">Integer</span>.valueOf(source);
        }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConverterFactory-SPI"><a class="anchor" href="#core-convert-ConverterFactory-SPI"></a>3.5.2. ConverterFactory</h4>
<div class="paragraph">
<p>When you need to centralize the conversion logic for an entire class hierarchy, for
example, when converting from String to java.lang.Enum objects, implement
<code>ConverterFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ConverterFactory</span>&lt;S, R&gt; {

        &lt;T <span class="directive">extends</span> R&gt; Converter&lt;S, T&gt; getConverter(<span class="predefined-type">Class</span>&lt;T&gt; targetType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parameterize S to be the type you are converting from and R to be the base type defining
the <em>range</em> of classes you can convert to. Then implement getConverter(Class&lt;T&gt;),
where T is a subclass of R.</p>
</div>
<div class="paragraph">
<p>Consider the <code>StringToEnum</code> ConverterFactory as an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.support</span>;

<span class="directive">final</span> <span class="type">class</span> <span class="class">StringToEnumConverterFactory</span> <span class="directive">implements</span> ConverterFactory&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Enum</span>&gt; {

        <span class="directive">public</span> &lt;T <span class="directive">extends</span> <span class="predefined-type">Enum</span>&gt; Converter&lt;<span class="predefined-type">String</span>, T&gt; getConverter(<span class="predefined-type">Class</span>&lt;T&gt; targetType) {
                <span class="keyword">return</span> <span class="keyword">new</span> StringToEnumConverter(targetType);
        }

        <span class="directive">private</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">StringToEnumConverter</span>&lt;T <span class="directive">extends</span> <span class="predefined-type">Enum</span>&gt; <span class="directive">implements</span> Converter&lt;<span class="predefined-type">String</span>, T&gt; {

                <span class="directive">private</span> <span class="predefined-type">Class</span>&lt;T&gt; enumType;

                <span class="directive">public</span> StringToEnumConverter(<span class="predefined-type">Class</span>&lt;T&gt; enumType) {
                        <span class="local-variable">this</span>.enumType = enumType;
                }

                <span class="directive">public</span> T convert(<span class="predefined-type">String</span> source) {
                        <span class="keyword">return</span> (T) <span class="predefined-type">Enum</span>.valueOf(<span class="local-variable">this</span>.enumType, source.trim());
                }
        }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-GenericConverter-SPI"><a class="anchor" href="#core-convert-GenericConverter-SPI"></a>3.5.3. GenericConverter</h4>
<div class="paragraph">
<p>When you require a sophisticated Converter implementation, consider the GenericConverter
interface. With a more flexible but less strongly typed signature, a GenericConverter
supports converting between multiple source and target types. In addition, a
GenericConverter makes available source and target field context you can use when
implementing your conversion logic. Such context allows a type conversion to be driven
by a field annotation, or generic information declared on a field signature.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert.converter</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">GenericConverter</span> {

        <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;ConvertiblePair&gt; getConvertibleTypes();

        <span class="predefined-type">Object</span> convert(<span class="predefined-type">Object</span> source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement a GenericConverter, have getConvertibleTypes() return the supported
source&#8594;target type pairs. Then implement convert(Object, TypeDescriptor,
TypeDescriptor) to implement your conversion logic. The source TypeDescriptor provides
access to the source field holding the value being converted. The target TypeDescriptor
provides access to the target field where the converted value will be set.</p>
</div>
<div class="paragraph">
<p>A good example of a GenericConverter is a converter that converts between a Java Array
and a Collection. Such an ArrayToCollectionConverter introspects the field that declares
the target Collection type to resolve the Collection&#8217;s element type. This allows each
element in the source array to be converted to the Collection element type before the
Collection is set on the target field.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because GenericConverter is a more complex SPI interface, only use it when you need it.
Favor Converter or ConverterFactory for basic type conversion needs.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="core-convert-ConditionalGenericConverter-SPI"><a class="anchor" href="#core-convert-ConditionalGenericConverter-SPI"></a>ConditionalGenericConverter</h5>
<div class="paragraph">
<p>Sometimes you only want a <code>Converter</code> to execute if a specific condition holds true. For
example, you might only want to execute a <code>Converter</code> if a specific annotation is present
on the target field. Or you might only want to execute a <code>Converter</code> if a specific method,
such as a <code>static valueOf</code> method, is defined on the target class.
<code>ConditionalGenericConverter</code> is the union of the <code>GenericConverter</code> and
<code>ConditionalConverter</code> interfaces that allows you to define such custom matching criteria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ConditionalConverter</span> {

        <span class="type">boolean</span> matches(TypeDescriptor sourceType, TypeDescriptor targetType);

}

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ConditionalGenericConverter</span>
        <span class="directive">extends</span> GenericConverter, ConditionalConverter {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A good example of a <code>ConditionalGenericConverter</code> is an EntityConverter that converts
between an persistent entity identifier and an entity reference. Such a EntityConverter
might only match if the target entity type declares a static finder method e.g.
<code>findAccount(Long)</code>. You would perform such a finder method check in the implementation of
<code>matches(TypeDescriptor, TypeDescriptor)</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConversionService-API"><a class="anchor" href="#core-convert-ConversionService-API"></a>3.5.4. ConversionService API</h4>
<div class="paragraph">
<p>The ConversionService defines a unified API for executing type conversion logic at
runtime. Converters are often executed behind this facade interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.core.convert</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ConversionService</span> {

        <span class="type">boolean</span> canConvert(<span class="predefined-type">Class</span>&lt;?&gt; sourceType, <span class="predefined-type">Class</span>&lt;?&gt; targetType);

        &lt;T&gt; T convert(<span class="predefined-type">Object</span> source, <span class="predefined-type">Class</span>&lt;T&gt; targetType);

        <span class="type">boolean</span> canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

        <span class="predefined-type">Object</span> convert(<span class="predefined-type">Object</span> source, TypeDescriptor sourceType, TypeDescriptor targetType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most ConversionService implementations also implement <code>ConverterRegistry</code>, which
provides an SPI for registering converters. Internally, a ConversionService
implementation delegates to its registered converters to carry out type conversion logic.</p>
</div>
<div class="paragraph">
<p>A robust ConversionService implementation is provided in the <code>core.convert.support</code>
package. <code>GenericConversionService</code> is the general-purpose implementation suitable for
use in most environments. <code>ConversionServiceFactory</code> provides a convenient factory for
creating common ConversionService configurations.</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-Spring-config"><a class="anchor" href="#core-convert-Spring-config"></a>3.5.5. Configuring a ConversionService</h4>
<div class="paragraph">
<p>A ConversionService is a stateless object designed to be instantiated at application
startup, then shared between multiple threads. In a Spring application, you typically
configure a ConversionService instance per Spring container (or ApplicationContext).
That ConversionService will be picked up by Spring and then used whenever a type
conversion needs to be performed by the framework. You may also inject this
ConversionService into any of your beans and invoke it directly.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If no ConversionService is registered with Spring, the original PropertyEditor-based
system is used.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To register a default ConversionService with Spring, add the following bean definition
with id <code>conversionService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">conversionService</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ConversionServiceFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A default ConversionService can convert between strings, numbers, enums, collections,
maps, and other common types. To supplement or override the default converters with your
own custom converter(s), set the <code>converters</code> property. Property values may implement
either of the Converter, ConverterFactory, or GenericConverter interfaces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">conversionService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.context.support.ConversionServiceFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">converters</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;set&gt;</span>
                        <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">example.MyCustomConverter</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/set&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also common to use a ConversionService within a Spring MVC application. See
<a href="web.html#mvc-config-conversion">Conversion and Formatting</a> in the Spring MVC chapter.</p>
</div>
<div class="paragraph">
<p>In certain situations you may wish to apply formatting during conversion. See
<a href="#format-FormatterRegistry-SPI">FormatterRegistry SPI</a> for details on using
<code>FormattingConversionServiceFactoryBean</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-programmatic-usage"><a class="anchor" href="#core-convert-programmatic-usage"></a>3.5.6. Using a ConversionService programmatically</h4>
<div class="paragraph">
<p>To work with a ConversionService instance programmatically, simply inject a reference to
it like you would for any other bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MyService(ConversionService conversionService) {
                <span class="local-variable">this</span>.conversionService = conversionService;
        }

        <span class="directive">public</span> <span class="type">void</span> doIt() {
                <span class="local-variable">this</span>.conversionService.convert(...)
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For most use cases, the <code>convert</code> method specifying the <em>targetType</em> can be used but it
will not work with more complex types such as a collection of a parameterized element.
If you want to convert a <code>List</code> of <code>Integer</code> to a <code>List</code> of <code>String</code> programmatically,
for instance, you need to provide a formal definition of the source and target types.</p>
</div>
<div class="paragraph">
<p>Fortunately, <code>TypeDescriptor</code> provides various options to make that straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DefaultConversionService cs = <span class="keyword">new</span> DefaultConversionService();

<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; input = ....
cs.convert(input,
        TypeDescriptor.forObject(input), <span class="comment">// List&lt;Integer&gt; type descriptor</span>
        TypeDescriptor.collection(<span class="predefined-type">List</span>.class, TypeDescriptor.valueOf(<span class="predefined-type">String</span>.class)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>DefaultConversionService</code> registers converters automatically which are
appropriate for most environments. This includes collection converters, scalar
converters, and also basic <code>Object</code> to <code>String</code> converters. The same converters can
be registered with any <code>ConverterRegistry</code> using the <em>static</em> <code>addDefaultConverters</code>
method on the <code>DefaultConversionService</code> class.</p>
</div>
<div class="paragraph">
<p>Converters for value types will be reused for arrays and collections, so there is
no need to create a specific converter to convert from a <code>Collection</code> of <code>S</code> to a
<code>Collection</code> of <code>T</code>, assuming that standard collection handling is appropriate.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format"><a class="anchor" href="#format"></a>3.6. Spring Field Formatting</h3>
<div class="paragraph">
<p>As discussed in the previous section, <a href="#core-convert"><code>core.convert</code></a> is a
general-purpose type conversion system. It provides a unified ConversionService API as
well as a strongly-typed Converter SPI for implementing conversion logic from one type
to another. A Spring Container uses this system to bind bean property values. In
addition, both the Spring Expression Language (SpEL) and DataBinder use this system to
bind field values. For example, when SpEL needs to coerce a <code>Short</code> to a <code>Long</code> to
complete an <code>expression.setValue(Object bean, Object value)</code> attempt, the core.convert
system performs the coercion.</p>
</div>
<div class="paragraph">
<p>Now consider the type conversion requirements of a typical client environment such as a
web or desktop application. In such environments, you typically convert <em>from String</em>
to support the client postback process, as well as back <em>to String</em> to support the
view rendering process. In addition, you often need to localize String values. The more
general <em>core.convert</em> Converter SPI does not address such <em>formatting</em> requirements
directly. To directly address them, Spring 3 introduces a convenient Formatter SPI that
provides a simple and robust alternative to PropertyEditors for client environments.</p>
</div>
<div class="paragraph">
<p>In general, use the Converter SPI when you need to implement general-purpose type
conversion logic; for example, for converting between a java.util.Date and and
java.lang.Long. Use the Formatter SPI when you&#8217;re working in a client environment, such
as a web application, and need to parse and print localized field values. The
ConversionService provides a unified type conversion API for both SPIs.</p>
</div>
<div class="sect3">
<h4 id="format-Formatter-SPI"><a class="anchor" href="#format-Formatter-SPI"></a>3.6.1. Formatter SPI</h4>
<div class="paragraph">
<p>The Formatter SPI to implement field formatting logic is simple and strongly typed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">Formatter</span>&lt;T&gt; <span class="directive">extends</span> Printer&lt;T&gt;, <span class="predefined-type">Parser</span>&lt;T&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where Formatter extends from the Printer and Parser building-block interfaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Printer</span>&lt;T&gt; {
        <span class="predefined-type">String</span> print(T fieldValue, <span class="predefined-type">Locale</span> locale);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.text.ParseException</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">Parser</span>&lt;T&gt; {
        T parse(<span class="predefined-type">String</span> clientValue, <span class="predefined-type">Locale</span> locale) <span class="directive">throws</span> <span class="exception">ParseException</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create your own Formatter, simply implement the Formatter interface above.
Parameterize T to be the type of object you wish to format, for example,
<code>java.util.Date</code>. Implement the <code>print()</code> operation to print an instance of T for
display in the client locale. Implement the <code>parse()</code> operation to parse an instance of
T from the formatted representation returned from the client locale. Your Formatter
should throw a ParseException or IllegalArgumentException if a parse attempt fails. Take
care to ensure your Formatter implementation is thread-safe.</p>
</div>
<div class="paragraph">
<p>Several Formatter implementations are provided in <code>format</code> subpackages as a convenience.
The <code>number</code> package provides a <code>NumberFormatter</code>, <code>CurrencyFormatter</code>, and
<code>PercentFormatter</code> to format <code>java.lang.Number</code> objects using a <code>java.text.NumberFormat</code>.
The <code>datetime</code> package provides a <code>DateFormatter</code> to format <code>java.util.Date</code> objects with
a <code>java.text.DateFormat</code>. The <code>datetime.joda</code> package provides comprehensive datetime
formatting support based on the <a href="http://joda-time.sourceforge.net">Joda Time library</a>.</p>
</div>
<div class="paragraph">
<p>Consider <code>DateFormatter</code> as an example <code>Formatter</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format.datetime</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">DateFormatter</span> <span class="directive">implements</span> <span class="predefined-type">Formatter</span>&lt;<span class="predefined-type">Date</span>&gt; {

        <span class="directive">private</span> <span class="predefined-type">String</span> pattern;

        <span class="directive">public</span> <span class="predefined-type">DateFormatter</span>(<span class="predefined-type">String</span> pattern) {
                <span class="local-variable">this</span>.pattern = pattern;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> print(<span class="predefined-type">Date</span> date, <span class="predefined-type">Locale</span> locale) {
                <span class="keyword">if</span> (date == <span class="predefined-constant">null</span>) {
                        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
                }
                <span class="keyword">return</span> getDateFormat(locale).format(date);
        }

        <span class="directive">public</span> <span class="predefined-type">Date</span> parse(<span class="predefined-type">String</span> formatted, <span class="predefined-type">Locale</span> locale) <span class="directive">throws</span> <span class="exception">ParseException</span> {
                <span class="keyword">if</span> (formatted.length() == <span class="integer">0</span>) {
                        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
                }
                <span class="keyword">return</span> getDateFormat(locale).parse(formatted);
        }

        <span class="directive">protected</span> <span class="predefined-type">DateFormat</span> getDateFormat(<span class="predefined-type">Locale</span> locale) {
                <span class="predefined-type">DateFormat</span> dateFormat = <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>(<span class="local-variable">this</span>.pattern, locale);
                dateFormat.setLenient(<span class="predefined-constant">false</span>);
                <span class="keyword">return</span> dateFormat;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring team welcomes community-driven <code>Formatter</code> contributions; see
<a href="https://jira.spring.io/browse/SPR">jira.spring.io</a> to contribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="format-CustomFormatAnnotations"><a class="anchor" href="#format-CustomFormatAnnotations"></a>3.6.2. Annotation-driven Formatting</h4>
<div class="paragraph">
<p>As you will see, field formatting can be configured by field type or annotation. To bind
an Annotation to a formatter, implement AnnotationFormatterFactory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">AnnotationFormatterFactory</span>&lt;A <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt; {

        <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getFieldTypes();

        Printer&lt;?&gt; getPrinter(A annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType);

        <span class="predefined-type">Parser</span>&lt;?&gt; getParser(A annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parameterize A to be the field annotationType you wish to associate formatting logic
with, for example <code>org.springframework.format.annotation.DateTimeFormat</code>. Have
<code>getFieldTypes()</code> return the types of fields the annotation may be used on. Have
<code>getPrinter()</code> return a Printer to print the value of an annotated field. Have
<code>getParser()</code> return a Parser to parse a clientValue for an annotated field.</p>
</div>
<div class="paragraph">
<p>The example AnnotationFormatterFactory implementation below binds the @NumberFormat
Annotation to a formatter. This annotation allows either a number style or pattern to be
specified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">NumberFormatAnnotationFormatterFactory</span>
                <span class="directive">implements</span> AnnotationFormatterFactory&lt;<span class="predefined-type">NumberFormat</span>&gt; {

        <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getFieldTypes() {
                <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt;(asList(<span class="keyword">new</span> <span class="predefined-type">Class</span>&lt;?&gt;<span class="type">[]</span> {
                        <span class="predefined-type">Short</span>.class, <span class="predefined-type">Integer</span>.class, <span class="predefined-type">Long</span>.class, <span class="predefined-type">Float</span>.class,
                        <span class="predefined-type">Double</span>.class, <span class="predefined-type">BigDecimal</span>.class, <span class="predefined-type">BigInteger</span>.class }));
        }

        <span class="directive">public</span> Printer&lt;<span class="predefined-type">Number</span>&gt; getPrinter(<span class="predefined-type">NumberFormat</span> annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType) {
                <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);
        }

        <span class="directive">public</span> <span class="predefined-type">Parser</span>&lt;<span class="predefined-type">Number</span>&gt; getParser(<span class="predefined-type">NumberFormat</span> annotation, <span class="predefined-type">Class</span>&lt;?&gt; fieldType) {
                <span class="keyword">return</span> configureFormatterFrom(annotation, fieldType);
        }

        <span class="directive">private</span> <span class="predefined-type">Formatter</span>&lt;<span class="predefined-type">Number</span>&gt; configureFormatterFrom(<span class="predefined-type">NumberFormat</span> annotation,
                        <span class="predefined-type">Class</span>&lt;?&gt; fieldType) {
                <span class="keyword">if</span> (!annotation.pattern().isEmpty()) {
                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">NumberFormatter</span>(annotation.pattern());
                } <span class="keyword">else</span> {
                        <span class="predefined-type">Style</span> style = annotation.style();
                        <span class="keyword">if</span> (style == <span class="predefined-type">Style</span>.PERCENT) {
                                <span class="keyword">return</span> <span class="keyword">new</span> PercentFormatter();
                        } <span class="keyword">else</span> <span class="keyword">if</span> (style == <span class="predefined-type">Style</span>.CURRENCY) {
                                <span class="keyword">return</span> <span class="keyword">new</span> CurrencyFormatter();
                        } <span class="keyword">else</span> {
                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">NumberFormatter</span>();
                        }
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To trigger formatting, simply annotate fields with @NumberFormat:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> {

        <span class="annotation">@NumberFormat</span>(style=<span class="predefined-type">Style</span>.CURRENCY)
        <span class="directive">private</span> <span class="predefined-type">BigDecimal</span> decimal;

}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="format-annotations-api"><a class="anchor" href="#format-annotations-api"></a>Format Annotation API</h5>
<div class="paragraph">
<p>A portable format annotation API exists in the <code>org.springframework.format.annotation</code>
package. Use @NumberFormat to format java.lang.Number fields. Use @DateTimeFormat to
format java.util.Date, java.util.Calendar, java.util.Long, or Joda Time fields.</p>
</div>
<div class="paragraph">
<p>The example below uses @DateTimeFormat to format a java.util.Date as a ISO Date
(yyyy-MM-dd):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyModel</span> {

        <span class="annotation">@DateTimeFormat</span>(iso=ISO.DATE)
        <span class="directive">private</span> <span class="predefined-type">Date</span> date;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistry-SPI"><a class="anchor" href="#format-FormatterRegistry-SPI"></a>3.6.3. FormatterRegistry SPI</h4>
<div class="paragraph">
<p>The FormatterRegistry is an SPI for registering formatters and converters.
<code>FormattingConversionService</code> is an implementation of FormatterRegistry suitable for
most environments. This implementation may be configured programmatically or
declaratively as a Spring bean using <code>FormattingConversionServiceFactoryBean</code>. Because
this implementation also implements <code>ConversionService</code>, it can be directly configured
for use with Spring&#8217;s DataBinder and the Spring Expression Language (SpEL).</p>
</div>
<div class="paragraph">
<p>Review the FormatterRegistry SPI below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">FormatterRegistry</span> <span class="directive">extends</span> ConverterRegistry {

        <span class="type">void</span> addFormatterForFieldType(<span class="predefined-type">Class</span>&lt;?&gt; fieldType, Printer&lt;?&gt; printer, <span class="predefined-type">Parser</span>&lt;?&gt; parser);

        <span class="type">void</span> addFormatterForFieldType(<span class="predefined-type">Class</span>&lt;?&gt; fieldType, <span class="predefined-type">Formatter</span>&lt;?&gt; formatter);

        <span class="type">void</span> addFormatterForFieldType(<span class="predefined-type">Formatter</span>&lt;?&gt; formatter);

        <span class="type">void</span> addFormatterForAnnotation(AnnotationFormatterFactory&lt;?, ?&gt; factory);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown above, Formatters can be registered by fieldType or annotation.</p>
</div>
<div class="paragraph">
<p>The FormatterRegistry SPI allows you to configure Formatting rules centrally, instead of
duplicating such configuration across your Controllers. For example, you might want to
enforce that all Date fields are formatted a certain way, or fields with a specific
annotation are formatted in a certain way. With a shared FormatterRegistry, you define
these rules once and they are applied whenever formatting is needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistrar-SPI"><a class="anchor" href="#format-FormatterRegistrar-SPI"></a>3.6.4. FormatterRegistrar SPI</h4>
<div class="paragraph">
<p>The FormatterRegistrar is an SPI for registering formatters and converters through the
FormatterRegistry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.springframework.format</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">FormatterRegistrar</span> {

        <span class="type">void</span> registerFormatters(FormatterRegistry registry);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A FormatterRegistrar is useful when registering multiple related converters and
formatters for a given formatting category, such as Date formatting. It can also be
useful where declarative registration is insufficient. For example when a formatter
needs to be indexed under a specific field type different from its own &lt;T&gt; or when
registering a Printer/Parser pair. The next section provides more information on
converter and formatter registration.</p>
</div>
</div>
<div class="sect3">
<h4 id="format-configuring-formatting-mvc"><a class="anchor" href="#format-configuring-formatting-mvc"></a>3.6.5. Configuring Formatting in Spring MVC</h4>
<div class="paragraph">
<p>See <a href="web.html#mvc-config-conversion">Conversion and Formatting</a> in the Spring MVC chapter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format-configuring-formatting-globaldatetimeformat"><a class="anchor" href="#format-configuring-formatting-globaldatetimeformat"></a>3.7. Configuring a global date &amp; time format</h3>
<div class="paragraph">
<p>By default, date and time fields that are not annotated with <code>@DateTimeFormat</code> are
converted from strings using the <code>DateFormat.SHORT</code> style. If you prefer, you can
change this by defining your own global format.</p>
</div>
<div class="paragraph">
<p>You will need to ensure that Spring does not register default formatters, and instead
you should register all formatters manually. Use the
<code>org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</code> or
<code>org.springframework.format.datetime.DateFormatterRegistrar</code> class depending on whether
you use the Joda Time library.</p>
</div>
<div class="paragraph">
<p>For example, the following Java configuration will register a global ' `yyyyMMdd&#8217;
format. This example does not depend on the Joda Time library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

        <span class="annotation">@Bean</span>
        <span class="directive">public</span> FormattingConversionService conversionService() {

                <span class="comment">// Use the DefaultFormattingConversionService but do not register defaults</span>
                DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService(<span class="predefined-constant">false</span>);

                <span class="comment">// Ensure @NumberFormat is still supported</span>
                conversionService.addFormatterForFieldAnnotation(<span class="keyword">new</span> NumberFormatAnnotationFormatterFactory());

                <span class="comment">// Register date conversion with a specific global format</span>
                DateFormatterRegistrar registrar = <span class="keyword">new</span> DateFormatterRegistrar();
                registrar.setFormatter(<span class="keyword">new</span> <span class="predefined-type">DateFormatter</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">yyyyMMdd</span><span class="delimiter">&quot;</span></span>));
                registrar.registerFormatters(conversionService);

                <span class="keyword">return</span> conversionService;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML based configuration you can use a
<code>FormattingConversionServiceFactoryBean</code>. Here is the same example, this time using Joda
Time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="error">&gt;</span>

        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">conversionService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.support.FormattingConversionServiceFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">registerDefaultFormatters</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">formatters</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;set&gt;</span>
                                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.number.NumberFormatAnnotationFormatterFactory</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
                        <span class="tag">&lt;/set&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">formatterRegistrars</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;set&gt;</span>
                                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dateFormatter</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                                                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">pattern</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yyyyMMdd</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                                                <span class="tag">&lt;/bean&gt;</span>
                                        <span class="tag">&lt;/property&gt;</span>
                                <span class="tag">&lt;/bean&gt;</span>
                        <span class="tag">&lt;/set&gt;</span>
                <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/bean&gt;</span>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Joda Time provides separate distinct types to represent <code>date</code>, <code>time</code> and <code>date-time</code>
values. The <code>dateFormatter</code>, <code>timeFormatter</code> and <code>dateTimeFormatter</code> properties of the
<code>JodaTimeFormatterRegistrar</code> should be used to configure the different formats for each
type. The <code>DateTimeFormatterFactoryBean</code> provides a convenient way to create formatters.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are using Spring MVC remember to explicitly configure the conversion service that
is used. For Java based <code>@Configuration</code> this means extending the
<code>WebMvcConfigurationSupport</code> class and overriding the <code>mvcConversionService()</code> method.
For XML you should use the <code>'conversion-service'</code> attribute of the
<code>mvc:annotation-driven</code> element.
See <a href="web.html#mvc-config-conversion">Conversion and Formatting</a> for details.</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-beanvalidation"><a class="anchor" href="#validation-beanvalidation"></a>3.8. Spring Validation</h3>
<div class="paragraph">
<p>Spring 3 introduces several enhancements to its validation support. First, the JSR-303
Bean Validation API is now fully supported. Second, when used programmatically, Spring&#8217;s
DataBinder can now validate objects as well as bind to them. Third, Spring MVC now has
support for declaratively validating <code>@Controller</code> inputs.</p>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-overview"><a class="anchor" href="#validation-beanvalidation-overview"></a>3.8.1. Overview of the JSR-303 Bean Validation API</h4>
<div class="paragraph">
<p>JSR-303 standardizes validation constraint declaration and metadata for the Java
platform. Using this API, you annotate domain model properties with declarative
validation constraints and the runtime enforces them. There are a number of built-in
constraints you can take advantage of. You may also define your own custom constraints.</p>
</div>
<div class="paragraph">
<p>To illustrate, consider a simple PersonForm model with two properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonForm</span> {
        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> <span class="type">int</span> age;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSR-303 allows you to define declarative validation constraints against such properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">PersonForm</span> {

        <span class="annotation">@NotNull</span>
        <span class="annotation">@Size</span>(max=<span class="integer">64</span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="annotation">@Min</span>(<span class="integer">0</span>)
        <span class="directive">private</span> <span class="type">int</span> age;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When an instance of this class is validated by a JSR-303 Validator, these constraints
will be enforced.</p>
</div>
<div class="paragraph">
<p>For general information on JSR-303/JSR-349, see the <a href="http://beanvalidation.org/">Bean
Validation website</a>. For information on the specific capabilities of the default
reference implementation, see the <a href="https://www.hibernate.org/412.html">Hibernate
Validator</a> documentation. To learn how to setup a Bean Validation provider as a Spring
bean, keep reading.</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring"><a class="anchor" href="#validation-beanvalidation-spring"></a>3.8.2. Configuring a Bean Validation Provider</h4>
<div class="paragraph">
<p>Spring provides full support for the Bean Validation API. This includes convenient
support for bootstrapping a JSR-303/JSR-349 Bean Validation provider as a Spring bean.
This allows for a <code>javax.validation.ValidatorFactory</code> or <code>javax.validation.Validator</code> to
be injected wherever validation is needed in your application.</p>
</div>
<div class="paragraph">
<p>Use the <code>LocalValidatorFactoryBean</code> to configure a default Validator as a Spring bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">validator</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The basic configuration above will trigger Bean Validation to initialize using its
default bootstrap mechanism. A JSR-303/JSR-349 provider, such as Hibernate Validator,
is expected to be present in the classpath and will be detected automatically.</p>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-inject"><a class="anchor" href="#validation-beanvalidation-spring-inject"></a>Injecting a Validator</h5>
<div class="paragraph">
<p><code>LocalValidatorFactoryBean</code> implements both <code>javax.validation.ValidatorFactory</code> and
<code>javax.validation.Validator</code>, as well as Spring&#8217;s
<code>org.springframework.validation.Validator</code>. You may inject a reference to either of
these interfaces into beans that need to invoke validation logic.</p>
</div>
<div class="paragraph">
<p>Inject a reference to <code>javax.validation.Validator</code> if you prefer to work with the Bean
Validation API directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.validation.Validator</span>;

<span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> <span class="predefined-type">Validator</span> validator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inject a reference to <code>org.springframework.validation.Validator</code> if your bean requires
the Spring Validation API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.validation.Validator</span>;

<span class="annotation">@Service</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyService</span> {

        <span class="annotation">@Autowired</span>
        <span class="directive">private</span> <span class="predefined-type">Validator</span> validator;

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-constraints"><a class="anchor" href="#validation-beanvalidation-spring-constraints"></a>Configuring Custom Constraints</h5>
<div class="paragraph">
<p>Each Bean Validation constraint consists of two parts. First, a <code>@Constraint</code> annotation
that declares the constraint and its configurable properties. Second, an implementation
of the <code>javax.validation.ConstraintValidator</code> interface that implements the constraint&#8217;s
behavior. To associate a declaration with an implementation, each <code>@Constraint</code> annotation
references a corresponding ValidationConstraint implementation class. At runtime, a
<code>ConstraintValidatorFactory</code> instantiates the referenced implementation when the
constraint annotation is encountered in your domain model.</p>
</div>
<div class="paragraph">
<p>By default, the <code>LocalValidatorFactoryBean</code> configures a <code>SpringConstraintValidatorFactory</code>
that uses Spring to create ConstraintValidator instances. This allows your custom
ConstraintValidators to benefit from dependency injection like any other Spring bean.</p>
</div>
<div class="paragraph">
<p>Shown below is an example of a custom <code>@Constraint</code> declaration, followed by an associated
<code>ConstraintValidator</code> implementation that uses Spring for dependency injection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Target</span>({<span class="predefined-type">ElementType</span>.METHOD, <span class="predefined-type">ElementType</span>.FIELD})
<span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Constraint</span>(validatedBy=MyConstraintValidator.class)
<span class="directive">public</span> <span class="annotation">@interface</span> MyConstraint {
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">javax.validation.ConstraintValidator</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">MyConstraintValidator</span> <span class="directive">implements</span> ConstraintValidator {

        <span class="annotation">@Autowired</span>;
        <span class="directive">private</span> Foo aDependency;

        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, a ConstraintValidator implementation may have its dependencies
@Autowired like any other Spring bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-method"><a class="anchor" href="#validation-beanvalidation-spring-method"></a>Spring-driven Method Validation</h5>
<div class="paragraph">
<p>The method validation feature supported by Bean Validation 1.1, and as a custom
extension also by Hibernate Validator 4.3, can be integrated into a Spring context
through a <code>MethodValidationPostProcessor</code> bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.validation.beanvalidation.MethodValidationPostProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to be eligible for Spring-driven method validation, all target classes need
to be annotated with Spring&#8217;s <code>@Validated</code> annotation, optionally declaring the
validation groups to use. Check out the <code>MethodValidationPostProcessor</code> javadocs
for setup details with Hibernate Validator and Bean Validation 1.1 providers.</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-other"><a class="anchor" href="#validation-beanvalidation-spring-other"></a>Additional Configuration Options</h5>
<div class="paragraph">
<p>The default <code>LocalValidatorFactoryBean</code> configuration should prove sufficient for most
cases. There are a number of configuration options for various Bean Validation
constructs, from message interpolation to traversal resolution. See the
<code>LocalValidatorFactoryBean</code> javadocs for more information on these options.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validation-binder"><a class="anchor" href="#validation-binder"></a>3.8.3. Configuring a DataBinder</h4>
<div class="paragraph">
<p>Since Spring 3, a DataBinder instance can be configured with a Validator. Once
configured, the Validator may be invoked by calling <code>binder.validate()</code>. Any validation
Errors are automatically added to the binder&#8217;s BindingResult.</p>
</div>
<div class="paragraph">
<p>When working with the DataBinder programmatically, this can be used to invoke validation
logic after binding to a target object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Foo target = <span class="keyword">new</span> Foo();
DataBinder binder = <span class="keyword">new</span> DataBinder(target);
binder.setValidator(<span class="keyword">new</span> FooValidator());

<span class="comment">// bind to the target object</span>
binder.bind(propertyValues);

<span class="comment">// validate the target object</span>
binder.validate();

<span class="comment">// get BindingResult that includes any validation errors</span>
BindingResult results = binder.getBindingResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A DataBinder can also be configured with multiple <code>Validator</code> instances via
<code>dataBinder.addValidators</code> and <code>dataBinder.replaceValidators</code>. This is useful when
combining globally configured Bean Validation with a Spring <code>Validator</code> configured
locally on a DataBinder instance. See <a href="#validation-mvc-configuring">[validation-mvc-configuring]</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-mvc"><a class="anchor" href="#validation-mvc"></a>3.8.4. Spring MVC 3 Validation</h4>
<div class="paragraph">
<p>See <a href="web.html#mvc-config-validation">Validation</a> in the Spring MVC chapter.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expressions"><a class="anchor" href="#expressions"></a>4. Spring Expression Language (SpEL)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="expressions-intro"><a class="anchor" href="#expressions-intro"></a>4.1. Introduction</h3>
<div class="paragraph">
<p>The Spring Expression Language (SpEL for short) is a powerful expression language that
supports querying and manipulating an object graph at runtime. The language syntax is
similar to Unified EL but offers additional features, most notably method invocation and
basic string templating functionality.</p>
</div>
<div class="paragraph">
<p>While there are several other Java expression languages available, OGNL, MVEL, and JBoss
EL, to name a few, the Spring Expression Language was created to provide the Spring
community with a single well supported expression language that can be used across all
the products in the Spring portfolio. Its language features are driven by the
requirements of the projects in the Spring portfolio, including tooling requirements for
code completion support within the eclipse based Spring Tool Suite. That said,
SpEL is based on a technology agnostic API allowing other expression language
implementations to be integrated should the need arise.</p>
</div>
<div class="paragraph">
<p>While SpEL serves as the foundation for expression evaluation within the Spring
portfolio, it is not directly tied to Spring and can be used independently. In order to
be self contained, many of the examples in this chapter use SpEL as if it were an
independent expression language. This requires creating a few bootstrapping
infrastructure classes such as the parser. Most Spring users will not need to deal with
this infrastructure and will instead only author expression strings for evaluation. An
example of this typical use is the integration of SpEL into creating XML or annotated
based bean definitions as shown in the section <a href="#expressions-beandef">Expression support
for defining bean definitions.</a></p>
</div>
<div class="paragraph">
<p>This chapter covers the features of the expression language, its API, and its language
syntax. In several places an Inventor and Inventor&#8217;s Society class are used as the
target objects for expression evaluation. These class declarations and the data used to
populate them are listed at the end of the chapter.</p>
</div>
</div>
<div class="sect2">
<h3 id="expressions-features"><a class="anchor" href="#expressions-features"></a>4.2. Feature Overview</h3>
<div class="paragraph">
<p>The expression language supports the following functionality</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Literal expressions</p>
</li>
<li>
<p>Boolean and relational operators</p>
</li>
<li>
<p>Regular expressions</p>
</li>
<li>
<p>Class expressions</p>
</li>
<li>
<p>Accessing properties, arrays, lists, maps</p>
</li>
<li>
<p>Method invocation</p>
</li>
<li>
<p>Relational operators</p>
</li>
<li>
<p>Assignment</p>
</li>
<li>
<p>Calling constructors</p>
</li>
<li>
<p>Bean references</p>
</li>
<li>
<p>Array construction</p>
</li>
<li>
<p>Inline lists</p>
</li>
<li>
<p>Inline maps</p>
</li>
<li>
<p>Ternary operator</p>
</li>
<li>
<p>Variables</p>
</li>
<li>
<p>User defined functions</p>
</li>
<li>
<p>Collection projection</p>
</li>
<li>
<p>Collection selection</p>
</li>
<li>
<p>Templated expressions</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="expressions-evaluation"><a class="anchor" href="#expressions-evaluation"></a>4.3. Expression Evaluation using Spring&#8217;s Expression Interface</h3>
<div class="paragraph">
<p>This section introduces the simple use of SpEL interfaces and its expression language.
The complete language reference can be found in the section
<a href="#expressions-language-ref">Language Reference</a>.</p>
</div>
<div class="paragraph">
<p>The following code introduces the SpEL API to evaluate the literal string expression
'Hello World'.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> message = (<span class="predefined-type">String</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of the message variable is simply 'Hello World'.</p>
</div>
<div class="paragraph">
<p>The SpEL classes and interfaces you are most likely to use are located in the packages
<code>org.springframework.expression</code> and its sub packages and <code>spel.support</code>.</p>
</div>
<div class="paragraph">
<p>The interface <code>ExpressionParser</code> is responsible for parsing an expression string. In
this example the expression string is a string literal denoted by the surrounding single
quotes. The interface <code>Expression</code> is responsible for evaluating the previously defined
expression string. There are two exceptions that can be thrown, <code>ParseException</code> and
<code>EvaluationException</code> when calling <code>parser.parseExpression</code> and <code>exp.getValue</code>
respectively.</p>
</div>
<div class="paragraph">
<p>SpEL supports a wide range of features, such as calling methods, accessing properties,
and calling constructors.</p>
</div>
<div class="paragraph">
<p>As an example of method invocation, we call the <code>concat</code> method on the string literal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'.concat('!')</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> message = (<span class="predefined-type">String</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of message is now 'Hello World!'.</p>
</div>
<div class="paragraph">
<p>As an example of calling a JavaBean property, the String property <code>Bytes</code> can be called
as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// invokes 'getBytes()'</span>
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'.bytes</strong></span><span class="delimiter">&quot;</span></span>);
<span class="type">byte</span><span class="type">[]</span> bytes = (<span class="type">byte</span><span class="type">[]</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>SpEL also supports nested properties using standard <em>dot</em> notation, i.e.
prop1.prop2.prop3 and the setting of property values</p>
</div>
<div class="paragraph">
<p>Public fields may also be accessed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// invokes 'getBytes().length'</span>
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>'Hello World'.bytes.length</strong></span><span class="delimiter">&quot;</span></span>);
<span class="type">int</span> length = (<span class="predefined-type">Integer</span>) exp.getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The String&#8217;s constructor can be called instead of using a string literal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>new String('hello world').toUpperCase()</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> message = exp.getValue(<span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the use of the generic method <code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code>.
Using this method removes the need to cast the value of the expression to the desired
result type. An <code>EvaluationException</code> will be thrown if the value cannot be cast to the
type <code>T</code> or converted using the registered type converter.</p>
</div>
<div class="paragraph">
<p>The more common usage of SpEL is to provide an expression string that is evaluated
against a specific object instance (called the root object). There are two options here
and which to choose depends on whether the object against which the expression is being
evaluated will be changing with each call to evaluate the expression. In the following
example we retrieve the <code>name</code> property from an instance of the Inventor class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create and set a calendar</span>
<span class="predefined-type">GregorianCalendar</span> c = <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span>();
c.set(<span class="integer">1856</span>, <span class="integer">7</span>, <span class="integer">9</span>);

<span class="comment">// The constructor arguments are name, birthday, and nationality.</span>
Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, c.getTime(), <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);

ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>name</strong></span><span class="delimiter">&quot;</span></span>);

EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);
<span class="predefined-type">String</span> name = (<span class="predefined-type">String</span>) exp.getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the last line, the value of the string variable <code>name</code> will be set to "Nikola Tesla".
The class StandardEvaluationContext is where you can specify which object the "name"
property will be evaluated against. This is the mechanism to use if the root object is
unlikely to change, it can simply be set once in the evaluation context. If the root
object is likely to change repeatedly, it can be supplied on each call to <code>getValue</code>, as
this next example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">/ Create and set a calendar
<span class="predefined-type">GregorianCalendar</span> c = <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span>();
c.set(<span class="integer">1856</span>, <span class="integer">7</span>, <span class="integer">9</span>);

<span class="comment">// The constructor arguments are name, birthday, and nationality.</span>
Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, c.getTime(), <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);

ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
<span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content"><strong>name</strong></span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">String</span> name = (<span class="predefined-type">String</span>) exp.getValue(tesla);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the inventor <code>tesla</code> has been supplied directly to <code>getValue</code> and the
expression evaluation infrastructure creates and manages a default evaluation context
internally - it did not require one to be supplied.</p>
</div>
<div class="paragraph">
<p>The StandardEvaluationContext is relatively expensive to construct and during repeated
usage it builds up cached state that enables subsequent expression evaluations to be
performed more quickly. For this reason it is better to cache and reuse them where
possible, rather than construct a new one for each expression evaluation.</p>
</div>
<div class="paragraph">
<p>In some cases it can be desirable to use a configured evaluation context and yet still
supply a different root object on each call to <code>getValue</code>. <code>getValue</code> allows both to be
specified on the same call. In these situations the root object passed on the call is
considered to override any (which maybe null) specified on the evaluation context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In standalone usage of SpEL there is a need to create the parser, parse expressions and
perhaps provide evaluation contexts and a root context object. However, more common
usage is to provide only the SpEL expression string as part of a configuration file, for
example for Spring bean or Spring Web Flow definitions. In this case, the parser,
evaluation context, root object and any predefined variables are all set up implicitly,
requiring the user to specify nothing other than the expressions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As a final introductory example, the use of a boolean operator is shown using the
Inventor object in the previous example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Expression</span> exp = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">name == 'Nikola Tesla'</span><span class="delimiter">&quot;</span></span>);
<span class="type">boolean</span> result = exp.getValue(context, <span class="predefined-type">Boolean</span>.class); <span class="comment">// evaluates to true</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="expressions-evaluation-context"><a class="anchor" href="#expressions-evaluation-context"></a>4.3.1. The EvaluationContext interface</h4>
<div class="paragraph">
<p>The interface <code>EvaluationContext</code> is used when evaluating an expression to resolve
properties, methods, fields, and to help perform type conversion. The out-of-the-box
implementation, <code>StandardEvaluationContext</code>, uses reflection to manipulate the object,
caching <code>java.lang.reflect.Method</code>, <code>java.lang.reflect.Field</code>, and
<code>java.lang.reflect.Constructor</code> instances for increased performance.</p>
</div>
<div class="paragraph">
<p>The <code>StandardEvaluationContext</code> is where you may specify the root object to evaluate
against via the method <code>setRootObject()</code> or passing the root object into the
constructor. You can also specify variables and functions that will be used in the
expression using the methods <code>setVariable()</code> and <code>registerFunction()</code>. The use of
variables and functions are described in the language reference sections
<a href="#expressions-ref-variables">Variables</a> and <a href="#expressions-ref-functions">Functions</a>. The
<code>StandardEvaluationContext</code> is also where you can register custom
<code>ConstructorResolver</code>s, <code>MethodResolver</code>s, and <code>PropertyAccessor</code>s to extend how SpEL
evaluates expressions. Please refer to the javadoc of these classes for more details.</p>
</div>
<div class="sect4">
<h5 id="expressions-type-conversion"><a class="anchor" href="#expressions-type-conversion"></a>Type Conversion</h5>
<div class="paragraph">
<p>By default SpEL uses the conversion service available in Spring core (
<code>org.springframework.core.convert.ConversionService</code>). This conversion service comes
with many converters built in for common conversions but is also fully extensible so
custom conversions between types can be added. Additionally it has the key capability
that it is generics aware. This means that when working with generic types in
expressions, SpEL will attempt conversions to maintain type correctness for any objects
it encounters.</p>
</div>
<div class="paragraph">
<p>What does this mean in practice? Suppose assignment, using <code>setValue()</code>, is being used
to set a <code>List</code> property. The type of the property is actually <code>List&lt;Boolean&gt;</code>. SpEL
will recognize that the elements of the list need to be converted to <code>Boolean</code> before
being placed in it. A simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Simple</span> {
        <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Boolean</span>&gt; booleanList = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Boolean</span>&gt;();
}

Simple simple = <span class="keyword">new</span> Simple();

simple.booleanList.add(<span class="predefined-constant">true</span>);

StandardEvaluationContext simpleContext = <span class="keyword">new</span> StandardEvaluationContext(simple);

<span class="comment">// false is passed in here as a string. SpEL and the conversion service will</span>
<span class="comment">// correctly recognize that it needs to be a Boolean and convert it</span>
parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">booleanList[0]</span><span class="delimiter">&quot;</span></span>).setValue(simpleContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// b will be false</span>
<span class="predefined-type">Boolean</span> b = simple.booleanList.get(<span class="integer">0</span>);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-parser-configuration"><a class="anchor" href="#expressions-parser-configuration"></a>4.3.2. Parser configuration</h4>
<div class="paragraph">
<p>It is possible to configure the SpEL expression parser using a parser configuration object
(<code>org.springframework.expression.spel.SpelParserConfiguration</code>). The configuration
object controls the behavior of some of the expression components. For example, if
indexing into an array or collection and the element at the specified index is <code>null</code>
it is possible to automatically create the element. This is useful when using expressions made up of a
chain of property references. If indexing into an array or list
and specifying an index that is beyond the end of the current size of the array or
list it is possible to automatically grow the array or list to accommodate that index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Demo</span> {
        <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list;
}

<span class="comment">// Turn on:</span>
<span class="comment">// - auto null reference initialization</span>
<span class="comment">// - auto collection growing</span>
SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="predefined-constant">true</span>,<span class="predefined-constant">true</span>);

ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);

<span class="predefined-type">Expression</span> expression = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">list[3]</span><span class="delimiter">&quot;</span></span>);

Demo demo = <span class="keyword">new</span> Demo();

<span class="predefined-type">Object</span> o = expression.getValue(demo);

<span class="comment">// demo.list will now be a real collection of 4 entries</span>
<span class="comment">// Each entry is a new empty String</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to configure the behaviour of the SpEL expression compiler.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-spel-compilation"><a class="anchor" href="#expressions-spel-compilation"></a>4.3.3. SpEL compilation</h4>
<div class="paragraph">
<p>Spring Framework 4.1 includes a basic expression compiler. Expressions are usually
interpreted which provides a lot of dynamic flexibility during evaluation but
does not provide the optimum performance. For occasional expression usage
this is fine, but when used by other components like Spring Integration,
performance can be very important and there is no real need for the dynamism.</p>
</div>
<div class="paragraph">
<p>The new SpEL compiler is intended to address this need. The
compiler will generate a real Java class on the fly during evaluation that embodies the
expression behavior and use that to achieve much faster expression
evaluation. Due to the lack of typing around expressions the compiler
uses information gathered during the interpreted evaluations of an
expression when performing compilation. For example, it does not know the type
of a property reference purely from the expression but during the first
interpreted evaluation it will find out what it is. Of course, basing the
compilation on this information could cause trouble later if the types of
the various expression elements change over time. For this reason compilation
is best suited to expressions whose type information is not going to change
on repeated evaluations.</p>
</div>
<div class="paragraph">
<p>For a basic expression like this:</p>
</div>
<div class="paragraph">
<p><code>someArray[0].someProperty.someOtherProperty &lt; 0.1</code></p>
</div>
<div class="paragraph">
<p>which involves array access, some property derefencing and numeric operations, the performance
gain can be very noticeable. In an example micro benchmark run of 50000 iterations, it was
taking 75ms to evaluate using only the interpreter and just 3ms using the compiled version
of the expression.</p>
</div>
<div class="sect4">
<h5 id="expressions-compiler-configuration"><a class="anchor" href="#expressions-compiler-configuration"></a>Compiler configuration</h5>
<div class="paragraph">
<p>The compiler is not turned on by default, but there are two ways to turn
it on. It can be turned on using the parser configuration process discussed earlier or
via a system property when SpEL usage is embedded inside another component. This section
discusses both of these options.</p>
</div>
<div class="paragraph">
<p>It is important to understand that there are a few modes the compiler can operate in, captured
in an enum (<code>org.springframework.expression.spel.SpelCompilerMode</code>). The modes are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OFF</code> - The compiler is switched off; this is the default.</p>
</li>
<li>
<p><code>IMMEDIATE</code> - In immediate mode the expressions are compiled as soon as possible. This
is typically after the first interpreted evaluation. If the compiled expression fails
(typically due to a type changing, as described above) then the caller of the expression
evaluation will receive an exception.</p>
</li>
<li>
<p><code>MIXED</code> - In mixed mode the expressions silently switch between interpreted and compiled
mode over time. After some number of interpreted runs they will switch to compiled
form and if something goes wrong with the compiled form (like a type changing, as
described above) then the expression will automatically switch back to interpreted form
again. Sometime later it may generate another compiled form and switch to it. Basically
the exception that the user gets in <code>IMMEDIATE</code> mode is instead handled internally.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>IMMEDIATE</code> mode exists because <code>MIXED</code> mode could cause issues for expressions that
have side effects. If a compiled expression blows up after partially succeeding it
may have already done something that has affected the state of the system. If this
has happened the caller may not want it to silently re-run in interpreted mode
since part of the expression may be running twice.</p>
</div>
<div class="paragraph">
<p>After selecting a mode, use the <code>SpelParserConfiguration</code> to configure the parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
        <span class="local-variable">this</span>.getClass().getClassLoader());

SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);

<span class="predefined-type">Expression</span> expr = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">payload</span><span class="delimiter">&quot;</span></span>);

MyMessage message = <span class="keyword">new</span> MyMessage();

<span class="predefined-type">Object</span> payload = expr.getValue(message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When specifying the compiler mode it is also possible to specify a classloader (passing null is allowed).
Compiled expressions will be defined in a child classloader created under any that is supplied.
It is important to ensure if a classloader is specified it can see all the types involved in
the expression evaluation process.
If none is specified then a default classloader will be used (typically the context classloader for
the thread that is running during expression evaluation).</p>
</div>
<div class="paragraph">
<p>The second way to configure the compiler is for use when SpEL is embedded inside some other
component and it may not be possible to configure via a configuration object.
In these cases it is possible to use a system property. The property
<code>spring.expression.compiler.mode</code> can be set to one of the <code>SpelCompilerMode</code>
enum values (<code>off</code>, <code>immediate</code>, or <code>mixed</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-compiler-limitations"><a class="anchor" href="#expressions-compiler-limitations"></a>Compiler limitations</h5>
<div class="paragraph">
<p>With Spring Framework 4.1 the basic compilation framework is in place. However, the framework does not
yet support compiling every kind of expression. The initial focus has been on the common expressions that are
likely to be used in performance critical contexts. These kinds of expression cannot be compiled
at the moment:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>expressions involving assignment</p>
</li>
<li>
<p>expressions relying on the conversion service</p>
</li>
<li>
<p>expressions using custom resolvers or accessors</p>
</li>
<li>
<p>expressions using selection or projection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>More and more types of expression will be compilable in the future.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-beandef"><a class="anchor" href="#expressions-beandef"></a>4.4. Expression support for defining bean definitions</h3>
<div class="paragraph">
<p>SpEL expressions can be used with XML or annotation-based configuration metadata for
defining <code>BeanDefinition</code>s. In both cases the syntax to define the expression is of the
form <code>#{ &lt;expression string&gt; }</code>.</p>
</div>
<div class="sect3">
<h4 id="expressions-beandef-xml-based"><a class="anchor" href="#expressions-beandef-xml-based"></a>4.4.1. XML based configuration</h4>
<div class="paragraph">
<p>A property or constructor-arg value can be set using expressions as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">numberGuess</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.NumberGuess</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">randomNumber</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ T(java.lang.Math).random() * 100.0 }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable <code>systemProperties</code> is predefined, so you can use it in your expressions as
shown below. Note that you do not have to prefix the predefined variable with the <code>#</code>
symbol in this context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">taxCalculator</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.TaxCalculator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">defaultLocale</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also refer to other bean properties by name, for example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">numberGuess</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.NumberGuess</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">randomNumber</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ T(java.lang.Math).random() * 100.0 }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">shapeGuess</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.spring.samples.ShapeGuess</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialShapeSeed</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ numberGuess.randomNumber }</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- other properties --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-beandef-annotation-based"><a class="anchor" href="#expressions-beandef-annotation-based"></a>4.4.2. Annotation-based configuration</h4>
<div class="paragraph">
<p>The <code>@Value</code> annotation can be placed on fields, methods and method/constructor
parameters to specify a default value.</p>
</div>
<div class="paragraph">
<p>Here is an example to set the default value of a field variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">FieldValueTestBean</span>

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="directive">public</span> <span class="type">void</span> setDefaultLocale(<span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getDefaultLocale() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.defaultLocale;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent but on a property setter method is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">PropertyValueTestBean</span>

        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> setDefaultLocale(<span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getDefaultLocale() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.defaultLocale;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Autowired methods and constructors can also use the <code>@Value</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleMovieLister</span> {

        <span class="directive">private</span> MovieFinder movieFinder;
        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> <span class="type">void</span> configure(MovieFinder movieFinder,
                        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{ systemProperties['user.region'] }</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.movieFinder = movieFinder;
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MovieRecommender</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> defaultLocale;

        <span class="directive">private</span> CustomerPreferenceDao customerPreferenceDao;

        <span class="annotation">@Autowired</span>
        <span class="directive">public</span> MovieRecommender(CustomerPreferenceDao customerPreferenceDao,
                        <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{systemProperties['user.country']}</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> defaultLocale) {
                <span class="local-variable">this</span>.customerPreferenceDao = customerPreferenceDao;
                <span class="local-variable">this</span>.defaultLocale = defaultLocale;
        }

        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-language-ref"><a class="anchor" href="#expressions-language-ref"></a>4.5. Language Reference</h3>
<div class="sect3">
<h4 id="expressions-ref-literal"><a class="anchor" href="#expressions-ref-literal"></a>4.5.1. Literal expressions</h4>
<div class="paragraph">
<p>The types of literal expressions supported are strings, numeric values (int, real, hex),
boolean and null. Strings are delimited by single quotes. To put a single quote itself
in a string, use two single quote characters.</p>
</div>
<div class="paragraph">
<p>The following listing shows simple usage of literals. Typically they would not be used
in isolation like this but rather as part of a more complex expression, for example
using a literal on one side of a logical comparison operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// evals to &quot;Hello World&quot;</span>
<span class="predefined-type">String</span> helloWorld = (<span class="predefined-type">String</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">'Hello World'</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="type">double</span> avogadrosNumber = (<span class="predefined-type">Double</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">6.0221415E+23</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="comment">// evals to 2147483647</span>
<span class="type">int</span> maxValue = (<span class="predefined-type">Integer</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">0x7FFFFFFF</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="type">boolean</span> trueValue = (<span class="predefined-type">Boolean</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>).getValue();

<span class="predefined-type">Object</span> nullValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">null</span><span class="delimiter">&quot;</span></span>).getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numbers support the use of the negative sign, exponential notation, and decimal points.
By default real numbers are parsed using Double.parseDouble().</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-properties-arrays"><a class="anchor" href="#expressions-properties-arrays"></a>4.5.2. Properties, Arrays, Lists, Maps, Indexers</h4>
<div class="paragraph">
<p>Navigating with property references is easy: just use a period to indicate a nested
property value. The instances of the <code>Inventor</code> class, pupin, and tesla, were populated with
data listed in the section <a href="#expressions-example-classes">Classes used in the examples</a>.
To navigate "down" and get Tesla&#8217;s year of birth and Pupin&#8217;s city of birth the following
expressions are used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evals to 1856</span>
<span class="type">int</span> year = (<span class="predefined-type">Integer</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Birthdate.Year + 1900</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">String</span> city = (<span class="predefined-type">String</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">placeOfBirth.City</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Case insensitivity is allowed for the first letter of property names. The contents of
arrays and lists are obtained using square bracket notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="comment">// Inventions Array</span>
StandardEvaluationContext teslaContext = <span class="keyword">new</span> StandardEvaluationContext(tesla);

<span class="comment">// evaluates to &quot;Induction motor&quot;</span>
<span class="predefined-type">String</span> invention = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">inventions[3]</span><span class="delimiter">&quot;</span></span>).getValue(
                teslaContext, <span class="predefined-type">String</span>.class);

<span class="comment">// Members List</span>
StandardEvaluationContext societyContext = <span class="keyword">new</span> StandardEvaluationContext(ieee);

<span class="comment">// evaluates to &quot;Nikola Tesla&quot;</span>
<span class="predefined-type">String</span> name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Members[0].Name</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">String</span>.class);

<span class="comment">// List and Array navigation</span>
<span class="comment">// evaluates to &quot;Wireless communication&quot;</span>
<span class="predefined-type">String</span> invention = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Members[0].Inventions[6]</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The contents of maps are obtained by specifying the literal key value within the
brackets. In this case, because keys for the Officers map are strings, we can specify
string literals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Officer's Dictionary</span>

Inventor pupin = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Officers['president']</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, Inventor.class);

<span class="comment">// evaluates to &quot;Idvor&quot;</span>
<span class="predefined-type">String</span> city = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Officers['president'].PlaceOfBirth.City</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">String</span>.class);

<span class="comment">// setting values</span>
parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Officers['advisors'][0].PlaceOfBirth.Country</span><span class="delimiter">&quot;</span></span>).setValue(
                societyContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">Croatia</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-lists"><a class="anchor" href="#expressions-inline-lists"></a>4.5.3. Inline lists</h4>
<div class="paragraph">
<p>Lists can be expressed directly in an expression using <code>{}</code> notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to a Java list containing the four numbers</span>
<span class="predefined-type">List</span> numbers = (<span class="predefined-type">List</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{1,2,3,4}</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">List</span> listOfLists = (<span class="predefined-type">List</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{{'a','b'},{'x','y'}}</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{}</code> by itself means an empty list. For performance reasons, if the list is itself
entirely composed of fixed literals then a constant list is created to represent the
expression, rather than building a new list on each evaluation.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-maps"><a class="anchor" href="#expressions-inline-maps"></a>4.5.4. Inline Maps</h4>
<div class="paragraph">
<p>Maps can also be expressed directly in an expression using <code>{key:value}</code> notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to a Java map containing the two entries</span>
<span class="predefined-type">Map</span> inventorInfo = (<span class="predefined-type">Map</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{name:'Nikola',dob:'10-July-1856'}</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">Map</span> mapOfMaps = (<span class="predefined-type">Map</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{:}</code> by itself means an empty map. For performance reasons, if the map is itself composed
of fixed literals or other nested constant structures (lists or maps) then a constant map is created
to represent the expression, rather than building a new map on each evaluation. Quoting of the map keys
is optional, the examples above are not using quoted keys.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-array-construction"><a class="anchor" href="#expressions-array-construction"></a>4.5.5. Array construction</h4>
<div class="paragraph">
<p>Arrays can be built using the familiar Java syntax, optionally supplying an initializer
to have the array populated at construction time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span><span class="type">[]</span> numbers1 = (<span class="type">int</span><span class="type">[]</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">new int[4]</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="comment">// Array with initializer</span>
<span class="type">int</span><span class="type">[]</span> numbers2 = (<span class="type">int</span><span class="type">[]</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">new int[]{1,2,3}</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="comment">// Multi dimensional array</span>
<span class="type">int</span><span class="type">[]</span><span class="type">[]</span> numbers3 = (<span class="type">int</span><span class="type">[]</span><span class="type">[]</span>) parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">new int[4][5]</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is not currently allowed to supply an initializer when constructing a
multi-dimensional array.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-methods"><a class="anchor" href="#expressions-methods"></a>4.5.6. Methods</h4>
<div class="paragraph">
<p>Methods are invoked using typical Java programming syntax. You may also invoke methods
on literals. Varargs are also supported.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// string literal, evaluates to &quot;bc&quot;</span>
<span class="predefined-type">String</span> c = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">'abc'.substring(2, 3)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class);

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> isMember = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Mihajlo Pupin')</span><span class="delimiter">&quot;</span></span>).getValue(
                societyContext, <span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operators"><a class="anchor" href="#expressions-operators"></a>4.5.7. Operators</h4>
<div class="sect4">
<h5 id="expressions-operators-relational"><a class="anchor" href="#expressions-operators-relational"></a>Relational operators</h5>
<div class="paragraph">
<p>The relational operators; equal, not equal, less than, less than or equal, greater than,
and greater than or equal are supported using standard operator notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">2 == 2</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">2 &lt; -5.0</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">'black' &lt; 'block'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Greater/less-than comparisons against <code>null</code> follow a simple rule: <code>null</code> is treated as
nothing here (i.e. NOT as zero). As a consequence, any other value is always greater
than <code>null</code> (<code>X &gt; null</code> is always <code>true</code>) and no other value is ever less than nothing
(<code>X &lt; null</code> is always <code>false</code>).</p>
</div>
<div class="paragraph">
<p>If you prefer numeric comparisons instead, please avoid number-based <code>null</code> comparisons
in favor of comparisons against zero (e.g. <code>X &gt; 0</code> or <code>X &lt; 0</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to standard relational operators SpEL supports the <code>instanceof</code> and regular
expression based <code>matches</code> operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'xyz' instanceof T(Integer)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'5.00' matches '</span><span class="content">\^</span><span class="content">-?</span><span class="char">\\</span><span class="content">d+(</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d{2})?$'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">//evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'5.0067' matches '</span><span class="content">\^</span><span class="content">-?</span><span class="char">\\</span><span class="content">d+(</span><span class="char">\\</span><span class="content">.</span><span class="char">\\</span><span class="content">d{2})?$'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Be careful with primitive types as they are immediately boxed up to the wrapper type,
so <code>1 instanceof T(int)</code> evaluates to <code>false</code> while <code>1 instanceof T(Integer)</code>
evaluates to <code>true</code>, as expected.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each symbolic operator can also be specified as a purely alphabetic equivalent. This
avoids problems where the symbols used have special meaning for the document type in
which the expression is embedded (eg. an XML document). The textual equivalents are
shown here: <code>lt</code> (<code>&lt;</code>), <code>gt</code> (<code>&gt;</code>), <code>le</code> (<code>&#8656;</code>), <code>ge</code> (<code>&gt;=</code>), <code>eq</code> (<code>==</code>),
<code>ne</code> (<code>!=</code>), <code>div</code> (<code>/</code>), <code>mod</code> (<code>%</code>), <code>not</code> (<code>!</code>). These are case insensitive.</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-logical"><a class="anchor" href="#expressions-operators-logical"></a>Logical operators</h5>
<div class="paragraph">
<p>The logical operators that are supported are and, or, and not. Their use is demonstrated
below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// -- AND --</span>

<span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">true and false</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Nikola Tesla') and isMember('Mihajlo Pupin')</span><span class="delimiter">&quot;</span></span>;
<span class="type">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, <span class="predefined-type">Boolean</span>.class);

<span class="comment">// -- OR --</span>

<span class="comment">// evaluates to true</span>
<span class="type">boolean</span> trueValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">true or false</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// evaluates to true</span>
<span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Nikola Tesla') or isMember('Albert Einstein')</span><span class="delimiter">&quot;</span></span>;
<span class="type">boolean</span> trueValue = parser.parseExpression(expression).getValue(societyContext, <span class="predefined-type">Boolean</span>.class);

<span class="comment">// -- NOT --</span>

<span class="comment">// evaluates to false</span>
<span class="type">boolean</span> falseValue = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">!true</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Boolean</span>.class);

<span class="comment">// -- AND and NOT --</span>
<span class="predefined-type">String</span> expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')</span><span class="delimiter">&quot;</span></span>;
<span class="type">boolean</span> falseValue = parser.parseExpression(expression).getValue(societyContext, <span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-mathematical"><a class="anchor" href="#expressions-operators-mathematical"></a>Mathematical operators</h5>
<div class="paragraph">
<p>The addition operator can be used on both numbers and strings. Subtraction, multiplication
and division can be used only on numbers. Other mathematical operators supported are
modulus (%) and exponential power (^). Standard operator precedence is enforced. These
operators are demonstrated below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Addition</span>
<span class="type">int</span> two = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1 + 1</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 2</span>

<span class="predefined-type">String</span> testString = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">'test' + ' ' + 'string'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class); <span class="comment">// 'test string'</span>

<span class="comment">// Subtraction</span>
<span class="type">int</span> four = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1 - -3</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 4</span>

<span class="type">double</span> d = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1000.00 - 1e4</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Double</span>.class); <span class="comment">// -9000</span>

<span class="comment">// Multiplication</span>
<span class="type">int</span> six = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">-2 * -3</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 6</span>

<span class="type">double</span> twentyFour = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">2.0 * 3e0 * 4</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Double</span>.class); <span class="comment">// 24.0</span>

<span class="comment">// Division</span>
<span class="type">int</span> minusTwo = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">6 / -3</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// -2</span>

<span class="type">double</span> one = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">8.0 / 4e0 / 2</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Double</span>.class); <span class="comment">// 1.0</span>

<span class="comment">// Modulus</span>
<span class="type">int</span> three = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">7 % 4</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 3</span>

<span class="type">int</span> one = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">8 / 5 % 2</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// 1</span>

<span class="comment">// Operator precedence</span>
<span class="type">int</span> minusTwentyOne = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">1+2-3*8</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Integer</span>.class); <span class="comment">// -21</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-assignment"><a class="anchor" href="#expressions-assignment"></a>4.5.8. Assignment</h4>
<div class="paragraph">
<p>Setting of a property is done by using the assignment operator. This would typically be
done within a call to <code>setValue</code> but can also be done inside a call to <code>getValue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor inventor = <span class="keyword">new</span> Inventor();
StandardEvaluationContext inventorContext = <span class="keyword">new</span> StandardEvaluationContext(inventor);

parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name</span><span class="delimiter">&quot;</span></span>).setValue(inventorContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">Alexander Seovic2</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// alternatively</span>

<span class="predefined-type">String</span> aleks = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Name = 'Alexandar Seovic'</span><span class="delimiter">&quot;</span></span>).getValue(inventorContext, <span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-types"><a class="anchor" href="#expressions-types"></a>4.5.9. Types</h4>
<div class="paragraph">
<p>The special <code>T</code> operator can be used to specify an instance of java.lang.Class (the
<em>type</em>). Static methods are invoked using this operator as well. The
<code>StandardEvaluationContext</code> uses a <code>TypeLocator</code> to find types and the
<code>StandardTypeLocator</code> (which can be replaced) is built with an understanding of the
java.lang package. This means T() references to types within java.lang do not need to be
fully qualified, but all other type references must be.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Class</span> dateClass = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">T(java.util.Date)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Class</span>.class);

<span class="predefined-type">Class</span> stringClass = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">T(String)</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">Class</span>.class);

<span class="type">boolean</span> trueValue = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR</span><span class="delimiter">&quot;</span></span>)
                .getValue(<span class="predefined-type">Boolean</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-constructors"><a class="anchor" href="#expressions-constructors"></a>4.5.10. Constructors</h4>
<div class="paragraph">
<p>Constructors can be invoked using the new operator. The fully qualified class name
should be used for all but the primitive type and String (where int, float, etc, can be
used).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor einstein = p.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')</span><span class="delimiter">&quot;</span></span>)
                .getValue(Inventor.class);

<span class="comment">//create new inventor instance within add method of List</span>
p.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Members.add(new org.spring.samples.spel.inventor.Inventor(
                        'Albert Einstein', 'German'))</span><span class="delimiter">&quot;</span></span>).getValue(societyContext);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-variables"><a class="anchor" href="#expressions-ref-variables"></a>4.5.11. Variables</h4>
<div class="paragraph">
<p>Variables can be referenced in the expression using the syntax <code>#variableName</code>. Variables
are set using the method setVariable on the <code>StandardEvaluationContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);
context.setVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">newName</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Mike Tesla</span><span class="delimiter">&quot;</span></span>);

parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name = #newName</span><span class="delimiter">&quot;</span></span>).getValue(context);

<span class="predefined-type">System</span>.out.println(tesla.getName()) <span class="comment">// &quot;Mike Tesla&quot;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="expressions-this-root"><a class="anchor" href="#expressions-this-root"></a>The #this and #root variables</h5>
<div class="paragraph">
<p>The variable #this is always defined and refers to the current evaluation object
(against which unqualified references are resolved). The variable #root is always
defined and refers to the root context object. Although #this may vary as components of
an expression are evaluated, #root always refers to the root.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// create an array of integers</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; primes = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Integer</span>&gt;();
primes.addAll(<span class="predefined-type">Arrays</span>.asList(<span class="integer">2</span>,<span class="integer">3</span>,<span class="integer">5</span>,<span class="integer">7</span>,<span class="integer">11</span>,<span class="integer">13</span>,<span class="integer">17</span>));

<span class="comment">// create parser and set variable 'primes' as the array of integers</span>
ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();
context.setVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">primes</span><span class="delimiter">&quot;</span></span>,primes);

<span class="comment">// all prime numbers &gt; 10 from the list (using selection ?{...})</span>
<span class="comment">// evaluates to [11, 13, 17]</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; primesGreaterThanTen = (<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt;) parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">#primes.?[#this&gt;10]</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-functions"><a class="anchor" href="#expressions-ref-functions"></a>4.5.12. Functions</h4>
<div class="paragraph">
<p>You can extend SpEL by registering user defined functions that can be called within the
expression string. The function is registered with the <code>StandardEvaluationContext</code> using
the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> registerFunction(<span class="predefined-type">String</span> name, <span class="predefined-type">Method</span> m)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A reference to a Java Method provides the implementation of the function. For example, a
utility method to reverse a string is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">StringUtils</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> reverseString(<span class="predefined-type">String</span> input) {
                <span class="predefined-type">StringBuilder</span> backwards = <span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>();
                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; input.length(); i++)
                        backwards.append(input.charAt(input.length() - <span class="integer">1</span> - i));
                }
                <span class="keyword">return</span> backwards.toString();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method is then registered with the evaluation context and can be used within an
expression string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();

context.registerFunction(<span class="string"><span class="delimiter">&quot;</span><span class="content">reverseString</span><span class="delimiter">&quot;</span></span>,
        StringUtils.class.getDeclaredMethod(<span class="string"><span class="delimiter">&quot;</span><span class="content">reverseString</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">Class</span><span class="type">[]</span> { <span class="predefined-type">String</span>.class }));

<span class="predefined-type">String</span> helloWorldReversed = parser.parseExpression(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">#reverseString('hello')</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-bean-references"><a class="anchor" href="#expressions-bean-references"></a>4.5.13. Bean references</h4>
<div class="paragraph">
<p>If the evaluation context has been configured with a bean resolver it is possible to
lookup beans from an expression using the (@) symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();
context.setBeanResolver(<span class="keyword">new</span> MyBeanResolver());

<span class="comment">// This will end up calling resolve(context,&quot;foo&quot;) on MyBeanResolver during evaluation</span>
<span class="predefined-type">Object</span> bean = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">@foo</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To access a factory bean itself, the bean name should instead be prefixed with a (&amp;) symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();
context.setBeanResolver(<span class="keyword">new</span> MyBeanResolver());

<span class="comment">// This will end up calling resolve(context,&quot;&amp;foo&quot;) on MyBeanResolver during evaluation</span>
<span class="predefined-type">Object</span> bean = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">&amp;foo</span><span class="delimiter">&quot;</span></span>).getValue(context);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-ternary"><a class="anchor" href="#expressions-operator-ternary"></a>4.5.14. Ternary Operator (If-Then-Else)</h4>
<div class="paragraph">
<p>You can use the ternary operator for performing if-then-else conditional logic inside
the expression. A minimal example is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> falseString = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">false ? 'trueExp' : 'falseExp'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the boolean false results in returning the string value 'falseExp'. A more
realistic example is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name</span><span class="delimiter">&quot;</span></span>).setValue(societyContext, <span class="string"><span class="delimiter">&quot;</span><span class="content">IEEE</span><span class="delimiter">&quot;</span></span>);
societyContext.setVariable(<span class="string"><span class="delimiter">&quot;</span><span class="content">queryName</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>);

expression = <span class="string"><span class="delimiter">&quot;</span><span class="content">isMember(#queryName)? #queryName + ' is a member of the ' </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'</span><span class="delimiter">&quot;</span></span>;

<span class="predefined-type">String</span> queryResultString = parser.parseExpression(expression)
                .getValue(societyContext, <span class="predefined-type">String</span>.class);
<span class="comment">// queryResultString = &quot;Nikola Tesla is a member of the IEEE Society&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Also see the next section on the Elvis operator for an even shorter syntax for the
ternary operator.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-elvis"><a class="anchor" href="#expressions-operator-elvis"></a>4.5.15. The Elvis Operator</h4>
<div class="paragraph">
<p>The Elvis operator is a shortening of the ternary operator syntax and is used in the
<a href="http://www.groovy-lang.org/operators.html#_elvis_operator">Groovy</a> language.
With the ternary operator syntax you usually have to repeat a variable twice, for
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="predefined-type">String</span> name = <span class="string"><span class="delimiter">&quot;</span><span class="content">Elvis Presley</span><span class="delimiter">&quot;</span></span>;
<span class="predefined-type">String</span> displayName = name != <span class="predefined-constant">null</span> ? name : <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown</span><span class="delimiter">&quot;</span></span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead you can use the Elvis operator, named for the resemblance to Elvis' hair style.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

<span class="predefined-type">String</span> name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">name?:'Unknown'</span><span class="delimiter">&quot;</span></span>).getValue(<span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(name); <span class="comment">// 'Unknown'</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a more complex example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);
StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);

<span class="predefined-type">String</span> name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name?:'Elvis Presley'</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(name); <span class="comment">// Nikola Tesla</span>

tesla.setName(<span class="predefined-constant">null</span>);

name = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Name?:'Elvis Presley'</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(name); <span class="comment">// Elvis Presley</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-safe-navigation"><a class="anchor" href="#expressions-operator-safe-navigation"></a>4.5.16. Safe Navigation operator</h4>
<div class="paragraph">
<p>The Safe Navigation operator is used to avoid a <code>NullPointerException</code> and comes from
the <a href="http://www.groovy-lang.org/operators.html#_safe_navigation_operator">Groovy</a>
language. Typically when you have a reference to an object you might need to verify that
it is not null before accessing methods or properties of the object. To avoid this, the
safe navigation operator will simply return null instead of throwing an exception.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();

Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string"><span class="delimiter">&quot;</span><span class="content">Nikola Tesla</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Serbian</span><span class="delimiter">&quot;</span></span>);
tesla.setPlaceOfBirth(<span class="keyword">new</span> PlaceOfBirth(<span class="string"><span class="delimiter">&quot;</span><span class="content">Smiljan</span><span class="delimiter">&quot;</span></span>));

StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);

<span class="predefined-type">String</span> city = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">PlaceOfBirth?.City</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);
<span class="predefined-type">System</span>.out.println(city); <span class="comment">// Smiljan</span>

tesla.setPlaceOfBirth(<span class="predefined-constant">null</span>);

city = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">PlaceOfBirth?.City</span><span class="delimiter">&quot;</span></span>).getValue(context, <span class="predefined-type">String</span>.class);

<span class="predefined-type">System</span>.out.println(city); <span class="comment">// null - does not throw NullPointerException!!!</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Elvis operator can be used to apply default values in expressions, e.g. in an
<code>@Value</code> expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{systemProperties['pop3.port'] ?: 25}</span><span class="delimiter">&quot;</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will inject a system property <code>pop3.port</code> if it is defined or 25 if not.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-selection"><a class="anchor" href="#expressions-collection-selection"></a>4.5.17. Collection Selection</h4>
<div class="paragraph">
<p>Selection is a powerful expression language feature that allows you to transform some
source collection into another by selecting from its entries.</p>
</div>
<div class="paragraph">
<p>Selection uses the syntax <code>.?[selectionExpression]</code>. This will filter the collection and
return a new collection containing a subset of the original elements. For example,
selection would allow us to easily get a list of Serbian inventors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Inventor&gt; list = (<span class="predefined-type">List</span>&lt;Inventor&gt;) parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">Members.?[Nationality == 'Serbian']</span><span class="delimiter">&quot;</span></span>).getValue(societyContext);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Selection is possible upon both lists and maps. In the former case the selection
criteria is evaluated against each individual list element whilst against a map the
selection criteria is evaluated against each map entry (objects of the Java type
<code>Map.Entry</code>). Map entries have their key and value accessible as properties for use in
the selection.</p>
</div>
<div class="paragraph">
<p>This expression will return a new map consisting of those elements of the original map
where the entry value is less than 27.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Map</span> newMap = parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">map.?[value&lt;27]</span><span class="delimiter">&quot;</span></span>).getValue();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to returning all the selected elements, it is possible to retrieve just the
first or the last value. To obtain the first entry matching the selection the syntax is
<code>^[&#8230;&#8203;]</code> whilst to obtain the last matching selection the syntax is <code>$[&#8230;&#8203;]</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-projection"><a class="anchor" href="#expressions-collection-projection"></a>4.5.18. Collection Projection</h4>
<div class="paragraph">
<p>Projection allows a collection to drive the evaluation of a sub-expression and the
result is a new collection. The syntax for projection is <code>![projectionExpression]</code>. Most
easily understood by example, suppose we have a list of inventors but want the list of
cities where they were born. Effectively we want to evaluate 'placeOfBirth.city' for
every entry in the inventor list. Using projection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// returns ['Smiljan', 'Idvor' ]</span>
<span class="predefined-type">List</span> placesOfBirth = (<span class="predefined-type">List</span>)parser.parseExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">Members.![placeOfBirth.city]</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A map can also be used to drive projection and in this case the projection expression is
evaluated against each entry in the map (represented as a Java <code>Map.Entry</code>). The result
of a projection across a map is a list consisting of the evaluation of the projection
expression against each map entry.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-templating"><a class="anchor" href="#expressions-templating"></a>4.5.19. Expression templating</h4>
<div class="paragraph">
<p>Expression templates allow a mixing of literal text with one or more evaluation blocks.
Each evaluation block is delimited with prefix and suffix characters that you can
define, a common choice is to use <code>#{ }</code> as the delimiters. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> randomPhrase = parser.parseExpression(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">random number is #{T(java.lang.Math).random()}</span><span class="delimiter">&quot;</span></span>,
                <span class="keyword">new</span> TemplateParserContext()).getValue(<span class="predefined-type">String</span>.class);

<span class="comment">// evaluates to &quot;random number is 0.7038186818312008&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The string is evaluated by concatenating the literal text 'random number is ' with the
result of evaluating the expression inside the #{ } delimiter, in this case the result
of calling that random() method. The second argument to the method <code>parseExpression()</code>
is of the type <code>ParserContext</code>. The <code>ParserContext</code> interface is used to influence how
the expression is parsed in order to support the expression templating functionality.
The definition of <code>TemplateParserContext</code> is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TemplateParserContext</span> <span class="directive">implements</span> ParserContext {

        <span class="directive">public</span> <span class="predefined-type">String</span> getExpressionPrefix() {
                <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">#{</span><span class="delimiter">&quot;</span></span>;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getExpressionSuffix() {
                <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;
        }

        <span class="directive">public</span> <span class="type">boolean</span> isTemplate() {
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-example-classes"><a class="anchor" href="#expressions-example-classes"></a>4.6. Classes used in the examples</h3>
<div class="paragraph">
<p>Inventor.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span>;

<span class="keyword">import</span> <span class="include">java.util.Date</span>;
<span class="keyword">import</span> <span class="include">java.util.GregorianCalendar</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Inventor</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;
        <span class="directive">private</span> <span class="predefined-type">String</span> nationality;
        <span class="directive">private</span> <span class="predefined-type">String</span><span class="type">[]</span> inventions;
        <span class="directive">private</span> <span class="predefined-type">Date</span> birthdate;
        <span class="directive">private</span> PlaceOfBirth placeOfBirth;

        <span class="directive">public</span> Inventor(<span class="predefined-type">String</span> name, <span class="predefined-type">String</span> nationality) {
                <span class="predefined-type">GregorianCalendar</span> c= <span class="keyword">new</span> <span class="predefined-type">GregorianCalendar</span>();
                <span class="local-variable">this</span>.name = name;
                <span class="local-variable">this</span>.nationality = nationality;
                <span class="local-variable">this</span>.birthdate = c.getTime();
        }

        <span class="directive">public</span> Inventor(<span class="predefined-type">String</span> name, <span class="predefined-type">Date</span> birthdate, <span class="predefined-type">String</span> nationality) {
                <span class="local-variable">this</span>.name = name;
                <span class="local-variable">this</span>.nationality = nationality;
                <span class="local-variable">this</span>.birthdate = birthdate;
        }

        <span class="directive">public</span> Inventor() {
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getNationality() {
                <span class="keyword">return</span> nationality;
        }

        <span class="directive">public</span> <span class="type">void</span> setNationality(<span class="predefined-type">String</span> nationality) {
                <span class="local-variable">this</span>.nationality = nationality;
        }

        <span class="directive">public</span> <span class="predefined-type">Date</span> getBirthdate() {
                <span class="keyword">return</span> birthdate;
        }

        <span class="directive">public</span> <span class="type">void</span> setBirthdate(<span class="predefined-type">Date</span> birthdate) {
                <span class="local-variable">this</span>.birthdate = birthdate;
        }

        <span class="directive">public</span> PlaceOfBirth getPlaceOfBirth() {
                <span class="keyword">return</span> placeOfBirth;
        }

        <span class="directive">public</span> <span class="type">void</span> setPlaceOfBirth(PlaceOfBirth placeOfBirth) {
                <span class="local-variable">this</span>.placeOfBirth = placeOfBirth;
        }

        <span class="directive">public</span> <span class="type">void</span> setInventions(<span class="predefined-type">String</span><span class="type">[]</span> inventions) {
                <span class="local-variable">this</span>.inventions = inventions;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span><span class="type">[]</span> getInventions() {
                <span class="keyword">return</span> inventions;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>PlaceOfBirth.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">PlaceOfBirth</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> city;
        <span class="directive">private</span> <span class="predefined-type">String</span> country;

        <span class="directive">public</span> PlaceOfBirth(<span class="predefined-type">String</span> city) {
                <span class="local-variable">this</span>.city=city;
        }

        <span class="directive">public</span> PlaceOfBirth(<span class="predefined-type">String</span> city, <span class="predefined-type">String</span> country) {
                <span class="local-variable">this</span>(city);
                <span class="local-variable">this</span>.country = country;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getCity() {
                <span class="keyword">return</span> city;
        }

        <span class="directive">public</span> <span class="type">void</span> setCity(<span class="predefined-type">String</span> s) {
                <span class="local-variable">this</span>.city = s;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getCountry() {
                <span class="keyword">return</span> country;
        }

        <span class="directive">public</span> <span class="type">void</span> setCountry(<span class="predefined-type">String</span> country) {
                <span class="local-variable">this</span>.country = country;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Society.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.spring.samples.spel.inventor</span>;

<span class="keyword">import</span> <span class="include">java.util</span>.*;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Society</span> {

        <span class="directive">private</span> <span class="predefined-type">String</span> name;

        <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> Advisors = <span class="string"><span class="delimiter">&quot;</span><span class="content">advisors</span><span class="delimiter">&quot;</span></span>;
        <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> President = <span class="string"><span class="delimiter">&quot;</span><span class="content">president</span><span class="delimiter">&quot;</span></span>;

        <span class="directive">private</span> <span class="predefined-type">List</span>&lt;Inventor&gt; members = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;Inventor&gt;();
        <span class="directive">private</span> <span class="predefined-type">Map</span> officers = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>();

        <span class="directive">public</span> <span class="predefined-type">List</span> getMembers() {
                <span class="keyword">return</span> members;
        }

        <span class="directive">public</span> <span class="predefined-type">Map</span> getOfficers() {
                <span class="keyword">return</span> officers;
        }

        <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
                <span class="keyword">return</span> name;
        }

        <span class="directive">public</span> <span class="type">void</span> setName(<span class="predefined-type">String</span> name) {
                <span class="local-variable">this</span>.name = name;
        }

        <span class="directive">public</span> <span class="type">boolean</span> isMember(<span class="predefined-type">String</span> name) {
                <span class="keyword">for</span> (Inventor inventor : members) {
                        <span class="keyword">if</span> (inventor.getName().equals(name)) {
                                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
                        }
                }
                <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop"><a class="anchor" href="#aop"></a>5. Aspect Oriented Programming with Spring</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="aop-introduction"><a class="anchor" href="#aop-introduction"></a>5.1. Introduction</h3>
<div class="paragraph">
<p><em>Aspect-Oriented Programming</em> (AOP) complements Object-Oriented Programming (OOP) by
providing another way of thinking about program structure. The key unit of modularity in
OOP is the class, whereas in AOP the unit of modularity is the <em>aspect</em>. Aspects
enable the modularization of concerns such as transaction management that cut across
multiple types and objects. (Such concerns are often termed <em>crosscutting</em> concerns in
AOP literature.)</p>
</div>
<div class="paragraph">
<p>One of the key components of Spring is the <em>AOP framework</em>. While the Spring IoC
container does not depend on AOP, meaning you do not need to use AOP if you don&#8217;t want
to, AOP complements Spring IoC to provide a very capable middleware solution.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Spring 2.0 AOP</div>
<div class="paragraph">
<p>Spring 2.0 introduces a simpler and more powerful way of writing custom aspects using
either a <a href="#aop-schema">schema-based approach</a> or the <a href="#aop-ataspectj">@AspectJ annotation
style</a>. Both of these styles offer fully typed advice and use of the AspectJ pointcut
language, while still using Spring AOP for weaving.</p>
</div>
<div class="paragraph">
<p>The Spring 2.0 schema- and @AspectJ-based AOP support is discussed in this chapter.
Spring 2.0 AOP remains fully backwards compatible with Spring 1.2 AOP, and the
lower-level AOP support offered by the Spring 1.2 APIs is discussed in <a href="#aop-api">the
following chapter</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>AOP is used in the Spring Framework to&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203; provide declarative enterprise services, especially as a replacement for EJB
declarative services. The most important such service is
<a href="#transaction-declarative"><em>declarative transaction management</em></a>.</p>
</li>
<li>
<p>&#8230;&#8203; allow users to implement custom aspects, complementing their use of OOP with AOP.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are interested only in generic declarative services or other pre-packaged
declarative middleware services such as pooling, you do not need to work directly with
Spring AOP, and can skip most of this chapter.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-introduction-defn"><a class="anchor" href="#aop-introduction-defn"></a>5.1.1. AOP concepts</h4>
<div class="paragraph">
<p>Let us begin by defining some central AOP concepts and terminology. These terms are not
Spring-specific&#8230;&#8203; unfortunately, AOP terminology is not particularly intuitive;
however, it would be even more confusing if Spring used its own terminology.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Aspect</em>: a modularization of a concern that cuts across multiple classes.
Transaction management is a good example of a crosscutting concern in enterprise Java
applications. In Spring AOP, aspects are implemented using regular classes
(the <a href="#aop-schema">schema-based approach</a>) or regular classes annotated with the
<code>@Aspect</code> annotation (the <a href="#aop-ataspectj"><code>@AspectJ</code> style</a>).</p>
</li>
<li>
<p><em>Join point</em>: a point during the execution of a program, such as the execution of a
method or the handling of an exception. In Spring AOP, a join point <em>always</em>
represents a method execution.</p>
</li>
<li>
<p><em>Advice</em>: action taken by an aspect at a particular join point. Different types of
advice include "around," "before" and "after" advice. (Advice types are discussed
below.) Many AOP frameworks, including Spring, model an advice as an <em>interceptor</em>,
maintaining a chain of interceptors <em>around</em> the join point.</p>
</li>
<li>
<p><em>Pointcut</em>: a predicate that matches join points. Advice is associated with a
pointcut expression and runs at any join point matched by the pointcut (for example,
the execution of a method with a certain name). The concept of join points as matched
by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut
expression language by default.</p>
</li>
<li>
<p><em>Introduction</em>: declaring additional methods or fields on behalf of a type. Spring
AOP allows you to introduce new interfaces (and a corresponding implementation) to any
advised object. For example, you could use an introduction to make a bean implement an
<code>IsModified</code> interface, to simplify caching. (An introduction is known as an
inter-type declaration in the AspectJ community.)</p>
</li>
<li>
<p><em>Target object</em>: object being advised by one or more aspects. Also referred to as
the <em>advised</em> object. Since Spring AOP is implemented using runtime proxies, this
object will always be a <em>proxied</em> object.</p>
</li>
<li>
<p><em>AOP proxy</em>: an object created by the AOP framework in order to implement the aspect
contracts (advise method executions and so on). In the Spring Framework, an AOP proxy
will be a JDK dynamic proxy or a CGLIB proxy.</p>
</li>
<li>
<p><em>Weaving</em>: linking aspects with other application types or objects to create an
advised object. This can be done at compile time (using the AspectJ compiler, for
example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks,
performs weaving at runtime.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Types of advice:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Before advice</em>: Advice that executes before a join point, but which does not have
the ability to prevent execution flow proceeding to the join point (unless it throws
an exception).</p>
</li>
<li>
<p><em>After returning advice</em>: Advice to be executed after a join point completes
normally: for example, if a method returns without throwing an exception.</p>
</li>
<li>
<p><em>After throwing advice</em>: Advice to be executed if a method exits by throwing an
exception.</p>
</li>
<li>
<p><em>After (finally) advice</em>: Advice to be executed regardless of the means by which a
join point exits (normal or exceptional return).</p>
</li>
<li>
<p><em>Around advice</em>: Advice that surrounds a join point such as a method invocation.
This is the most powerful kind of advice. Around advice can perform custom behavior
before and after the method invocation. It is also responsible for choosing whether to
proceed to the join point or to shortcut the advised method execution by returning its
own return value or throwing an exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Around advice is the most general kind of advice. Since Spring AOP, like AspectJ,
provides a full range of advice types, we recommend that you use the least powerful
advice type that can implement the required behavior. For example, if you need only to
update a cache with the return value of a method, you are better off implementing an
after returning advice than an around advice, although an around advice can accomplish
the same thing. Using the most specific advice type provides a simpler programming model
with less potential for errors. For example, you do not need to invoke the <code>proceed()</code>
method on the <code>JoinPoint</code> used for around advice, and hence cannot fail to invoke it.</p>
</div>
<div class="paragraph">
<p>In Spring 2.0, all advice parameters are statically typed, so that you work with advice
parameters of the appropriate type (the type of the return value from a method execution
for example) rather than <code>Object</code> arrays.</p>
</div>
<div class="paragraph">
<p>The concept of join points, matched by pointcuts, is the key to AOP which distinguishes
it from older technologies offering only interception. Pointcuts enable advice to be
targeted independently of the Object-Oriented hierarchy. For example, an around advice
providing declarative transaction management can be applied to a set of methods spanning
multiple objects (such as all business operations in the service layer).</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-introduction-spring-defn"><a class="anchor" href="#aop-introduction-spring-defn"></a>5.1.2. Spring AOP capabilities and goals</h4>
<div class="paragraph">
<p>Spring AOP is implemented in pure Java. There is no need for a special compilation
process. Spring AOP does not need to control the class loader hierarchy, and is thus
suitable for use in a Servlet container or application server.</p>
</div>
<div class="paragraph">
<p>Spring AOP currently supports only method execution join points (advising the execution
of methods on Spring beans). Field interception is not implemented, although support for
field interception could be added without breaking the core Spring AOP APIs. If you need
to advise field access and update join points, consider a language such as AspectJ.</p>
</div>
<div class="paragraph">
<p>Spring AOP&#8217;s approach to AOP differs from that of most other AOP frameworks. The aim is
not to provide the most complete AOP implementation (although Spring AOP is quite
capable); it is rather to provide a close integration between AOP implementation and
Spring IoC to help solve common problems in enterprise applications.</p>
</div>
<div class="paragraph">
<p>Thus, for example, the Spring Framework&#8217;s AOP functionality is normally used in
conjunction with the Spring IoC container. Aspects are configured using normal bean
definition syntax (although this allows powerful "autoproxying" capabilities): this is a
crucial difference from other AOP implementations. There are some things you cannot do
easily or efficiently with Spring AOP, such as advise very fine-grained objects (such as
domain objects typically): AspectJ is the best choice in such cases. However, our
experience is that Spring AOP provides an excellent solution to most problems in
enterprise Java applications that are amenable to AOP.</p>
</div>
<div class="paragraph">
<p>Spring AOP will never strive to compete with AspectJ to provide a comprehensive AOP
solution. We believe that both proxy-based frameworks like Spring AOP and full-blown
frameworks such as AspectJ are valuable, and that they are complementary, rather than in
competition. Spring seamlessly integrates Spring AOP and IoC with AspectJ, to enable
all uses of AOP to be catered for within a consistent Spring-based application
architecture. This integration does not affect the Spring AOP API or the AOP Alliance
API: Spring AOP remains backward-compatible. See <a href="#aop-api">the following chapter</a> for a
discussion of the Spring AOP APIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One of the central tenets of the Spring Framework is that of <em>non-invasiveness</em>; this
is the idea that you should not be forced to introduce framework-specific classes and
interfaces into your business/domain model. However, in some places the Spring Framework
does give you the option to introduce Spring Framework-specific dependencies into your
codebase: the rationale in giving you such options is because in certain scenarios it
might be just plain easier to read or code some specific piece of functionality in such
a way. The Spring Framework (almost) always offers you the choice though: you have the
freedom to make an informed decision as to which option best suits your particular use
case or scenario.</p>
</div>
<div class="paragraph">
<p>One such choice that is relevant to this chapter is that of which AOP framework (and
which AOP style) to choose. You have the choice of AspectJ and/or Spring AOP, and you
also have the choice of either the @AspectJ annotation-style approach or the Spring XML
configuration-style approach. The fact that this chapter chooses to introduce the
@AspectJ-style approach first should not be taken as an indication that the Spring team
favors the @AspectJ annotation-style approach over the Spring XML configuration-style.</p>
</div>
<div class="paragraph">
<p>See <a href="#aop-choosing">Choosing which AOP declaration style to use</a> for a more complete discussion of the whys and wherefores of each
style.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-introduction-proxies"><a class="anchor" href="#aop-introduction-proxies"></a>5.1.3. AOP Proxies</h4>
<div class="paragraph">
<p>Spring AOP defaults to using standard JDK <em>dynamic proxies</em> for AOP proxies. This
enables any interface (or set of interfaces) to be proxied.</p>
</div>
<div class="paragraph">
<p>Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than
interfaces. CGLIB is used by default if a business object does not implement an
interface. As it is good practice to program to interfaces rather than classes; business
classes normally will implement one or more business interfaces. It is possible to
<a href="#aop-proxying">force the use of CGLIB</a>, in those (hopefully rare) cases where you
need to advise a method that is not declared on an interface, or where you need to
pass a proxied object to a method as a concrete type.</p>
</div>
<div class="paragraph">
<p>It is important to grasp the fact that Spring AOP is <em>proxy-based</em>. See
<a href="#aop-understanding-aop-proxies">Understanding AOP proxies</a> for a thorough examination of exactly what this
implementation detail actually means.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-ataspectj"><a class="anchor" href="#aop-ataspectj"></a>5.2. @AspectJ support</h3>
<div class="paragraph">
<p>@AspectJ refers to a style of declaring aspects as regular Java classes annotated with
annotations. The @AspectJ style was introduced by the
<a href="https://www.eclipse.org/aspectj">AspectJ project</a> as part of the AspectJ 5 release. Spring
interprets the same annotations as AspectJ 5, using a library supplied by AspectJ
for pointcut parsing and matching. The AOP runtime is still pure Spring AOP though, and
there is no dependency on the AspectJ compiler or weaver.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using the AspectJ compiler and weaver enables use of the full AspectJ language, and is
discussed in <a href="#aop-using-aspectj">Using AspectJ with Spring applications</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-aspectj-support"><a class="anchor" href="#aop-aspectj-support"></a>5.2.1. Enabling @AspectJ Support</h4>
<div class="paragraph">
<p>To use @AspectJ aspects in a Spring configuration you need to enable Spring support for
configuring Spring AOP based on @AspectJ aspects, and <em>autoproxying</em> beans based on
whether or not they are advised by those aspects. By autoproxying we mean that if Spring
determines that a bean is advised by one or more aspects, it will automatically generate
a proxy for that bean to intercept method invocations and ensure that advice is executed
as needed.</p>
</div>
<div class="paragraph">
<p>The @AspectJ support can be enabled with XML or Java style configuration. In either
case you will also need to ensure that AspectJ&#8217;s <code>aspectjweaver.jar</code> library is on the
classpath of your application (version 1.6.8 or later). This library is available in the
<code>'lib'</code> directory of an AspectJ distribution or via the Maven Central repository.</p>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-java"><a class="anchor" href="#aop-enable-aspectj-java"></a>Enabling @AspectJ Support with Java configuration</h5>
<div class="paragraph">
<p>To enable @AspectJ support with Java <code>@Configuration</code> add the <code>@EnableAspectJAutoProxy</code>
annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableAspectJAutoProxy</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-xml"><a class="anchor" href="#aop-enable-aspectj-xml"></a>Enabling @AspectJ Support with XML configuration</h5>
<div class="paragraph">
<p>To enable @AspectJ support with XML based configuration use the <code>aop:aspectj-autoproxy</code>
element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy</span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This assumes that you are using schema support as described in <a href="appendix.html#xsd-configuration">XML Schema-based configuration</a>. See <a href="appendix.html#xsd-config-body-schemas-aop">the AOP schema</a>
for how to import the tags in the <code>aop</code> namespace.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-at-aspectj"><a class="anchor" href="#aop-at-aspectj"></a>5.2.2. Declaring an aspect</h4>
<div class="paragraph">
<p>With the @AspectJ support enabled, any bean defined in your application context with a
class that is an @AspectJ aspect (has the <code>@Aspect</code> annotation) will be automatically
detected by Spring and used to configure Spring AOP. The following example shows the
minimal definition required for a not-very-useful aspect:</p>
</div>
<div class="paragraph">
<p>A regular bean definition in the application context, pointing to a bean class that has
the <code>@Aspect</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.xyz.NotVeryUsefulAspect</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- configure properties of aspect here as normal --&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the <code>NotVeryUsefulAspect</code> class definition, annotated with
<code>org.aspectj.lang.annotation.Aspect</code> annotation;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.xyz</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">NotVeryUsefulAspect</span> {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aspects (classes annotated with <code>@Aspect</code>) may have methods and fields just like any
other class. They may also contain pointcut, advice, and introduction (inter-type)
declarations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Autodetecting aspects through component scanning</div>
<div class="paragraph">
<p>You may register aspect classes as regular beans in your Spring XML configuration, or
autodetect them through classpath scanning - just like any other Spring-managed bean.
However, note that the <em>@Aspect</em> annotation is <em>not</em> sufficient for autodetection in
the classpath: For that purpose, you need to add a separate <em>@Component</em> annotation
(or alternatively a custom stereotype annotation that qualifies, as per the rules of
Spring&#8217;s component scanner).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Advising aspects with other aspects?</div>
<div class="paragraph">
<p>In Spring AOP, it is <em>not</em> possible to have aspects themselves be the target of advice
from other aspects. The <em>@Aspect</em> annotation on a class marks it as an aspect, and
hence excludes it from auto-proxying.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-pointcuts"><a class="anchor" href="#aop-pointcuts"></a>5.2.3. Declaring a pointcut</h4>
<div class="paragraph">
<p>Recall that pointcuts determine join points of interest, and thus enable us to control
when advice executes. <em>Spring AOP only supports method execution join points for Spring
beans</em>, so you can think of a pointcut as matching the execution of methods on Spring
beans. A pointcut declaration has two parts: a signature comprising a name and any
parameters, and a pointcut expression that determines <em>exactly</em> which method
executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut
signature is provided by a regular method definition, and the pointcut expression is
indicated using the <code>@Pointcut</code> annotation (the method serving as the pointcut signature
<em>must</em> have a <code>void</code> return type).</p>
</div>
<div class="paragraph">
<p>An example will help make this distinction between a pointcut signature and a pointcut
expression clear. The following example defines a pointcut named <code>'anyOldTransfer'</code> that
will match the execution of any method named <code>'transfer'</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* transfer(..))</span><span class="delimiter">&quot;</span></span>)<span class="comment">// the pointcut expression</span>
<span class="directive">private</span> <span class="type">void</span> anyOldTransfer() {}<span class="comment">// the pointcut signature</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut expression that forms the value of the <code>@Pointcut</code> annotation is a regular
AspectJ 5 pointcut expression. For a full discussion of AspectJ&#8217;s pointcut language, see
the <a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ
Programming Guide</a> (and for extensions, the
<a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5
Developers Notebook</a>) or one of the books on AspectJ such as "Eclipse AspectJ" by Colyer
et. al. or "AspectJ in Action" by Ramnivas Laddad.</p>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-designators"><a class="anchor" href="#aop-pointcuts-designators"></a>Supported Pointcut Designators</h5>
<div class="paragraph">
<p>Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut
expressions:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Other pointcut types</div>
<div class="paragraph">
<p>The full AspectJ pointcut language supports additional pointcut designators that are not
supported in Spring. These are: <code>call, get, set, preinitialization,
staticinitialization, initialization, handler, adviceexecution, withincode, cflow,
cflowbelow, if, @this</code>, and <code>@withincode</code>. Use of these pointcut designators in pointcut
expressions interpreted by Spring AOP will result in an <code>IllegalArgumentException</code> being
thrown.</p>
</div>
<div class="paragraph">
<p>The set of pointcut designators supported by Spring AOP may be extended in future
releases to support more of the AspectJ pointcut designators.</p>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><em>execution</em> - for matching method execution join points, this is the primary
pointcut designator you will use when working with Spring AOP</p>
</li>
<li>
<p><em>within</em> - limits matching to join points within certain types (simply the execution
of a method declared within a matching type when using Spring AOP)</p>
</li>
<li>
<p><em>this</em> - limits matching to join points (the execution of methods when using Spring
AOP) where the bean reference (Spring AOP proxy) is an instance of the given type</p>
</li>
<li>
<p><em>target</em> - limits matching to join points (the execution of methods when using
Spring AOP) where the target object (application object being proxied) is an instance
of the given type</p>
</li>
<li>
<p><em>args</em> - limits matching to join points (the execution of methods when using Spring
AOP) where the arguments are instances of the given types</p>
</li>
<li>
<p><em>@target</em> - limits matching to join points (the execution of methods when using
Spring AOP) where the class of the executing object has an annotation of the given type</p>
</li>
<li>
<p><em>@args</em> - limits matching to join points (the execution of methods when using Spring
AOP) where the runtime type of the actual arguments passed have annotations of the
given type(s)</p>
</li>
<li>
<p><em>@within</em> - limits matching to join points within types that have the given
annotation (the execution of methods declared in types with the given annotation when
using Spring AOP)</p>
</li>
<li>
<p><em>@annotation</em> - limits matching to join points where the subject of the join point
(method being executed in Spring AOP) has the given annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because Spring AOP limits matching to only method execution join points, the discussion
of the pointcut designators above gives a narrower definition than you will find in the
AspectJ programming guide. In addition, AspectJ itself has type-based semantics and at
an execution join point both <code>this</code> and <code>target</code> refer to the same object - the
object executing the method. Spring AOP is a proxy-based system and differentiates
between the proxy object itself (bound to <code>this</code>) and the target object behind the
proxy (bound to <code>target</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Due to the proxy-based nature of Spring&#8217;s AOP framework, calls within the target object
are by definition <em>not</em> intercepted. For JDK proxies, only public interface method
calls on the proxy can be intercepted. With CGLIB, public and protected method calls on
the proxy will be intercepted, and even package-visible methods if necessary. However,
common interactions through proxies should always be designed through public signatures.</p>
</div>
<div class="paragraph">
<p>Note that pointcut definitions are generally matched against any intercepted method.
If a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with
potential non-public interactions through proxies, it needs to be defined accordingly.</p>
</div>
<div class="paragraph">
<p>If your interception needs include method calls or even constructors within the target
class, consider the use of Spring-driven <a href="#aop-aj-ltw">native AspectJ weaving</a> instead
of Spring&#8217;s proxy-based AOP framework. This constitutes a different mode of AOP usage
with different characteristics, so be sure to make yourself familiar with weaving first
before making a decision.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring AOP also supports an additional PCD named <code>bean</code>. This PCD allows you to limit
the matching of join points to a particular named Spring bean, or to a set of named
Spring beans (when using wildcards). The <code>bean</code> PCD has the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>idOrNameOfBean</code> token can be the name of any Spring bean: limited wildcard
support using the <code>*</code> character is provided, so if you establish some naming
conventions for your Spring beans you can quite easily write a <code>bean</code> PCD expression
to pick them out. As is the case with other pointcut designators, the <code>bean</code> PCD can
be &amp;&amp;'ed, ||'ed, and ! (negated) too.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Please note that the <code>bean</code> PCD is <em>only</em> supported in Spring AOP - and <em>not</em> in
native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that
AspectJ defines and therefore not available for aspects declared in the <code>@Aspect</code> model.</p>
</div>
<div class="paragraph">
<p>The <code>bean</code> PCD operates at the <em>instance</em> level (building on the Spring bean name
concept) rather than at the type level only (which is what weaving-based AOP is limited
to). Instance-based pointcut designators are a special capability of Spring&#8217;s
proxy-based AOP framework and its close integration with the Spring bean factory, where
it is natural and straightforward to identify specific beans by name.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-combining"><a class="anchor" href="#aop-pointcuts-combining"></a>Combining pointcut expressions</h5>
<div class="paragraph">
<p>Pointcut expressions can be combined using '&amp;&amp;', '||' and '!'. It is also possible to
refer to pointcut expressions by name. The following example shows three pointcut
expressions: <code>anyPublicOperation</code> (which matches if a method execution join point
represents the execution of any public method); <code>inTrading</code> (which matches if a method
execution is in the trading module), and <code>tradingOperation</code> (which matches if a method
execution represents any public method in the trading module).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(public * *(..))</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> anyPublicOperation() {}

<span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.trading..*)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> inTrading() {}

<span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">anyPublicOperation() &amp;&amp; inTrading()</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> tradingOperation() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a best practice to build more complex pointcut expressions out of smaller named
components as shown above. When referring to pointcuts by name, normal Java visibility
rules apply (you can see private pointcuts in the same type, protected pointcuts in the
hierarchy, public pointcuts anywhere and so on). Visibility does not affect pointcut
<em>matching</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-common-pointcuts"><a class="anchor" href="#aop-common-pointcuts"></a>Sharing common pointcut definitions</h5>
<div class="paragraph">
<p>When working with enterprise applications, you often want to refer to modules of the
application and particular sets of operations from within several aspects. We recommend
defining a "SystemArchitecture" aspect that captures common pointcut expressions for
this purpose. A typical such aspect would look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.xyz.someapp</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Pointcut</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SystemArchitecture</span> {

        <span class="comment">/**
         * A join point is in the web layer if the method is defined
         * in a type in the com.xyz.someapp.web package or any sub-package
         * under that.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.web..*)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> inWebLayer() {}

        <span class="comment">/**
         * A join point is in the service layer if the method is defined
         * in a type in the com.xyz.someapp.service package or any sub-package
         * under that.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.service..*)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> inServiceLayer() {}

        <span class="comment">/**
         * A join point is in the data access layer if the method is defined
         * in a type in the com.xyz.someapp.dao package or any sub-package
         * under that.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">within(com.xyz.someapp.dao..*)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> inDataAccessLayer() {}

        <span class="comment">/**
         * A business service is the execution of any method defined on a service
         * interface. This definition assumes that interfaces are placed in the
         * &quot;service&quot; package, and that implementation types are in sub-packages.
         *
         * If you group service interfaces by functional area (for example,
         * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
         * the pointcut expression &quot;execution(* com.xyz.someapp..service.*.*(..))&quot;
         * could be used instead.
         *
         * Alternatively, you can write the expression using the 'bean'
         * PCD, like so &quot;bean(*Service)&quot;. (This assumes that you have
         * named your Spring service beans in a consistent fashion.)
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.someapp..service.*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> businessService() {}

        <span class="comment">/**
         * A data access operation is the execution of any method defined on a
         * dao interface. This definition assumes that interfaces are placed in the
         * &quot;dao&quot; package, and that implementation types are in sub-packages.
         */</span>
        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.someapp.dao.*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> dataAccessOperation() {}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcuts defined in such an aspect can be referred to anywhere that you need a
pointcut expression. For example, to make the service layer transactional, you could
write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>
        <span class="tag">&lt;aop:advisor</span>
                <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.someapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">advice-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;tx:advice</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;tx:attributes&gt;</span>
                <span class="tag">&lt;tx:method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">propagation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">REQUIRED</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/tx:attributes&gt;</span>
<span class="tag">&lt;/tx:advice&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;aop:config&gt;</code> and <code>&lt;aop:advisor&gt;</code> elements are discussed in <a href="#aop-schema">Schema-based AOP support</a>. The
transaction elements are discussed in <a href="data-access.html#transaction">Transaction Management</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-examples"><a class="anchor" href="#aop-pointcuts-examples"></a>Examples</h5>
<div class="paragraph">
<p>Spring AOP users are likely to use the <code>execution</code> pointcut designator the most often.
The format of an execution expression is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
                        <span class="directive">throws</span>-pattern?)</code></pre>
</div>
</div>
<div class="paragraph">
<p>All parts except the returning type pattern (ret-type-pattern in the snippet above),
name pattern, and parameters pattern are optional. The returning type pattern determines
what the return type of the method must be in order for a join point to be matched. Most
frequently you will use <code>*</code> as the returning type pattern, which matches any return
type. A fully-qualified type name will match only when the method returns the given
type. The name pattern matches the method name. You can use the <code>*</code> wildcard as all or
part of a name pattern. If specifying a declaring type pattern
then include a trailing <code>.</code> to join it to the name pattern component.
The parameters pattern is slightly more complex: <code>()</code> matches a
method that takes no parameters, whereas <code>(..)</code> matches any number of parameters (zero
or more). The pattern <code>(*)</code> matches a method taking one parameter of any type,
<code>(*,String)</code> matches a method taking two parameters, the first can be of any type, the
second must be a String. Consult the
<a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">Language
Semantics</a> section of the AspectJ Programming Guide for more information.</p>
</div>
<div class="paragraph">
<p>Some examples of common pointcut expressions are given below.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the execution of any public method:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(<span class="directive">public</span> * *(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>the execution of any method with a name beginning with "set":</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* set*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>the execution of any method defined by the <code>AccountService</code> interface:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* com.xyz.service.AccountService.*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>the execution of any method defined in the service package:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* com.xyz.service.*.*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>the execution of any method defined in the service package or a sub-package:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">execution(* com.xyz.service..*.*(..))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) within the service package:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">within(com.xyz.service.*)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) within the service package or a
sub-package:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">within(com.xyz.service..*)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) where the proxy implements the
<code>AccountService</code> interface:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">this</span>(com.xyz.service.AccountService)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>'this' is more commonly used in a binding form :- see the following section on advice
for how to make the proxy object available in the advice body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) where the target object
implements the <code>AccountService</code> interface:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">target(com.xyz.service.AccountService)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>'target' is more commonly used in a binding form :- see the following section on advice
for how to make the target object available in the advice body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) which takes a single parameter,
and where the argument passed at runtime is <code>Serializable</code>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">args(java.io.Serializable)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>'args' is more commonly used in a binding form :- see the following section on advice
for how to make the method arguments available in the advice body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that the pointcut given in this example is different to <code>execution(*
*(java.io.Serializable))</code>: the args version matches if the argument passed at runtime is
Serializable, the execution version matches if the method signature declares a single
parameter of type <code>Serializable</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) where the target object has an
<code>@Transactional</code> annotation:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@target</span>(org.springframework.transaction.annotation.Transactional)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>'@target' can also be used in a binding form :- see the following section on advice for
how to make the annotation object available in the advice body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) where the declared type of the
target object has an <code>@Transactional</code> annotation:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@within</span>(org.springframework.transaction.annotation.Transactional)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>'@within' can also be used in a binding form :- see the following section on advice for
how to make the annotation object available in the advice body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) where the executing method has an
<code>@Transactional</code> annotation:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@annotation</span>(org.springframework.transaction.annotation.Transactional)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>'@annotation' can also be used in a binding form :- see the following section on advice
for how to make the annotation object available in the advice body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) which takes a single parameter,
and where the runtime type of the argument passed has the <code>@Classified</code> annotation:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@args</span>(com.xyz.security.Classified)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>'@args' can also be used in a binding form :- see the following section on advice for
how to make the annotation object(s) available in the advice body.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) on a Spring bean named
<code>tradeService</code>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">bean(tradeService)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>any join point (method execution only in Spring AOP) on Spring beans having names that
match the wildcard expression <code>*Service</code>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">bean(*Service)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="writing-good-pointcuts"><a class="anchor" href="#writing-good-pointcuts"></a>Writing good pointcuts</h5>
<div class="paragraph">
<p>During compilation, AspectJ processes pointcuts in order to try and optimize matching
performance. Examining code and determining if each join point matches (statically or
dynamically) a given pointcut is a costly process. (A dynamic match means the match
cannot be fully determined from static analysis and a test will be placed in the code to
determine if there is an actual match when the code is running). On first encountering a
pointcut declaration, AspectJ will rewrite it into an optimal form for the matching
process. What does this mean? Basically pointcuts are rewritten in DNF (Disjunctive
Normal Form) and the components of the pointcut are sorted such that those components
that are cheaper to evaluate are checked first. This means you do not have to worry
about understanding the performance of various pointcut designators and may supply them
in any order in a pointcut declaration.</p>
</div>
<div class="paragraph">
<p>However, AspectJ can only work with what it is told, and for optimal performance of
matching you should think about what they are trying to achieve and narrow the search
space for matches as much as possible in the definition. The existing designators
naturally fall into one of three groups: kinded, scoping and context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kinded designators are those which select a particular kind of join point. For
example: execution, get, set, call, handler</p>
</li>
<li>
<p>Scoping designators are those which select a group of join points of interest (of
probably many kinds). For example: within, withincode</p>
</li>
<li>
<p>Contextual designators are those that match (and optionally bind) based on context.
For example: this, target, @annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A well written pointcut should try and include at least the first two types (kinded and
scoping), whilst the contextual designators may be included if wishing to match based on
join point context, or bind that context for use in the advice. Supplying either just a
kinded designator or just a contextual designator will work but could affect weaving
performance (time and memory used) due to all the extra processing and analysis. Scoping
designators are very fast to match and their usage means AspectJ can very quickly
dismiss groups of join points that should not be further processed - that is why a good
pointcut should always include one if possible.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice"><a class="anchor" href="#aop-advice"></a>5.2.4. Declaring advice</h4>
<div class="paragraph">
<p>Advice is associated with a pointcut expression, and runs before, after, or around
method executions matched by the pointcut. The pointcut expression may be either a
simple reference to a named pointcut, or a pointcut expression declared in place.</p>
</div>
<div class="sect4">
<h5 id="aop-advice-before"><a class="anchor" href="#aop-advice-before"></a>Before advice</h5>
<div class="paragraph">
<p>Before advice is declared in an aspect using the <code>@Before</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Before</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">BeforeExample</span> {

        <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If using an in-place pointcut expression we could rewrite the above example as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Before</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">BeforeExample</span> {

        <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.dao.*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-returning"><a class="anchor" href="#aop-advice-after-returning"></a>After returning advice</h5>
<div class="paragraph">
<p>After returning advice runs when a matched method execution returns normally. It is
declared using the <code>@AfterReturning</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterReturning</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterReturningExample</span> {

        <span class="annotation">@AfterReturning</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note: it is of course possible to have multiple advice declarations, and other members
as well, all inside the same aspect. We&#8217;re just showing a single advice declaration in
these examples to focus on the issue under discussion at the time.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes you need access in the advice body to the actual value that was returned. You
can use the form of <code>@AfterReturning</code> that binds the return value for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterReturning</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterReturningExample</span> {

        <span class="annotation">@AfterReturning</span>(
                pointcut=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>,
                returning=<span class="string"><span class="delimiter">&quot;</span><span class="content">retVal</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doAccessCheck(<span class="predefined-type">Object</span> retVal) {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name used in the <code>returning</code> attribute must correspond to the name of a parameter in
the advice method. When a method execution returns, the return value will be passed to
the advice method as the corresponding argument value. A <code>returning</code> clause also
restricts matching to only those method executions that return a value of the specified
type ( <code>Object</code> in this case, which will match any return value).</p>
</div>
<div class="paragraph">
<p>Please note that it is <em>not</em> possible to return a totally different reference when
using after-returning advice.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-throwing"><a class="anchor" href="#aop-advice-after-throwing"></a>After throwing advice</h5>
<div class="paragraph">
<p>After throwing advice runs when a matched method execution exits by throwing an
exception. It is declared using the <code>@AfterThrowing</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterThrowing</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterThrowingExample</span> {

        <span class="annotation">@AfterThrowing</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doRecoveryActions() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Often you want the advice to run only when exceptions of a given type are thrown, and
you also often need access to the thrown exception in the advice body. Use the
<code>throwing</code> attribute to both restrict matching (if desired, use <code>Throwable</code> as the
exception type otherwise) and bind the thrown exception to an advice parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.AfterThrowing</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterThrowingExample</span> {

        <span class="annotation">@AfterThrowing</span>(
                pointcut=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>,
                throwing=<span class="string"><span class="delimiter">&quot;</span><span class="content">ex</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doRecoveryActions(DataAccessException ex) {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name used in the <code>throwing</code> attribute must correspond to the name of a parameter in
the advice method. When a method execution exits by throwing an exception, the exception
will be passed to the advice method as the corresponding argument value. A <code>throwing</code>
clause also restricts matching to only those method executions that throw an exception
of the specified type ( <code>DataAccessException</code> in this case).</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-finally"><a class="anchor" href="#aop-advice-after-finally"></a>After (finally) advice</h5>
<div class="paragraph">
<p>After (finally) advice runs however a matched method execution exits. It is declared
using the <code>@After</code> annotation. After advice must be prepared to handle both normal and
exception return conditions. It is typically used for releasing resources, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.After</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AfterFinallyExample</span> {

        <span class="annotation">@After</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> doReleaseLock() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-around-advice"><a class="anchor" href="#aop-ataspectj-around-advice"></a>Around advice</h5>
<div class="paragraph">
<p>The final kind of advice is around advice. Around advice runs "around" a matched method
execution. It has the opportunity to do work both before and after the method executes,
and to determine when, how, and even if, the method actually gets to execute at all.
Around advice is often used if you need to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer for example). Always
use the least powerful form of advice that meets your requirements (i.e. don&#8217;t use
around advice if simple before advice would do).</p>
</div>
<div class="paragraph">
<p>Around advice is declared using the <code>@Around</code> annotation. The first parameter of the
advice method must be of type <code>ProceedingJoinPoint</code>. Within the body of the advice,
calling <code>proceed()</code> on the <code>ProceedingJoinPoint</code> causes the underlying method to
execute. The <code>proceed</code> method may also be called passing in an <code>Object[]</code> - the values
in the array will be used as the arguments to the method execution when it proceeds.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The behavior of proceed when called with an Object[] is a little different than the
behavior of proceed for around advice compiled by the AspectJ compiler. For around
advice written using the traditional AspectJ language, the number of arguments passed to
proceed must match the number of arguments passed to the around advice (not the number
of arguments taken by the underlying join point), and the value passed to proceed in a
given argument position supplants the original value at the join point for the entity
the value was bound to (Don&#8217;t worry if this doesn&#8217;t make sense right now!). The approach
taken by Spring is simpler and a better match to its proxy-based, execution only
semantics. You only need to be aware of this difference if you are compiling @AspectJ
aspects written for Spring and using proceed with arguments with the AspectJ compiler
and weaver. There is a way to write such aspects that is 100% compatible across both
Spring AOP and AspectJ, and this is discussed in the following section on advice
parameters.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Around</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.ProceedingJoinPoint</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AroundExample</span> {

        <span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">Object</span> doBasicProfiling(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// start stopwatch</span>
                <span class="predefined-type">Object</span> retVal = pjp.proceed();
                <span class="comment">// stop stopwatch</span>
                <span class="keyword">return</span> retVal;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value returned by the around advice will be the return value seen by the caller of
the method. A simple caching aspect for example could return a value from a cache if it
has one, and invoke proceed() if it does not. Note that proceed may be invoked once,
many times, or not at all within the body of the around advice, all of these are quite
legal.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params"><a class="anchor" href="#aop-ataspectj-advice-params"></a>Advice parameters</h5>
<div class="paragraph">
<p>Spring offers fully typed advice - meaning that you declare the parameters you need
in the advice signature (as we saw for the returning and throwing examples above) rather
than work with <code>Object[]</code> arrays all the time. We&#8217;ll see how to make argument and other
contextual values available to the advice body in a moment. First let&#8217;s take a look at
how to write generic advice that can find out about the method the advice is currently
advising.</p>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-the-joinpoint"><a class="anchor" href="#aop-ataspectj-advice-params-the-joinpoint"></a>Access to the current JoinPoint</h6>
<div class="paragraph">
<p>Any advice method may declare as its first parameter, a parameter of type
<code>org.aspectj.lang.JoinPoint</code> (please note that around advice is <em>required</em> to declare
a first parameter of type <code>ProceedingJoinPoint</code>, which is a subclass of <code>JoinPoint</code>. The
<code>JoinPoint</code> interface provides a number of useful methods such as <code>getArgs()</code> (returns
the method arguments), <code>getThis()</code> (returns the proxy object), <code>getTarget()</code> (returns
the target object), <code>getSignature()</code> (returns a description of the method that is being
advised) and <code>toString()</code> (prints a useful description of the method being advised).
Please do consult the javadocs for full details.</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-passing"><a class="anchor" href="#aop-ataspectj-advice-params-passing"></a>Passing parameters to advice</h6>
<div class="paragraph">
<p>We&#8217;ve already seen how to bind the returned value or exception value (using after
returning and after throwing advice). To make argument values available to the advice
body, you can use the binding form of <code>args</code>. If a parameter name is used in place of a
type name in an args expression, then the value of the corresponding argument will be
passed as the parameter value when the advice is invoked. An example should make this
clearer. Suppose you want to advise the execution of dao operations that take an Account
object as the first parameter, and you need access to the account in the advice body.
You could write the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> validateAccount(Account account) {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>args(account,..)</code> part of the pointcut expression serves two purposes: firstly, it
restricts matching to only those method executions where the method takes at least one
parameter, and the argument passed to that parameter is an instance of <code>Account</code>;
secondly, it makes the actual <code>Account</code> object available to the advice via the <code>account</code>
parameter.</p>
</div>
<div class="paragraph">
<p>Another way of writing this is to declare a pointcut that "provides" the <code>Account</code>
object value when it matches a join point, and then just refer to the named pointcut
from the advice. This would look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">private</span> <span class="type">void</span> accountDataAccessOperation(Account account) {}

<span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">accountDataAccessOperation(account)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> validateAccount(Account account) {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interested reader is once more referred to the AspectJ programming guide for more
details.</p>
</div>
<div class="paragraph">
<p>The proxy object ( <code>this</code>), target object ( <code>target</code>), and annotations ( <code>@within,
@target, @annotation, @args</code>) can all be bound in a similar fashion. The following
example shows how you could match the execution of methods annotated with an
<code>@Auditable</code> annotation, and extract the audit code.</p>
</div>
<div class="paragraph">
<p>First the definition of the <code>@Auditable</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="annotation">@Target</span>(<span class="predefined-type">ElementType</span>.METHOD)
<span class="directive">public</span> <span class="annotation">@interface</span> Auditable {
        AuditCode value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then the advice that matches the execution of <code>@Auditable</code> methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(Auditable auditable) {
        AuditCode code = auditable.value();
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-generics"><a class="anchor" href="#aop-ataspectj-advice-params-generics"></a>Advice parameters and generics</h6>
<div class="paragraph">
<p>Spring AOP can handle generics used in class declarations and method parameters. Suppose
you have a generic type like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Sample</span>&lt;T&gt; {
        <span class="type">void</span> sampleGenericMethod(T param);
        <span class="type">void</span> sampleGenericCollectionMethod(<span class="predefined-type">Collection</span>&lt;T&gt; param);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can restrict interception of method types to certain parameter types by simply
typing the advice parameter to the parameter type you want to intercept the method for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> beforeSampleMethod(MyType param) {
        <span class="comment">// Advice implementation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That this works is pretty obvious as we already discussed above. However, it&#8217;s worth
pointing out that this won&#8217;t work for generic collections. So you cannot define a
pointcut like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> beforeSampleMethod(<span class="predefined-type">Collection</span>&lt;MyType&gt; param) {
        <span class="comment">// Advice implementation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this work we would have to inspect every element of the collection, which is not
reasonable as we also cannot decide how to treat <code>null</code> values in general. To achieve
something similar to this you have to type the parameter to <code>Collection&lt;?&gt;</code> and manually
check the type of the elements.</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-names"><a class="anchor" href="#aop-ataspectj-advice-params-names"></a>Determining argument names</h6>
<div class="paragraph">
<p>The parameter binding in advice invocations relies on matching names used in pointcut
expressions to declared parameter names in (advice and pointcut) method signatures.
Parameter names are <em>not</em> available through Java reflection, so Spring AOP uses the
following strategies to determine parameter names:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the parameter names have been specified by the user explicitly, then the specified
parameter names are used: both the advice and the pointcut annotations have
an optional "argNames" attribute which can be used to specify the argument names of
the annotated method - these argument names <em>are</em> available at runtime. For example:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)</span><span class="delimiter">&quot;</span></span>,
                argNames=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean,auditable</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(<span class="predefined-type">Object</span> bean, Auditable auditable) {
        AuditCode code = auditable.value();
        <span class="comment">// ... use code and bean</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the first parameter is of the <code>JoinPoint</code>, <code>ProceedingJoinPoint</code>, or
<code>JoinPoint.StaticPart</code> type, you may leave out the name of the parameter from the value
of the "argNames" attribute. For example, if you modify the preceding advice to receive
the join point object, the "argNames" attribute need not include it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)</span><span class="delimiter">&quot;</span></span>,
                argNames=<span class="string"><span class="delimiter">&quot;</span><span class="content">bean,auditable</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(JoinPoint jp, <span class="predefined-type">Object</span> bean, Auditable auditable) {
        AuditCode code = auditable.value();
        <span class="comment">// ... use code, bean, and jp</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The special treatment given to the first parameter of the <code>JoinPoint</code>,
<code>ProceedingJoinPoint</code>, and <code>JoinPoint.StaticPart</code> types is particularly convenient for
advice that do not collect any other join point context. In such situations, you may
simply omit the "argNames" attribute. For example, the following advice need not declare
the "argNames" attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod()</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">void</span> audit(JoinPoint jp) {
        <span class="comment">// ... use jp</span>
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the <code>'argNames'</code> attribute is a little clumsy, so if the <code>'argNames'</code> attribute
has not been specified, then Spring AOP will look at the debug information for the
class and try to determine the parameter names from the local variable table. This
information will be present as long as the classes have been compiled with debug
information ( <code>'-g:vars'</code> at a minimum). The consequences of compiling with this flag
on are: (1) your code will be slightly easier to understand (reverse engineer), (2)
the class file sizes will be very slightly bigger (typically inconsequential), (3) the
optimization to remove unused local variables will not be applied by your compiler. In
other words, you should encounter no difficulties building with this flag on.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the
debug information then there is no need to add the argNames attribute as the compiler
will retain the needed information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>If the code has been compiled without the necessary debug information, then Spring AOP
will attempt to deduce the pairing of binding variables to parameters (for example, if
only one variable is bound in the pointcut expression, and the advice method only
takes one parameter, the pairing is obvious!). If the binding of variables is
ambiguous given the available information, then an <code>AmbiguousBindingException</code> will be
thrown.</p>
</li>
<li>
<p>If all of the above strategies fail then an <code>IllegalArgumentException</code> will be thrown.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-proceeding-with-the-call"><a class="anchor" href="#aop-ataspectj-advice-proceeding-with-the-call"></a>Proceeding with arguments</h6>
<div class="paragraph">
<p>We remarked earlier that we would describe how to write a proceed call <em>with
arguments</em> that works consistently across Spring AOP and AspectJ. The solution is
simply to ensure that the advice signature binds each of the method parameters in order.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(List&lt;Account&gt; find*(..)) &amp;&amp; </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">args(accountHolderNamePattern)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">Object</span> preProcessQueryPattern(ProceedingJoinPoint pjp,
                <span class="predefined-type">String</span> accountHolderNamePattern) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
        <span class="predefined-type">String</span> newPattern = preProcess(accountHolderNamePattern);
        <span class="keyword">return</span> pjp.proceed(<span class="keyword">new</span> <span class="predefined-type">Object</span><span class="type">[]</span> {newPattern});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In many cases you will be doing this binding anyway (as in the example above).</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-ordering"><a class="anchor" href="#aop-ataspectj-advice-ordering"></a>Advice ordering</h5>
<div class="paragraph">
<p>What happens when multiple pieces of advice all want to run at the same join point?
Spring AOP follows the same precedence rules as AspectJ to determine the order of advice
execution. The highest precedence advice runs first "on the way in" (so given two pieces
of before advice, the one with highest precedence runs first). "On the way out" from a
join point, the highest precedence advice runs last (so given two pieces of after
advice, the one with the highest precedence will run second).</p>
</div>
<div class="paragraph">
<p>When two pieces of advice defined in <em>different</em> aspects both need to run at the same
join point, unless you specify otherwise the order of execution is undefined. You can
control the order of execution by specifying precedence. This is done in the normal
Spring way by either implementing the <code>org.springframework.core.Ordered</code> interface in
the aspect class or annotating it with the <code>Order</code> annotation. Given two aspects, the
aspect returning the lower value from <code>Ordered.getValue()</code> (or the annotation value) has
the higher precedence.</p>
</div>
<div class="paragraph">
<p>When two pieces of advice defined in <em>the same</em> aspect both need to run at the same
join point, the ordering is undefined (since there is no way to retrieve the declaration
order via reflection for javac-compiled classes). Consider collapsing such advice
methods into one advice method per join point in each aspect class, or refactor the
pieces of advice into separate aspect classes - which can be ordered at the aspect level.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-introductions"><a class="anchor" href="#aop-introductions"></a>5.2.5. Introductions</h4>
<div class="paragraph">
<p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare
that advised objects implement a given interface, and to provide an implementation of
that interface on behalf of those objects.</p>
</div>
<div class="paragraph">
<p>An introduction is made using the <code>@DeclareParents</code> annotation. This annotation is used
to declare that matching types have a new parent (hence the name). For example, given an
interface <code>UsageTracked</code>, and an implementation of that interface <code>DefaultUsageTracked</code>,
the following aspect declares that all implementors of service interfaces also implement
the <code>UsageTracked</code> interface. (In order to expose statistics via JMX for example.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">UsageTracking</span> {

        <span class="annotation">@DeclareParents</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xzy.myapp.service.*+</span><span class="delimiter">&quot;</span></span>, defaultImpl=DefaultUsageTracked.class)
        <span class="directive">public</span> <span class="directive">static</span> UsageTracked mixin;

        <span class="annotation">@Before</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> recordUsage(UsageTracked usageTracked) {
                usageTracked.incrementUseCount();
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface to be implemented is determined by the type of the annotated field. The
<code>value</code> attribute of the <code>@DeclareParents</code> annotation is an AspectJ type pattern :- any
bean of a matching type will implement the UsageTracked interface. Note that in the
before advice of the above example, service beans can be directly used as
implementations of the <code>UsageTracked</code> interface. If accessing a bean programmatically
you would write the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-instantiation-models"><a class="anchor" href="#aop-instantiation-models"></a>5.2.6. Aspect instantiation models</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>(This is an advanced topic, so if you are just starting out with AOP you can safely skip
it until later.)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default there will be a single instance of each aspect within the application
context. AspectJ calls this the singleton instantiation model. It is possible to define
aspects with alternate lifecycles :- Spring supports AspectJ&#8217;s <code>perthis</code> and <code>pertarget</code>
instantiation models ( <code>percflow, percflowbelow,</code> and <code>pertypewithin</code> are not currently
supported).</p>
</div>
<div class="paragraph">
<p>A "perthis" aspect is declared by specifying a <code>perthis</code> clause in the <code>@Aspect</code>
annotation. Let&#8217;s look at an example, and then we&#8217;ll explain how it works.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">perthis(com.xyz.myapp.SystemArchitecture.businessService())</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyAspect</span> {

        <span class="directive">private</span> <span class="type">int</span> someState;

        <span class="annotation">@Before</span>(com.xyz.myapp.SystemArchitecture.businessService())
        <span class="directive">public</span> <span class="type">void</span> recordServiceUsage() {
                <span class="comment">// ...</span>
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effect of the <code>'perthis'</code> clause is that one aspect instance will be created for
each unique service object executing a business service (each unique object bound to
'this' at join points matched by the pointcut expression). The aspect instance is
created the first time that a method is invoked on the service object. The aspect goes
out of scope when the service object goes out of scope. Before the aspect instance is
created, none of the advice within it executes. As soon as the aspect instance has been
created, the advice declared within it will execute at matched join points, but only
when the service object is the one this aspect is associated with. See the AspectJ
programming guide for more information on per-clauses.</p>
</div>
<div class="paragraph">
<p>The <code>'pertarget'</code> instantiation model works in exactly the same way as perthis, but
creates one aspect instance for each unique target object at matched join points.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-example"><a class="anchor" href="#aop-ataspectj-example"></a>5.2.7. Example</h4>
<div class="paragraph">
<p>Now that you have seen how all the constituent parts work, let&#8217;s put them together to do
something useful!</p>
</div>
<div class="paragraph">
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, deadlock loser). If the operation is retried, it is quite likely to succeed
next time round. For business services where it is appropriate to retry in such
conditions (idempotent operations that don&#8217;t need to go back to the user for conflict
resolution), we&#8217;d like to transparently retry the operation to avoid the client seeing a
<code>PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer, and hence is ideal for implementing via an
aspect.</p>
</div>
<div class="paragraph">
<p>Because we want to retry the operation, we will need to use around advice so that we can
call proceed multiple times. Here&#8217;s how the basic aspect implementation looks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConcurrentOperationExecutor</span> <span class="directive">implements</span> Ordered {

        <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> DEFAULT_MAX_RETRIES = <span class="integer">2</span>;

        <span class="directive">private</span> <span class="type">int</span> maxRetries = DEFAULT_MAX_RETRIES;
        <span class="directive">private</span> <span class="type">int</span> order = <span class="integer">1</span>;

        <span class="directive">public</span> <span class="type">void</span> setMaxRetries(<span class="type">int</span> maxRetries) {
                <span class="local-variable">this</span>.maxRetries = maxRetries;
        }

        <span class="directive">public</span> <span class="type">int</span> getOrder() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.order;
        }

        <span class="directive">public</span> <span class="type">void</span> setOrder(<span class="type">int</span> order) {
                <span class="local-variable">this</span>.order = order;
        }

        <span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="type">int</span> numAttempts = <span class="integer">0</span>;
                PessimisticLockingFailureException lockFailureException;
                <span class="keyword">do</span> {
                        numAttempts++;
                        <span class="keyword">try</span> {
                                <span class="keyword">return</span> pjp.proceed();
                        }
                        <span class="keyword">catch</span>(PessimisticLockingFailureException ex) {
                                lockFailureException = ex;
                        }
                } <span class="keyword">while</span>(numAttempts &lt;= <span class="local-variable">this</span>.maxRetries);
                <span class="keyword">throw</span> lockFailureException;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the aspect implements the <code>Ordered</code> interface so we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code>maxRetries</code> and <code>order</code> properties will both be configured by Spring. The
main action happens in the <code>doConcurrentOperation</code> around advice. Notice that for the
moment we&#8217;re applying the retry logic to all <code>businessService()s</code>. We try to proceed,
and if we fail with an <code>PessimisticLockingFailureException</code> we simply try again unless
we have exhausted all of our retry attempts.</p>
</div>
<div class="paragraph">
<p>The corresponding Spring configuration is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy</span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationExecutor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.impl.ConcurrentOperationExecutor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxRetries</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To refine the aspect so that it only retries idempotent operations, we might define an
<code>Idempotent</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Idempotent {
        <span class="comment">// marker annotation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and use the annotation to annotate the implementation of service operations. The change
to the aspect to only retry idempotent operations simply involves refining the pointcut
expression so that only <code>@Idempotent</code> operations match:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; </span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">@annotation(com.xyz.myapp.service.Idempotent)</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
        ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema"><a class="anchor" href="#aop-schema"></a>5.3. Schema-based AOP support</h3>
<div class="paragraph">
<p>If you prefer an XML-based format, then Spring also offers support for defining aspects
using the new "aop" namespace tags. The exact same pointcut expressions and advice kinds
are supported as when using the @AspectJ style, hence in this section we will focus on
the new <em>syntax</em> and refer the reader to the discussion in the previous section
(<a href="#aop-ataspectj">@AspectJ support</a>) for an understanding of writing pointcut expressions and the binding
of advice parameters.</p>
</div>
<div class="paragraph">
<p>To use the aop namespace tags described in this section, you need to import the
<code>spring-aop</code> schema as described in <a href="appendix.html#xsd-configuration">XML Schema-based configuration</a>.
See <a href="appendix.html#xsd-config-body-schemas-aop">the AOP schema</a>
for how to import the tags in the <code>aop</code> namespace.</p>
</div>
<div class="paragraph">
<p>Within your Spring configurations, all aspect and advisor elements must be placed within
an <code>&lt;aop:config&gt;</code> element (you can have more than one <code>&lt;aop:config&gt;</code> element in an
application context configuration). An <code>&lt;aop:config&gt;</code> element can contain pointcut,
advisor, and aspect elements (note these must be declared in that order).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>&lt;aop:config&gt;</code> style of configuration makes heavy use of Spring&#8217;s
<a href="#aop-autoproxy">auto-proxying</a> mechanism. This can cause issues (such as advice not
being woven) if you are already using explicit auto-proxying via the use of
<code>BeanNameAutoProxyCreator</code> or suchlike. The recommended usage pattern is to use either
just the <code>&lt;aop:config&gt;</code> style, or just the <code>AutoProxyCreator</code> style.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-schema-declaring-an-aspect"><a class="anchor" href="#aop-schema-declaring-an-aspect"></a>5.3.1. Declaring an aspect</h4>
<div class="paragraph">
<p>Using the schema support, an aspect is simply a regular Java object defined as a bean in
your Spring application context. The state and behavior is captured in the fields and
methods of the object, and the pointcut and advice information is captured in the XML.</p>
</div>
<div class="paragraph">
<p>An aspect is declared using the &lt;aop:aspect&gt; element, and the backing bean is referenced
using the <code>ref</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>
        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                ...
        <span class="tag">&lt;/aop:aspect&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">...</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        ...
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean backing the aspect (" `aBean`" in this case) can of course be configured and
dependency injected just like any other Spring bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-pointcuts"><a class="anchor" href="#aop-schema-pointcuts"></a>5.3.2. Declaring a pointcut</h4>
<div class="paragraph">
<p>A named pointcut can be declared inside an &lt;aop:config&gt; element, enabling the pointcut
definition to be shared across several aspects and advisors.</p>
</div>
<div class="paragraph">
<p>A pointcut representing the execution of any business service in the service layer could
be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the pointcut expression itself is using the same AspectJ pointcut expression
language as described in <a href="#aop-ataspectj">@AspectJ support</a>. If you are using the schema based
declaration style, you can refer to named pointcuts defined in types
(@Aspects) within the pointcut expression. Another way of defining the above pointcut
would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming you have a <code>SystemArchitecture</code> aspect as described in <a href="#aop-common-pointcuts">Sharing common pointcut definitions</a>.</p>
</div>
<div class="paragraph">
<p>Declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                ...

        <span class="tag">&lt;/aop:aspect&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Much the same way in an @AspectJ aspect, pointcuts declared using the schema based
definition style may collect join point context. For example, the following pointcut
collects the 'this' object as the join point context and passes it to advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..)) </span><span class="entity">&amp;amp;</span><span class="entity">&amp;amp;</span> <span class="content">this(service)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;aop:before</span> <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">monitor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                ...

        <span class="tag">&lt;/aop:aspect&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice must be declared to receive the collected join point context by including
parameters of the matching names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> monitor(<span class="predefined-type">Object</span> service) {
        ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When combining pointcut sub-expressions, '&amp;&amp;' is awkward within an XML document, and so
the keywords 'and', 'or' and 'not' can be used in place of '&amp;&amp;', '||' and '!'
respectively. For example, the previous pointcut may be better written as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..)) **and** this(service)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;aop:before</span> <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">monitor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                ...
        <span class="tag">&lt;/aop:aspect&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that pointcuts defined in this way are referred to by their XML id and cannot be
used as named pointcuts to form composite pointcuts. The named pointcut support in the
schema based definition style is thus more limited than that offered by the @AspectJ
style.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice"><a class="anchor" href="#aop-schema-advice"></a>5.3.3. Declaring advice</h4>
<div class="paragraph">
<p>The same five advice kinds are supported as for the @AspectJ style, and they have
exactly the same semantics.</p>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-before"><a class="anchor" href="#aop-schema-advice-before"></a>Before advice</h5>
<div class="paragraph">
<p>Before advice runs before a matched method execution. It is declared inside an
<code>&lt;aop:aspect&gt;</code> using the &lt;aop:before&gt; element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beforeExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:before</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here <code>dataAccessOperation</code> is the id of a pointcut defined at the top ( <code>&lt;aop:config&gt;</code>)
level. To define the pointcut inline instead, replace the <code>pointcut-ref</code> attribute with
a <code>pointcut</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beforeExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:before</span>
                <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.dao.*.*(..))</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we noted in the discussion of the @AspectJ style, using named pointcuts can
significantly improve the readability of your code.</p>
</div>
<div class="paragraph">
<p>The method attribute identifies a method ( <code>doAccessCheck</code>) that provides the body of
the advice. This method must be defined for the bean referenced by the aspect element
containing the advice. Before a data access operation is executed (a method execution
join point matched by the pointcut expression), the "doAccessCheck" method on the aspect
bean will be invoked.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-returning"><a class="anchor" href="#aop-schema-advice-after-returning"></a>After returning advice</h5>
<div class="paragraph">
<p>After returning advice runs when a matched method execution completes normally. It is
declared inside an <code>&lt;aop:aspect&gt;</code> in the same way as before advice. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterReturningExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-returning</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as in the @AspectJ style, it is possible to get hold of the return value within the
advice body. Use the returning attribute to specify the name of the parameter to which
the return value should be passed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterReturningExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-returning</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">returning</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">retVal</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doAccessCheck</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The doAccessCheck method must declare a parameter named <code>retVal</code>. The type of this
parameter constrains matching in the same way as described for @AfterReturning. For
example, the method signature may be declared as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> doAccessCheck(<span class="predefined-type">Object</span> retVal) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-throwing"><a class="anchor" href="#aop-schema-advice-after-throwing"></a>After throwing advice</h5>
<div class="paragraph">
<p>After throwing advice executes when a matched method execution exits by throwing an
exception. It is declared inside an <code>&lt;aop:aspect&gt;</code> using the after-throwing element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterThrowingExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-throwing</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doRecoveryActions</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as in the @AspectJ style, it is possible to get hold of the thrown exception within
the advice body. Use the throwing attribute to specify the name of the parameter to
which the exception should be passed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterThrowingExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after-throwing</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">throwing</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessEx</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doRecoveryActions</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The doRecoveryActions method must declare a parameter named <code>dataAccessEx</code>. The type of
this parameter constrains matching in the same way as described for @AfterThrowing. For
example, the method signature may be declared as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> doRecoveryActions(DataAccessException dataAccessEx) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-finally"><a class="anchor" href="#aop-schema-advice-after-finally"></a>After (finally) advice</h5>
<div class="paragraph">
<p>After (finally) advice runs however a matched method execution exits. It is declared
using the <code>after</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">afterFinallyExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:after</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">dataAccessOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doReleaseLock</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-around"><a class="anchor" href="#aop-schema-advice-around"></a>Around advice</h5>
<div class="paragraph">
<p>The final kind of advice is around advice. Around advice runs "around" a matched method
execution. It has the opportunity to do work both before and after the method executes,
and to determine when, how, and even if, the method actually gets to execute at all.
Around advice is often used if you need to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer for example). Always
use the least powerful form of advice that meets your requirements; don&#8217;t use around
advice if simple before advice would do.</p>
</div>
<div class="paragraph">
<p>Around advice is declared using the <code>aop:around</code> element. The first parameter of the
advice method must be of type <code>ProceedingJoinPoint</code>. Within the body of the advice,
calling <code>proceed()</code> on the <code>ProceedingJoinPoint</code> causes the underlying method to
execute. The <code>proceed</code> method may also be calling passing in an <code>Object[]</code> - the values
in the array will be used as the arguments to the method execution when it proceeds. See
<a href="#aop-ataspectj-around-advice">Around advice</a> for notes on calling proceed with an <code>Object[]</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aroundExample</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:around</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doBasicProfiling</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        ...

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the <code>doBasicProfiling</code> advice would be exactly the same as in the
@AspectJ example (minus the annotation of course):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Object</span> doBasicProfiling(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
        <span class="comment">// start stopwatch</span>
        <span class="predefined-type">Object</span> retVal = pjp.proceed();
        <span class="comment">// stop stopwatch</span>
        <span class="keyword">return</span> retVal;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-params"><a class="anchor" href="#aop-schema-params"></a>Advice parameters</h5>
<div class="paragraph">
<p>The schema based declaration style supports fully typed advice in the same way as
described for the @AspectJ support - by matching pointcut parameters by name against
advice method parameters. See <a href="#aop-ataspectj-advice-params">Advice parameters</a> for details. If you wish
to explicitly specify argument names for the advice methods (not relying on the
detection strategies previously described) then this is done using the <code>arg-names</code>
attribute of the advice element, which is treated in the same manner to the "argNames"
attribute in an advice annotation as described in <a href="#aop-ataspectj-advice-params-names">Determining argument names</a>.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:before</span>
        <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">audit</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">arg-names</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">auditable</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>arg-names</code> attribute accepts a comma-delimited list of parameter names.</p>
</div>
<div class="paragraph">
<p>Find below a slightly more involved example of the XSD-based approach that illustrates
some around advice used in conjunction with a number of strongly typed parameters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">x.y.service</span>;

<span class="directive">public</span> <span class="type">interface</span> <span class="class">FooService</span> {

        Foo getFoo(<span class="predefined-type">String</span> fooName, <span class="type">int</span> age);
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">DefaultFooService</span> <span class="directive">implements</span> FooService {

        <span class="directive">public</span> Foo getFoo(<span class="predefined-type">String</span> name, <span class="type">int</span> age) {
                <span class="keyword">return</span> <span class="keyword">new</span> Foo(name, age);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next up is the aspect. Notice the fact that the <code>profile(..)</code> method accepts a number of
strongly-typed parameters, the first of which happens to be the join point used to
proceed with the method call: the presence of this parameter is an indication that the
<code>profile(..)</code> is to be used as <code>around</code> advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">x.y</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang.ProceedingJoinPoint</span>;
<span class="keyword">import</span> <span class="include">org.springframework.util.StopWatch</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">SimpleProfiler</span> {

        <span class="directive">public</span> <span class="predefined-type">Object</span> profile(ProceedingJoinPoint call, <span class="predefined-type">String</span> name, <span class="type">int</span> age) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                StopWatch clock = <span class="keyword">new</span> StopWatch(<span class="string"><span class="delimiter">&quot;</span><span class="content">Profiling for '</span><span class="delimiter">&quot;</span></span> + name + <span class="string"><span class="delimiter">&quot;</span><span class="content">' and '</span><span class="delimiter">&quot;</span></span> + age + <span class="string"><span class="delimiter">&quot;</span><span class="content">'</span><span class="delimiter">&quot;</span></span>);
                <span class="keyword">try</span> {
                        clock.start(call.toShortString());
                        <span class="keyword">return</span> call.proceed();
                } <span class="keyword">finally</span> {
                        clock.stop();
                        <span class="predefined-type">System</span>.out.println(clock.prettyPrint());
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, here is the XML configuration that is required to effect the execution of the
above advice for a particular join point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:aop</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/aop</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fooService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.service.DefaultFooService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- this is the actual advice itself --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profiler</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">x.y.SimpleProfiler</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;aop:config&gt;</span>
                <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profiler</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theExecutionOfSomeFooServiceMethod</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* x.y.service.FooService.getFoo(String,int))</span>
                                <span class="content">and args(name, age)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                        <span class="tag">&lt;aop:around</span> <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">theExecutionOfSomeFooServiceMethod</span><span class="delimiter">&quot;</span></span>
                                <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profile</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;/aop:aspect&gt;</span>
        <span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we had the following driver script, we would get output something like this on
standard output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.beans.factory.BeanFactory</span>;
<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;
<span class="keyword">import</span> <span class="include">x.y.service.FooService</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Boot</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span> {
                BeanFactory ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">x/y/plain.xml</span><span class="delimiter">&quot;</span></span>);
                FooService foo = (FooService) ctx.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">fooService</span><span class="delimiter">&quot;</span></span>);
                foo.getFoo(<span class="string"><span class="delimiter">&quot;</span><span class="content">Pengo</span><span class="delimiter">&quot;</span></span>, <span class="integer">12</span>);
        }
}</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ordering"><a class="anchor" href="#aop-ordering"></a>Advice ordering</h5>
<div class="paragraph">
<p>When multiple advice needs to execute at the same join point (executing method) the
ordering rules are as described in <a href="#aop-ataspectj-advice-ordering">Advice ordering</a>. The precedence
between aspects is determined by either adding the <code>Order</code> annotation to the bean
backing the aspect or by having the bean implement the <code>Ordered</code> interface.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-introductions"><a class="anchor" href="#aop-schema-introductions"></a>5.3.4. Introductions</h4>
<div class="paragraph">
<p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare
that advised objects implement a given interface, and to provide an implementation of
that interface on behalf of those objects.</p>
</div>
<div class="paragraph">
<p>An introduction is made using the <code>aop:declare-parents</code> element inside an <code>aop:aspect</code>
This element is used to declare that matching types have a new parent (hence the name).
For example, given an interface <code>UsageTracked</code>, and an implementation of that interface
<code>DefaultUsageTracked</code>, the following aspect declares that all implementors of service
interfaces also implement the <code>UsageTracked</code> interface. (In order to expose statistics
via JMX for example.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">usageTrackerAspect</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">usageTracking</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;aop:declare-parents</span>
                <span class="attribute-name">types-matching</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xzy.myapp.service.*+</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">implement-interface</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.tracking.UsageTracked</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">default-impl</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.tracking.DefaultUsageTracked</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;aop:before</span>
                <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.SystemArchitecture.businessService()</span>
                        <span class="content">and this(usageTracked)</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">recordUsage</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:aspect&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The class backing the <code>usageTracking</code> bean would contain the method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> recordUsage(UsageTracked usageTracked) {
        usageTracked.incrementUseCount();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface to be implemented is determined by <code>implement-interface</code> attribute. The
value of the <code>types-matching</code> attribute is an AspectJ type pattern :- any bean of a
matching type will implement the <code>UsageTracked</code> interface. Note that in the before
advice of the above example, service beans can be directly used as implementations of
the <code>UsageTracked</code> interface. If accessing a bean programmatically you would write the
following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-instatiation-models"><a class="anchor" href="#aop-schema-instatiation-models"></a>5.3.5. Aspect instantiation models</h4>
<div class="paragraph">
<p>The only supported instantiation model for schema-defined aspects is the singleton
model. Other instantiation models may be supported in future releases.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advisors"><a class="anchor" href="#aop-schema-advisors"></a>5.3.6. Advisors</h4>
<div class="paragraph">
<p>The concept of "advisors" is brought forward from the AOP support defined in Spring 1.2
and does not have a direct equivalent in AspectJ. An advisor is like a small
self-contained aspect that has a single piece of advice. The advice itself is
represented by a bean, and must implement one of the advice interfaces described in
<a href="#aop-api-advice-types">Advice types in Spring</a>. Advisors can take advantage of AspectJ pointcut expressions
though.</p>
</div>
<div class="paragraph">
<p>Spring supports the advisor concept with the <code>&lt;aop:advisor&gt;</code> element. You will most
commonly see it used in conjunction with transactional advice, which also has its own
namespace support in Spring. Here&#8217;s how it looks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;aop:advisor</span>
                <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">advice-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;tx:advice</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">tx-advice</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;tx:attributes&gt;</span>
                <span class="tag">&lt;tx:method</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">propagation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">REQUIRED</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/tx:attributes&gt;</span>
<span class="tag">&lt;/tx:advice&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As well as the <code>pointcut-ref</code> attribute used in the above example, you can also use the
<code>pointcut</code> attribute to define a pointcut expression inline.</p>
</div>
<div class="paragraph">
<p>To define the precedence of an advisor so that the advice can participate in ordering,
use the <code>order</code> attribute to define the <code>Ordered</code> value of the advisor.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-example"><a class="anchor" href="#aop-schema-example"></a>5.3.7. Example</h4>
<div class="paragraph">
<p>Let&#8217;s see how the concurrent locking failure retry example from
<a href="#aop-ataspectj-example">Example</a> looks when rewritten using the schema support.</p>
</div>
<div class="paragraph">
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, deadlock loser). If the operation is retried, it is quite likely it will
succeed next time round. For business services where it is appropriate to retry in such
conditions (idempotent operations that don&#8217;t need to go back to the user for conflict
resolution), we&#8217;d like to transparently retry the operation to avoid the client seeing a
<code>PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer, and hence is ideal for implementing via an
aspect.</p>
</div>
<div class="paragraph">
<p>Because we want to retry the operation, we&#8217;ll need to use around advice so that we can
call proceed multiple times. Here&#8217;s how the basic aspect implementation looks (it&#8217;s just
a regular Java class using the schema support):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ConcurrentOperationExecutor</span> <span class="directive">implements</span> Ordered {

        <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> DEFAULT_MAX_RETRIES = <span class="integer">2</span>;

        <span class="directive">private</span> <span class="type">int</span> maxRetries = DEFAULT_MAX_RETRIES;
        <span class="directive">private</span> <span class="type">int</span> order = <span class="integer">1</span>;

        <span class="directive">public</span> <span class="type">void</span> setMaxRetries(<span class="type">int</span> maxRetries) {
                <span class="local-variable">this</span>.maxRetries = maxRetries;
        }

        <span class="directive">public</span> <span class="type">int</span> getOrder() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.order;
        }

        <span class="directive">public</span> <span class="type">void</span> setOrder(<span class="type">int</span> order) {
                <span class="local-variable">this</span>.order = order;
        }

        <span class="directive">public</span> <span class="predefined-type">Object</span> doConcurrentOperation(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="type">int</span> numAttempts = <span class="integer">0</span>;
                PessimisticLockingFailureException lockFailureException;
                <span class="keyword">do</span> {
                        numAttempts++;
                        <span class="keyword">try</span> {
                                <span class="keyword">return</span> pjp.proceed();
                        }
                        <span class="keyword">catch</span>(PessimisticLockingFailureException ex) {
                                lockFailureException = ex;
                        }
                } <span class="keyword">while</span>(numAttempts &lt;= <span class="local-variable">this</span>.maxRetries);
                <span class="keyword">throw</span> lockFailureException;
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the aspect implements the <code>Ordered</code> interface so we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code>maxRetries</code> and <code>order</code> properties will both be configured by Spring. The
main action happens in the <code>doConcurrentOperation</code> around advice method. We try to
proceed, and if we fail with a <code>PessimisticLockingFailureException</code> we simply try again
unless we have exhausted all of our retry attempts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This class is identical to the one used in the @AspectJ example, but with the
annotations removed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The corresponding Spring configuration is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config&gt;</span>

        <span class="tag">&lt;aop:aspect</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationRetry</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationExecutor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

                <span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">idempotentOperation</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

                <span class="tag">&lt;aop:around</span>
                        <span class="attribute-name">pointcut-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">idempotentOperation</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">doConcurrentOperation</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;/aop:aspect&gt;</span>

<span class="tag">&lt;/aop:config&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">concurrentOperationExecutor</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.service.impl.ConcurrentOperationExecutor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxRetries</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">100</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that for the time being we assume that all business services are idempotent. If
this is not the case we can refine the aspect so that it only retries genuinely
idempotent operations, by introducing an <code>Idempotent</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Retention</span>(<span class="predefined-type">RetentionPolicy</span>.RUNTIME)
<span class="directive">public</span> <span class="annotation">@interface</span> Idempotent {
        <span class="comment">// marker annotation</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and using the annotation to annotate the implementation of service operations. The
change to the aspect to retry only idempotent operations simply involves refining the
pointcut expression so that only <code>@Idempotent</code> operations match:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">idempotentOperation</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* com.xyz.myapp.service.*.*(..)) and</span>
                <span class="content">@annotation(com.xyz.myapp.service.Idempotent)</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-choosing"><a class="anchor" href="#aop-choosing"></a>5.4. Choosing which AOP declaration style to use</h3>
<div class="paragraph">
<p>Once you have decided that an aspect is the best approach for implementing a given
requirement, how do you decide between using Spring AOP or AspectJ, and between the
Aspect language (code) style, @AspectJ annotation style, or the Spring XML style? These
decisions are influenced by a number of factors including application requirements,
development tools, and team familiarity with AOP.</p>
</div>
<div class="sect3">
<h4 id="aop-spring-or-aspectj"><a class="anchor" href="#aop-spring-or-aspectj"></a>5.4.1. Spring AOP or full AspectJ?</h4>
<div class="paragraph">
<p>Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ as
there is no requirement to introduce the AspectJ compiler / weaver into your development
and build processes. If you only need to advise the execution of operations on Spring
beans, then Spring AOP is the right choice. If you need to advise objects not managed by
the Spring container (such as domain objects typically), then you will need to use
AspectJ. You will also need to use AspectJ if you wish to advise join points other than
simple method executions (for example, field get or set join points, and so on).</p>
</div>
<div class="paragraph">
<p>When using AspectJ, you have the choice of the AspectJ language syntax (also known as
the "code style") or the @AspectJ annotation style. Clearly, if you are not using Java
5+ then the choice has been made for you&#8230;&#8203; use the code style. If aspects play a large
role in your design, and you are able to use the <a href="https://www.eclipse.org/ajdt/">AspectJ
Development Tools (AJDT)</a> plugin for Eclipse, then the AspectJ language syntax is the
preferred option: it is cleaner and simpler because the language was purposefully
designed for writing aspects. If you are not using Eclipse, or have only a few aspects
that do not play a major role in your application, then you may want to consider using
the @AspectJ style and sticking with a regular Java compilation in your IDE, and adding
an aspect weaving phase to your build script.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-or-xml"><a class="anchor" href="#aop-ataspectj-or-xml"></a>5.4.2. @AspectJ or XML for Spring AOP?</h4>
<div class="paragraph">
<p>If you have chosen to use Spring AOP, then you have a choice of @AspectJ or XML style.
There are various tradeoffs to consider.</p>
</div>
<div class="paragraph">
<p>The XML style will be most familiar to existing Spring users and it is backed by genuine
POJOs. When using AOP as a tool to configure enterprise services then XML can be a good
choice (a good test is whether you consider the pointcut expression to be a part of your
configuration you might want to change independently). With the XML style arguably it is
clearer from your configuration what aspects are present in the system.</p>
</div>
<div class="paragraph">
<p>The XML style has two disadvantages. Firstly it does not fully encapsulate the
implementation of the requirement it addresses in a single place. The DRY principle says
that there should be a single, unambiguous, authoritative representation of any piece of
knowledge within a system. When using the XML style, the knowledge of <em>how</em> a
requirement is implemented is split across the declaration of the backing bean class,
and the XML in the configuration file. When using the @AspectJ style there is a single
module - the aspect - in which this information is encapsulated. Secondly, the XML style
is slightly more limited in what it can express than the @AspectJ style: only the
"singleton" aspect instantiation model is supported, and it is not possible to combine
named pointcuts declared in XML. For example, in the @AspectJ style you can write
something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Pointcut</span>(execution(* get*()))
<span class="directive">public</span> <span class="type">void</span> propertyAccess() {}

<span class="annotation">@Pointcut</span>(execution(org.xyz.Account+ *(..))
<span class="directive">public</span> <span class="type">void</span> operationReturningAnAccount() {}

<span class="annotation">@Pointcut</span>(propertyAccess() &amp;&amp; operationReturningAnAccount())
<span class="directive">public</span> <span class="type">void</span> accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the XML style I can declare the first two pointcuts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">propertyAccess</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(* get*())</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;aop:pointcut</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">operationReturningAnAccount</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(org.xyz.Account+ *(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The downside of the XML approach is that you cannot define the
<code>accountPropertyAccess</code> pointcut by combining these definitions.</p>
</div>
<div class="paragraph">
<p>The @AspectJ style supports additional instantiation models, and richer pointcut
composition. It has the advantage of keeping the aspect as a modular unit. It also has
the advantage the @AspectJ aspects can be understood (and thus consumed) both by Spring
AOP and by AspectJ - so if you later decide you need the capabilities of AspectJ to
implement additional requirements then it is very easy to migrate to an AspectJ-based
approach. On balance the Spring team prefer the @AspectJ style whenever you have aspects
that do more than simple "configuration" of enterprise services.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-mixing-styles"><a class="anchor" href="#aop-mixing-styles"></a>5.5. Mixing aspect types</h3>
<div class="paragraph">
<p>It is perfectly possible to mix @AspectJ style aspects using the autoproxying support,
schema-defined <code>&lt;aop:aspect&gt;</code> aspects, <code>&lt;aop:advisor&gt;</code> declared advisors and even
proxies and interceptors defined using the Spring 1.2 style in the same configuration.
All of these are implemented using the same underlying support mechanism and will
co-exist without any difficulty.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-proxying"><a class="anchor" href="#aop-proxying"></a>5.6. Proxying mechanisms</h3>
<div class="paragraph">
<p>Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given
target object. (JDK dynamic proxies are preferred whenever you have a choice).</p>
</div>
<div class="paragraph">
<p>If the target object to be proxied implements at least one interface then a JDK dynamic
proxy will be used. All of the interfaces implemented by the target type will be
proxied. If the target object does not implement any interfaces then a CGLIB proxy will
be created.</p>
</div>
<div class="paragraph">
<p>If you want to force the use of CGLIB proxying (for example, to proxy every method
defined for the target object, not just those implemented by its interfaces) you can do
so. However, there are some issues to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>final</code> methods cannot be advised, as they cannot be overridden.</p>
</li>
<li>
<p>As of Spring 3.2, it is no longer necessary to add CGLIB to your project classpath, as
CGLIB classes are repackaged under org.springframework and included directly in the
spring-core JAR. This means that CGLIB-based proxy support 'just works' in the same
way that JDK dynamic proxies always have.</p>
</li>
<li>
<p>As of Spring 4.0, the constructor of your proxied object will NOT be called twice
anymore since the CGLIB proxy instance will be created via Objenesis. Only if your
JVM does not allow for constructor bypassing, you might see double invocations and
corresponding debug log entries from Spring&#8217;s AOP support.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To force the use of CGLIB proxies set the value of the <code>proxy-target-class</code> attribute of
the <code>&lt;aop:config&gt;</code> element to true:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:config</span> <span class="attribute-name">proxy-target-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- other beans defined here... --&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To force CGLIB proxying when using the @AspectJ autoproxy support, set the
<code>'proxy-target-class'</code> attribute of the <code>&lt;aop:aspectj-autoproxy&gt;</code> element to <code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy</span> <span class="attribute-name">proxy-target-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Multiple <code>&lt;aop:config/&gt;</code> sections are collapsed into a single unified auto-proxy creator
at runtime, which applies the <em>strongest</em> proxy settings that any of the
<code>&lt;aop:config/&gt;</code> sections (typically from different XML bean definition files) specified.
This also applies to the <code>&lt;tx:annotation-driven/&gt;</code> and <code>&lt;aop:aspectj-autoproxy/&gt;</code>
elements.</p>
</div>
<div class="paragraph">
<p>To be clear: using <code>proxy-target-class="true"</code> on <code>&lt;tx:annotation-driven/&gt;</code>,
<code>&lt;aop:aspectj-autoproxy/&gt;</code> or <code>&lt;aop:config/&gt;</code> elements will force the use of CGLIB
proxies <em>for all three of them</em>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-understanding-aop-proxies"><a class="anchor" href="#aop-understanding-aop-proxies"></a>5.6.1. Understanding AOP proxies</h4>
<div class="paragraph">
<p>Spring AOP is <em>proxy-based</em>. It is vitally important that you grasp the semantics of
what that last statement actually means before you write your own aspects or use any of
the Spring AOP-based aspects supplied with the Spring Framework.</p>
</div>
<div class="paragraph">
<p>Consider first the scenario where you have a plain-vanilla, un-proxied,
nothing-special-about-it, straight object reference, as illustrated by the following
code snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimplePojo</span> <span class="directive">implements</span> Pojo {

        <span class="directive">public</span> <span class="type">void</span> foo() {
                <span class="comment">// this next method invocation is a direct call on the 'this' reference</span>
                <span class="local-variable">this</span>.bar();
        }

        <span class="directive">public</span> <span class="type">void</span> bar() {
                <span class="comment">// some logic...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you invoke a method on an object reference, the method is invoked <em>directly</em> on
that object reference, as can be seen below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-plain-pojo-call.png" alt="aop proxy plain pojo call">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                Pojo pojo = <span class="keyword">new</span> SimplePojo();

                <span class="comment">// this is a direct method call on the 'pojo' reference</span>
                pojo.foo();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Things change slightly when the reference that client code has is a proxy. Consider the
following diagram and code snippet.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-call.png" alt="aop proxy call">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());
                factory.addInterface(Pojo.class);
                factory.addAdvice(<span class="keyword">new</span> RetryAdvice());

                Pojo pojo = (Pojo) factory.getProxy();

                <span class="comment">// this is a method call on the proxy!</span>
                pojo.foo();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key thing to understand here is that the client code inside the <code>main(..)</code> of the
<code>Main</code> class <em>has a reference to the proxy</em>. This means that method calls on that
object reference will be calls on the proxy, and as such the proxy will be able to
delegate to all of the interceptors (advice) that are relevant to that particular method
call. However, once the call has finally reached the target object, the <code>SimplePojo</code>
reference in this case, any method calls that it may make on itself, such as
<code>this.bar()</code> or <code>this.foo()</code>, are going to be invoked against the <em>this</em> reference,
and <em>not</em> the proxy. This has important implications. It means that self-invocation is
<em>not</em> going to result in the advice associated with a method invocation getting a
chance to execute.</p>
</div>
<div class="paragraph">
<p>Okay, so what is to be done about this? The best approach (the term best is used loosely
here) is to refactor your code such that the self-invocation does not happen. For sure,
this does entail some work on your part, but it is the best, least-invasive approach.
The next approach is absolutely horrendous, and I am almost reticent to point it out
precisely because it is so horrendous. You can (choke!) totally tie the logic within
your class to Spring AOP by doing this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">SimplePojo</span> <span class="directive">implements</span> Pojo {

        <span class="directive">public</span> <span class="type">void</span> foo() {
                <span class="comment">// this works, but... gah!</span>
                ((Pojo) AopContext.currentProxy()).bar();
        }

        <span class="directive">public</span> <span class="type">void</span> bar() {
                <span class="comment">// some logic...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This totally couples your code to Spring AOP, <em>and</em> it makes the class itself aware of
the fact that it is being used in an AOP context, which flies in the face of AOP. It
also requires some additional configuration when the proxy is being created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> SimplePojo());
                factory.adddInterface(Pojo.class);
                factory.addAdvice(<span class="keyword">new</span> RetryAdvice());
                factory.setExposeProxy(<span class="predefined-constant">true</span>);

                Pojo pojo = (Pojo) factory.getProxy();

                <span class="comment">// this is a method call on the proxy!</span>
                pojo.foo();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, it must be noted that AspectJ does not have this self-invocation issue because
it is not a proxy-based AOP framework.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-aspectj-programmatic"><a class="anchor" href="#aop-aspectj-programmatic"></a>5.7. Programmatic creation of @AspectJ Proxies</h3>
<div class="paragraph">
<p>In addition to declaring aspects in your configuration using either <code>&lt;aop:config&gt;</code> or
<code>&lt;aop:aspectj-autoproxy&gt;</code>, it is also possible programmatically to create proxies that
advise target objects. For the full details of Spring&#8217;s AOP API, see the next chapter.
Here we want to focus on the ability to automatically create proxies using @AspectJ
aspects.</p>
</div>
<div class="paragraph">
<p>The class <code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> can be used
to create a proxy for a target object that is advised by one or more @AspectJ aspects.
Basic usage for this class is very simple, as illustrated below. See the javadocs for
full information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// create a factory that can generate a proxy for the given target object</span>
AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory(targetObject);

<span class="comment">// add an aspect, the class must be an @AspectJ aspect</span>
<span class="comment">// you can call this as many times as you need with different aspects</span>
factory.addAspect(<span class="predefined-type">SecurityManager</span>.class);

<span class="comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span>
factory.addAspect(usageTracker);

<span class="comment">// now get the proxy object...</span>
MyInterfaceType proxy = factory.getProxy();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-using-aspectj"><a class="anchor" href="#aop-using-aspectj"></a>5.8. Using AspectJ with Spring applications</h3>
<div class="paragraph">
<p>Everything we&#8217;ve covered so far in this chapter is pure Spring AOP. In this section,
we&#8217;re going to look at how you can use the AspectJ compiler/weaver instead of, or in
addition to, Spring AOP if your needs go beyond the facilities offered by Spring AOP
alone.</p>
</div>
<div class="paragraph">
<p>Spring ships with a small AspectJ aspect library, which is available standalone in your
distribution as <code>spring-aspects.jar</code>; you&#8217;ll need to add this to your classpath in order
to use the aspects in it. <a href="#aop-atconfigurable">在 Spring 中使用 AspectJ 对域对象进行依赖注入</a> and <a href="#aop-ajlib-other">Other Spring aspects for AspectJ</a> discuss the
content of this library and how you can use it. <a href="#aop-aj-configure">Configuring AspectJ aspects using Spring IoC</a> discusses how to
dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally,
<a href="#aop-aj-ltw">Load-time weaving with AspectJ in the Spring Framework</a> provides an introduction to load-time weaving for Spring applications
using AspectJ.</p>
</div>
<div class="sect3">
<h4 id="aop-atconfigurable"><a class="anchor" href="#aop-atconfigurable"></a>5.8.1. 在 Spring 中使用 AspectJ 对域对象进行依赖注入</h4>
<div class="paragraph">
<p>The Spring container instantiates and configures beans defined in your application
context. It is also possible to ask a bean factory to configure a <em>pre-existing</em>
object given the name of a bean definition containing the configuration to be applied.
The <code>spring-aspects.jar</code> contains an annotation-driven aspect that exploits this
capability to allow dependency injection of <em>any object</em>. The support is intended to
be used for objects created <em>outside of the control of any container</em>. Domain objects
often fall into this category because they are often created programmatically using the
<code>new</code> operator, or by an ORM tool as a result of a database query.</p>
</div>
<div class="paragraph">
<p>The <code>@Configurable</code> annotation marks a class as eligible for Spring-driven
configuration. In the simplest case it can be used just as a marker annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.xyz.myapp.domain</span>;

<span class="keyword">import</span> <span class="include">org.springframework.beans.factory.annotation.Configurable</span>;

<span class="annotation">@Configurable</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Account</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When used as a marker interface in this way, Spring will configure new instances of the
annotated type ( <code>Account</code> in this case) using a bean definition (typically
prototype-scoped) with the same name as the fully-qualified type name (
<code>com.xyz.myapp.domain.Account</code>). Since the default name for a bean is the
fully-qualified name of its type, a convenient way to declare the prototype definition
is simply to omit the <code>id</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.myapp.domain.Account</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fundsTransferService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">fundsTransferService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to explicitly specify the name of the prototype bean definition to use, you
can do so directly in the annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.xyz.myapp.domain</span>;

<span class="keyword">import</span> <span class="include">org.springframework.beans.factory.annotation.Configurable</span>;

<span class="annotation">@Configurable</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">account</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Account</span> {
        <span class="comment">// ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring will now look for a bean definition named "account" and use that as the
definition to configure new <code>Account</code> instances.</p>
</div>
<div class="paragraph">
<p>You can also use autowiring to avoid having to specify a dedicated bean definition at
all. To have Spring apply autowiring use the <code>autowire</code> property of the
<code>@Configurable</code> annotation: specify either <code>@Configurable(autowire=Autowire.BY_TYPE)</code> or
<code>@Configurable(autowire=Autowire.BY_NAME</code> for autowiring by type or by name
respectively. As an alternative, as of Spring 2.5 it is preferable to specify explicit,
annotation-driven dependency injection for your <code>@Configurable</code> beans by using
<code>@Autowired</code> or <code>@Inject</code> at the field or method level (see <a href="#beans-annotation-config">Annotation-based container configuration</a>
for further details).</p>
</div>
<div class="paragraph">
<p>Finally you can enable Spring dependency checking for the object references in the newly
created and configured object by using the <code>dependencyCheck</code> attribute (for example:
<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>). If this attribute is
set to true, then Spring will validate after configuration that all properties (<em>which
are not primitives or collections</em>) have been set.</p>
</div>
<div class="paragraph">
<p>Using the annotation on its own does nothing of course. It is the
<code>AnnotationBeanConfigurerAspect</code> in <code>spring-aspects.jar</code> that acts on the presence of
the annotation. In essence the aspect says "after returning from the initialization of a
new object of a type annotated with <code>@Configurable</code>, configure the newly created object
using Spring in accordance with the properties of the annotation". In this context,
<em>initialization</em> refers to newly instantiated objects (e.g., objects instantiated with
the <code>new</code> operator) as well as to <code>Serializable</code> objects that are undergoing
deserialization (e.g., via
<a href="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html">readResolve()</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One of the key phrases in the above paragraph is '<em>in essence</em>'. For most cases, the
exact semantics of '<em>after returning from the initialization of a new object</em>' will be
fine&#8230;&#8203; in this context, '<em>after initialization</em>' means that the dependencies will be
injected <em>after</em> the object has been constructed - this means that the dependencies
will not be available for use in the constructor bodies of the class. If you want the
dependencies to be injected <em>before</em> the constructor bodies execute, and thus be
available for use in the body of the constructors, then you need to define this on the
<code>@Configurable</code> declaration like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configurable</span>(preConstruction=<span class="predefined-constant">true</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can find out more information about the language semantics of the various pointcut
types in AspectJ
<a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">in this
appendix</a> of the <a href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ
Programming Guide</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For this to work the annotated types must be woven with the AspectJ weaver - you can
either use a build-time Ant or Maven task to do this (see for example the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ Development
Environment Guide</a>) or load-time weaving (see <a href="#aop-aj-ltw">Load-time weaving with AspectJ in the Spring Framework</a>). The
<code>AnnotationBeanConfigurerAspect</code> itself needs configuring by Spring (in order to obtain
a reference to the bean factory that is to be used to configure new objects). If you are
using Java based configuration simply add <code>@EnableSpringConfigured</code> to any
<code>@Configuration</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableSpringConfigured</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML based configuration, the Spring <a href="appendix.html#xsd-config-body-schemas-context"><code>context</code> namespace</a> defines a convenient <code>context:spring-configured</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;context:spring-configured</span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of <code>@Configurable</code> objects created <em>before</em> the aspect has been configured
will result in a message being issued to the debug log and no configuration of the
object taking place. An example might be a bean in the Spring configuration that creates
domain objects when it is initialized by Spring. In this case you can use the
"depends-on" bean attribute to manually specify that the bean depends on the
configuration aspect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xzy.myapp.service.MyService</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">depends-on</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- ... --&gt;</span>

<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Do not activate <code>@Configurable</code> processing through the bean configurer aspect unless you
really mean to rely on its semantics at runtime. In particular, make sure that you do
not use <code>@Configurable</code> on bean classes which are registered as regular Spring beans
with the container: You would get double initialization otherwise, once through the
container and once through the aspect.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="aop-configurable-testing"><a class="anchor" href="#aop-configurable-testing"></a>Unit testing @Configurable objects</h5>
<div class="paragraph">
<p>One of the goals of the <code>@Configurable</code> support is to enable independent unit testing of
domain objects without the difficulties associated with hard-coded lookups. If
<code>@Configurable</code> types have not been woven by AspectJ then the annotation has no affect
during unit testing, and you can simply set mock or stub property references in the
object under test and proceed as normal. If <code>@Configurable</code> types <em>have</em> been woven by
AspectJ then you can still unit test outside of the container as normal, but you will
see a warning message each time that you construct an <code>@Configurable</code> object indicating
that it has not been configured by Spring.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-configurable-container"><a class="anchor" href="#aop-configurable-container"></a>Working with multiple application contexts</h5>
<div class="paragraph">
<p>The <code>AnnotationBeanConfigurerAspect</code> used to implement the <code>@Configurable</code> support is an
AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope of
<code>static</code> members, that is to say there is one aspect instance per classloader that
defines the type. This means that if you define multiple application contexts within the
same classloader hierarchy you need to consider where to define the
<code>@EnableSpringConfigured</code> bean and where to place <code>spring-aspects.jar</code> on the classpath.</p>
</div>
<div class="paragraph">
<p>Consider a typical Spring web-app configuration with a shared parent application context
defining common business services and everything needed to support them, and one child
application context per servlet containing definitions particular to that servlet. All
of these contexts will co-exist within the same classloader hierarchy, and so the
<code>AnnotationBeanConfigurerAspect</code> can only hold a reference to one of them. In this case
we recommend defining the <code>@EnableSpringConfigured</code> bean in the shared (parent)
application context: this defines the services that you are likely to want to inject
into domain objects. A consequence is that you cannot configure domain objects with
references to beans defined in the child (servlet-specific) contexts using the
@Configurable mechanism (probably not something you want to do anyway!).</p>
</div>
<div class="paragraph">
<p>When deploying multiple web-apps within the same container, ensure that each
web-application loads the types in <code>spring-aspects.jar</code> using its own classloader (for
example, by placing <code>spring-aspects.jar</code> in <code>'WEB-INF/lib'</code>). If <code>spring-aspects.jar</code> is
only added to the container wide classpath (and hence loaded by the shared parent
classloader), all web applications will share the same aspect instance which is probably
not what you want.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-ajlib-other"><a class="anchor" href="#aop-ajlib-other"></a>5.8.2. Other Spring aspects for AspectJ</h4>
<div class="paragraph">
<p>In addition to the <code>@Configurable</code> aspect, <code>spring-aspects.jar</code> contains an AspectJ
aspect that can be used to drive Spring&#8217;s transaction management for types and methods
annotated with the <code>@Transactional</code> annotation. This is primarily intended for users who
want to use the Spring Framework&#8217;s transaction support outside of the Spring container.</p>
</div>
<div class="paragraph">
<p>The aspect that interprets <code>@Transactional</code> annotations is the
<code>AnnotationTransactionAspect</code>. When using this aspect, you must annotate the
<em>implementation</em> class (and/or methods within that class), <em>not</em> the interface (if
any) that the class implements. AspectJ follows Java&#8217;s rule that annotations on
interfaces are <em>not inherited</em>.</p>
</div>
<div class="paragraph">
<p>A <code>@Transactional</code> annotation on a class specifies the default transaction semantics for
the execution of any <em>public</em> operation in the class.</p>
</div>
<div class="paragraph">
<p>A <code>@Transactional</code> annotation on a method within the class overrides the default
transaction semantics given by the class annotation (if present). Methods of any
visibility may be annotated, including private methods. Annotating non-public methods
directly is the only way to get transaction demarcation for the execution of such methods.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since Spring Framework 4.2, <code>spring-aspects</code> provides a similar aspect that offers the
exact same features for the standard <code>javax.transaction.Transactional</code> annotation. Check
<code>JtaAnnotationTransactionAspect</code> for more details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For AspectJ programmers that want to use the Spring configuration and transaction
management support but don&#8217;t want to (or cannot) use annotations, <code>spring-aspects.jar</code>
also contains <code>abstract</code> aspects you can extend to provide your own pointcut
definitions. See the sources for the <code>AbstractBeanConfigurerAspect</code> and
<code>AbstractTransactionAspect</code> aspects for more information. As an example, the following
excerpt shows how you could write an aspect to configure all instances of objects
defined in the domain model using prototype bean definitions that match the
fully-qualified class names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> aspect DomainObjectConfiguration <span class="directive">extends</span> AbstractBeanConfigurerAspect {

        <span class="directive">public</span> DomainObjectConfiguration() {
                setBeanWiringInfoResolver(<span class="keyword">new</span> ClassNameBeanWiringInfoResolver());
        }

        <span class="comment">// the creation of a new bean (any object in the domain model)</span>
        <span class="directive">protected</span> pointcut beanCreation(<span class="predefined-type">Object</span> beanInstance) :
                initialization(<span class="keyword">new</span>(..)) &amp;&amp;
                SystemArchitecture.inDomainModel() &amp;&amp;
                <span class="local-variable">this</span>(beanInstance);

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-configure"><a class="anchor" href="#aop-aj-configure"></a>5.8.3. Configuring AspectJ aspects using Spring IoC</h4>
<div class="paragraph">
<p>When using AspectJ aspects with Spring applications, it is natural to both want and
expect to be able to configure such aspects using Spring. The AspectJ runtime itself is
responsible for aspect creation, and the means of configuring the AspectJ created
aspects via Spring depends on the AspectJ instantiation model (the <code>per-xxx</code> clause)
used by the aspect.</p>
</div>
<div class="paragraph">
<p>The majority of AspectJ aspects are <em>singleton</em> aspects. Configuration of these
aspects is very easy: simply create a bean definition referencing the aspect type as
normal, and include the bean attribute <code>'factory-method="aspectOf"'</code>. This ensures that
Spring obtains the aspect instance by asking AspectJ for it rather than trying to create
an instance itself. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profiler</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.xyz.profiler.Profiler</span><span class="delimiter">&quot;</span></span>
                <span class="error"><strong></span><span class="error"></strong></span><span class="attribute-name">factory-method</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">aspectOf</span><span class="delimiter">&quot;</span></span><span class="error"><strong></span><span class="error"></strong></span><span class="tag">&gt;</span>

        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">profilingStrategy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jamonProfilingStrategy</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Non-singleton aspects are harder to configure: however it is possible to do so by
creating prototype bean definitions and using the <code>@Configurable</code> support from
<code>spring-aspects.jar</code> to configure the aspect instances once they have bean created by
the AspectJ runtime.</p>
</div>
<div class="paragraph">
<p>If you have some @AspectJ aspects that you want to weave with AspectJ (for example,
using load-time weaving for domain model types) and other @AspectJ aspects that you want
to use with Spring AOP, and these aspects are all configured using Spring, then you will
need to tell the Spring AOP @AspectJ autoproxying support which exact subset of the
@AspectJ aspects defined in the configuration should be used for autoproxying. You can
do this by using one or more <code>&lt;include/&gt;</code> elements inside the <code>&lt;aop:aspectj-autoproxy/&gt;</code>
declaration. Each <code>&lt;include/&gt;</code> element specifies a name pattern, and only beans with
names matched by at least one of the patterns will be used for Spring AOP autoproxy
configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;aop:aspectj-autoproxy&gt;</span>
        <span class="tag">&lt;aop:include</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thisBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;aop:include</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">thatBean</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/aop:aspectj-autoproxy&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Do not be misled by the name of the <code>&lt;aop:aspectj-autoproxy/&gt;</code> element: using it will
result in the creation of <em>Spring AOP proxies</em>. The @AspectJ style of aspect
declaration is just being used here, but the AspectJ runtime is <em>not</em> involved.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw"><a class="anchor" href="#aop-aj-ltw"></a>5.8.4. Load-time weaving with AspectJ in the Spring Framework</h4>
<div class="paragraph">
<p>Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an
application&#8217;s class files as they are being loaded into the Java virtual machine (JVM).
The focus of this section is on configuring and using LTW in the specific context of the
Spring Framework: this section is not an introduction to LTW though. For full details on
the specifics of LTW and configuring LTW with just AspectJ (with Spring not being
involved at all), see the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">LTW section of the AspectJ
Development Environment Guide</a>.</p>
</div>
<div class="paragraph">
<p>The value-add that the Spring Framework brings to AspectJ LTW is in enabling much
finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected using
a Java (5+) agent, which is switched on by specifying a VM argument when starting up a
JVM. It is thus a JVM-wide setting, which may be fine in some situations, but often is a
little too coarse. Spring-enabled LTW enables you to switch on LTW on a
<em>per-ClassLoader</em> basis, which obviously is more fine-grained and which can make more
sense in a 'single-JVM-multiple-application' environment (such as is found in a typical
application server environment).</p>
</div>
<div class="paragraph">
<p>Further, <a href="#aop-aj-ltw-environments">in certain environments</a>, this support enables
load-time weaving <em>without making any modifications to the application server&#8217;s launch
script</em> that will be needed to add <code>-javaagent:path/to/aspectjweaver.jar</code> or (as we
describe later in this section)
<code>-javaagent:path/to/org.springframework.instrument-{version}.jar</code> (previously named
<code>spring-agent.jar</code>). Developers simply modify one or more files that form the
application context to enable load-time weaving instead of relying on administrators who
typically are in charge of the deployment configuration such as the launch script.</p>
</div>
<div class="paragraph">
<p>Now that the sales pitch is over, let us first walk through a quick example of AspectJ
LTW using Spring, followed by detailed specifics about elements introduced in the
following example. For a complete example, please see the
<a href="https://github.com/spring-projects/spring-petclinic">Petclinic sample application</a>.</p>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-first-example"><a class="anchor" href="#aop-aj-ltw-first-example"></a>A first example</h5>
<div class="paragraph">
<p>Let us assume that you are an application developer who has been tasked with diagnosing
the cause of some performance problems in a system. Rather than break out a profiling
tool, what we are going to do is switch on a simple profiling aspect that will enable us
to very quickly get some performance metrics, so that we can then apply a finer-grained
profiling tool to that specific area immediately afterwards.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The example presented here uses XML style configuration, it is also possible to
configure and use @AspectJ with <a href="#beans-java">Java Configuration</a>.
Specifically the <code>@EnableLoadTimeWeaving</code> annotation can be used as an alternative to
<code>&lt;context:load-time-weaver/&gt;</code> (see <a href="#aop-aj-ltw-spring">below</a> for details).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is the profiling aspect. Nothing too fancy, just a quick-and-dirty time-based
profiler, using the @AspectJ-style of aspect declaration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">foo</span>;

<span class="keyword">import</span> <span class="include">org.aspectj.lang.ProceedingJoinPoint</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Aspect</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Around</span>;
<span class="keyword">import</span> <span class="include">org.aspectj.lang.annotation.Pointcut</span>;
<span class="keyword">import</span> <span class="include">org.springframework.util.StopWatch</span>;
<span class="keyword">import</span> <span class="include">org.springframework.core.annotation.Order</span>;

<span class="annotation">@Aspect</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ProfilingAspect</span> {

        <span class="annotation">@Around</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">methodsToBeProfiled()</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="predefined-type">Object</span> profile(ProceedingJoinPoint pjp) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                StopWatch sw = <span class="keyword">new</span> StopWatch(getClass().getSimpleName());
                <span class="keyword">try</span> {
                        sw.start(pjp.getSignature().getName());
                        <span class="keyword">return</span> pjp.proceed();
                } <span class="keyword">finally</span> {
                        sw.stop();
                        <span class="predefined-type">System</span>.out.println(sw.prettyPrint());
                }
        }

        <span class="annotation">@Pointcut</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(public * foo..*.*(..))</span><span class="delimiter">&quot;</span></span>)
        <span class="directive">public</span> <span class="type">void</span> methodsToBeProfiled(){}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will also need to create an <code>META-INF/aop.xml</code> file, to inform the AspectJ weaver
that we want to weave our <code>ProfilingAspect</code> into our classes. This file convention,
namely the presence of a file (or files) on the Java classpath called
<code>META-INF/aop.xml</code> is standard AspectJ.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="doctype">&lt;!DOCTYPE aspectj PUBLIC &quot;-//AspectJ//DTD//EN&quot; &quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;&gt;</span>
<span class="tag">&lt;aspectj&gt;</span>

        <span class="tag">&lt;weaver&gt;</span>
                <span class="comment">&lt;!-- only weave classes in our application-specific packages --&gt;</span>
                <span class="tag">&lt;include</span> <span class="attribute-name">within</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.*</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/weaver&gt;</span>

        <span class="tag">&lt;aspects&gt;</span>
                <span class="comment">&lt;!-- weave in just this aspect --&gt;</span>
                <span class="tag">&lt;aspect</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.ProfilingAspect</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/aspects&gt;</span>

<span class="tag">&lt;/aspectj&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now to the Spring-specific portion of the configuration. We need to configure a
<code>LoadTimeWeaver</code> (all explained later, just take it on trust for now). This load-time
weaver is the essential component responsible for weaving the aspect configuration in
one or more <code>META-INF/aop.xml</code> files into the classes in your application. The good
thing is that it does not require a lot of configuration, as can be seen below (there
are some more options that you can specify, but these are detailed later).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="comment">&lt;!-- a service object; we will be profiling its methods --&gt;</span>
        <span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">entitlementCalculationService</span><span class="delimiter">&quot;</span></span>
                        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">foo.StubEntitlementCalculationService</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="comment">&lt;!-- this switches on the load-time weaving --&gt;</span>
        <strong><span class="tag">&lt;context:load-time-weaver</span><span class="tag">/&gt;</span></strong>
<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that all the required artifacts are in place - the aspect, the <code>META-INF/aop.xml</code>
file, and the Spring configuration -, let us create a simple driver class with a
<code>main(..)</code> method to demonstrate the LTW in action.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">foo</span>;

<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>, Main.class);

                EntitlementCalculationService entitlementCalculationService
                        = (EntitlementCalculationService) ctx.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">entitlementCalculationService</span><span class="delimiter">&quot;</span></span>);

                <span class="comment">// the profiling aspect is 'woven' around this method execution</span>
                entitlementCalculationService.calculateEntitlement();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is one last thing to do. The introduction to this section did say that one could
switch on LTW selectively on a per- <code>ClassLoader</code> basis with Spring, and this is true.
However, just for this example, we are going to use a Java agent (supplied with Spring)
to switch on the LTW. This is the command line we will use to run the above <code>Main</code> class:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>-javaagent</code> is a flag for specifying and enabling
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">agents
to instrument programs running on the JVM</a>. The Spring Framework ships with such an
agent, the <code>InstrumentationSavingAgent</code>, which is packaged in the
<code>spring-instrument.jar</code> that was supplied as the value of the <code>-javaagent</code> argument in
the above example.</p>
</div>
<div class="paragraph">
<p>The output from the execution of the <code>Main</code> program will look something like that below.
(I have introduced a <code>Thread.sleep(..)</code> statement into the <code>calculateEntitlement()</code>
implementation so that the profiler actually captures something other than 0
milliseconds - the <code>01234</code> milliseconds is <em>not</em> an overhead introduced by the AOP :) )</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre>
</div>
</div>
<div class="paragraph">
<p>Since this LTW is effected using full-blown AspectJ, we are not just limited to advising
Spring beans; the following slight variation on the <code>Main</code> program will yield the same
result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">foo</span>;

<span class="keyword">import</span> <span class="include">org.springframework.context.support.ClassPathXmlApplicationContext</span>;

<span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">Main</span> {

        <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {

                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">beans.xml</span><span class="delimiter">&quot;</span></span>, Main.class);

                EntitlementCalculationService entitlementCalculationService =
                        <span class="keyword">new</span> StubEntitlementCalculationService();

                <span class="comment">// the profiling aspect will be 'woven' around this method execution</span>
                entitlementCalculationService.calculateEntitlement();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how in the above program we are simply bootstrapping the Spring container, and
then creating a new instance of the <code>StubEntitlementCalculationService</code> totally outside
the context of Spring&#8230;&#8203; the profiling advice still gets woven in.</p>
</div>
<div class="paragraph">
<p>The example admittedly is simplistic&#8230;&#8203; however the basics of the LTW support in Spring
have all been introduced in the above example, and the rest of this section will explain
the 'why' behind each bit of configuration and usage in detail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>ProfilingAspect</code> used in this example may be basic, but it is quite useful. It is a
nice example of a development-time aspect that developers can use during development (of
course), and then quite easily exclude from builds of the application being deployed
into UAT or production.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-the-aspects"><a class="anchor" href="#aop-aj-ltw-the-aspects"></a>Aspects</h5>
<div class="paragraph">
<p>The aspects that you use in LTW have to be AspectJ aspects. They can be written in
either the AspectJ language itself or you can write your aspects in the @AspectJ-style.
It means that your aspects are then both valid AspectJ <em>and</em> Spring AOP aspects.
Furthermore, the compiled aspect classes need to be available on the classpath.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-aop_dot_xml"><a class="anchor" href="#aop-aj-ltw-aop_dot_xml"></a>'META-INF/aop.xml'</h5>
<div class="paragraph">
<p>The AspectJ LTW infrastructure is configured using one or more <code>META-INF/aop.xml</code>
files, that are on the Java classpath (either directly, or more typically in jar files).</p>
</div>
<div class="paragraph">
<p>The structure and contents of this file is detailed in the main AspectJ reference
documentation, and the interested reader is
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">referred to
that resource</a>. (I appreciate that this section is brief, but the <code>aop.xml</code> file is
100% AspectJ - there is no Spring-specific information or semantics that apply to it,
and so there is no extra value that I can contribute either as a result), so rather than
rehash the quite satisfactory section that the AspectJ developers wrote, I am just
directing you there.)</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-libraries"><a class="anchor" href="#aop-aj-ltw-libraries"></a>Required libraries (JARS)</h5>
<div class="paragraph">
<p>At a minimum you will need the following libraries to use the Spring Framework&#8217;s support
for AspectJ LTW:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-aop.jar</code> (version 2.5 or later, plus all mandatory dependencies)</p>
</li>
<li>
<p><code>aspectjweaver.jar</code> (version 1.6.8 or later)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you are using the <a href="#aop-aj-ltw-environment-generic">Spring-provided agent to enable
instrumentation</a>, you will also need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-instrument.jar</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-spring"><a class="anchor" href="#aop-aj-ltw-spring"></a>Spring configuration</h5>
<div class="paragraph">
<p>The key component in Spring&#8217;s LTW support is the <code>LoadTimeWeaver</code> interface (in the
<code>org.springframework.instrument.classloading</code> package), and the numerous implementations
of it that ship with the Spring distribution. A <code>LoadTimeWeaver</code> is responsible for
adding one or more <code>java.lang.instrument.ClassFileTransformers</code> to a <code>ClassLoader</code> at
runtime, which opens the door to all manner of interesting applications, one of which
happens to be the LTW of aspects.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are unfamiliar with the idea of runtime class file transformation, you are
encouraged to read the javadoc API documentation for the <code>java.lang.instrument</code> package
before continuing. This is not a huge chore because there is - rather annoyingly -
precious little documentation there&#8230;&#8203; the key interfaces and classes will at least be
laid out in front of you for reference as you read through this section.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuring a <code>LoadTimeWeaver</code> for a particular <code>ApplicationContext</code> can be as easy as
adding one line. (Please note that you almost certainly will need to be using an
<code>ApplicationContext</code> as your Spring container - typically a <code>BeanFactory</code> will not be
enough because the LTW support makes use of <code>BeanFactoryPostProcessors</code>.)</p>
</div>
<div class="paragraph">
<p>To enable the Spring Framework&#8217;s LTW support, you need to configure a <code>LoadTimeWeaver</code>,
which typically is done using the <code>@EnableLoadTimeWeaving</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableLoadTimeWeaving</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you prefer XML based configuration, use the
<code>&lt;context:load-time-weaver/&gt;</code> element. Note that the element is defined in the
<code>context</code> namespace.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:load-time-weaver</span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above configuration will define and register a number of LTW-specific infrastructure
beans for you automatically, such as a <code>LoadTimeWeaver</code> and an <code>AspectJWeavingEnabler</code>.
The default <code>LoadTimeWeaver</code> is the <code>DefaultContextLoadTimeWeaver</code> class, which attempts
to decorate an automatically detected <code>LoadTimeWeaver</code>: the exact type of
<code>LoadTimeWeaver</code> that will be 'automatically detected' is dependent upon your runtime
environment (summarized in the following table).</p>
</div>
<table id="aop-aj-ltw-spring-env-impls" class="tableblock frame-all grid-all spread">
<caption class="title">Table 13. DefaultContextLoadTimeWeaver LoadTimeWeavers</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Runtime Environment</th>
<th class="tableblock halign-left valign-top"><code>LoadTimeWeaver</code> implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Oracle&#8217;s
<a href="http://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebLogicLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Oracle&#8217;s <a href="http://glassfish.dev.java.net/">GlassFish</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GlassFishLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in <a href="https://tomcat.apache.org/">Apache Tomcat</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Red Hat&#8217;s <a href="http://www.jboss.org/jbossas/">JBoss AS</a> or <a href="http://www.wildfly.org/">WildFly</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JBossLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in IBM&#8217;s <a href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSphereLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JVM started with Spring <code>InstrumentationSavingAgent</code> <em>(java
-javaagent:path/to/spring-instrument.jar)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InstrumentationLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fallback, expecting the underlying ClassLoader to follow common conventions (e.g.
applicable to <code>TomcatInstrumentableClassLoader</code> and <a href="http://www.caucho.com/">Resin</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReflectiveLoadTimeWeaver</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that these are just the <code>LoadTimeWeavers</code> that are autodetected when using the
<code>DefaultContextLoadTimeWeaver</code>: it is of course possible to specify exactly which
<code>LoadTimeWeaver</code> implementation that you wish to use.</p>
</div>
<div class="paragraph">
<p>To specify a specific <code>LoadTimeWeaver</code> with Java configuration implement the
<code>LoadTimeWeavingConfigurer</code> interface and override the <code>getLoadTimeWeaver()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableLoadTimeWeaving</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AppConfig</span> <span class="directive">implements</span> LoadTimeWeavingConfigurer {

        <span class="annotation">@Override</span>
        <span class="directive">public</span> LoadTimeWeaver getLoadTimeWeaver() {
                <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveLoadTimeWeaver();
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using XML based configuration you can specify the fully-qualified classname
as the value of the <code>weaver-class</code> attribute on the <code>&lt;context:load-time-weaver/&gt;</code>
element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xmlns:context</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/context</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span>
                <span class="content">http://www.springframework.org/schema/beans</span>
                <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
                <span class="content">http://www.springframework.org/schema/context</span>
                <span class="content">http://www.springframework.org/schema/context/spring-context.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

        <span class="tag">&lt;context:load-time-weaver</span>
                        <span class="attribute-name">weaver-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>LoadTimeWeaver</code> that is defined and registered by the configuration can be later
retrieved from the Spring container using the well-known name <code>loadTimeWeaver</code>.
Remember that the <code>LoadTimeWeaver</code> exists just as a mechanism for Spring&#8217;s LTW
infrastructure to add one or more <code>ClassFileTransformers</code>. The actual
<code>ClassFileTransformer</code> that does the LTW is the <code>ClassPreProcessorAgentAdapter</code> (from
the <code>org.aspectj.weaver.loadtime</code> package) class. See the class-level javadocs of the
<code>ClassPreProcessorAgentAdapter</code> class for further details, because the specifics of how
the weaving is actually effected is beyond the scope of this section.</p>
</div>
<div class="paragraph">
<p>There is one final attribute of the configuration left to discuss: the
<code>aspectjWeaving</code> attribute (or <code>aspectj-weaving</code> if you are using XML). This is a
simple attribute that controls whether LTW is enabled or not; it is as simple as that.
It accepts one of three possible values, summarized below, with the default value being
<code>autodetect</code> if the attribute is not present.</p>
</div>
<table id="aop-aj-ltw-ltw-tag-attrs" class="tableblock frame-all grid-all spread">
<caption class="title">Table 14. AspectJ weaving attribute values</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation Value</th>
<th class="tableblock halign-left valign-top">XML Value</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>on</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ weaving is on, and aspects will be woven at load-time as appropriate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DISABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTW is off&#8230;&#8203; no aspect will be woven at load-time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AUTODETECT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>autodetect</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the Spring LTW infrastructure can find at least one <code>META-INF/aop.xml</code> file,
then AspectJ weaving is on, else it is off. This is the default value.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-environments"><a class="anchor" href="#aop-aj-ltw-environments"></a>Environment-specific configuration</h5>
<div class="paragraph">
<p>This last section contains any additional settings and configuration that you will need
when using Spring&#8217;s LTW support in environments such as application servers and web
containers.</p>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environment-tomcat"><a class="anchor" href="#aop-aj-ltw-environment-tomcat"></a>Tomcat</h6>
<div class="paragraph">
<p>Historically, <a href="https://tomcat.apache.org/">Apache Tomcat</a>'s default class loader did not
support class transformation which is why Spring provides an enhanced implementation
that addresses this need. Named <code>TomcatInstrumentableClassLoader</code>, the loader works on
Tomcat 6.0 and above.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Do not define <code>TomcatInstrumentableClassLoader</code> anymore on Tomcat 8.0 and higher.
Instead, let Spring automatically use Tomcat&#8217;s new native <code>InstrumentableClassLoader</code>
facility through the <code>TomcatLoadTimeWeaver</code> strategy.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you still need to use <code>TomcatInstrumentableClassLoader</code>, it can be registered
individually for <em>each</em> web application as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Copy <code>org.springframework.instrument.tomcat.jar</code> into <em>$CATALINA_HOME</em>/lib, where
<em>$CATALINA_HOME</em> represents the root of the Tomcat installation)</p>
</li>
<li>
<p>Instruct Tomcat to use the custom class loader (instead of the default) by editing the
web application context file:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;Context</span> <span class="attribute-name">path</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/myWebApp</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">docBase</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">/my/webApp/location</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;Loader</span>
                <span class="attribute-name">loaderClass</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/Context&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Apache Tomcat (6.0+) supports several context locations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>server configuration file - <em>$CATALINA_HOME/conf/server.xml</em></p>
</li>
<li>
<p>default context configuration - <em>$CATALINA_HOME/conf/context.xml</em> - that affects all
deployed web applications</p>
</li>
<li>
<p>per-web application configuration which can be deployed either on the server-side at
<em>$CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml</em> or embedded
inside the web-app archive at <em>META-INF/context.xml</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For efficiency, the embedded per-web-app configuration style is recommended because it
will impact only applications that use the custom class loader and does not require any
changes to the server configuration. See the Tomcat 6.0.x
<a href="https://tomcat.apache.org/tomcat-6.0-doc/config/context.html">documentation</a> for more
details about available context locations.</p>
</div>
<div class="paragraph">
<p>Alternatively, consider the use of the Spring-provided generic VM agent, to be specified
in Tomcat&#8217;s launch script (see above). This will make instrumentation available to all
deployed web applications, no matter what ClassLoader they happen to run on.</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"><a class="anchor" href="#aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish-jboss"></a>WebLogic, WebSphere, Resin, GlassFish, JBoss</h6>
<div class="paragraph">
<p>Recent versions of WebLogic Server (version 10 and above), IBM WebSphere Application
Server (version 7 and above), Resin (3.1 and above) and JBoss (6.x or above) provide a
ClassLoader that is capable of local instrumentation. Spring&#8217;s native LTW leverages such
ClassLoaders to enable AspectJ weaving. You can enable LTW by simply activating
load-time weaving as described earlier. Specifically, you do <em>not</em> need to modify the
launch script to add <code>-javaagent:path/to/spring-instrument.jar</code>.</p>
</div>
<div class="paragraph">
<p>Note that GlassFish instrumentation-capable ClassLoader is available only in its EAR
environment. For GlassFish web applications, follow the Tomcat setup instructions as
outlined above.</p>
</div>
<div class="paragraph">
<p>Note that on JBoss 6.x, the app server scanning needs to be disabled to prevent it from
loading the classes before the application actually starts. A quick workaround is to add
to your artifact a file named <code>WEB-INF/jboss-scanning.xml</code> with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;scanning</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">urn:jboss:scanning:1.0</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environment-generic"><a class="anchor" href="#aop-aj-ltw-environment-generic"></a>Generic Java applications</h6>
<div class="paragraph">
<p>When class instrumentation is required in environments that do not support or are not
supported by the existing <code>LoadTimeWeaver</code> implementations, a JDK agent can be the only
solution. For such cases, Spring provides <code>InstrumentationLoadTimeWeaver</code>, which
requires a Spring-specific (but very general) VM agent,
<code>org.springframework.instrument-{version}.jar</code> (previously named <code>spring-agent.jar</code>).</p>
</div>
<div class="paragraph">
<p>To use it, you must start the virtual machine with the Spring agent, by supplying the
following JVM options:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-javaagent:/path/to/org.springframework.instrument-{version}.jar</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this requires modification of the VM launch script which may prevent you from
using this in application server environments (depending on your operation policies).
Additionally, the JDK agent will instrument the <em>entire</em> VM which can prove expensive.</p>
</div>
<div class="paragraph">
<p>For performance reasons, it is recommended to use this configuration only if your target
environment (such as <a href="https://www.eclipse.org/jetty/">Jetty</a>) does not have (or does not
support) a dedicated LTW.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-resources"><a class="anchor" href="#aop-resources"></a>5.9. Further Resources</h3>
<div class="paragraph">
<p>More information on AspectJ can be found on the <a href="https://www.eclipse.org/aspectj">AspectJ
website</a>.</p>
</div>
<div class="paragraph">
<p>The book <em>Eclipse AspectJ</em> by Adrian Colyer et. al. (Addison-Wesley, 2005) provides a
comprehensive introduction and reference for the AspectJ language.</p>
</div>
<div class="paragraph">
<p>The book <em>AspectJ in Action, Second Edition</em> by Ramnivas Laddad (Manning, 2009) comes highly
recommended; the focus of the book is on AspectJ, but a lot of general AOP themes are
explored (in some depth).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api"><a class="anchor" href="#aop-api"></a>6. Spring AOP APIs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="aop-api-introduction"><a class="anchor" href="#aop-api-introduction"></a>6.1. Introduction</h3>
<div class="paragraph">
<p>The previous chapter described the Spring&#8217;s support for AOP using
@AspectJ and schema-based aspect definitions. In this chapter we discuss the lower-level
Spring AOP APIs and the AOP support used in Spring 1.2 applications. For new
applications, we recommend the use of the Spring 2.0 and later AOP support described in
the previous chapter, but when working with existing applications, or when reading books
and articles, you may come across Spring 1.2 style examples. Spring 4.0 is backwards
compatible with Spring 1.2 and everything described in this chapter is fully supported
in Spring 4.0.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts"><a class="anchor" href="#aop-api-pointcuts"></a>6.2. Pointcut API in Spring</h3>
<div class="paragraph">
<p>Let&#8217;s look at how Spring handles the crucial pointcut concept.</p>
</div>
<div class="sect3">
<h4 id="aop-api-concepts"><a class="anchor" href="#aop-api-concepts"></a>6.2.1. Concepts</h4>
<div class="paragraph">
<p>Spring&#8217;s pointcut model enables pointcut reuse independent of advice types. It&#8217;s
possible to target different advice using the same pointcut.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.aop.Pointcut</code> interface is the central interface, used to
target advices to particular classes and methods. The complete interface is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Pointcut</span> {

        ClassFilter getClassFilter();

        MethodMatcher getMethodMatcher();

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Splitting the <code>Pointcut</code> interface into two parts allows reuse of class and method
matching parts, and fine-grained composition operations (such as performing a "union"
with another method matcher).</p>
</div>
<div class="paragraph">
<p>The <code>ClassFilter</code> interface is used to restrict the pointcut to a given set of target
classes. If the <code>matches()</code> method always returns true, all target classes will be
matched:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">ClassFilter</span> {

        <span class="type">boolean</span> matches(<span class="predefined-type">Class</span> clazz);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MethodMatcher</code> interface is normally more important. The complete interface is
shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodMatcher</span> {

        <span class="type">boolean</span> matches(<span class="predefined-type">Method</span> m, <span class="predefined-type">Class</span> targetClass);

        <span class="type">boolean</span> isRuntime();

        <span class="type">boolean</span> matches(<span class="predefined-type">Method</span> m, <span class="predefined-type">Class</span> targetClass, <span class="predefined-type">Object</span><span class="type">[]</span> args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>matches(Method, Class)</code> method is used to test whether this pointcut will ever
match a given method on a target class. This evaluation can be performed when an AOP
proxy is created, to avoid the need for a test on every method invocation. If the
2-argument matches method returns true for a given method, and the <code>isRuntime()</code> method
for the MethodMatcher returns true, the 3-argument matches method will be invoked on
every method invocation. This enables a pointcut to look at the arguments passed to the
method invocation immediately before the target advice is to execute.</p>
</div>
<div class="paragraph">
<p>Most MethodMatchers are static, meaning that their <code>isRuntime()</code> method returns false.
In this case, the 3-argument matches method will never be invoked.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If possible, try to make pointcuts static, allowing the AOP framework to cache the
results of pointcut evaluation when an AOP proxy is created.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcut-ops"><a class="anchor" href="#aop-api-pointcut-ops"></a>6.2.2. Operations on pointcuts</h4>
<div class="paragraph">
<p>Spring supports operations on pointcuts: notably, <em>union</em> and <em>intersection</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Union means the methods that either pointcut matches.</p>
</li>
<li>
<p>Intersection means the methods that both pointcuts match.</p>
</li>
<li>
<p>Union is usually more useful.</p>
</li>
<li>
<p>Pointcuts can be composed using the static methods in the
<em>org.springframework.aop.support.Pointcuts</em> class, or using the
<em>ComposablePointcut</em> class in the same package. However, using AspectJ pointcut
expressions is usually a simpler approach.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-aspectj"><a class="anchor" href="#aop-api-pointcuts-aspectj"></a>6.2.3. AspectJ expression pointcuts</h4>
<div class="paragraph">
<p>Since 2.0, the most important type of pointcut used by Spring is
<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>. This is a pointcut that
uses an AspectJ supplied library to parse an AspectJ pointcut expression string.</p>
</div>
<div class="paragraph">
<p>See the previous chapter for a discussion of supported AspectJ pointcut primitives.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-impls"><a class="anchor" href="#aop-api-pointcuts-impls"></a>6.2.4. Convenience pointcut implementations</h4>
<div class="paragraph">
<p>Spring provides several convenient pointcut implementations. Some can be used out of the
box; others are intended to be subclassed in application-specific pointcuts.</p>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-static"><a class="anchor" href="#aop-api-pointcuts-static"></a>Static pointcuts</h5>
<div class="paragraph">
<p>Static pointcuts are based on method and target class, and cannot take into account the
method&#8217;s arguments. Static pointcuts are sufficient - <em>and best</em> - for most usages.
It&#8217;s possible for Spring to evaluate a static pointcut only once, when a method is first
invoked: after that, there is no need to evaluate the pointcut again with each method
invocation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider some static pointcut implementations included with Spring.</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-regex"><a class="anchor" href="#aop-api-pointcuts-regex"></a>Regular expression pointcuts</h6>
<div class="paragraph">
<p>One obvious way to specify static pointcuts is regular expressions. Several AOP
frameworks besides Spring make this possible.
<code>org.springframework.aop.support.JdkRegexpMethodPointcut</code> is a generic regular
expression pointcut, using the regular expression support in JDK 1.4+.</p>
</div>
<div class="paragraph">
<p>Using the <code>JdkRegexpMethodPointcut</code> class, you can provide a list of pattern Strings. If
any of these is a match, the pointcut will evaluate to true. (So the result is
effectively the union of these pointcuts.)</p>
</div>
<div class="paragraph">
<p>The usage is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">settersAndAbsquatulatePointcut</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.support.JdkRegexpMethodPointcut</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">patterns</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*set.*<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*absquatulate<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring provides a convenience class, <code>RegexpMethodPointcutAdvisor</code>, that allows us to
also reference an Advice (remember that an Advice can be an interceptor, before advice,
throws advice etc.). Behind the scenes, Spring will use a <code>JdkRegexpMethodPointcut</code>.
Using <code>RegexpMethodPointcutAdvisor</code> simplifies wiring, as the one bean encapsulates both
pointcut and advice, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">settersAndAbsquatulateAdvisor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.support.RegexpMethodPointcutAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">advice</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanNameOfAopAllianceInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">patterns</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*set.*<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>.*absquatulate<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>RegexpMethodPointcutAdvisor</em> can be used with any Advice type.</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-attribute-driven"><a class="anchor" href="#aop-api-pointcuts-attribute-driven"></a>Attribute-driven pointcuts</h6>
<div class="paragraph">
<p>An important type of static pointcut is a <em>metadata-driven</em> pointcut. This uses the
values of metadata attributes: typically, source-level metadata.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-dynamic"><a class="anchor" href="#aop-api-pointcuts-dynamic"></a>Dynamic pointcuts</h5>
<div class="paragraph">
<p>Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account
method <em>arguments</em>, as well as static information. This means that they must be
evaluated with every method invocation; the result cannot be cached, as arguments will
vary.</p>
</div>
<div class="paragraph">
<p>The main example is the <code>control flow</code> pointcut.</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-cflow"><a class="anchor" href="#aop-api-pointcuts-cflow"></a>Control flow pointcuts</h6>
<div class="paragraph">
<p>Spring control flow pointcuts are conceptually similar to AspectJ <em>cflow</em> pointcuts,
although less powerful. (There is currently no way to specify that a pointcut executes
below a join point matched by another pointcut.) A control flow pointcut matches the
current call stack. For example, it might fire if the join point was invoked by a method
in the <code>com.mycompany.web</code> package, or by the <code>SomeCaller</code> class. Control flow pointcuts
are specified using the <code>org.springframework.aop.support.ControlFlowPointcut</code> class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Control flow pointcuts are significantly more expensive to evaluate at runtime than even
other dynamic pointcuts. In Java 1.4, the cost is about 5 times that of other dynamic
pointcuts.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-superclasses"><a class="anchor" href="#aop-api-pointcuts-superclasses"></a>6.2.5. Pointcut superclasses</h4>
<div class="paragraph">
<p>Spring provides useful pointcut superclasses to help you to implement your own pointcuts.</p>
</div>
<div class="paragraph">
<p>Because static pointcuts are most useful, you&#8217;ll probably subclass
StaticMethodMatcherPointcut, as shown below. This requires implementing just one
abstract method (although it&#8217;s possible to override other methods to customize behavior):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TestStaticPointcut</span> <span class="directive">extends</span> StaticMethodMatcherPointcut {

        <span class="directive">public</span> <span class="type">boolean</span> matches(<span class="predefined-type">Method</span> m, <span class="predefined-type">Class</span> targetClass) {
                <span class="comment">// return true if custom criteria match</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are also superclasses for dynamic pointcuts.</p>
</div>
<div class="paragraph">
<p>You can use custom pointcuts with any advice type in Spring 1.0 RC2 and above.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-custom"><a class="anchor" href="#aop-api-pointcuts-custom"></a>6.2.6. Custom pointcuts</h4>
<div class="paragraph">
<p>Because pointcuts in Spring AOP are Java classes, rather than language features (as in
AspectJ) it&#8217;s possible to declare custom pointcuts, whether static or dynamic. Custom
pointcuts in Spring can be arbitrarily complex. However, using the AspectJ pointcut
expression language is recommended if possible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Later versions of Spring may offer support for "semantic pointcuts" as offered by JAC:
for example, "all methods that change instance variables in the target object."</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advice"><a class="anchor" href="#aop-api-advice"></a>6.3. Advice API in Spring</h3>
<div class="paragraph">
<p>Let&#8217;s now look at how Spring AOP handles advice.</p>
</div>
<div class="sect3">
<h4 id="aop-api-advice-lifecycle"><a class="anchor" href="#aop-api-advice-lifecycle"></a>6.3.1. Advice lifecycles</h4>
<div class="paragraph">
<p>Each advice is a Spring bean. An advice instance can be shared across all advised
objects, or unique to each advised object. This corresponds to <em>per-class</em> or
<em>per-instance</em> advice.</p>
</div>
<div class="paragraph">
<p>Per-class advice is used most often. It is appropriate for generic advice such as
transaction advisors. These do not depend on the state of the proxied object or add new
state; they merely act on the method and arguments.</p>
</div>
<div class="paragraph">
<p>Per-instance advice is appropriate for introductions, to support mixins. In this case,
the advice adds state to the proxied object.</p>
</div>
<div class="paragraph">
<p>It&#8217;s possible to use a mix of shared and per-instance advice in the same AOP proxy.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-types"><a class="anchor" href="#aop-api-advice-types"></a>6.3.2. Advice types in Spring</h4>
<div class="paragraph">
<p>Spring provides several advice types out of the box, and is extensible to support
arbitrary advice types. Let us look at the basic concepts and standard advice types.</p>
</div>
<div class="sect4">
<h5 id="aop-api-advice-around"><a class="anchor" href="#aop-api-advice-around"></a>Interception around advice</h5>
<div class="paragraph">
<p>The most fundamental advice type in Spring is <em>interception around advice</em>.</p>
</div>
<div class="paragraph">
<p>Spring is compliant with the AOP Alliance interface for around advice using method
interception. MethodInterceptors implementing around advice should implement the
following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodInterceptor</span> <span class="directive">extends</span> Interceptor {

        <span class="predefined-type">Object</span> invoke(MethodInvocation invocation) <span class="directive">throws</span> <span class="predefined-type">Throwable</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MethodInvocation</code> argument to the <code>invoke()</code> method exposes the method being
invoked; the target join point; the AOP proxy; and the arguments to the method. The
<code>invoke()</code> method should return the invocation&#8217;s result: the return value of the join
point.</p>
</div>
<div class="paragraph">
<p>A simple <code>MethodInterceptor</code> implementation looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DebugInterceptor</span> <span class="directive">implements</span> MethodInterceptor {

        <span class="directive">public</span> <span class="predefined-type">Object</span> invoke(MethodInvocation invocation) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Before: invocation=[</span><span class="delimiter">&quot;</span></span> + invocation + <span class="string"><span class="delimiter">&quot;</span><span class="content">]</span><span class="delimiter">&quot;</span></span>);
                <span class="predefined-type">Object</span> rval = invocation.proceed();
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Invocation returned</span><span class="delimiter">&quot;</span></span>);
                <span class="keyword">return</span> rval;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the call to the MethodInvocation&#8217;s <code>proceed()</code> method. This proceeds down the
interceptor chain towards the join point. Most interceptors will invoke this method, and
return its return value. However, a MethodInterceptor, like any around advice, can
return a different value or throw an exception rather than invoke the proceed method.
However, you don&#8217;t want to do this without good reason!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>MethodInterceptors offer interoperability with other AOP Alliance-compliant AOP
implementations. The other advice types discussed in the remainder of this section
implement common AOP concepts, but in a Spring-specific way. While there is an advantage
in using the most specific advice type, stick with MethodInterceptor around advice if
you are likely to want to run the aspect in another AOP framework. Note that pointcuts
are not currently interoperable between frameworks, and the AOP Alliance does not
currently define pointcut interfaces.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-before"><a class="anchor" href="#aop-api-advice-before"></a>Before advice</h5>
<div class="paragraph">
<p>A simpler advice type is a <em>before advice</em>. This does not need a <code>MethodInvocation</code>
object, since it will only be called before entering the method.</p>
</div>
<div class="paragraph">
<p>The main advantage of a before advice is that there is no need to invoke the <code>proceed()</code>
method, and therefore no possibility of inadvertently failing to proceed down the
interceptor chain.</p>
</div>
<div class="paragraph">
<p>The <code>MethodBeforeAdvice</code> interface is shown below. (Spring&#8217;s API design would allow for
field before advice, although the usual objects apply to field interception and it&#8217;s
unlikely that Spring will ever implement it).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">MethodBeforeAdvice</span> <span class="directive">extends</span> BeforeAdvice {

        <span class="type">void</span> before(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target) <span class="directive">throws</span> <span class="predefined-type">Throwable</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the return type is <code>void</code>. Before advice can insert custom behavior before the join
point executes, but cannot change the return value. If a before advice throws an
exception, this will abort further execution of the interceptor chain. The exception
will propagate back up the interceptor chain. If it is unchecked, or on the signature of
the invoked method, it will be passed directly to the client; otherwise it will be
wrapped in an unchecked exception by the AOP proxy.</p>
</div>
<div class="paragraph">
<p>An example of a before advice in Spring, which counts all method invocations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CountingBeforeAdvice</span> <span class="directive">implements</span> MethodBeforeAdvice {

        <span class="directive">private</span> <span class="type">int</span> count;

        <span class="directive">public</span> <span class="type">void</span> before(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                ++count;
        }

        <span class="directive">public</span> <span class="type">int</span> getCount() {
                <span class="keyword">return</span> count;
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Before advice can be used with any pointcut.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-throws"><a class="anchor" href="#aop-api-advice-throws"></a>Throws advice</h5>
<div class="paragraph">
<p><em>Throws advice</em> is invoked after the return of the join point if the join point threw
an exception. Spring offers typed throws advice. Note that this means that the
<code>org.springframework.aop.ThrowsAdvice</code> interface does not contain any methods: It is a
tag interface identifying that the given object implements one or more typed throws
advice methods. These should be in the form of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">afterThrowing([<span class="predefined-type">Method</span>, args, target], subclassOfThrowable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only the last argument is required. The method signatures may have either one or four
arguments, depending on whether the advice method is interested in the method and
arguments. The following classes are examples of throws advice.</p>
</div>
<div class="paragraph">
<p>The advice below is invoked if a <code>RemoteException</code> is thrown (including subclasses):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">RemoteThrowsAdvice</span> <span class="directive">implements</span> ThrowsAdvice {

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="exception">RemoteException</span> ex) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// Do something with remote exception</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following advice is invoked if a <code>ServletException</code> is thrown. Unlike the above
advice, it declares 4 arguments, so that it has access to the invoked method, method
arguments and target object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ServletThrowsAdviceWithArguments</span> <span class="directive">implements</span> ThrowsAdvice {

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target, ServletException ex) {
                <span class="comment">// Do something with all arguments</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final example illustrates how these two methods could be used in a single class,
which handles both <code>RemoteException</code> and <code>ServletException</code>. Any number of throws advice
methods can be combined in a single class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> <span class="type">class</span> <span class="class">CombinedThrowsAdvice</span> <span class="directive">implements</span> ThrowsAdvice {

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="exception">RemoteException</span> ex) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="comment">// Do something with remote exception</span>
        }

        <span class="directive">public</span> <span class="type">void</span> afterThrowing(<span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target, ServletException ex) {
                <span class="comment">// Do something with all arguments</span>
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a throws-advice method throws an exception itself, it will override the
original exception (i.e. change the exception thrown to the user). The overriding
exception will typically be a RuntimeException; this is compatible with any method
signature. However, if a throws-advice method throws a checked exception, it will have
to match the declared exceptions of the target method and is hence to some degree
coupled to specific target method signatures. <em>Do not throw an undeclared checked
exception that is incompatible with the target method&#8217;s signature!</em></p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Throws advice can be used with any pointcut.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-after-returning"><a class="anchor" href="#aop-api-advice-after-returning"></a>After Returning advice</h5>
<div class="paragraph">
<p>An after returning advice in Spring must implement the
<em>org.springframework.aop.AfterReturningAdvice</em> interface, shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">AfterReturningAdvice</span> <span class="directive">extends</span> Advice {

        <span class="type">void</span> afterReturning(<span class="predefined-type">Object</span> returnValue, <span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target)
                        <span class="directive">throws</span> <span class="predefined-type">Throwable</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An after returning advice has access to the return value (which it cannot modify),
invoked method, methods arguments and target.</p>
</div>
<div class="paragraph">
<p>The following after returning advice counts all successful method invocations that have
not thrown exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CountingAfterReturningAdvice</span> <span class="directive">implements</span> AfterReturningAdvice {

        <span class="directive">private</span> <span class="type">int</span> count;

        <span class="directive">public</span> <span class="type">void</span> afterReturning(<span class="predefined-type">Object</span> returnValue, <span class="predefined-type">Method</span> m, <span class="predefined-type">Object</span><span class="type">[]</span> args, <span class="predefined-type">Object</span> target)
                        <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                ++count;
        }

        <span class="directive">public</span> <span class="type">int</span> getCount() {
                <span class="keyword">return</span> count;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This advice doesn&#8217;t change the execution path. If it throws an exception, this will be
thrown up the interceptor chain instead of the return value.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>After returning advice can be used with any pointcut.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-introduction"><a class="anchor" href="#aop-api-advice-introduction"></a>Introduction advice</h5>
<div class="paragraph">
<p>Spring treats introduction advice as a special kind of interception advice.</p>
</div>
<div class="paragraph">
<p>Introduction requires an <code>IntroductionAdvisor</code>, and an <code>IntroductionInterceptor</code>,
implementing the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionInterceptor</span> <span class="directive">extends</span> MethodInterceptor {

        <span class="type">boolean</span> implementsInterface(<span class="predefined-type">Class</span> intf);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>invoke()</code> method inherited from the AOP Alliance <code>MethodInterceptor</code> interface must
implement the introduction: that is, if the invoked method is on an introduced
interface, the introduction interceptor is responsible for handling the method call - it
cannot invoke <code>proceed()</code>.</p>
</div>
<div class="paragraph">
<p>Introduction advice cannot be used with any pointcut, as it applies only at class,
rather than method, level. You can only use introduction advice with the
<code>IntroductionAdvisor</code>, which has the following methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionAdvisor</span> <span class="directive">extends</span> Advisor, IntroductionInfo {

        ClassFilter getClassFilter();

        <span class="type">void</span> validateInterfaces() <span class="directive">throws</span> <span class="exception">IllegalArgumentException</span>;
}

<span class="directive">public</span> <span class="type">interface</span> <span class="class">IntroductionInfo</span> {

        <span class="predefined-type">Class</span><span class="type">[]</span> getInterfaces();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no <code>MethodMatcher</code>, and hence no <code>Pointcut</code>, associated with introduction
advice. Only class filtering is logical.</p>
</div>
<div class="paragraph">
<p>The <code>getInterfaces()</code> method returns the interfaces introduced by this advisor.</p>
</div>
<div class="paragraph">
<p>The <code>validateInterfaces()</code> method is used internally to see whether or not the
introduced interfaces can be implemented by the configured <code>IntroductionInterceptor</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at a simple example from the Spring test suite. Let&#8217;s suppose we want to
introduce the following interface to one or more objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Lockable</span> {
        <span class="type">void</span> lock();
        <span class="type">void</span> unlock();
        <span class="type">boolean</span> locked();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This illustrates a <em>mixin</em>. We want to be able to cast advised objects to Lockable,
whatever their type, and call lock and unlock methods. If we call the lock() method, we
want all setter methods to throw a <code>LockedException</code>. Thus we can add an aspect that
provides the ability to make objects immutable, without them having any knowledge of it:
a good example of AOP.</p>
</div>
<div class="paragraph">
<p>Firstly, we&#8217;ll need an <code>IntroductionInterceptor</code> that does the heavy lifting. In this
case, we extend the <code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>
convenience class. We could implement IntroductionInterceptor directly, but using
<code>DelegatingIntroductionInterceptor</code> is best for most cases.</p>
</div>
<div class="paragraph">
<p>The <code>DelegatingIntroductionInterceptor</code> is designed to delegate an introduction to an
actual implementation of the introduced interface(s), concealing the use of interception
to do so. The delegate can be set to any object using a constructor argument; the
default delegate (when the no-arg constructor is used) is this. Thus in the example
below, the delegate is the <code>LockMixin</code> subclass of <code>DelegatingIntroductionInterceptor</code>.
Given a delegate (by default itself), a <code>DelegatingIntroductionInterceptor</code> instance
looks for all interfaces implemented by the delegate (other than
IntroductionInterceptor), and will support introductions against any of them. It&#8217;s
possible for subclasses such as <code>LockMixin</code> to call the <code>suppressInterface(Class intf)</code>
method to suppress interfaces that should not be exposed. However, no matter how many
interfaces an <code>IntroductionInterceptor</code> is prepared to support, the
<code>IntroductionAdvisor</code> used will control which interfaces are actually exposed. An
introduced interface will conceal any implementation of the same interface by the target.</p>
</div>
<div class="paragraph">
<p>Thus <code>LockMixin</code> extends <code>DelegatingIntroductionInterceptor</code> and implements <code>Lockable</code>
itself. The superclass automatically picks up that Lockable can be supported for
introduction, so we don&#8217;t need to specify that. We could introduce any number of
interfaces in this way.</p>
</div>
<div class="paragraph">
<p>Note the use of the <code>locked</code> instance variable. This effectively adds additional state
to that held in the target object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">LockMixin</span> <span class="directive">extends</span> DelegatingIntroductionInterceptor <span class="directive">implements</span> Lockable {

        <span class="directive">private</span> <span class="type">boolean</span> locked;

        <span class="directive">public</span> <span class="type">void</span> lock() {
                <span class="local-variable">this</span>.locked = <span class="predefined-constant">true</span>;
        }

        <span class="directive">public</span> <span class="type">void</span> unlock() {
                <span class="local-variable">this</span>.locked = <span class="predefined-constant">false</span>;
        }

        <span class="directive">public</span> <span class="type">boolean</span> locked() {
                <span class="keyword">return</span> <span class="local-variable">this</span>.locked;
        }

        <span class="directive">public</span> <span class="predefined-type">Object</span> invoke(MethodInvocation invocation) <span class="directive">throws</span> <span class="predefined-type">Throwable</span> {
                <span class="keyword">if</span> (locked() &amp;&amp; invocation.getMethod().getName().indexOf(<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>) == <span class="integer">0</span>) {
                        <span class="keyword">throw</span> <span class="keyword">new</span> LockedException();
                }
                <span class="keyword">return</span> <span class="local-variable">super</span>.invoke(invocation);
        }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Often it isn&#8217;t necessary to override the <code>invoke()</code> method: the
<code>DelegatingIntroductionInterceptor</code> implementation - which calls the delegate method if
the method is introduced, otherwise proceeds towards the join point - is usually
sufficient. In the present case, we need to add a check: no setter method can be invoked
if in locked mode.</p>
</div>
<div class="paragraph">
<p>The introduction advisor required is simple. All it needs to do is hold a distinct
<code>LockMixin</code> instance, and specify the introduced interfaces - in this case, just
<code>Lockable</code>. A more complex example might take a reference to the introduction
interceptor (which would be defined as a prototype): in this case, there&#8217;s no
configuration relevant for a <code>LockMixin</code>, so we simply create it using <code>new</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">LockMixinAdvisor</span> <span class="directive">extends</span> DefaultIntroductionAdvisor {

        <span class="directive">public</span> LockMixinAdvisor() {
                <span class="local-variable">super</span>(<span class="keyword">new</span> LockMixin(), Lockable.class);
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can apply this advisor very simply: it requires no configuration. (However, it <em>is</em>
necessary: It&#8217;s impossible to use an <code>IntroductionInterceptor</code> without an
<em>IntroductionAdvisor</em>.) As usual with introductions, the advisor must be per-instance,
as it is stateful. We need a different instance of <code>LockMixinAdvisor</code>, and hence
<code>LockMixin</code>, for each advised object. The advisor comprises part of the advised object&#8217;s
state.</p>
</div>
<div class="paragraph">
<p>We can apply this advisor programmatically, using the <code>Advised.addAdvisor()</code> method, or
(the recommended way) in XML configuration, like any other advisor. All proxy creation
choices discussed below, including "auto proxy creators," correctly handle introductions
and stateful mixins.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advisor"><a class="anchor" href="#aop-api-advisor"></a>6.4. Advisor API in Spring</h3>
<div class="paragraph">
<p>In Spring, an Advisor is an aspect that contains just a single advice object associated
with a pointcut expression.</p>
</div>
<div class="paragraph">
<p>Apart from the special case of introductions, any advisor can be used with any advice.
<code>org.springframework.aop.support.DefaultPointcutAdvisor</code> is the most commonly used
advisor class. For example, it can be used with a <code>MethodInterceptor</code>, <code>BeforeAdvice</code> or
<code>ThrowsAdvice</code>.</p>
</div>
<div class="paragraph">
<p>It is possible to mix advisor and advice types in Spring in the same AOP proxy. For
example, you could use a interception around advice, throws advice and before advice in
one proxy configuration: Spring will automatically create the necessary interceptor
chain.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-pfb"><a class="anchor" href="#aop-pfb"></a>6.5. Using the ProxyFactoryBean to create AOP proxies</h3>
<div class="paragraph">
<p>If you&#8217;re using the Spring IoC container (an ApplicationContext or BeanFactory) for your
business objects - and you should be! - you will want to use one of Spring&#8217;s AOP
FactoryBeans. (Remember that a factory bean introduces a layer of indirection, enabling
it to create objects of a different type.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Spring AOP support also uses factory beans under the covers.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The basic way to create an AOP proxy in Spring is to use the
<em>org.springframework.aop.framework.ProxyFactoryBean</em>. This gives complete control over
the pointcuts and advice that will apply, and their ordering. However, there are simpler
options that are preferable if you don&#8217;t need such control.</p>
</div>
<div class="sect3">
<h4 id="aop-pfb-1"><a class="anchor" href="#aop-pfb-1"></a>6.5.1. Basics</h4>
<div class="paragraph">
<p>The <code>ProxyFactoryBean</code>, like other Spring <code>FactoryBean</code> implementations, introduces a
level of indirection. If you define a <code>ProxyFactoryBean</code> with name <code>foo</code>, what objects
referencing <code>foo</code> see is not the <code>ProxyFactoryBean</code> instance itself, but an object
created by the <code>ProxyFactoryBean&#8217;s implementation of the `getObject()</code> method. This
method will create an AOP proxy wrapping a target object.</p>
</div>
<div class="paragraph">
<p>One of the most important benefits of using a <code>ProxyFactoryBean</code> or another IoC-aware
class to create AOP proxies, is that it means that advices and pointcuts can also be
managed by IoC. This is a powerful feature, enabling certain approaches that are hard to
achieve with other AOP frameworks. For example, an advice may itself reference
application objects (besides the target, which should be available in any AOP
framework), benefiting from all the pluggability provided by Dependency Injection.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-2"><a class="anchor" href="#aop-pfb-2"></a>6.5.2. JavaBean properties</h4>
<div class="paragraph">
<p>In common with most <code>FactoryBean</code> implementations provided with Spring, the
<code>ProxyFactoryBean</code> class is itself a JavaBean. Its properties are used to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify the target you want to proxy.</p>
</li>
<li>
<p>Specify whether to use CGLIB (see below and also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some key properties are inherited from <code>org.springframework.aop.framework.ProxyConfig</code>
(the superclass for all AOP proxy factories in Spring). These key properties include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyTargetClass</code>: <code>true</code> if the target class is to be proxied, rather than the
target class' interfaces. If this property value is set to <code>true</code>, then CGLIB proxies
will be created (but see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
<li>
<p><code>optimize</code>: controls whether or not aggressive optimizations are applied to proxies
<em>created via CGLIB</em>. One should not blithely use this setting unless one fully
understands how the relevant AOP proxy handles optimization. This is currently used
only for CGLIB proxies; it has no effect with JDK dynamic proxies.</p>
</li>
<li>
<p><code>frozen</code>: if a proxy configuration is <code>frozen</code>, then changes to the configuration are
no longer allowed. This is useful both as a slight optimization and for those cases
when you don&#8217;t want callers to be able to manipulate the proxy (via the <code>Advised</code>
interface) after the proxy has been created. The default value of this property is
<code>false</code>, so changes such as adding additional advice are allowed.</p>
</li>
<li>
<p><code>exposeProxy</code>: determines whether or not the current proxy should be exposed in a
<code>ThreadLocal</code> so that it can be accessed by the target. If a target needs to obtain
the proxy and the <code>exposeProxy</code> property is set to <code>true</code>, the target can use the
<code>AopContext.currentProxy()</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other properties specific to <code>ProxyFactoryBean</code> include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyInterfaces</code>: array of String interface names. If this isn&#8217;t supplied, a CGLIB
proxy for the target class will be used (but see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
<li>
<p><code>interceptorNames</code>: String array of <code>Advisor</code>, interceptor or other advice names to
apply. Ordering is significant, on a first come-first served basis. That is to say
that the first interceptor in the list will be the first to be able to intercept the
invocation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The names are bean names in the current factory, including bean names from ancestor
factories. You can&#8217;t mention bean references here since doing so would result in the
<code>ProxyFactoryBean</code> ignoring the singleton setting of the advice.</p>
</div>
<div class="paragraph">
<p>You can append an interceptor name with an asterisk ( <code>*</code>). This will result in the
application of all advisor beans with names starting with the part before the asterisk
to be applied. An example of using this feature can be found in <a href="#aop-global-advisors">Using 'global' advisors</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>singleton: whether or not the factory should return a single object, no matter how
often the <code>getObject()</code> method is called. Several <code>FactoryBean</code> implementations offer
such a method. The default value is <code>true</code>. If you want to use stateful advice - for
example, for stateful mixins - use prototype advices along with a singleton value of
<code>false</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-proxy-types"><a class="anchor" href="#aop-pfb-proxy-types"></a>6.5.3. JDK- and CGLIB-based proxies</h4>
<div class="paragraph">
<p>This section serves as the definitive documentation on how the <code>ProxyFactoryBean</code>
chooses to create one of either a JDK- and CGLIB-based proxy for a particular target
object (that is to be proxied).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The behavior of the <code>ProxyFactoryBean</code> with regard to creating JDK- or CGLIB-based
proxies changed between versions 1.2.x and 2.0 of Spring. The <code>ProxyFactoryBean</code> now
exhibits similar semantics with regard to auto-detecting interfaces as those of the
<code>TransactionProxyFactoryBean</code> class.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the class of a target object that is to be proxied (hereafter simply referred to as
the target class) doesn&#8217;t implement any interfaces, then a CGLIB-based proxy will be
created. This is the easiest scenario, because JDK proxies are interface based, and no
interfaces means JDK proxying isn&#8217;t even possible. One simply plugs in the target bean,
and specifies the list of interceptors via the <code>interceptorNames</code> property. Note that a
CGLIB-based proxy will be created even if the <code>proxyTargetClass</code> property of the
<code>ProxyFactoryBean</code> has been set to <code>false</code>. (Obviously this makes no sense, and is best
removed from the bean definition because it is at best redundant, and at worst
confusing.)</p>
</div>
<div class="paragraph">
<p>If the target class implements one (or more) interfaces, then the type of proxy that is
created depends on the configuration of the <code>ProxyFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyTargetClass</code> property of the <code>ProxyFactoryBean</code> has been set to <code>true</code>,
then a CGLIB-based proxy will be created. This makes sense, and is in keeping with the
principle of least surprise. Even if the <code>proxyInterfaces</code> property of the
<code>ProxyFactoryBean</code> has been set to one or more fully qualified interface names, the fact
that the <code>proxyTargetClass</code> property is set to <code>true</code> <em>will</em> cause CGLIB-based
proxying to be in effect.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyInterfaces</code> property of the <code>ProxyFactoryBean</code> has been set to one or more
fully qualified interface names, then a JDK-based proxy will be created. The created
proxy will implement all of the interfaces that were specified in the <code>proxyInterfaces</code>
property; if the target class happens to implement a whole lot more interfaces than
those specified in the <code>proxyInterfaces</code> property, that is all well and good but those
additional interfaces will not be implemented by the returned proxy.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyInterfaces</code> property of the <code>ProxyFactoryBean</code> has <em>not</em> been set, but
the target class <em>does implement one (or more)</em> interfaces, then the
<code>ProxyFactoryBean</code> will auto-detect the fact that the target class does actually
implement at least one interface, and a JDK-based proxy will be created. The interfaces
that are actually proxied will be <em>all</em> of the interfaces that the target class
implements; in effect, this is the same as simply supplying a list of each and every
interface that the target class implements to the <code>proxyInterfaces</code> property. However,
it is significantly less work, and less prone to typos.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-intf"><a class="anchor" href="#aop-api-proxying-intf"></a>6.5.4. Proxying interfaces</h4>
<div class="paragraph">
<p>Let&#8217;s look at a simple example of <code>ProxyFactoryBean</code> in action. This example involves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>target bean</em> that will be proxied. This is the "personTarget" bean definition in
the example below.</p>
</li>
<li>
<p>An Advisor and an Interceptor used to provide advice.</p>
</li>
<li>
<p>An AOP proxy bean definition specifying the target object (the personTarget bean) and
the interfaces to proxy, along with the advices to apply.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">personTarget</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.PersonImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Tony</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">51</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someProperty</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Custom string property value</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">debugInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.DebugInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>
        <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">proxyInterfaces</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.Person</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">personTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>myAdvisor<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>debugInterceptor<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>interceptorNames</code> property takes a list of String: the bean names of the
interceptor or advisors in the current factory. Advisors, interceptors, before, after
returning and throws advice objects can be used. The ordering of advisors is significant.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You might be wondering why the list doesn&#8217;t hold bean references. The reason for this is
that if the ProxyFactoryBean&#8217;s singleton property is set to false, it must be able to
return independent proxy instances. If any of the advisors is itself a prototype, an
independent instance would need to be returned, so it&#8217;s necessary to be able to obtain
an instance of the prototype from the factory; holding a reference isn&#8217;t sufficient.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The "person" bean definition above can be used in place of a Person implementation, as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Person person = (Person) factory.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other beans in the same IoC context can express a strongly typed dependency on it, as
with an ordinary Java object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">personUser</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.PersonUser</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span><span class="tag">&lt;ref</span> <span class="attribute-name">bean</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span><span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PersonUser</code> class in this example would expose a property of type Person. As far as
it&#8217;s concerned, the AOP proxy can be used transparently in place of a "real" person
implementation. However, its class would be a dynamic proxy class. It would be possible
to cast it to the <code>Advised</code> interface (discussed below).</p>
</div>
<div class="paragraph">
<p>It&#8217;s possible to conceal the distinction between target and proxy using an anonymous
<em>inner bean</em>, as follows. Only the <code>ProxyFactoryBean</code> definition is different; the
advice is included only for completeness:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">someProperty</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Custom string property value</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">debugInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.DebugInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">proxyInterfaces</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.Person</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="comment">&lt;!-- Use inner bean, not local reference to target --&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.PersonImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Tony</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">51</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>myAdvisor<span class="tag">&lt;/value&gt;</span>
                        <span class="tag">&lt;value&gt;</span>debugInterceptor<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This has the advantage that there&#8217;s only one object of type <code>Person</code>: useful if we want
to prevent users of the application context from obtaining a reference to the un-advised
object, or need to avoid any ambiguity with Spring IoC <em>autowiring</em>. There&#8217;s also
arguably an advantage in that the ProxyFactoryBean definition is self-contained.
However, there are times when being able to obtain the un-advised target from the
factory might actually be an <em>advantage</em>: for example, in certain test scenarios.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-class"><a class="anchor" href="#aop-api-proxying-class"></a>6.5.5. Proxying classes</h4>
<div class="paragraph">
<p>What if you need to proxy a class, rather than one or more interfaces?</p>
</div>
<div class="paragraph">
<p>Imagine that in our example above, there was no <code>Person</code> interface: we needed to advise
a class called <code>Person</code> that didn&#8217;t implement any business interface. In this case, you
can configure Spring to use CGLIB proxying, rather than dynamic proxies. Simply set the
<code>proxyTargetClass</code> property on the ProxyFactoryBean above to true. While it&#8217;s best to
program to interfaces, rather than classes, the ability to advise classes that don&#8217;t
implement interfaces can be useful when working with legacy code. (In general, Spring
isn&#8217;t prescriptive. While it makes it easy to apply good practices, it avoids forcing a
particular approach.)</p>
</div>
<div class="paragraph">
<p>If you want to, you can force the use of CGLIB in any case, even if you do have
interfaces.</p>
</div>
<div class="paragraph">
<p>CGLIB proxying works by generating a subclass of the target class at runtime. Spring
configures this generated subclass to delegate method calls to the original target: the
subclass is used to implement the <em>Decorator</em> pattern, weaving in the advice.</p>
</div>
<div class="paragraph">
<p>CGLIB proxying should generally be transparent to users. However, there are some issues
to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Final</code> methods can&#8217;t be advised, as they can&#8217;t be overridden.</p>
</li>
<li>
<p>There is no need to add CGLIB to your classpath. As of Spring 3.2, CGLIB is repackaged
and included in the spring-core JAR. In other words, CGLIB-based AOP will work "out of
the box" just as do JDK dynamic proxies.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There&#8217;s little performance difference between CGLIB proxying and dynamic proxies. As of
Spring 1.0, dynamic proxies are slightly faster. However, this may change in the future.
Performance should not be a decisive consideration in this case.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-global-advisors"><a class="anchor" href="#aop-global-advisors"></a>6.5.6. Using 'global' advisors</h4>
<div class="paragraph">
<p>By appending an asterisk to an interceptor name, all advisors with bean names matching
the part before the asterisk, will be added to the advisor chain. This can come in handy
if you need to add a standard set of 'global' advisors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">proxy</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">service</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>global*<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">global_debug</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.DebugInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">global_performance</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.interceptor.PerformanceMonitorInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-concise-proxy"><a class="anchor" href="#aop-concise-proxy"></a>6.6. Concise proxy definitions</h3>
<div class="paragraph">
<p>Especially when defining transactional proxies, you may end up with many similar proxy
definitions. The use of parent and child bean definitions, along with inner bean
definitions, can result in much cleaner and more concise proxy definitions.</p>
</div>
<div class="paragraph">
<p>First a parent, <em>template</em>, bean definition is created for the proxy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">txProxyTemplate</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">abstract</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;props&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/prop&gt;</span>
                <span class="tag">&lt;/props&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This will never be instantiated itself, so may actually be incomplete. Then each proxy
which needs to be created is just a child bean definition, which wraps the target of the
proxy as an inner bean definition, since the target will never be used on its own anyway.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">txProxyTemplate</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.MyServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is of course possible to override properties from the parent template, such as in
this case, the transaction propagation settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mySpecialService</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">parent</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">txProxyTemplate</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">target</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.samples.MySpecialServiceImpl</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributes</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;props&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">get*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">find*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">load*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/prop&gt;</span>
                        <span class="tag">&lt;prop</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">store*</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/prop&gt;</span>
                <span class="tag">&lt;/props&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in the example above, we have explicitly marked the parent bean definition as
<em>abstract</em> by using the <em>abstract</em> attribute, as described
<a href="#beans-child-bean-definitions">previously</a>, so that it may not actually ever be
instantiated. Application contexts (but not simple bean factories) will by default
pre-instantiate all singletons. It is therefore important (at least for singleton beans)
that if you have a (parent) bean definition which you intend to use only as a template,
and this definition specifies a class, you must make sure to set the <em>abstract</em>
attribute to <em>true</em>, otherwise the application context will actually try to
pre-instantiate it.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-prog"><a class="anchor" href="#aop-prog"></a>6.7. Creating AOP proxies programmatically with the ProxyFactory</h3>
<div class="paragraph">
<p>It&#8217;s easy to create AOP proxies programmatically using Spring. This enables you to use
Spring AOP without dependency on Spring IoC.</p>
</div>
<div class="paragraph">
<p>The following listing shows creation of a proxy for a target object, with one
interceptor and one advisor. The interfaces implemented by the target object will
automatically be proxied:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ProxyFactory factory = <span class="keyword">new</span> ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step is to construct an object of type
<code>org.springframework.aop.framework.ProxyFactory</code>. You can create this with a target
object, as in the above example, or specify the interfaces to be proxied in an alternate
constructor.</p>
</div>
<div class="paragraph">
<p>You can add advices (with interceptors as a specialized kind of advice) and/or advisors,
and manipulate them for the life of the ProxyFactory. If you add an
IntroductionInterceptionAroundAdvisor, you can cause the proxy to implement additional
interfaces.</p>
</div>
<div class="paragraph">
<p>There are also convenience methods on ProxyFactory (inherited from <code>AdvisedSupport</code>)
which allow you to add other advice types such as before and throws advice.
AdvisedSupport is the superclass of both ProxyFactory and ProxyFactoryBean.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Integrating AOP proxy creation with the IoC framework is best practice in most
applications. We recommend that you externalize configuration from Java code with AOP,
as in general.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advised"><a class="anchor" href="#aop-api-advised"></a>6.8. Manipulating advised objects</h3>
<div class="paragraph">
<p>However you create AOP proxies, you can manipulate them using the
<code>org.springframework.aop.framework.Advised</code> interface. Any AOP proxy can be cast to this
interface, whichever other interfaces it implements. This interface includes the
following methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Advisor<span class="type">[]</span> getAdvisors();

<span class="type">void</span> addAdvice(Advice advice) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> addAdvice(<span class="type">int</span> pos, Advice advice) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> addAdvisor(Advisor advisor) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> addAdvisor(<span class="type">int</span> pos, Advisor advisor) <span class="directive">throws</span> AopConfigException;

<span class="type">int</span> indexOf(Advisor advisor);

<span class="type">boolean</span> removeAdvisor(Advisor advisor) <span class="directive">throws</span> AopConfigException;

<span class="type">void</span> removeAdvisor(<span class="type">int</span> index) <span class="directive">throws</span> AopConfigException;

<span class="type">boolean</span> replaceAdvisor(Advisor a, Advisor b) <span class="directive">throws</span> AopConfigException;

<span class="type">boolean</span> isFrozen();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getAdvisors()</code> method will return an Advisor for every advisor, interceptor or
other advice type that has been added to the factory. If you added an Advisor, the
returned advisor at this index will be the object that you added. If you added an
interceptor or other advice type, Spring will have wrapped this in an advisor with a
pointcut that always returns true. Thus if you added a <code>MethodInterceptor</code>, the advisor
returned for this index will be an <code>DefaultPointcutAdvisor</code> returning your
<code>MethodInterceptor</code> and a pointcut that matches all classes and methods.</p>
</div>
<div class="paragraph">
<p>The <code>addAdvisor()</code> methods can be used to add any Advisor. Usually the advisor holding
pointcut and advice will be the generic <code>DefaultPointcutAdvisor</code>, which can be used with
any advice or pointcut (but not for introductions).</p>
</div>
<div class="paragraph">
<p>By default, it&#8217;s possible to add or remove advisors or interceptors even once a proxy
has been created. The only restriction is that it&#8217;s impossible to add or remove an
introduction advisor, as existing proxies from the factory will not show the interface
change. (You can obtain a new proxy from the factory to avoid this problem.)</p>
</div>
<div class="paragraph">
<p>A simple example of casting an AOP proxy to the <code>Advised</code> interface and examining and
manipulating its advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Advised advised = (Advised) myObject;
Advisor<span class="type">[]</span> advisors = advised.getAdvisors();
<span class="type">int</span> oldAdvisorCount = advisors.length;
<span class="predefined-type">System</span>.out.println(oldAdvisorCount + <span class="string"><span class="delimiter">&quot;</span><span class="content"> advisors</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Add an advice like an interceptor without a pointcut</span>
<span class="comment">// Will match all proxied methods</span>
<span class="comment">// Can use for interceptors, before, after returning or throws advice</span>
advised.addAdvice(<span class="keyword">new</span> DebugInterceptor());

<span class="comment">// Add selective advice using a pointcut</span>
advised.addAdvisor(<span class="keyword">new</span> DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">Added two advisors</span><span class="delimiter">&quot;</span></span>, oldAdvisorCount + <span class="integer">2</span>, advised.getAdvisors().length);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It&#8217;s questionable whether it&#8217;s advisable (no pun intended) to modify advice on a
business object in production, although there are no doubt legitimate usage cases.
However, it can be very useful in development: for example, in tests. I have sometimes
found it very useful to be able to add test code in the form of an interceptor or other
advice, getting inside a method invocation I want to test. (For example, the advice can
get inside a transaction created for that method: for example, to run SQL to check that
a database was correctly updated, before marking the transaction for roll back.)</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on how you created the proxy, you can usually set a <code>frozen</code> flag, in which
case the <code>Advised</code> <code>isFrozen()</code> method will return true, and any attempts to modify
advice through addition or removal will result in an <code>AopConfigException</code>. The ability
to freeze the state of an advised object is useful in some cases, for example, to
prevent calling code removing a security interceptor. It may also be used in Spring 1.1
to allow aggressive optimization if runtime advice modification is known not to be
required.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-autoproxy"><a class="anchor" href="#aop-autoproxy"></a>6.9. Using the "auto-proxy" facility</h3>
<div class="paragraph">
<p>So far we&#8217;ve considered explicit creation of AOP proxies using a <code>ProxyFactoryBean</code> or
similar factory bean.</p>
</div>
<div class="paragraph">
<p>Spring also allows us to use "auto-proxy" bean definitions, which can automatically
proxy selected bean definitions. This is built on Spring "bean post processor"
infrastructure, which enables modification of any bean definition as the container loads.</p>
</div>
<div class="paragraph">
<p>In this model, you set up some special bean definitions in your XML bean definition file
to configure the auto proxy infrastructure. This allows you just to declare the targets
eligible for auto-proxying: you don&#8217;t need to use <code>ProxyFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to do this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using an auto-proxy creator that refers to specific beans in the current context.</p>
</li>
<li>
<p>A special case of auto-proxy creation that deserves to be considered separately;
auto-proxy creation driven by source-level metadata attributes.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="aop-autoproxy-choices"><a class="anchor" href="#aop-autoproxy-choices"></a>6.9.1. Autoproxy bean definitions</h4>
<div class="paragraph">
<p>The <code>org.springframework.aop.framework.autoproxy</code> package provides the following
standard auto-proxy creators.</p>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy"><a class="anchor" href="#aop-api-autoproxy"></a>BeanNameAutoProxyCreator</h5>
<div class="paragraph">
<p>The <code>BeanNameAutoProxyCreator</code> class is a <code>BeanPostProcessor</code> that automatically creates
AOP proxies for beans with names matching literal values or wildcards.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">beanNames</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">jdk*,onlyJdk</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;list&gt;</span>
                        <span class="tag">&lt;value&gt;</span>myInterceptor<span class="tag">&lt;/value&gt;</span>
                <span class="tag">&lt;/list&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>ProxyFactoryBean</code>, there is an <code>interceptorNames</code> property rather than a list
of interceptors, to allow correct behavior for prototype advisors. Named "interceptors"
can be advisors or any advice type.</p>
</div>
<div class="paragraph">
<p>As with auto proxying in general, the main point of using <code>BeanNameAutoProxyCreator</code> is
to apply the same configuration consistently to multiple objects, with minimal volume of
configuration. It is a popular choice for applying declarative transactions to multiple
objects.</p>
</div>
<div class="paragraph">
<p>Bean definitions whose names match, such as "jdkMyBean" and "onlyJdk" in the above
example, are plain old bean definitions with the target class. An AOP proxy will be
created automatically by the <code>BeanNameAutoProxyCreator</code>. The same advice will be applied
to all matching beans. Note that if advisors are used (rather than the interceptor in
the above example), the pointcuts may apply differently to different beans.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy-default"><a class="anchor" href="#aop-api-autoproxy-default"></a>DefaultAdvisorAutoProxyCreator</h5>
<div class="paragraph">
<p>A more general and extremely powerful auto proxy creator is
<code>DefaultAdvisorAutoProxyCreator</code>. This will automagically apply eligible advisors in the
current context, without the need to include specific bean names in the auto-proxy
advisor&#8217;s bean definition. It offers the same merit of consistent configuration and
avoidance of duplication as <code>BeanNameAutoProxyCreator</code>.</p>
</div>
<div class="paragraph">
<p>Using this mechanism involves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specifying a <code>DefaultAdvisorAutoProxyCreator</code> bean definition.</p>
</li>
<li>
<p>Specifying any number of Advisors in the same or related contexts. Note that these
<em>must</em> be Advisors, not just interceptors or other advices. This is necessary
because there must be a pointcut to evaluate, to check the eligibility of each advice
to candidate bean definitions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> will automatically evaluate the pointcut contained
in each advisor, to see what (if any) advice it should apply to each business object
(such as "businessObject1" and "businessObject2" in the example).</p>
</div>
<div class="paragraph">
<p>This means that any number of advisors can be applied automatically to each business
object. If no pointcut in any of the advisors matches any method in a business object,
the object will not be proxied. As bean definitions are added for new business objects,
they will automatically be proxied if necessary.</p>
</div>
<div class="paragraph">
<p>Autoproxying in general has the advantage of making it impossible for callers or
dependencies to obtain an un-advised object. Calling getBean("businessObject1") on this
ApplicationContext will return an AOP proxy, not the target business object. (The "inner
bean" idiom shown earlier also offers this benefit.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject1</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.BusinessObject1</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="comment">&lt;!-- Properties omitted --&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject2</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.BusinessObject2</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> is very useful if you want to apply the same advice
consistently to many business objects. Once the infrastructure definitions are in place,
you can simply add new business objects without including specific proxy configuration.
You can also drop in additional aspects very easily - for example, tracing or
performance monitoring aspects - with minimal change to configuration.</p>
</div>
<div class="paragraph">
<p>The DefaultAdvisorAutoProxyCreator offers support for filtering (using a naming
convention so that only certain advisors are evaluated, allowing use of multiple,
differently configured, AdvisorAutoProxyCreators in the same factory) and ordering.
Advisors can implement the <code>org.springframework.core.Ordered</code> interface to ensure
correct ordering if this is an issue. The TransactionAttributeSourceAdvisor used in the
above example has a configurable order value; the default setting is unordered.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy-abstract"><a class="anchor" href="#aop-api-autoproxy-abstract"></a>AbstractAdvisorAutoProxyCreator</h5>
<div class="paragraph">
<p>This is the superclass of DefaultAdvisorAutoProxyCreator. You can create your own
auto-proxy creators by subclassing this class, in the unlikely event that advisor
definitions offer insufficient customization to the behavior of the framework
<code>DefaultAdvisorAutoProxyCreator</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-autoproxy-metadata"><a class="anchor" href="#aop-autoproxy-metadata"></a>6.9.2. Using metadata-driven auto-proxying</h4>
<div class="paragraph">
<p>A particularly important type of auto-proxying is driven by metadata. This produces a
similar programming model to .NET <code>ServicedComponents</code>. Instead of defining metadata in
XML descriptors, configuration for transaction management and other enterprise services
is held in source-level attributes.</p>
</div>
<div class="paragraph">
<p>In this case, you use the <code>DefaultAdvisorAutoProxyCreator</code>, in combination with Advisors
that understand metadata attributes. The metadata specifics are held in the pointcut
part of the candidate advisors, rather than in the auto-proxy creation class itself.</p>
</div>
<div class="paragraph">
<p>This is really a special case of the <code>DefaultAdvisorAutoProxyCreator</code>, but deserves
consideration on its own. (The metadata-aware code is in the pointcuts contained in the
advisors, not the AOP framework itself.)</p>
</div>
<div class="paragraph">
<p>The <code>/attributes</code> directory of the JPetStore sample application shows the use of
attribute-driven auto-proxying. In this case, there&#8217;s no need to use the
<code>TransactionProxyFactoryBean</code>. Simply defining transactional attributes on business
objects is sufficient, because of the use of metadata-aware pointcuts. The bean
definitions include the following code, in <code>/WEB-INF/declarativeServices.xml</code>. Note that
this is generic, and can be used outside the JPetStore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.AttributesTransactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">attributes</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">attributes</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
                <span class="tag">&lt;/bean&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">attributes</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.metadata.commons.CommonsAttributes</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> bean definition (the name is not significant, hence
it can even be omitted) will pick up all eligible pointcuts in the current application
context. In this case, the "transactionAdvisor" bean definition, of type
<code>TransactionAttributeSourceAdvisor</code>, will apply to classes or methods carrying a
transaction attribute. The TransactionAttributeSourceAdvisor depends on a
TransactionInterceptor, via constructor dependency. The example resolves this via
autowiring. The <code>AttributesTransactionAttributeSource</code> depends on an implementation of
the <code>org.springframework.metadata.Attributes</code> interface. In this fragment, the
"attributes" bean satisfies this, using the Jakarta Commons Attributes API to obtain
attribute information. (The application code must have been compiled using the Commons
Attributes compilation task.)</p>
</div>
<div class="paragraph">
<p>The <code>/annotation</code> directory of the JPetStore sample application contains an analogous
example for auto-proxying driven by JDK 1.5+ annotations. The following configuration
enables automatic detection of Spring&#8217;s <code>Transactional</code> annotation, leading to implicit
proxies for beans containing that annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionInterceptor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.interceptor.TransactionInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
                <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.annotation.AnnotationTransactionAttributeSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TransactionInterceptor</code> defined here depends on a <code>PlatformTransactionManager</code>
definition, which is not included in this generic file (although it could be) because it
will be specific to the application&#8217;s transaction requirements (typically JTA, as in
this example, or Hibernate or JDBC):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">transactionManager</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.transaction.jta.JtaTransactionManager</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you require only declarative transaction management, using these generic XML
definitions will result in Spring automatically proxying all classes or methods with
transaction attributes. You won&#8217;t need to work directly with AOP, and the programming
model is similar to that of .NET ServicedComponents.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This mechanism is extensible. It&#8217;s possible to do auto-proxying based on custom
attributes. You need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Define your custom attribute.</p>
</li>
<li>
<p>Specify an Advisor with the necessary advice, including a pointcut that is triggered
by the presence of the custom attribute on a class or method. You may be able to use
an existing advice, merely implementing a static pointcut that picks up the custom
attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s possible for such advisors to be unique to each advised class (for example, mixins):
they simply need to be defined as prototype, rather than singleton, bean definitions.
For example, the <code>LockMixin</code> introduction interceptor from the Spring test suite,
shown above, could be used in conjunction with a generic <code>DefaultIntroductionAdvisor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lockMixin</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">test.mixin.LockMixin</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lockableAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.support.DefaultIntroductionAdvisor</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">lockMixin</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that both <code>lockMixin</code> and <code>lockableAdvisor</code> are defined as prototypes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-targetsource"><a class="anchor" href="#aop-targetsource"></a>6.10. Using TargetSources</h3>
<div class="paragraph">
<p>Spring offers the concept of a <em>TargetSource</em>, expressed in the
<code>org.springframework.aop.TargetSource</code> interface. This interface is responsible for
returning the "target object" implementing the join point. The <code>TargetSource</code>
implementation is asked for a target instance each time the AOP proxy handles a method
invocation.</p>
</div>
<div class="paragraph">
<p>Developers using Spring AOP don&#8217;t normally need to work directly with TargetSources, but
this provides a powerful means of supporting pooling, hot swappable and other
sophisticated targets. For example, a pooling TargetSource can return a different target
instance for each invocation, using a pool to manage instances.</p>
</div>
<div class="paragraph">
<p>If you do not specify a TargetSource, a default implementation is used that wraps a
local object. The same target is returned for each invocation (as you would expect).</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the standard target sources provided with Spring, and how you can use them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When using a custom target source, your target will usually need to be a prototype
rather than a singleton bean definition. This allows Spring to create a new target
instance when required.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-ts-swap"><a class="anchor" href="#aop-ts-swap"></a>6.10.1. Hot swappable target sources</h4>
<div class="paragraph">
<p>The <code>org.springframework.aop.target.HotSwappableTargetSource</code> exists to allow the target
of an AOP proxy to be switched while allowing callers to keep their references to it.</p>
</div>
<div class="paragraph">
<p>Changing the target source&#8217;s target takes effect immediately. The
<code>HotSwappableTargetSource</code> is threadsafe.</p>
</div>
<div class="paragraph">
<p>You can change the target via the <code>swap()</code> method on HotSwappableTargetSource as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">swapper</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">Object</span> oldTarget = swapper.swap(newTarget);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The XML definitions required look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialTarget</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mycompany.OldTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">swapper</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.HotSwappableTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">initialTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">swappable</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">swapper</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above <code>swap()</code> call changes the target of the swappable bean. Clients who hold a
reference to that bean will be unaware of the change, but will immediately start hitting
the new target.</p>
</div>
<div class="paragraph">
<p>Although this example doesn&#8217;t add any advice - and it&#8217;s not necessary to add advice to
use a <code>TargetSource</code> - of course any <code>TargetSource</code> can be used in conjunction with
arbitrary advice.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-pool"><a class="anchor" href="#aop-ts-pool"></a>6.10.2. Pooling target sources</h4>
<div class="paragraph">
<p>Using a pooling target source provides a similar programming model to stateless session
EJBs, in which a pool of identical instances is maintained, with method invocations
going to free objects in the pool.</p>
</div>
<div class="paragraph">
<p>A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can
be applied to any POJO. As with Spring in general, this service can be applied in a
non-invasive way.</p>
</div>
<div class="paragraph">
<p>Spring provides out-of-the-box support for Commons Pool 2.2, which provides a
fairly efficient pooling implementation. You&#8217;ll need the commons-pool Jar on your
application&#8217;s classpath to use this feature. It&#8217;s also possible to subclass
<code>org.springframework.aop.target.AbstractPoolingTargetSource</code> to support any other
pooling API.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Commons Pool 1.5+ is also supported but deprecated as of Spring Framework 4.2.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sample configuration is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mycompany.MyBusinessObject</span><span class="delimiter">&quot;</span></span>
                <span class="attribute-name">scope</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototype</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        ... properties omitted
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolTargetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.CommonsPool2TargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetBeanName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">maxSize</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">25</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.framework.ProxyFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">interceptorNames</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">myInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the target object - "businessObjectTarget" in the example - <em>must</em> be a
prototype. This allows the <code>PoolingTargetSource</code> implementation to create new instances
of the target to grow the pool as necessary. See the javadocs of
<code>AbstractPoolingTargetSource</code> and the concrete subclass you wish to use for information
about its properties: "maxSize" is the most basic, and always guaranteed to be present.</p>
</div>
<div class="paragraph">
<p>In this case, "myInterceptor" is the name of an interceptor that would need to be
defined in the same IoC context. However, it isn&#8217;t necessary to specify interceptors to
use pooling. If you want only pooling, and no other advice, don&#8217;t set the
interceptorNames property at all.</p>
</div>
<div class="paragraph">
<p>It&#8217;s possible to configure Spring so as to be able to cast any pooled object to the
<code>org.springframework.aop.target.PoolingConfig</code> interface, which exposes information
about the configuration and current size of the pool through an introduction. You&#8217;ll
need to define an advisor like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolConfigAdvisor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.beans.factory.config.MethodInvokingFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetObject</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">poolTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetMethod</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">getPoolingConfigMixin</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This advisor is obtained by calling a convenience method on the
<code>AbstractPoolingTargetSource</code> class, hence the use of MethodInvokingFactoryBean. This
advisor&#8217;s name ("poolConfigAdvisor" here) must be in the list of interceptors names in
the ProxyFactoryBean exposing the pooled object.</p>
</div>
<div class="paragraph">
<p>The cast will look as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">PoolingConfig conf = (PoolingConfig) beanFactory.getBean(<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObject</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Max pool size is </span><span class="delimiter">&quot;</span></span> + conf.getMaxSize());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Pooling stateless service objects is not usually necessary. We don&#8217;t believe it should
be the default choice, as most stateless objects are naturally thread safe, and instance
pooling is problematic if resources are cached.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Simpler pooling is available using auto-proxying. It&#8217;s possible to set the TargetSources
used by any auto-proxy creator.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-prototype"><a class="anchor" href="#aop-ts-prototype"></a>6.10.3. Prototype target sources</h4>
<div class="paragraph">
<p>Setting up a "prototype" target source is similar to a pooling TargetSource. In this
case, a new instance of the target will be created on every method invocation. Although
the cost of creating a new object isn&#8217;t high in a modern JVM, the cost of wiring up the
new object (satisfying its IoC dependencies) may be more expensive. Thus you shouldn&#8217;t
use this approach without very good reason.</p>
</div>
<div class="paragraph">
<p>To do this, you could modify the <code>poolTargetSource</code> definition shown above as follows.
(I&#8217;ve also changed the name, for clarity.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">prototypeTargetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.PrototypeTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetBeanName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s only one property: the name of the target bean. Inheritance is used in the
TargetSource implementations to ensure consistent naming. As with the pooling target
source, the target bean must be a prototype bean definition.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-threadlocal"><a class="anchor" href="#aop-ts-threadlocal"></a>6.10.4. ThreadLocal target sources</h4>
<div class="paragraph">
<p><code>ThreadLocal</code> target sources are useful if you need an object to be created for each
incoming request (per thread that is). The concept of a <code>ThreadLocal</code> provide a JDK-wide
facility to transparently store resource alongside a thread. Setting up a
<code>ThreadLocalTargetSource</code> is pretty much the same as was explained for the other types
of target source:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">threadlocalTargetSource</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.aop.target.ThreadLocalTargetSource</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">targetBeanName</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">businessObjectTarget</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ThreadLocals come with serious issues (potentially resulting in memory leaks) when
incorrectly using them in a multi-threaded and multi-classloader environments. One
should always consider wrapping a threadlocal in some other class and never directly use
the <code>ThreadLocal</code> itself (except of course in the wrapper class). Also, one should
always remember to correctly set and unset (where the latter simply involved a call to
<code>ThreadLocal.set(null)</code>) the resource local to the thread. Unsetting should be done in
any case since not unsetting it might result in problematic behavior. Spring&#8217;s
ThreadLocal support does this for you and should always be considered in favor of using
ThreadLocals without other proper handling code.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-extensibility"><a class="anchor" href="#aop-extensibility"></a>6.11. Defining new Advice types</h3>
<div class="paragraph">
<p>Spring AOP is designed to be extensible. While the interception implementation strategy
is presently used internally, it is possible to support arbitrary advice types in
addition to the out-of-the-box interception around advice, before, throws advice and
after returning advice.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.aop.framework.adapter</code> package is an SPI package allowing
support for new custom advice types to be added without changing the core framework.
The only constraint on a custom <code>Advice</code> type is that it must implement the
<code>org.aopalliance.aop.Advice</code> marker interface.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>org.springframework.aop.framework.adapter</code> javadocs for further
information.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-resources"><a class="anchor" href="#aop-api-resources"></a>6.12. Further resources</h3>
<div class="paragraph">
<p>Please refer to the Spring sample applications for further examples of Spring AOP:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The JPetStore&#8217;s default configuration illustrates the use of the
<code>TransactionProxyFactoryBean</code> for declarative transaction management.</p>
</li>
<li>
<p>The <code>/attributes</code> directory of the JPetStore illustrates the use of attribute-driven
declarative transaction management.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="null-safety"><a class="anchor" href="#null-safety"></a>7. Null-safety</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although Java does not allow to express null-safety with its type system, Spring Framework
now provides following annotations in the <code>org.springframework.lang</code> package to declare
nullability of APIs and fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a> annotation where specific parameter,
return value or field cannot be <code>null</code> (not needed on parameter and return value
where <code>@NonNullApi</code> and <code>@NonNullFields</code> apply) .</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a> annotation where specific
parameter, return value or field can be <code>null</code>.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a> annotation at package level
declares non-null as the default behavior for parameters and return values.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/javadoc-api/org/springframework/lang/NonNullFields.html"><code>@NonNullFields</code></a> annotation at package
level declares non-null as the default behavior for fields.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Framework leverages itself these annotations, but they can also be used in any Spring based
Java project to declare null-safe APIs and optionally null-safe fields. Generic type arguments,
varargs and array elements nullability are not supported yet, but should be in an upcoming
release, see <a href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a> for up-to-date information.
Nullability declaration are expected to be fine-tuned between Spring Framework release,
including minor ones. Nullability of types used inside method bodies is outside of the
scope of this feature.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Libraries like Reactor or Spring Data provide null-safe APIs leveraging this feature.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="use-cases"><a class="anchor" href="#use-cases"></a>7.1. Use cases</h3>
<div class="paragraph">
<p>In addition to providing an explicit declaration for Spring Framework API nullability,
these annotation can be used by IDE (such as IDEA or Eclipse) to provide useful
warnings to Java developers related to null-safety in order to avoid <code>NullPointerException</code>
at runtime.</p>
</div>
<div class="paragraph">
<p>They are also used to make Spring API null-safe in Kotlin projects since Kotlin natively
supports <a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>. More details
are available in <a href="kotlin.html#null-safety">Kotlin support documentation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jsr-305-meta-annotations"><a class="anchor" href="#jsr-305-meta-annotations"></a>7.2. JSR 305 meta-annotations</h3>
<div class="paragraph">
<p>Spring annotations are meta-annotated with <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>
annotations (a dormant but widely spread JSR). JSR 305 meta-annotations allows tooling vendors
like IDEA or Kotlin to provide null-safety support in a generic way, without having to hard-code
support for Spring annotations.</p>
</div>
<div class="paragraph">
<p>It is not necessary nor recommended to add JSR 305 dependency in project classpath to
take advantage of Spring null-safe API. Only projects like
Spring-based libraries using null-safety annotations in their codebase should add
<code>com.google.code.findbugs:jsr305:3.0.2</code> with <code>compileOnly</code> Gradle configuration or Maven
<code>provided</code> scope to avoid compile warnings.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. See <a href="overview.html#background-ioc">Inversion of Control</a>
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. See <a href="#beans-factory-collaborators">Dependency Injection</a>
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. But see also <a href="#resources-filesystemresource-caveats">FileSystemResource caveats</a>.
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.0.0.RELEASE<br>
Last updated 2017-09-28 11:00:47 UTC
</div>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/af2821b0/cloudflare-static/email-decode.min.js"></script><script>var rootLink=document.createElement("a");rootLink.setAttribute("href","index.html");rootLink.innerHTML="<i class=\"fa fa-chevron-left\" aria-hidden=\"true\"></i>&nbsp;&nbsp;Back to index";var p=document.createElement("p");p.appendChild(rootLink);var toc=document.getElementById('toc')
var sectlevel1=toc.getElementsByClassName("sectlevel1")[0]
toc.insertBefore(p,sectlevel1);</script>
<script>if(window.parent==window){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create','UA-2728886-23','auto',{'siteSpeedSampleRate':100});ga('send','pageview');}</script></body>
</html>